
Vehicle-Direction-FinalProject.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000096b6  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         0000014a  00800060  000096b6  0000974a  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          000006ad  008001aa  008001aa  00009894  2**0
                  ALLOC
  3 .stab         0000b670  00000000  00000000  00009894  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      000065f3  00000000  00000000  00014f04  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 000001a0  00000000  00000000  0001b4f7  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_pubnames 000001f2  00000000  00000000  0001b697  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   0000240b  00000000  00000000  0001b889  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00001386  00000000  00000000  0001dc94  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   000011d6  00000000  00000000  0001f01a  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  000001c0  00000000  00000000  000201f0  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    000002f6  00000000  00000000  000203b0  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    0000096e  00000000  00000000  000206a6  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000050  00000000  00000000  00021014  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      10:	0c 94 df 49 	jmp	0x93be	; 0x93be <__vector_4>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 68 0a 	jmp	0x14d0	; 0x14d0 <__vector_7>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	11 e0       	ldi	r17, 0x01	; 1
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	e6 eb       	ldi	r30, 0xB6	; 182
      68:	f6 e9       	ldi	r31, 0x96	; 150
      6a:	02 c0       	rjmp	.+4      	; 0x70 <.do_copy_data_start>

0000006c <.do_copy_data_loop>:
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0

00000070 <.do_copy_data_start>:
      70:	aa 3a       	cpi	r26, 0xAA	; 170
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <.do_copy_data_loop>

00000076 <__do_clear_bss>:
      76:	18 e0       	ldi	r17, 0x08	; 8
      78:	aa ea       	ldi	r26, 0xAA	; 170
      7a:	b1 e0       	ldi	r27, 0x01	; 1
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	a7 35       	cpi	r26, 0x57	; 87
      82:	b1 07       	cpc	r27, r17
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 ac 49 	call	0x9358	; 0x9358 <main>
      8a:	0c 94 59 4b 	jmp	0x96b2	; 0x96b2 <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <__fixunssfsi>:
      92:	ef 92       	push	r14
      94:	ff 92       	push	r15
      96:	0f 93       	push	r16
      98:	1f 93       	push	r17
      9a:	7b 01       	movw	r14, r22
      9c:	8c 01       	movw	r16, r24
      9e:	20 e0       	ldi	r18, 0x00	; 0
      a0:	30 e0       	ldi	r19, 0x00	; 0
      a2:	40 e0       	ldi	r20, 0x00	; 0
      a4:	5f e4       	ldi	r21, 0x4F	; 79
      a6:	0e 94 f5 03 	call	0x7ea	; 0x7ea <__gesf2>
      aa:	88 23       	and	r24, r24
      ac:	8c f0       	brlt	.+34     	; 0xd0 <__fixunssfsi+0x3e>
      ae:	c8 01       	movw	r24, r16
      b0:	b7 01       	movw	r22, r14
      b2:	20 e0       	ldi	r18, 0x00	; 0
      b4:	30 e0       	ldi	r19, 0x00	; 0
      b6:	40 e0       	ldi	r20, 0x00	; 0
      b8:	5f e4       	ldi	r21, 0x4F	; 79
      ba:	0e 94 c1 01 	call	0x382	; 0x382 <__subsf3>
      be:	0e 94 55 04 	call	0x8aa	; 0x8aa <__fixsfsi>
      c2:	9b 01       	movw	r18, r22
      c4:	ac 01       	movw	r20, r24
      c6:	20 50       	subi	r18, 0x00	; 0
      c8:	30 40       	sbci	r19, 0x00	; 0
      ca:	40 40       	sbci	r20, 0x00	; 0
      cc:	50 48       	sbci	r21, 0x80	; 128
      ce:	06 c0       	rjmp	.+12     	; 0xdc <__fixunssfsi+0x4a>
      d0:	c8 01       	movw	r24, r16
      d2:	b7 01       	movw	r22, r14
      d4:	0e 94 55 04 	call	0x8aa	; 0x8aa <__fixsfsi>
      d8:	9b 01       	movw	r18, r22
      da:	ac 01       	movw	r20, r24
      dc:	b9 01       	movw	r22, r18
      de:	ca 01       	movw	r24, r20
      e0:	1f 91       	pop	r17
      e2:	0f 91       	pop	r16
      e4:	ff 90       	pop	r15
      e6:	ef 90       	pop	r14
      e8:	08 95       	ret

000000ea <_fpadd_parts>:
      ea:	a0 e0       	ldi	r26, 0x00	; 0
      ec:	b0 e0       	ldi	r27, 0x00	; 0
      ee:	eb e7       	ldi	r30, 0x7B	; 123
      f0:	f0 e0       	ldi	r31, 0x00	; 0
      f2:	0c 94 e1 4a 	jmp	0x95c2	; 0x95c2 <__prologue_saves__>
      f6:	dc 01       	movw	r26, r24
      f8:	2b 01       	movw	r4, r22
      fa:	fa 01       	movw	r30, r20
      fc:	9c 91       	ld	r25, X
      fe:	92 30       	cpi	r25, 0x02	; 2
     100:	08 f4       	brcc	.+2      	; 0x104 <_fpadd_parts+0x1a>
     102:	39 c1       	rjmp	.+626    	; 0x376 <_fpadd_parts+0x28c>
     104:	eb 01       	movw	r28, r22
     106:	88 81       	ld	r24, Y
     108:	82 30       	cpi	r24, 0x02	; 2
     10a:	08 f4       	brcc	.+2      	; 0x10e <_fpadd_parts+0x24>
     10c:	33 c1       	rjmp	.+614    	; 0x374 <_fpadd_parts+0x28a>
     10e:	94 30       	cpi	r25, 0x04	; 4
     110:	69 f4       	brne	.+26     	; 0x12c <_fpadd_parts+0x42>
     112:	84 30       	cpi	r24, 0x04	; 4
     114:	09 f0       	breq	.+2      	; 0x118 <_fpadd_parts+0x2e>
     116:	2f c1       	rjmp	.+606    	; 0x376 <_fpadd_parts+0x28c>
     118:	11 96       	adiw	r26, 0x01	; 1
     11a:	9c 91       	ld	r25, X
     11c:	11 97       	sbiw	r26, 0x01	; 1
     11e:	89 81       	ldd	r24, Y+1	; 0x01
     120:	98 17       	cp	r25, r24
     122:	09 f4       	brne	.+2      	; 0x126 <_fpadd_parts+0x3c>
     124:	28 c1       	rjmp	.+592    	; 0x376 <_fpadd_parts+0x28c>
     126:	a9 e8       	ldi	r26, 0x89	; 137
     128:	b0 e0       	ldi	r27, 0x00	; 0
     12a:	25 c1       	rjmp	.+586    	; 0x376 <_fpadd_parts+0x28c>
     12c:	84 30       	cpi	r24, 0x04	; 4
     12e:	09 f4       	brne	.+2      	; 0x132 <_fpadd_parts+0x48>
     130:	21 c1       	rjmp	.+578    	; 0x374 <_fpadd_parts+0x28a>
     132:	82 30       	cpi	r24, 0x02	; 2
     134:	a9 f4       	brne	.+42     	; 0x160 <_fpadd_parts+0x76>
     136:	92 30       	cpi	r25, 0x02	; 2
     138:	09 f0       	breq	.+2      	; 0x13c <_fpadd_parts+0x52>
     13a:	1d c1       	rjmp	.+570    	; 0x376 <_fpadd_parts+0x28c>
     13c:	9a 01       	movw	r18, r20
     13e:	ad 01       	movw	r20, r26
     140:	88 e0       	ldi	r24, 0x08	; 8
     142:	ea 01       	movw	r28, r20
     144:	09 90       	ld	r0, Y+
     146:	ae 01       	movw	r20, r28
     148:	e9 01       	movw	r28, r18
     14a:	09 92       	st	Y+, r0
     14c:	9e 01       	movw	r18, r28
     14e:	81 50       	subi	r24, 0x01	; 1
     150:	c1 f7       	brne	.-16     	; 0x142 <_fpadd_parts+0x58>
     152:	e2 01       	movw	r28, r4
     154:	89 81       	ldd	r24, Y+1	; 0x01
     156:	11 96       	adiw	r26, 0x01	; 1
     158:	9c 91       	ld	r25, X
     15a:	89 23       	and	r24, r25
     15c:	81 83       	std	Z+1, r24	; 0x01
     15e:	08 c1       	rjmp	.+528    	; 0x370 <_fpadd_parts+0x286>
     160:	92 30       	cpi	r25, 0x02	; 2
     162:	09 f4       	brne	.+2      	; 0x166 <_fpadd_parts+0x7c>
     164:	07 c1       	rjmp	.+526    	; 0x374 <_fpadd_parts+0x28a>
     166:	12 96       	adiw	r26, 0x02	; 2
     168:	2d 90       	ld	r2, X+
     16a:	3c 90       	ld	r3, X
     16c:	13 97       	sbiw	r26, 0x03	; 3
     16e:	eb 01       	movw	r28, r22
     170:	8a 81       	ldd	r24, Y+2	; 0x02
     172:	9b 81       	ldd	r25, Y+3	; 0x03
     174:	14 96       	adiw	r26, 0x04	; 4
     176:	ad 90       	ld	r10, X+
     178:	bd 90       	ld	r11, X+
     17a:	cd 90       	ld	r12, X+
     17c:	dc 90       	ld	r13, X
     17e:	17 97       	sbiw	r26, 0x07	; 7
     180:	ec 80       	ldd	r14, Y+4	; 0x04
     182:	fd 80       	ldd	r15, Y+5	; 0x05
     184:	0e 81       	ldd	r16, Y+6	; 0x06
     186:	1f 81       	ldd	r17, Y+7	; 0x07
     188:	91 01       	movw	r18, r2
     18a:	28 1b       	sub	r18, r24
     18c:	39 0b       	sbc	r19, r25
     18e:	b9 01       	movw	r22, r18
     190:	37 ff       	sbrs	r19, 7
     192:	04 c0       	rjmp	.+8      	; 0x19c <_fpadd_parts+0xb2>
     194:	66 27       	eor	r22, r22
     196:	77 27       	eor	r23, r23
     198:	62 1b       	sub	r22, r18
     19a:	73 0b       	sbc	r23, r19
     19c:	60 32       	cpi	r22, 0x20	; 32
     19e:	71 05       	cpc	r23, r1
     1a0:	0c f0       	brlt	.+2      	; 0x1a4 <_fpadd_parts+0xba>
     1a2:	61 c0       	rjmp	.+194    	; 0x266 <_fpadd_parts+0x17c>
     1a4:	12 16       	cp	r1, r18
     1a6:	13 06       	cpc	r1, r19
     1a8:	6c f5       	brge	.+90     	; 0x204 <_fpadd_parts+0x11a>
     1aa:	37 01       	movw	r6, r14
     1ac:	48 01       	movw	r8, r16
     1ae:	06 2e       	mov	r0, r22
     1b0:	04 c0       	rjmp	.+8      	; 0x1ba <_fpadd_parts+0xd0>
     1b2:	96 94       	lsr	r9
     1b4:	87 94       	ror	r8
     1b6:	77 94       	ror	r7
     1b8:	67 94       	ror	r6
     1ba:	0a 94       	dec	r0
     1bc:	d2 f7       	brpl	.-12     	; 0x1b2 <_fpadd_parts+0xc8>
     1be:	21 e0       	ldi	r18, 0x01	; 1
     1c0:	30 e0       	ldi	r19, 0x00	; 0
     1c2:	40 e0       	ldi	r20, 0x00	; 0
     1c4:	50 e0       	ldi	r21, 0x00	; 0
     1c6:	04 c0       	rjmp	.+8      	; 0x1d0 <_fpadd_parts+0xe6>
     1c8:	22 0f       	add	r18, r18
     1ca:	33 1f       	adc	r19, r19
     1cc:	44 1f       	adc	r20, r20
     1ce:	55 1f       	adc	r21, r21
     1d0:	6a 95       	dec	r22
     1d2:	d2 f7       	brpl	.-12     	; 0x1c8 <_fpadd_parts+0xde>
     1d4:	21 50       	subi	r18, 0x01	; 1
     1d6:	30 40       	sbci	r19, 0x00	; 0
     1d8:	40 40       	sbci	r20, 0x00	; 0
     1da:	50 40       	sbci	r21, 0x00	; 0
     1dc:	2e 21       	and	r18, r14
     1de:	3f 21       	and	r19, r15
     1e0:	40 23       	and	r20, r16
     1e2:	51 23       	and	r21, r17
     1e4:	21 15       	cp	r18, r1
     1e6:	31 05       	cpc	r19, r1
     1e8:	41 05       	cpc	r20, r1
     1ea:	51 05       	cpc	r21, r1
     1ec:	21 f0       	breq	.+8      	; 0x1f6 <_fpadd_parts+0x10c>
     1ee:	21 e0       	ldi	r18, 0x01	; 1
     1f0:	30 e0       	ldi	r19, 0x00	; 0
     1f2:	40 e0       	ldi	r20, 0x00	; 0
     1f4:	50 e0       	ldi	r21, 0x00	; 0
     1f6:	79 01       	movw	r14, r18
     1f8:	8a 01       	movw	r16, r20
     1fa:	e6 28       	or	r14, r6
     1fc:	f7 28       	or	r15, r7
     1fe:	08 29       	or	r16, r8
     200:	19 29       	or	r17, r9
     202:	3c c0       	rjmp	.+120    	; 0x27c <_fpadd_parts+0x192>
     204:	23 2b       	or	r18, r19
     206:	d1 f1       	breq	.+116    	; 0x27c <_fpadd_parts+0x192>
     208:	26 0e       	add	r2, r22
     20a:	37 1e       	adc	r3, r23
     20c:	35 01       	movw	r6, r10
     20e:	46 01       	movw	r8, r12
     210:	06 2e       	mov	r0, r22
     212:	04 c0       	rjmp	.+8      	; 0x21c <_fpadd_parts+0x132>
     214:	96 94       	lsr	r9
     216:	87 94       	ror	r8
     218:	77 94       	ror	r7
     21a:	67 94       	ror	r6
     21c:	0a 94       	dec	r0
     21e:	d2 f7       	brpl	.-12     	; 0x214 <_fpadd_parts+0x12a>
     220:	21 e0       	ldi	r18, 0x01	; 1
     222:	30 e0       	ldi	r19, 0x00	; 0
     224:	40 e0       	ldi	r20, 0x00	; 0
     226:	50 e0       	ldi	r21, 0x00	; 0
     228:	04 c0       	rjmp	.+8      	; 0x232 <_fpadd_parts+0x148>
     22a:	22 0f       	add	r18, r18
     22c:	33 1f       	adc	r19, r19
     22e:	44 1f       	adc	r20, r20
     230:	55 1f       	adc	r21, r21
     232:	6a 95       	dec	r22
     234:	d2 f7       	brpl	.-12     	; 0x22a <_fpadd_parts+0x140>
     236:	21 50       	subi	r18, 0x01	; 1
     238:	30 40       	sbci	r19, 0x00	; 0
     23a:	40 40       	sbci	r20, 0x00	; 0
     23c:	50 40       	sbci	r21, 0x00	; 0
     23e:	2a 21       	and	r18, r10
     240:	3b 21       	and	r19, r11
     242:	4c 21       	and	r20, r12
     244:	5d 21       	and	r21, r13
     246:	21 15       	cp	r18, r1
     248:	31 05       	cpc	r19, r1
     24a:	41 05       	cpc	r20, r1
     24c:	51 05       	cpc	r21, r1
     24e:	21 f0       	breq	.+8      	; 0x258 <_fpadd_parts+0x16e>
     250:	21 e0       	ldi	r18, 0x01	; 1
     252:	30 e0       	ldi	r19, 0x00	; 0
     254:	40 e0       	ldi	r20, 0x00	; 0
     256:	50 e0       	ldi	r21, 0x00	; 0
     258:	59 01       	movw	r10, r18
     25a:	6a 01       	movw	r12, r20
     25c:	a6 28       	or	r10, r6
     25e:	b7 28       	or	r11, r7
     260:	c8 28       	or	r12, r8
     262:	d9 28       	or	r13, r9
     264:	0b c0       	rjmp	.+22     	; 0x27c <_fpadd_parts+0x192>
     266:	82 15       	cp	r24, r2
     268:	93 05       	cpc	r25, r3
     26a:	2c f0       	brlt	.+10     	; 0x276 <_fpadd_parts+0x18c>
     26c:	1c 01       	movw	r2, r24
     26e:	aa 24       	eor	r10, r10
     270:	bb 24       	eor	r11, r11
     272:	65 01       	movw	r12, r10
     274:	03 c0       	rjmp	.+6      	; 0x27c <_fpadd_parts+0x192>
     276:	ee 24       	eor	r14, r14
     278:	ff 24       	eor	r15, r15
     27a:	87 01       	movw	r16, r14
     27c:	11 96       	adiw	r26, 0x01	; 1
     27e:	9c 91       	ld	r25, X
     280:	d2 01       	movw	r26, r4
     282:	11 96       	adiw	r26, 0x01	; 1
     284:	8c 91       	ld	r24, X
     286:	98 17       	cp	r25, r24
     288:	09 f4       	brne	.+2      	; 0x28c <_fpadd_parts+0x1a2>
     28a:	45 c0       	rjmp	.+138    	; 0x316 <_fpadd_parts+0x22c>
     28c:	99 23       	and	r25, r25
     28e:	39 f0       	breq	.+14     	; 0x29e <_fpadd_parts+0x1b4>
     290:	a8 01       	movw	r20, r16
     292:	97 01       	movw	r18, r14
     294:	2a 19       	sub	r18, r10
     296:	3b 09       	sbc	r19, r11
     298:	4c 09       	sbc	r20, r12
     29a:	5d 09       	sbc	r21, r13
     29c:	06 c0       	rjmp	.+12     	; 0x2aa <_fpadd_parts+0x1c0>
     29e:	a6 01       	movw	r20, r12
     2a0:	95 01       	movw	r18, r10
     2a2:	2e 19       	sub	r18, r14
     2a4:	3f 09       	sbc	r19, r15
     2a6:	40 0b       	sbc	r20, r16
     2a8:	51 0b       	sbc	r21, r17
     2aa:	57 fd       	sbrc	r21, 7
     2ac:	08 c0       	rjmp	.+16     	; 0x2be <_fpadd_parts+0x1d4>
     2ae:	11 82       	std	Z+1, r1	; 0x01
     2b0:	33 82       	std	Z+3, r3	; 0x03
     2b2:	22 82       	std	Z+2, r2	; 0x02
     2b4:	24 83       	std	Z+4, r18	; 0x04
     2b6:	35 83       	std	Z+5, r19	; 0x05
     2b8:	46 83       	std	Z+6, r20	; 0x06
     2ba:	57 83       	std	Z+7, r21	; 0x07
     2bc:	1d c0       	rjmp	.+58     	; 0x2f8 <_fpadd_parts+0x20e>
     2be:	81 e0       	ldi	r24, 0x01	; 1
     2c0:	81 83       	std	Z+1, r24	; 0x01
     2c2:	33 82       	std	Z+3, r3	; 0x03
     2c4:	22 82       	std	Z+2, r2	; 0x02
     2c6:	88 27       	eor	r24, r24
     2c8:	99 27       	eor	r25, r25
     2ca:	dc 01       	movw	r26, r24
     2cc:	82 1b       	sub	r24, r18
     2ce:	93 0b       	sbc	r25, r19
     2d0:	a4 0b       	sbc	r26, r20
     2d2:	b5 0b       	sbc	r27, r21
     2d4:	84 83       	std	Z+4, r24	; 0x04
     2d6:	95 83       	std	Z+5, r25	; 0x05
     2d8:	a6 83       	std	Z+6, r26	; 0x06
     2da:	b7 83       	std	Z+7, r27	; 0x07
     2dc:	0d c0       	rjmp	.+26     	; 0x2f8 <_fpadd_parts+0x20e>
     2de:	22 0f       	add	r18, r18
     2e0:	33 1f       	adc	r19, r19
     2e2:	44 1f       	adc	r20, r20
     2e4:	55 1f       	adc	r21, r21
     2e6:	24 83       	std	Z+4, r18	; 0x04
     2e8:	35 83       	std	Z+5, r19	; 0x05
     2ea:	46 83       	std	Z+6, r20	; 0x06
     2ec:	57 83       	std	Z+7, r21	; 0x07
     2ee:	82 81       	ldd	r24, Z+2	; 0x02
     2f0:	93 81       	ldd	r25, Z+3	; 0x03
     2f2:	01 97       	sbiw	r24, 0x01	; 1
     2f4:	93 83       	std	Z+3, r25	; 0x03
     2f6:	82 83       	std	Z+2, r24	; 0x02
     2f8:	24 81       	ldd	r18, Z+4	; 0x04
     2fa:	35 81       	ldd	r19, Z+5	; 0x05
     2fc:	46 81       	ldd	r20, Z+6	; 0x06
     2fe:	57 81       	ldd	r21, Z+7	; 0x07
     300:	da 01       	movw	r26, r20
     302:	c9 01       	movw	r24, r18
     304:	01 97       	sbiw	r24, 0x01	; 1
     306:	a1 09       	sbc	r26, r1
     308:	b1 09       	sbc	r27, r1
     30a:	8f 5f       	subi	r24, 0xFF	; 255
     30c:	9f 4f       	sbci	r25, 0xFF	; 255
     30e:	af 4f       	sbci	r26, 0xFF	; 255
     310:	bf 43       	sbci	r27, 0x3F	; 63
     312:	28 f3       	brcs	.-54     	; 0x2de <_fpadd_parts+0x1f4>
     314:	0b c0       	rjmp	.+22     	; 0x32c <_fpadd_parts+0x242>
     316:	91 83       	std	Z+1, r25	; 0x01
     318:	33 82       	std	Z+3, r3	; 0x03
     31a:	22 82       	std	Z+2, r2	; 0x02
     31c:	ea 0c       	add	r14, r10
     31e:	fb 1c       	adc	r15, r11
     320:	0c 1d       	adc	r16, r12
     322:	1d 1d       	adc	r17, r13
     324:	e4 82       	std	Z+4, r14	; 0x04
     326:	f5 82       	std	Z+5, r15	; 0x05
     328:	06 83       	std	Z+6, r16	; 0x06
     32a:	17 83       	std	Z+7, r17	; 0x07
     32c:	83 e0       	ldi	r24, 0x03	; 3
     32e:	80 83       	st	Z, r24
     330:	24 81       	ldd	r18, Z+4	; 0x04
     332:	35 81       	ldd	r19, Z+5	; 0x05
     334:	46 81       	ldd	r20, Z+6	; 0x06
     336:	57 81       	ldd	r21, Z+7	; 0x07
     338:	57 ff       	sbrs	r21, 7
     33a:	1a c0       	rjmp	.+52     	; 0x370 <_fpadd_parts+0x286>
     33c:	c9 01       	movw	r24, r18
     33e:	aa 27       	eor	r26, r26
     340:	97 fd       	sbrc	r25, 7
     342:	a0 95       	com	r26
     344:	ba 2f       	mov	r27, r26
     346:	81 70       	andi	r24, 0x01	; 1
     348:	90 70       	andi	r25, 0x00	; 0
     34a:	a0 70       	andi	r26, 0x00	; 0
     34c:	b0 70       	andi	r27, 0x00	; 0
     34e:	56 95       	lsr	r21
     350:	47 95       	ror	r20
     352:	37 95       	ror	r19
     354:	27 95       	ror	r18
     356:	82 2b       	or	r24, r18
     358:	93 2b       	or	r25, r19
     35a:	a4 2b       	or	r26, r20
     35c:	b5 2b       	or	r27, r21
     35e:	84 83       	std	Z+4, r24	; 0x04
     360:	95 83       	std	Z+5, r25	; 0x05
     362:	a6 83       	std	Z+6, r26	; 0x06
     364:	b7 83       	std	Z+7, r27	; 0x07
     366:	82 81       	ldd	r24, Z+2	; 0x02
     368:	93 81       	ldd	r25, Z+3	; 0x03
     36a:	01 96       	adiw	r24, 0x01	; 1
     36c:	93 83       	std	Z+3, r25	; 0x03
     36e:	82 83       	std	Z+2, r24	; 0x02
     370:	df 01       	movw	r26, r30
     372:	01 c0       	rjmp	.+2      	; 0x376 <_fpadd_parts+0x28c>
     374:	d2 01       	movw	r26, r4
     376:	cd 01       	movw	r24, r26
     378:	cd b7       	in	r28, 0x3d	; 61
     37a:	de b7       	in	r29, 0x3e	; 62
     37c:	e2 e1       	ldi	r30, 0x12	; 18
     37e:	0c 94 fd 4a 	jmp	0x95fa	; 0x95fa <__epilogue_restores__>

00000382 <__subsf3>:
     382:	a0 e2       	ldi	r26, 0x20	; 32
     384:	b0 e0       	ldi	r27, 0x00	; 0
     386:	e7 ec       	ldi	r30, 0xC7	; 199
     388:	f1 e0       	ldi	r31, 0x01	; 1
     38a:	0c 94 ed 4a 	jmp	0x95da	; 0x95da <__prologue_saves__+0x18>
     38e:	69 83       	std	Y+1, r22	; 0x01
     390:	7a 83       	std	Y+2, r23	; 0x02
     392:	8b 83       	std	Y+3, r24	; 0x03
     394:	9c 83       	std	Y+4, r25	; 0x04
     396:	2d 83       	std	Y+5, r18	; 0x05
     398:	3e 83       	std	Y+6, r19	; 0x06
     39a:	4f 83       	std	Y+7, r20	; 0x07
     39c:	58 87       	std	Y+8, r21	; 0x08
     39e:	e9 e0       	ldi	r30, 0x09	; 9
     3a0:	ee 2e       	mov	r14, r30
     3a2:	f1 2c       	mov	r15, r1
     3a4:	ec 0e       	add	r14, r28
     3a6:	fd 1e       	adc	r15, r29
     3a8:	ce 01       	movw	r24, r28
     3aa:	01 96       	adiw	r24, 0x01	; 1
     3ac:	b7 01       	movw	r22, r14
     3ae:	0e 94 46 06 	call	0xc8c	; 0xc8c <__unpack_f>
     3b2:	8e 01       	movw	r16, r28
     3b4:	0f 5e       	subi	r16, 0xEF	; 239
     3b6:	1f 4f       	sbci	r17, 0xFF	; 255
     3b8:	ce 01       	movw	r24, r28
     3ba:	05 96       	adiw	r24, 0x05	; 5
     3bc:	b8 01       	movw	r22, r16
     3be:	0e 94 46 06 	call	0xc8c	; 0xc8c <__unpack_f>
     3c2:	8a 89       	ldd	r24, Y+18	; 0x12
     3c4:	91 e0       	ldi	r25, 0x01	; 1
     3c6:	89 27       	eor	r24, r25
     3c8:	8a 8b       	std	Y+18, r24	; 0x12
     3ca:	c7 01       	movw	r24, r14
     3cc:	b8 01       	movw	r22, r16
     3ce:	ae 01       	movw	r20, r28
     3d0:	47 5e       	subi	r20, 0xE7	; 231
     3d2:	5f 4f       	sbci	r21, 0xFF	; 255
     3d4:	0e 94 75 00 	call	0xea	; 0xea <_fpadd_parts>
     3d8:	0e 94 71 05 	call	0xae2	; 0xae2 <__pack_f>
     3dc:	a0 96       	adiw	r28, 0x20	; 32
     3de:	e6 e0       	ldi	r30, 0x06	; 6
     3e0:	0c 94 09 4b 	jmp	0x9612	; 0x9612 <__epilogue_restores__+0x18>

000003e4 <__addsf3>:
     3e4:	a0 e2       	ldi	r26, 0x20	; 32
     3e6:	b0 e0       	ldi	r27, 0x00	; 0
     3e8:	e8 ef       	ldi	r30, 0xF8	; 248
     3ea:	f1 e0       	ldi	r31, 0x01	; 1
     3ec:	0c 94 ed 4a 	jmp	0x95da	; 0x95da <__prologue_saves__+0x18>
     3f0:	69 83       	std	Y+1, r22	; 0x01
     3f2:	7a 83       	std	Y+2, r23	; 0x02
     3f4:	8b 83       	std	Y+3, r24	; 0x03
     3f6:	9c 83       	std	Y+4, r25	; 0x04
     3f8:	2d 83       	std	Y+5, r18	; 0x05
     3fa:	3e 83       	std	Y+6, r19	; 0x06
     3fc:	4f 83       	std	Y+7, r20	; 0x07
     3fe:	58 87       	std	Y+8, r21	; 0x08
     400:	f9 e0       	ldi	r31, 0x09	; 9
     402:	ef 2e       	mov	r14, r31
     404:	f1 2c       	mov	r15, r1
     406:	ec 0e       	add	r14, r28
     408:	fd 1e       	adc	r15, r29
     40a:	ce 01       	movw	r24, r28
     40c:	01 96       	adiw	r24, 0x01	; 1
     40e:	b7 01       	movw	r22, r14
     410:	0e 94 46 06 	call	0xc8c	; 0xc8c <__unpack_f>
     414:	8e 01       	movw	r16, r28
     416:	0f 5e       	subi	r16, 0xEF	; 239
     418:	1f 4f       	sbci	r17, 0xFF	; 255
     41a:	ce 01       	movw	r24, r28
     41c:	05 96       	adiw	r24, 0x05	; 5
     41e:	b8 01       	movw	r22, r16
     420:	0e 94 46 06 	call	0xc8c	; 0xc8c <__unpack_f>
     424:	c7 01       	movw	r24, r14
     426:	b8 01       	movw	r22, r16
     428:	ae 01       	movw	r20, r28
     42a:	47 5e       	subi	r20, 0xE7	; 231
     42c:	5f 4f       	sbci	r21, 0xFF	; 255
     42e:	0e 94 75 00 	call	0xea	; 0xea <_fpadd_parts>
     432:	0e 94 71 05 	call	0xae2	; 0xae2 <__pack_f>
     436:	a0 96       	adiw	r28, 0x20	; 32
     438:	e6 e0       	ldi	r30, 0x06	; 6
     43a:	0c 94 09 4b 	jmp	0x9612	; 0x9612 <__epilogue_restores__+0x18>

0000043e <__mulsf3>:
     43e:	a0 e2       	ldi	r26, 0x20	; 32
     440:	b0 e0       	ldi	r27, 0x00	; 0
     442:	e5 e2       	ldi	r30, 0x25	; 37
     444:	f2 e0       	ldi	r31, 0x02	; 2
     446:	0c 94 e1 4a 	jmp	0x95c2	; 0x95c2 <__prologue_saves__>
     44a:	69 83       	std	Y+1, r22	; 0x01
     44c:	7a 83       	std	Y+2, r23	; 0x02
     44e:	8b 83       	std	Y+3, r24	; 0x03
     450:	9c 83       	std	Y+4, r25	; 0x04
     452:	2d 83       	std	Y+5, r18	; 0x05
     454:	3e 83       	std	Y+6, r19	; 0x06
     456:	4f 83       	std	Y+7, r20	; 0x07
     458:	58 87       	std	Y+8, r21	; 0x08
     45a:	ce 01       	movw	r24, r28
     45c:	01 96       	adiw	r24, 0x01	; 1
     45e:	be 01       	movw	r22, r28
     460:	67 5f       	subi	r22, 0xF7	; 247
     462:	7f 4f       	sbci	r23, 0xFF	; 255
     464:	0e 94 46 06 	call	0xc8c	; 0xc8c <__unpack_f>
     468:	ce 01       	movw	r24, r28
     46a:	05 96       	adiw	r24, 0x05	; 5
     46c:	be 01       	movw	r22, r28
     46e:	6f 5e       	subi	r22, 0xEF	; 239
     470:	7f 4f       	sbci	r23, 0xFF	; 255
     472:	0e 94 46 06 	call	0xc8c	; 0xc8c <__unpack_f>
     476:	99 85       	ldd	r25, Y+9	; 0x09
     478:	92 30       	cpi	r25, 0x02	; 2
     47a:	88 f0       	brcs	.+34     	; 0x49e <__mulsf3+0x60>
     47c:	89 89       	ldd	r24, Y+17	; 0x11
     47e:	82 30       	cpi	r24, 0x02	; 2
     480:	c8 f0       	brcs	.+50     	; 0x4b4 <__mulsf3+0x76>
     482:	94 30       	cpi	r25, 0x04	; 4
     484:	19 f4       	brne	.+6      	; 0x48c <__mulsf3+0x4e>
     486:	82 30       	cpi	r24, 0x02	; 2
     488:	51 f4       	brne	.+20     	; 0x49e <__mulsf3+0x60>
     48a:	04 c0       	rjmp	.+8      	; 0x494 <__mulsf3+0x56>
     48c:	84 30       	cpi	r24, 0x04	; 4
     48e:	29 f4       	brne	.+10     	; 0x49a <__mulsf3+0x5c>
     490:	92 30       	cpi	r25, 0x02	; 2
     492:	81 f4       	brne	.+32     	; 0x4b4 <__mulsf3+0x76>
     494:	89 e8       	ldi	r24, 0x89	; 137
     496:	90 e0       	ldi	r25, 0x00	; 0
     498:	c6 c0       	rjmp	.+396    	; 0x626 <__mulsf3+0x1e8>
     49a:	92 30       	cpi	r25, 0x02	; 2
     49c:	49 f4       	brne	.+18     	; 0x4b0 <__mulsf3+0x72>
     49e:	20 e0       	ldi	r18, 0x00	; 0
     4a0:	9a 85       	ldd	r25, Y+10	; 0x0a
     4a2:	8a 89       	ldd	r24, Y+18	; 0x12
     4a4:	98 13       	cpse	r25, r24
     4a6:	21 e0       	ldi	r18, 0x01	; 1
     4a8:	2a 87       	std	Y+10, r18	; 0x0a
     4aa:	ce 01       	movw	r24, r28
     4ac:	09 96       	adiw	r24, 0x09	; 9
     4ae:	bb c0       	rjmp	.+374    	; 0x626 <__mulsf3+0x1e8>
     4b0:	82 30       	cpi	r24, 0x02	; 2
     4b2:	49 f4       	brne	.+18     	; 0x4c6 <__mulsf3+0x88>
     4b4:	20 e0       	ldi	r18, 0x00	; 0
     4b6:	9a 85       	ldd	r25, Y+10	; 0x0a
     4b8:	8a 89       	ldd	r24, Y+18	; 0x12
     4ba:	98 13       	cpse	r25, r24
     4bc:	21 e0       	ldi	r18, 0x01	; 1
     4be:	2a 8b       	std	Y+18, r18	; 0x12
     4c0:	ce 01       	movw	r24, r28
     4c2:	41 96       	adiw	r24, 0x11	; 17
     4c4:	b0 c0       	rjmp	.+352    	; 0x626 <__mulsf3+0x1e8>
     4c6:	2d 84       	ldd	r2, Y+13	; 0x0d
     4c8:	3e 84       	ldd	r3, Y+14	; 0x0e
     4ca:	4f 84       	ldd	r4, Y+15	; 0x0f
     4cc:	58 88       	ldd	r5, Y+16	; 0x10
     4ce:	6d 88       	ldd	r6, Y+21	; 0x15
     4d0:	7e 88       	ldd	r7, Y+22	; 0x16
     4d2:	8f 88       	ldd	r8, Y+23	; 0x17
     4d4:	98 8c       	ldd	r9, Y+24	; 0x18
     4d6:	ee 24       	eor	r14, r14
     4d8:	ff 24       	eor	r15, r15
     4da:	87 01       	movw	r16, r14
     4dc:	aa 24       	eor	r10, r10
     4de:	bb 24       	eor	r11, r11
     4e0:	65 01       	movw	r12, r10
     4e2:	40 e0       	ldi	r20, 0x00	; 0
     4e4:	50 e0       	ldi	r21, 0x00	; 0
     4e6:	60 e0       	ldi	r22, 0x00	; 0
     4e8:	70 e0       	ldi	r23, 0x00	; 0
     4ea:	e0 e0       	ldi	r30, 0x00	; 0
     4ec:	f0 e0       	ldi	r31, 0x00	; 0
     4ee:	c1 01       	movw	r24, r2
     4f0:	81 70       	andi	r24, 0x01	; 1
     4f2:	90 70       	andi	r25, 0x00	; 0
     4f4:	89 2b       	or	r24, r25
     4f6:	e9 f0       	breq	.+58     	; 0x532 <__mulsf3+0xf4>
     4f8:	e6 0c       	add	r14, r6
     4fa:	f7 1c       	adc	r15, r7
     4fc:	08 1d       	adc	r16, r8
     4fe:	19 1d       	adc	r17, r9
     500:	9a 01       	movw	r18, r20
     502:	ab 01       	movw	r20, r22
     504:	2a 0d       	add	r18, r10
     506:	3b 1d       	adc	r19, r11
     508:	4c 1d       	adc	r20, r12
     50a:	5d 1d       	adc	r21, r13
     50c:	80 e0       	ldi	r24, 0x00	; 0
     50e:	90 e0       	ldi	r25, 0x00	; 0
     510:	a0 e0       	ldi	r26, 0x00	; 0
     512:	b0 e0       	ldi	r27, 0x00	; 0
     514:	e6 14       	cp	r14, r6
     516:	f7 04       	cpc	r15, r7
     518:	08 05       	cpc	r16, r8
     51a:	19 05       	cpc	r17, r9
     51c:	20 f4       	brcc	.+8      	; 0x526 <__mulsf3+0xe8>
     51e:	81 e0       	ldi	r24, 0x01	; 1
     520:	90 e0       	ldi	r25, 0x00	; 0
     522:	a0 e0       	ldi	r26, 0x00	; 0
     524:	b0 e0       	ldi	r27, 0x00	; 0
     526:	ba 01       	movw	r22, r20
     528:	a9 01       	movw	r20, r18
     52a:	48 0f       	add	r20, r24
     52c:	59 1f       	adc	r21, r25
     52e:	6a 1f       	adc	r22, r26
     530:	7b 1f       	adc	r23, r27
     532:	aa 0c       	add	r10, r10
     534:	bb 1c       	adc	r11, r11
     536:	cc 1c       	adc	r12, r12
     538:	dd 1c       	adc	r13, r13
     53a:	97 fe       	sbrs	r9, 7
     53c:	08 c0       	rjmp	.+16     	; 0x54e <__mulsf3+0x110>
     53e:	81 e0       	ldi	r24, 0x01	; 1
     540:	90 e0       	ldi	r25, 0x00	; 0
     542:	a0 e0       	ldi	r26, 0x00	; 0
     544:	b0 e0       	ldi	r27, 0x00	; 0
     546:	a8 2a       	or	r10, r24
     548:	b9 2a       	or	r11, r25
     54a:	ca 2a       	or	r12, r26
     54c:	db 2a       	or	r13, r27
     54e:	31 96       	adiw	r30, 0x01	; 1
     550:	e0 32       	cpi	r30, 0x20	; 32
     552:	f1 05       	cpc	r31, r1
     554:	49 f0       	breq	.+18     	; 0x568 <__mulsf3+0x12a>
     556:	66 0c       	add	r6, r6
     558:	77 1c       	adc	r7, r7
     55a:	88 1c       	adc	r8, r8
     55c:	99 1c       	adc	r9, r9
     55e:	56 94       	lsr	r5
     560:	47 94       	ror	r4
     562:	37 94       	ror	r3
     564:	27 94       	ror	r2
     566:	c3 cf       	rjmp	.-122    	; 0x4ee <__mulsf3+0xb0>
     568:	fa 85       	ldd	r31, Y+10	; 0x0a
     56a:	ea 89       	ldd	r30, Y+18	; 0x12
     56c:	2b 89       	ldd	r18, Y+19	; 0x13
     56e:	3c 89       	ldd	r19, Y+20	; 0x14
     570:	8b 85       	ldd	r24, Y+11	; 0x0b
     572:	9c 85       	ldd	r25, Y+12	; 0x0c
     574:	28 0f       	add	r18, r24
     576:	39 1f       	adc	r19, r25
     578:	2e 5f       	subi	r18, 0xFE	; 254
     57a:	3f 4f       	sbci	r19, 0xFF	; 255
     57c:	17 c0       	rjmp	.+46     	; 0x5ac <__mulsf3+0x16e>
     57e:	ca 01       	movw	r24, r20
     580:	81 70       	andi	r24, 0x01	; 1
     582:	90 70       	andi	r25, 0x00	; 0
     584:	89 2b       	or	r24, r25
     586:	61 f0       	breq	.+24     	; 0x5a0 <__mulsf3+0x162>
     588:	16 95       	lsr	r17
     58a:	07 95       	ror	r16
     58c:	f7 94       	ror	r15
     58e:	e7 94       	ror	r14
     590:	80 e0       	ldi	r24, 0x00	; 0
     592:	90 e0       	ldi	r25, 0x00	; 0
     594:	a0 e0       	ldi	r26, 0x00	; 0
     596:	b0 e8       	ldi	r27, 0x80	; 128
     598:	e8 2a       	or	r14, r24
     59a:	f9 2a       	or	r15, r25
     59c:	0a 2b       	or	r16, r26
     59e:	1b 2b       	or	r17, r27
     5a0:	76 95       	lsr	r23
     5a2:	67 95       	ror	r22
     5a4:	57 95       	ror	r21
     5a6:	47 95       	ror	r20
     5a8:	2f 5f       	subi	r18, 0xFF	; 255
     5aa:	3f 4f       	sbci	r19, 0xFF	; 255
     5ac:	77 fd       	sbrc	r23, 7
     5ae:	e7 cf       	rjmp	.-50     	; 0x57e <__mulsf3+0x140>
     5b0:	0c c0       	rjmp	.+24     	; 0x5ca <__mulsf3+0x18c>
     5b2:	44 0f       	add	r20, r20
     5b4:	55 1f       	adc	r21, r21
     5b6:	66 1f       	adc	r22, r22
     5b8:	77 1f       	adc	r23, r23
     5ba:	17 fd       	sbrc	r17, 7
     5bc:	41 60       	ori	r20, 0x01	; 1
     5be:	ee 0c       	add	r14, r14
     5c0:	ff 1c       	adc	r15, r15
     5c2:	00 1f       	adc	r16, r16
     5c4:	11 1f       	adc	r17, r17
     5c6:	21 50       	subi	r18, 0x01	; 1
     5c8:	30 40       	sbci	r19, 0x00	; 0
     5ca:	40 30       	cpi	r20, 0x00	; 0
     5cc:	90 e0       	ldi	r25, 0x00	; 0
     5ce:	59 07       	cpc	r21, r25
     5d0:	90 e0       	ldi	r25, 0x00	; 0
     5d2:	69 07       	cpc	r22, r25
     5d4:	90 e4       	ldi	r25, 0x40	; 64
     5d6:	79 07       	cpc	r23, r25
     5d8:	60 f3       	brcs	.-40     	; 0x5b2 <__mulsf3+0x174>
     5da:	2b 8f       	std	Y+27, r18	; 0x1b
     5dc:	3c 8f       	std	Y+28, r19	; 0x1c
     5de:	db 01       	movw	r26, r22
     5e0:	ca 01       	movw	r24, r20
     5e2:	8f 77       	andi	r24, 0x7F	; 127
     5e4:	90 70       	andi	r25, 0x00	; 0
     5e6:	a0 70       	andi	r26, 0x00	; 0
     5e8:	b0 70       	andi	r27, 0x00	; 0
     5ea:	80 34       	cpi	r24, 0x40	; 64
     5ec:	91 05       	cpc	r25, r1
     5ee:	a1 05       	cpc	r26, r1
     5f0:	b1 05       	cpc	r27, r1
     5f2:	61 f4       	brne	.+24     	; 0x60c <__mulsf3+0x1ce>
     5f4:	47 fd       	sbrc	r20, 7
     5f6:	0a c0       	rjmp	.+20     	; 0x60c <__mulsf3+0x1ce>
     5f8:	e1 14       	cp	r14, r1
     5fa:	f1 04       	cpc	r15, r1
     5fc:	01 05       	cpc	r16, r1
     5fe:	11 05       	cpc	r17, r1
     600:	29 f0       	breq	.+10     	; 0x60c <__mulsf3+0x1ce>
     602:	40 5c       	subi	r20, 0xC0	; 192
     604:	5f 4f       	sbci	r21, 0xFF	; 255
     606:	6f 4f       	sbci	r22, 0xFF	; 255
     608:	7f 4f       	sbci	r23, 0xFF	; 255
     60a:	40 78       	andi	r20, 0x80	; 128
     60c:	1a 8e       	std	Y+26, r1	; 0x1a
     60e:	fe 17       	cp	r31, r30
     610:	11 f0       	breq	.+4      	; 0x616 <__mulsf3+0x1d8>
     612:	81 e0       	ldi	r24, 0x01	; 1
     614:	8a 8f       	std	Y+26, r24	; 0x1a
     616:	4d 8f       	std	Y+29, r20	; 0x1d
     618:	5e 8f       	std	Y+30, r21	; 0x1e
     61a:	6f 8f       	std	Y+31, r22	; 0x1f
     61c:	78 a3       	std	Y+32, r23	; 0x20
     61e:	83 e0       	ldi	r24, 0x03	; 3
     620:	89 8f       	std	Y+25, r24	; 0x19
     622:	ce 01       	movw	r24, r28
     624:	49 96       	adiw	r24, 0x19	; 25
     626:	0e 94 71 05 	call	0xae2	; 0xae2 <__pack_f>
     62a:	a0 96       	adiw	r28, 0x20	; 32
     62c:	e2 e1       	ldi	r30, 0x12	; 18
     62e:	0c 94 fd 4a 	jmp	0x95fa	; 0x95fa <__epilogue_restores__>

00000632 <__divsf3>:
     632:	a8 e1       	ldi	r26, 0x18	; 24
     634:	b0 e0       	ldi	r27, 0x00	; 0
     636:	ef e1       	ldi	r30, 0x1F	; 31
     638:	f3 e0       	ldi	r31, 0x03	; 3
     63a:	0c 94 e9 4a 	jmp	0x95d2	; 0x95d2 <__prologue_saves__+0x10>
     63e:	69 83       	std	Y+1, r22	; 0x01
     640:	7a 83       	std	Y+2, r23	; 0x02
     642:	8b 83       	std	Y+3, r24	; 0x03
     644:	9c 83       	std	Y+4, r25	; 0x04
     646:	2d 83       	std	Y+5, r18	; 0x05
     648:	3e 83       	std	Y+6, r19	; 0x06
     64a:	4f 83       	std	Y+7, r20	; 0x07
     64c:	58 87       	std	Y+8, r21	; 0x08
     64e:	b9 e0       	ldi	r27, 0x09	; 9
     650:	eb 2e       	mov	r14, r27
     652:	f1 2c       	mov	r15, r1
     654:	ec 0e       	add	r14, r28
     656:	fd 1e       	adc	r15, r29
     658:	ce 01       	movw	r24, r28
     65a:	01 96       	adiw	r24, 0x01	; 1
     65c:	b7 01       	movw	r22, r14
     65e:	0e 94 46 06 	call	0xc8c	; 0xc8c <__unpack_f>
     662:	8e 01       	movw	r16, r28
     664:	0f 5e       	subi	r16, 0xEF	; 239
     666:	1f 4f       	sbci	r17, 0xFF	; 255
     668:	ce 01       	movw	r24, r28
     66a:	05 96       	adiw	r24, 0x05	; 5
     66c:	b8 01       	movw	r22, r16
     66e:	0e 94 46 06 	call	0xc8c	; 0xc8c <__unpack_f>
     672:	29 85       	ldd	r18, Y+9	; 0x09
     674:	22 30       	cpi	r18, 0x02	; 2
     676:	08 f4       	brcc	.+2      	; 0x67a <__divsf3+0x48>
     678:	7e c0       	rjmp	.+252    	; 0x776 <__divsf3+0x144>
     67a:	39 89       	ldd	r19, Y+17	; 0x11
     67c:	32 30       	cpi	r19, 0x02	; 2
     67e:	10 f4       	brcc	.+4      	; 0x684 <__divsf3+0x52>
     680:	b8 01       	movw	r22, r16
     682:	7c c0       	rjmp	.+248    	; 0x77c <__divsf3+0x14a>
     684:	8a 85       	ldd	r24, Y+10	; 0x0a
     686:	9a 89       	ldd	r25, Y+18	; 0x12
     688:	89 27       	eor	r24, r25
     68a:	8a 87       	std	Y+10, r24	; 0x0a
     68c:	24 30       	cpi	r18, 0x04	; 4
     68e:	11 f0       	breq	.+4      	; 0x694 <__divsf3+0x62>
     690:	22 30       	cpi	r18, 0x02	; 2
     692:	31 f4       	brne	.+12     	; 0x6a0 <__divsf3+0x6e>
     694:	23 17       	cp	r18, r19
     696:	09 f0       	breq	.+2      	; 0x69a <__divsf3+0x68>
     698:	6e c0       	rjmp	.+220    	; 0x776 <__divsf3+0x144>
     69a:	69 e8       	ldi	r22, 0x89	; 137
     69c:	70 e0       	ldi	r23, 0x00	; 0
     69e:	6e c0       	rjmp	.+220    	; 0x77c <__divsf3+0x14a>
     6a0:	34 30       	cpi	r19, 0x04	; 4
     6a2:	39 f4       	brne	.+14     	; 0x6b2 <__divsf3+0x80>
     6a4:	1d 86       	std	Y+13, r1	; 0x0d
     6a6:	1e 86       	std	Y+14, r1	; 0x0e
     6a8:	1f 86       	std	Y+15, r1	; 0x0f
     6aa:	18 8a       	std	Y+16, r1	; 0x10
     6ac:	1c 86       	std	Y+12, r1	; 0x0c
     6ae:	1b 86       	std	Y+11, r1	; 0x0b
     6b0:	04 c0       	rjmp	.+8      	; 0x6ba <__divsf3+0x88>
     6b2:	32 30       	cpi	r19, 0x02	; 2
     6b4:	21 f4       	brne	.+8      	; 0x6be <__divsf3+0x8c>
     6b6:	84 e0       	ldi	r24, 0x04	; 4
     6b8:	89 87       	std	Y+9, r24	; 0x09
     6ba:	b7 01       	movw	r22, r14
     6bc:	5f c0       	rjmp	.+190    	; 0x77c <__divsf3+0x14a>
     6be:	2b 85       	ldd	r18, Y+11	; 0x0b
     6c0:	3c 85       	ldd	r19, Y+12	; 0x0c
     6c2:	8b 89       	ldd	r24, Y+19	; 0x13
     6c4:	9c 89       	ldd	r25, Y+20	; 0x14
     6c6:	28 1b       	sub	r18, r24
     6c8:	39 0b       	sbc	r19, r25
     6ca:	3c 87       	std	Y+12, r19	; 0x0c
     6cc:	2b 87       	std	Y+11, r18	; 0x0b
     6ce:	ed 84       	ldd	r14, Y+13	; 0x0d
     6d0:	fe 84       	ldd	r15, Y+14	; 0x0e
     6d2:	0f 85       	ldd	r16, Y+15	; 0x0f
     6d4:	18 89       	ldd	r17, Y+16	; 0x10
     6d6:	ad 88       	ldd	r10, Y+21	; 0x15
     6d8:	be 88       	ldd	r11, Y+22	; 0x16
     6da:	cf 88       	ldd	r12, Y+23	; 0x17
     6dc:	d8 8c       	ldd	r13, Y+24	; 0x18
     6de:	ea 14       	cp	r14, r10
     6e0:	fb 04       	cpc	r15, r11
     6e2:	0c 05       	cpc	r16, r12
     6e4:	1d 05       	cpc	r17, r13
     6e6:	40 f4       	brcc	.+16     	; 0x6f8 <__divsf3+0xc6>
     6e8:	ee 0c       	add	r14, r14
     6ea:	ff 1c       	adc	r15, r15
     6ec:	00 1f       	adc	r16, r16
     6ee:	11 1f       	adc	r17, r17
     6f0:	21 50       	subi	r18, 0x01	; 1
     6f2:	30 40       	sbci	r19, 0x00	; 0
     6f4:	3c 87       	std	Y+12, r19	; 0x0c
     6f6:	2b 87       	std	Y+11, r18	; 0x0b
     6f8:	20 e0       	ldi	r18, 0x00	; 0
     6fa:	30 e0       	ldi	r19, 0x00	; 0
     6fc:	40 e0       	ldi	r20, 0x00	; 0
     6fe:	50 e0       	ldi	r21, 0x00	; 0
     700:	80 e0       	ldi	r24, 0x00	; 0
     702:	90 e0       	ldi	r25, 0x00	; 0
     704:	a0 e0       	ldi	r26, 0x00	; 0
     706:	b0 e4       	ldi	r27, 0x40	; 64
     708:	60 e0       	ldi	r22, 0x00	; 0
     70a:	70 e0       	ldi	r23, 0x00	; 0
     70c:	ea 14       	cp	r14, r10
     70e:	fb 04       	cpc	r15, r11
     710:	0c 05       	cpc	r16, r12
     712:	1d 05       	cpc	r17, r13
     714:	40 f0       	brcs	.+16     	; 0x726 <__divsf3+0xf4>
     716:	28 2b       	or	r18, r24
     718:	39 2b       	or	r19, r25
     71a:	4a 2b       	or	r20, r26
     71c:	5b 2b       	or	r21, r27
     71e:	ea 18       	sub	r14, r10
     720:	fb 08       	sbc	r15, r11
     722:	0c 09       	sbc	r16, r12
     724:	1d 09       	sbc	r17, r13
     726:	b6 95       	lsr	r27
     728:	a7 95       	ror	r26
     72a:	97 95       	ror	r25
     72c:	87 95       	ror	r24
     72e:	ee 0c       	add	r14, r14
     730:	ff 1c       	adc	r15, r15
     732:	00 1f       	adc	r16, r16
     734:	11 1f       	adc	r17, r17
     736:	6f 5f       	subi	r22, 0xFF	; 255
     738:	7f 4f       	sbci	r23, 0xFF	; 255
     73a:	6f 31       	cpi	r22, 0x1F	; 31
     73c:	71 05       	cpc	r23, r1
     73e:	31 f7       	brne	.-52     	; 0x70c <__divsf3+0xda>
     740:	da 01       	movw	r26, r20
     742:	c9 01       	movw	r24, r18
     744:	8f 77       	andi	r24, 0x7F	; 127
     746:	90 70       	andi	r25, 0x00	; 0
     748:	a0 70       	andi	r26, 0x00	; 0
     74a:	b0 70       	andi	r27, 0x00	; 0
     74c:	80 34       	cpi	r24, 0x40	; 64
     74e:	91 05       	cpc	r25, r1
     750:	a1 05       	cpc	r26, r1
     752:	b1 05       	cpc	r27, r1
     754:	61 f4       	brne	.+24     	; 0x76e <__divsf3+0x13c>
     756:	27 fd       	sbrc	r18, 7
     758:	0a c0       	rjmp	.+20     	; 0x76e <__divsf3+0x13c>
     75a:	e1 14       	cp	r14, r1
     75c:	f1 04       	cpc	r15, r1
     75e:	01 05       	cpc	r16, r1
     760:	11 05       	cpc	r17, r1
     762:	29 f0       	breq	.+10     	; 0x76e <__divsf3+0x13c>
     764:	20 5c       	subi	r18, 0xC0	; 192
     766:	3f 4f       	sbci	r19, 0xFF	; 255
     768:	4f 4f       	sbci	r20, 0xFF	; 255
     76a:	5f 4f       	sbci	r21, 0xFF	; 255
     76c:	20 78       	andi	r18, 0x80	; 128
     76e:	2d 87       	std	Y+13, r18	; 0x0d
     770:	3e 87       	std	Y+14, r19	; 0x0e
     772:	4f 87       	std	Y+15, r20	; 0x0f
     774:	58 8b       	std	Y+16, r21	; 0x10
     776:	be 01       	movw	r22, r28
     778:	67 5f       	subi	r22, 0xF7	; 247
     77a:	7f 4f       	sbci	r23, 0xFF	; 255
     77c:	cb 01       	movw	r24, r22
     77e:	0e 94 71 05 	call	0xae2	; 0xae2 <__pack_f>
     782:	68 96       	adiw	r28, 0x18	; 24
     784:	ea e0       	ldi	r30, 0x0A	; 10
     786:	0c 94 05 4b 	jmp	0x960a	; 0x960a <__epilogue_restores__+0x10>

0000078a <__gtsf2>:
     78a:	a8 e1       	ldi	r26, 0x18	; 24
     78c:	b0 e0       	ldi	r27, 0x00	; 0
     78e:	eb ec       	ldi	r30, 0xCB	; 203
     790:	f3 e0       	ldi	r31, 0x03	; 3
     792:	0c 94 ed 4a 	jmp	0x95da	; 0x95da <__prologue_saves__+0x18>
     796:	69 83       	std	Y+1, r22	; 0x01
     798:	7a 83       	std	Y+2, r23	; 0x02
     79a:	8b 83       	std	Y+3, r24	; 0x03
     79c:	9c 83       	std	Y+4, r25	; 0x04
     79e:	2d 83       	std	Y+5, r18	; 0x05
     7a0:	3e 83       	std	Y+6, r19	; 0x06
     7a2:	4f 83       	std	Y+7, r20	; 0x07
     7a4:	58 87       	std	Y+8, r21	; 0x08
     7a6:	89 e0       	ldi	r24, 0x09	; 9
     7a8:	e8 2e       	mov	r14, r24
     7aa:	f1 2c       	mov	r15, r1
     7ac:	ec 0e       	add	r14, r28
     7ae:	fd 1e       	adc	r15, r29
     7b0:	ce 01       	movw	r24, r28
     7b2:	01 96       	adiw	r24, 0x01	; 1
     7b4:	b7 01       	movw	r22, r14
     7b6:	0e 94 46 06 	call	0xc8c	; 0xc8c <__unpack_f>
     7ba:	8e 01       	movw	r16, r28
     7bc:	0f 5e       	subi	r16, 0xEF	; 239
     7be:	1f 4f       	sbci	r17, 0xFF	; 255
     7c0:	ce 01       	movw	r24, r28
     7c2:	05 96       	adiw	r24, 0x05	; 5
     7c4:	b8 01       	movw	r22, r16
     7c6:	0e 94 46 06 	call	0xc8c	; 0xc8c <__unpack_f>
     7ca:	89 85       	ldd	r24, Y+9	; 0x09
     7cc:	82 30       	cpi	r24, 0x02	; 2
     7ce:	40 f0       	brcs	.+16     	; 0x7e0 <__gtsf2+0x56>
     7d0:	89 89       	ldd	r24, Y+17	; 0x11
     7d2:	82 30       	cpi	r24, 0x02	; 2
     7d4:	28 f0       	brcs	.+10     	; 0x7e0 <__gtsf2+0x56>
     7d6:	c7 01       	movw	r24, r14
     7d8:	b8 01       	movw	r22, r16
     7da:	0e 94 be 06 	call	0xd7c	; 0xd7c <__fpcmp_parts_f>
     7de:	01 c0       	rjmp	.+2      	; 0x7e2 <__gtsf2+0x58>
     7e0:	8f ef       	ldi	r24, 0xFF	; 255
     7e2:	68 96       	adiw	r28, 0x18	; 24
     7e4:	e6 e0       	ldi	r30, 0x06	; 6
     7e6:	0c 94 09 4b 	jmp	0x9612	; 0x9612 <__epilogue_restores__+0x18>

000007ea <__gesf2>:
     7ea:	a8 e1       	ldi	r26, 0x18	; 24
     7ec:	b0 e0       	ldi	r27, 0x00	; 0
     7ee:	eb ef       	ldi	r30, 0xFB	; 251
     7f0:	f3 e0       	ldi	r31, 0x03	; 3
     7f2:	0c 94 ed 4a 	jmp	0x95da	; 0x95da <__prologue_saves__+0x18>
     7f6:	69 83       	std	Y+1, r22	; 0x01
     7f8:	7a 83       	std	Y+2, r23	; 0x02
     7fa:	8b 83       	std	Y+3, r24	; 0x03
     7fc:	9c 83       	std	Y+4, r25	; 0x04
     7fe:	2d 83       	std	Y+5, r18	; 0x05
     800:	3e 83       	std	Y+6, r19	; 0x06
     802:	4f 83       	std	Y+7, r20	; 0x07
     804:	58 87       	std	Y+8, r21	; 0x08
     806:	89 e0       	ldi	r24, 0x09	; 9
     808:	e8 2e       	mov	r14, r24
     80a:	f1 2c       	mov	r15, r1
     80c:	ec 0e       	add	r14, r28
     80e:	fd 1e       	adc	r15, r29
     810:	ce 01       	movw	r24, r28
     812:	01 96       	adiw	r24, 0x01	; 1
     814:	b7 01       	movw	r22, r14
     816:	0e 94 46 06 	call	0xc8c	; 0xc8c <__unpack_f>
     81a:	8e 01       	movw	r16, r28
     81c:	0f 5e       	subi	r16, 0xEF	; 239
     81e:	1f 4f       	sbci	r17, 0xFF	; 255
     820:	ce 01       	movw	r24, r28
     822:	05 96       	adiw	r24, 0x05	; 5
     824:	b8 01       	movw	r22, r16
     826:	0e 94 46 06 	call	0xc8c	; 0xc8c <__unpack_f>
     82a:	89 85       	ldd	r24, Y+9	; 0x09
     82c:	82 30       	cpi	r24, 0x02	; 2
     82e:	40 f0       	brcs	.+16     	; 0x840 <__gesf2+0x56>
     830:	89 89       	ldd	r24, Y+17	; 0x11
     832:	82 30       	cpi	r24, 0x02	; 2
     834:	28 f0       	brcs	.+10     	; 0x840 <__gesf2+0x56>
     836:	c7 01       	movw	r24, r14
     838:	b8 01       	movw	r22, r16
     83a:	0e 94 be 06 	call	0xd7c	; 0xd7c <__fpcmp_parts_f>
     83e:	01 c0       	rjmp	.+2      	; 0x842 <__gesf2+0x58>
     840:	8f ef       	ldi	r24, 0xFF	; 255
     842:	68 96       	adiw	r28, 0x18	; 24
     844:	e6 e0       	ldi	r30, 0x06	; 6
     846:	0c 94 09 4b 	jmp	0x9612	; 0x9612 <__epilogue_restores__+0x18>

0000084a <__ltsf2>:
     84a:	a8 e1       	ldi	r26, 0x18	; 24
     84c:	b0 e0       	ldi	r27, 0x00	; 0
     84e:	eb e2       	ldi	r30, 0x2B	; 43
     850:	f4 e0       	ldi	r31, 0x04	; 4
     852:	0c 94 ed 4a 	jmp	0x95da	; 0x95da <__prologue_saves__+0x18>
     856:	69 83       	std	Y+1, r22	; 0x01
     858:	7a 83       	std	Y+2, r23	; 0x02
     85a:	8b 83       	std	Y+3, r24	; 0x03
     85c:	9c 83       	std	Y+4, r25	; 0x04
     85e:	2d 83       	std	Y+5, r18	; 0x05
     860:	3e 83       	std	Y+6, r19	; 0x06
     862:	4f 83       	std	Y+7, r20	; 0x07
     864:	58 87       	std	Y+8, r21	; 0x08
     866:	89 e0       	ldi	r24, 0x09	; 9
     868:	e8 2e       	mov	r14, r24
     86a:	f1 2c       	mov	r15, r1
     86c:	ec 0e       	add	r14, r28
     86e:	fd 1e       	adc	r15, r29
     870:	ce 01       	movw	r24, r28
     872:	01 96       	adiw	r24, 0x01	; 1
     874:	b7 01       	movw	r22, r14
     876:	0e 94 46 06 	call	0xc8c	; 0xc8c <__unpack_f>
     87a:	8e 01       	movw	r16, r28
     87c:	0f 5e       	subi	r16, 0xEF	; 239
     87e:	1f 4f       	sbci	r17, 0xFF	; 255
     880:	ce 01       	movw	r24, r28
     882:	05 96       	adiw	r24, 0x05	; 5
     884:	b8 01       	movw	r22, r16
     886:	0e 94 46 06 	call	0xc8c	; 0xc8c <__unpack_f>
     88a:	89 85       	ldd	r24, Y+9	; 0x09
     88c:	82 30       	cpi	r24, 0x02	; 2
     88e:	40 f0       	brcs	.+16     	; 0x8a0 <__stack+0x41>
     890:	89 89       	ldd	r24, Y+17	; 0x11
     892:	82 30       	cpi	r24, 0x02	; 2
     894:	28 f0       	brcs	.+10     	; 0x8a0 <__stack+0x41>
     896:	c7 01       	movw	r24, r14
     898:	b8 01       	movw	r22, r16
     89a:	0e 94 be 06 	call	0xd7c	; 0xd7c <__fpcmp_parts_f>
     89e:	01 c0       	rjmp	.+2      	; 0x8a2 <__stack+0x43>
     8a0:	81 e0       	ldi	r24, 0x01	; 1
     8a2:	68 96       	adiw	r28, 0x18	; 24
     8a4:	e6 e0       	ldi	r30, 0x06	; 6
     8a6:	0c 94 09 4b 	jmp	0x9612	; 0x9612 <__epilogue_restores__+0x18>

000008aa <__fixsfsi>:
     8aa:	ac e0       	ldi	r26, 0x0C	; 12
     8ac:	b0 e0       	ldi	r27, 0x00	; 0
     8ae:	eb e5       	ldi	r30, 0x5B	; 91
     8b0:	f4 e0       	ldi	r31, 0x04	; 4
     8b2:	0c 94 f1 4a 	jmp	0x95e2	; 0x95e2 <__prologue_saves__+0x20>
     8b6:	69 83       	std	Y+1, r22	; 0x01
     8b8:	7a 83       	std	Y+2, r23	; 0x02
     8ba:	8b 83       	std	Y+3, r24	; 0x03
     8bc:	9c 83       	std	Y+4, r25	; 0x04
     8be:	ce 01       	movw	r24, r28
     8c0:	01 96       	adiw	r24, 0x01	; 1
     8c2:	be 01       	movw	r22, r28
     8c4:	6b 5f       	subi	r22, 0xFB	; 251
     8c6:	7f 4f       	sbci	r23, 0xFF	; 255
     8c8:	0e 94 46 06 	call	0xc8c	; 0xc8c <__unpack_f>
     8cc:	8d 81       	ldd	r24, Y+5	; 0x05
     8ce:	82 30       	cpi	r24, 0x02	; 2
     8d0:	61 f1       	breq	.+88     	; 0x92a <__fixsfsi+0x80>
     8d2:	82 30       	cpi	r24, 0x02	; 2
     8d4:	50 f1       	brcs	.+84     	; 0x92a <__fixsfsi+0x80>
     8d6:	84 30       	cpi	r24, 0x04	; 4
     8d8:	21 f4       	brne	.+8      	; 0x8e2 <__fixsfsi+0x38>
     8da:	8e 81       	ldd	r24, Y+6	; 0x06
     8dc:	88 23       	and	r24, r24
     8de:	51 f1       	breq	.+84     	; 0x934 <__fixsfsi+0x8a>
     8e0:	2e c0       	rjmp	.+92     	; 0x93e <__fixsfsi+0x94>
     8e2:	2f 81       	ldd	r18, Y+7	; 0x07
     8e4:	38 85       	ldd	r19, Y+8	; 0x08
     8e6:	37 fd       	sbrc	r19, 7
     8e8:	20 c0       	rjmp	.+64     	; 0x92a <__fixsfsi+0x80>
     8ea:	6e 81       	ldd	r22, Y+6	; 0x06
     8ec:	2f 31       	cpi	r18, 0x1F	; 31
     8ee:	31 05       	cpc	r19, r1
     8f0:	1c f0       	brlt	.+6      	; 0x8f8 <__fixsfsi+0x4e>
     8f2:	66 23       	and	r22, r22
     8f4:	f9 f0       	breq	.+62     	; 0x934 <__fixsfsi+0x8a>
     8f6:	23 c0       	rjmp	.+70     	; 0x93e <__fixsfsi+0x94>
     8f8:	8e e1       	ldi	r24, 0x1E	; 30
     8fa:	90 e0       	ldi	r25, 0x00	; 0
     8fc:	82 1b       	sub	r24, r18
     8fe:	93 0b       	sbc	r25, r19
     900:	29 85       	ldd	r18, Y+9	; 0x09
     902:	3a 85       	ldd	r19, Y+10	; 0x0a
     904:	4b 85       	ldd	r20, Y+11	; 0x0b
     906:	5c 85       	ldd	r21, Y+12	; 0x0c
     908:	04 c0       	rjmp	.+8      	; 0x912 <__fixsfsi+0x68>
     90a:	56 95       	lsr	r21
     90c:	47 95       	ror	r20
     90e:	37 95       	ror	r19
     910:	27 95       	ror	r18
     912:	8a 95       	dec	r24
     914:	d2 f7       	brpl	.-12     	; 0x90a <__fixsfsi+0x60>
     916:	66 23       	and	r22, r22
     918:	b1 f0       	breq	.+44     	; 0x946 <__fixsfsi+0x9c>
     91a:	50 95       	com	r21
     91c:	40 95       	com	r20
     91e:	30 95       	com	r19
     920:	21 95       	neg	r18
     922:	3f 4f       	sbci	r19, 0xFF	; 255
     924:	4f 4f       	sbci	r20, 0xFF	; 255
     926:	5f 4f       	sbci	r21, 0xFF	; 255
     928:	0e c0       	rjmp	.+28     	; 0x946 <__fixsfsi+0x9c>
     92a:	20 e0       	ldi	r18, 0x00	; 0
     92c:	30 e0       	ldi	r19, 0x00	; 0
     92e:	40 e0       	ldi	r20, 0x00	; 0
     930:	50 e0       	ldi	r21, 0x00	; 0
     932:	09 c0       	rjmp	.+18     	; 0x946 <__fixsfsi+0x9c>
     934:	2f ef       	ldi	r18, 0xFF	; 255
     936:	3f ef       	ldi	r19, 0xFF	; 255
     938:	4f ef       	ldi	r20, 0xFF	; 255
     93a:	5f e7       	ldi	r21, 0x7F	; 127
     93c:	04 c0       	rjmp	.+8      	; 0x946 <__fixsfsi+0x9c>
     93e:	20 e0       	ldi	r18, 0x00	; 0
     940:	30 e0       	ldi	r19, 0x00	; 0
     942:	40 e0       	ldi	r20, 0x00	; 0
     944:	50 e8       	ldi	r21, 0x80	; 128
     946:	b9 01       	movw	r22, r18
     948:	ca 01       	movw	r24, r20
     94a:	2c 96       	adiw	r28, 0x0c	; 12
     94c:	e2 e0       	ldi	r30, 0x02	; 2
     94e:	0c 94 0d 4b 	jmp	0x961a	; 0x961a <__epilogue_restores__+0x20>

00000952 <__floatunsisf>:
     952:	a8 e0       	ldi	r26, 0x08	; 8
     954:	b0 e0       	ldi	r27, 0x00	; 0
     956:	ef ea       	ldi	r30, 0xAF	; 175
     958:	f4 e0       	ldi	r31, 0x04	; 4
     95a:	0c 94 e9 4a 	jmp	0x95d2	; 0x95d2 <__prologue_saves__+0x10>
     95e:	7b 01       	movw	r14, r22
     960:	8c 01       	movw	r16, r24
     962:	61 15       	cp	r22, r1
     964:	71 05       	cpc	r23, r1
     966:	81 05       	cpc	r24, r1
     968:	91 05       	cpc	r25, r1
     96a:	19 f4       	brne	.+6      	; 0x972 <__floatunsisf+0x20>
     96c:	82 e0       	ldi	r24, 0x02	; 2
     96e:	89 83       	std	Y+1, r24	; 0x01
     970:	60 c0       	rjmp	.+192    	; 0xa32 <__floatunsisf+0xe0>
     972:	83 e0       	ldi	r24, 0x03	; 3
     974:	89 83       	std	Y+1, r24	; 0x01
     976:	8e e1       	ldi	r24, 0x1E	; 30
     978:	c8 2e       	mov	r12, r24
     97a:	d1 2c       	mov	r13, r1
     97c:	dc 82       	std	Y+4, r13	; 0x04
     97e:	cb 82       	std	Y+3, r12	; 0x03
     980:	ed 82       	std	Y+5, r14	; 0x05
     982:	fe 82       	std	Y+6, r15	; 0x06
     984:	0f 83       	std	Y+7, r16	; 0x07
     986:	18 87       	std	Y+8, r17	; 0x08
     988:	c8 01       	movw	r24, r16
     98a:	b7 01       	movw	r22, r14
     98c:	0e 94 22 05 	call	0xa44	; 0xa44 <__clzsi2>
     990:	fc 01       	movw	r30, r24
     992:	31 97       	sbiw	r30, 0x01	; 1
     994:	f7 ff       	sbrs	r31, 7
     996:	3b c0       	rjmp	.+118    	; 0xa0e <__floatunsisf+0xbc>
     998:	22 27       	eor	r18, r18
     99a:	33 27       	eor	r19, r19
     99c:	2e 1b       	sub	r18, r30
     99e:	3f 0b       	sbc	r19, r31
     9a0:	57 01       	movw	r10, r14
     9a2:	68 01       	movw	r12, r16
     9a4:	02 2e       	mov	r0, r18
     9a6:	04 c0       	rjmp	.+8      	; 0x9b0 <__floatunsisf+0x5e>
     9a8:	d6 94       	lsr	r13
     9aa:	c7 94       	ror	r12
     9ac:	b7 94       	ror	r11
     9ae:	a7 94       	ror	r10
     9b0:	0a 94       	dec	r0
     9b2:	d2 f7       	brpl	.-12     	; 0x9a8 <__floatunsisf+0x56>
     9b4:	40 e0       	ldi	r20, 0x00	; 0
     9b6:	50 e0       	ldi	r21, 0x00	; 0
     9b8:	60 e0       	ldi	r22, 0x00	; 0
     9ba:	70 e0       	ldi	r23, 0x00	; 0
     9bc:	81 e0       	ldi	r24, 0x01	; 1
     9be:	90 e0       	ldi	r25, 0x00	; 0
     9c0:	a0 e0       	ldi	r26, 0x00	; 0
     9c2:	b0 e0       	ldi	r27, 0x00	; 0
     9c4:	04 c0       	rjmp	.+8      	; 0x9ce <__floatunsisf+0x7c>
     9c6:	88 0f       	add	r24, r24
     9c8:	99 1f       	adc	r25, r25
     9ca:	aa 1f       	adc	r26, r26
     9cc:	bb 1f       	adc	r27, r27
     9ce:	2a 95       	dec	r18
     9d0:	d2 f7       	brpl	.-12     	; 0x9c6 <__floatunsisf+0x74>
     9d2:	01 97       	sbiw	r24, 0x01	; 1
     9d4:	a1 09       	sbc	r26, r1
     9d6:	b1 09       	sbc	r27, r1
     9d8:	8e 21       	and	r24, r14
     9da:	9f 21       	and	r25, r15
     9dc:	a0 23       	and	r26, r16
     9de:	b1 23       	and	r27, r17
     9e0:	00 97       	sbiw	r24, 0x00	; 0
     9e2:	a1 05       	cpc	r26, r1
     9e4:	b1 05       	cpc	r27, r1
     9e6:	21 f0       	breq	.+8      	; 0x9f0 <__floatunsisf+0x9e>
     9e8:	41 e0       	ldi	r20, 0x01	; 1
     9ea:	50 e0       	ldi	r21, 0x00	; 0
     9ec:	60 e0       	ldi	r22, 0x00	; 0
     9ee:	70 e0       	ldi	r23, 0x00	; 0
     9f0:	4a 29       	or	r20, r10
     9f2:	5b 29       	or	r21, r11
     9f4:	6c 29       	or	r22, r12
     9f6:	7d 29       	or	r23, r13
     9f8:	4d 83       	std	Y+5, r20	; 0x05
     9fa:	5e 83       	std	Y+6, r21	; 0x06
     9fc:	6f 83       	std	Y+7, r22	; 0x07
     9fe:	78 87       	std	Y+8, r23	; 0x08
     a00:	8e e1       	ldi	r24, 0x1E	; 30
     a02:	90 e0       	ldi	r25, 0x00	; 0
     a04:	8e 1b       	sub	r24, r30
     a06:	9f 0b       	sbc	r25, r31
     a08:	9c 83       	std	Y+4, r25	; 0x04
     a0a:	8b 83       	std	Y+3, r24	; 0x03
     a0c:	12 c0       	rjmp	.+36     	; 0xa32 <__floatunsisf+0xe0>
     a0e:	30 97       	sbiw	r30, 0x00	; 0
     a10:	81 f0       	breq	.+32     	; 0xa32 <__floatunsisf+0xe0>
     a12:	0e 2e       	mov	r0, r30
     a14:	04 c0       	rjmp	.+8      	; 0xa1e <__floatunsisf+0xcc>
     a16:	ee 0c       	add	r14, r14
     a18:	ff 1c       	adc	r15, r15
     a1a:	00 1f       	adc	r16, r16
     a1c:	11 1f       	adc	r17, r17
     a1e:	0a 94       	dec	r0
     a20:	d2 f7       	brpl	.-12     	; 0xa16 <__floatunsisf+0xc4>
     a22:	ed 82       	std	Y+5, r14	; 0x05
     a24:	fe 82       	std	Y+6, r15	; 0x06
     a26:	0f 83       	std	Y+7, r16	; 0x07
     a28:	18 87       	std	Y+8, r17	; 0x08
     a2a:	ce 1a       	sub	r12, r30
     a2c:	df 0a       	sbc	r13, r31
     a2e:	dc 82       	std	Y+4, r13	; 0x04
     a30:	cb 82       	std	Y+3, r12	; 0x03
     a32:	1a 82       	std	Y+2, r1	; 0x02
     a34:	ce 01       	movw	r24, r28
     a36:	01 96       	adiw	r24, 0x01	; 1
     a38:	0e 94 71 05 	call	0xae2	; 0xae2 <__pack_f>
     a3c:	28 96       	adiw	r28, 0x08	; 8
     a3e:	ea e0       	ldi	r30, 0x0A	; 10
     a40:	0c 94 05 4b 	jmp	0x960a	; 0x960a <__epilogue_restores__+0x10>

00000a44 <__clzsi2>:
     a44:	ef 92       	push	r14
     a46:	ff 92       	push	r15
     a48:	0f 93       	push	r16
     a4a:	1f 93       	push	r17
     a4c:	7b 01       	movw	r14, r22
     a4e:	8c 01       	movw	r16, r24
     a50:	80 e0       	ldi	r24, 0x00	; 0
     a52:	e8 16       	cp	r14, r24
     a54:	80 e0       	ldi	r24, 0x00	; 0
     a56:	f8 06       	cpc	r15, r24
     a58:	81 e0       	ldi	r24, 0x01	; 1
     a5a:	08 07       	cpc	r16, r24
     a5c:	80 e0       	ldi	r24, 0x00	; 0
     a5e:	18 07       	cpc	r17, r24
     a60:	88 f4       	brcc	.+34     	; 0xa84 <__clzsi2+0x40>
     a62:	8f ef       	ldi	r24, 0xFF	; 255
     a64:	e8 16       	cp	r14, r24
     a66:	f1 04       	cpc	r15, r1
     a68:	01 05       	cpc	r16, r1
     a6a:	11 05       	cpc	r17, r1
     a6c:	31 f0       	breq	.+12     	; 0xa7a <__clzsi2+0x36>
     a6e:	28 f0       	brcs	.+10     	; 0xa7a <__clzsi2+0x36>
     a70:	88 e0       	ldi	r24, 0x08	; 8
     a72:	90 e0       	ldi	r25, 0x00	; 0
     a74:	a0 e0       	ldi	r26, 0x00	; 0
     a76:	b0 e0       	ldi	r27, 0x00	; 0
     a78:	17 c0       	rjmp	.+46     	; 0xaa8 <__clzsi2+0x64>
     a7a:	80 e0       	ldi	r24, 0x00	; 0
     a7c:	90 e0       	ldi	r25, 0x00	; 0
     a7e:	a0 e0       	ldi	r26, 0x00	; 0
     a80:	b0 e0       	ldi	r27, 0x00	; 0
     a82:	12 c0       	rjmp	.+36     	; 0xaa8 <__clzsi2+0x64>
     a84:	80 e0       	ldi	r24, 0x00	; 0
     a86:	e8 16       	cp	r14, r24
     a88:	80 e0       	ldi	r24, 0x00	; 0
     a8a:	f8 06       	cpc	r15, r24
     a8c:	80 e0       	ldi	r24, 0x00	; 0
     a8e:	08 07       	cpc	r16, r24
     a90:	81 e0       	ldi	r24, 0x01	; 1
     a92:	18 07       	cpc	r17, r24
     a94:	28 f0       	brcs	.+10     	; 0xaa0 <__clzsi2+0x5c>
     a96:	88 e1       	ldi	r24, 0x18	; 24
     a98:	90 e0       	ldi	r25, 0x00	; 0
     a9a:	a0 e0       	ldi	r26, 0x00	; 0
     a9c:	b0 e0       	ldi	r27, 0x00	; 0
     a9e:	04 c0       	rjmp	.+8      	; 0xaa8 <__clzsi2+0x64>
     aa0:	80 e1       	ldi	r24, 0x10	; 16
     aa2:	90 e0       	ldi	r25, 0x00	; 0
     aa4:	a0 e0       	ldi	r26, 0x00	; 0
     aa6:	b0 e0       	ldi	r27, 0x00	; 0
     aa8:	20 e2       	ldi	r18, 0x20	; 32
     aaa:	30 e0       	ldi	r19, 0x00	; 0
     aac:	40 e0       	ldi	r20, 0x00	; 0
     aae:	50 e0       	ldi	r21, 0x00	; 0
     ab0:	28 1b       	sub	r18, r24
     ab2:	39 0b       	sbc	r19, r25
     ab4:	4a 0b       	sbc	r20, r26
     ab6:	5b 0b       	sbc	r21, r27
     ab8:	04 c0       	rjmp	.+8      	; 0xac2 <__clzsi2+0x7e>
     aba:	16 95       	lsr	r17
     abc:	07 95       	ror	r16
     abe:	f7 94       	ror	r15
     ac0:	e7 94       	ror	r14
     ac2:	8a 95       	dec	r24
     ac4:	d2 f7       	brpl	.-12     	; 0xaba <__clzsi2+0x76>
     ac6:	f7 01       	movw	r30, r14
     ac8:	ef 56       	subi	r30, 0x6F	; 111
     aca:	ff 4f       	sbci	r31, 0xFF	; 255
     acc:	80 81       	ld	r24, Z
     ace:	28 1b       	sub	r18, r24
     ad0:	31 09       	sbc	r19, r1
     ad2:	41 09       	sbc	r20, r1
     ad4:	51 09       	sbc	r21, r1
     ad6:	c9 01       	movw	r24, r18
     ad8:	1f 91       	pop	r17
     ada:	0f 91       	pop	r16
     adc:	ff 90       	pop	r15
     ade:	ef 90       	pop	r14
     ae0:	08 95       	ret

00000ae2 <__pack_f>:
     ae2:	df 92       	push	r13
     ae4:	ef 92       	push	r14
     ae6:	ff 92       	push	r15
     ae8:	0f 93       	push	r16
     aea:	1f 93       	push	r17
     aec:	fc 01       	movw	r30, r24
     aee:	e4 80       	ldd	r14, Z+4	; 0x04
     af0:	f5 80       	ldd	r15, Z+5	; 0x05
     af2:	06 81       	ldd	r16, Z+6	; 0x06
     af4:	17 81       	ldd	r17, Z+7	; 0x07
     af6:	d1 80       	ldd	r13, Z+1	; 0x01
     af8:	80 81       	ld	r24, Z
     afa:	82 30       	cpi	r24, 0x02	; 2
     afc:	48 f4       	brcc	.+18     	; 0xb10 <__pack_f+0x2e>
     afe:	80 e0       	ldi	r24, 0x00	; 0
     b00:	90 e0       	ldi	r25, 0x00	; 0
     b02:	a0 e1       	ldi	r26, 0x10	; 16
     b04:	b0 e0       	ldi	r27, 0x00	; 0
     b06:	e8 2a       	or	r14, r24
     b08:	f9 2a       	or	r15, r25
     b0a:	0a 2b       	or	r16, r26
     b0c:	1b 2b       	or	r17, r27
     b0e:	a5 c0       	rjmp	.+330    	; 0xc5a <__pack_f+0x178>
     b10:	84 30       	cpi	r24, 0x04	; 4
     b12:	09 f4       	brne	.+2      	; 0xb16 <__pack_f+0x34>
     b14:	9f c0       	rjmp	.+318    	; 0xc54 <__pack_f+0x172>
     b16:	82 30       	cpi	r24, 0x02	; 2
     b18:	21 f4       	brne	.+8      	; 0xb22 <__pack_f+0x40>
     b1a:	ee 24       	eor	r14, r14
     b1c:	ff 24       	eor	r15, r15
     b1e:	87 01       	movw	r16, r14
     b20:	05 c0       	rjmp	.+10     	; 0xb2c <__pack_f+0x4a>
     b22:	e1 14       	cp	r14, r1
     b24:	f1 04       	cpc	r15, r1
     b26:	01 05       	cpc	r16, r1
     b28:	11 05       	cpc	r17, r1
     b2a:	19 f4       	brne	.+6      	; 0xb32 <__pack_f+0x50>
     b2c:	e0 e0       	ldi	r30, 0x00	; 0
     b2e:	f0 e0       	ldi	r31, 0x00	; 0
     b30:	96 c0       	rjmp	.+300    	; 0xc5e <__pack_f+0x17c>
     b32:	62 81       	ldd	r22, Z+2	; 0x02
     b34:	73 81       	ldd	r23, Z+3	; 0x03
     b36:	9f ef       	ldi	r25, 0xFF	; 255
     b38:	62 38       	cpi	r22, 0x82	; 130
     b3a:	79 07       	cpc	r23, r25
     b3c:	0c f0       	brlt	.+2      	; 0xb40 <__pack_f+0x5e>
     b3e:	5b c0       	rjmp	.+182    	; 0xbf6 <__pack_f+0x114>
     b40:	22 e8       	ldi	r18, 0x82	; 130
     b42:	3f ef       	ldi	r19, 0xFF	; 255
     b44:	26 1b       	sub	r18, r22
     b46:	37 0b       	sbc	r19, r23
     b48:	2a 31       	cpi	r18, 0x1A	; 26
     b4a:	31 05       	cpc	r19, r1
     b4c:	2c f0       	brlt	.+10     	; 0xb58 <__pack_f+0x76>
     b4e:	20 e0       	ldi	r18, 0x00	; 0
     b50:	30 e0       	ldi	r19, 0x00	; 0
     b52:	40 e0       	ldi	r20, 0x00	; 0
     b54:	50 e0       	ldi	r21, 0x00	; 0
     b56:	2a c0       	rjmp	.+84     	; 0xbac <__pack_f+0xca>
     b58:	b8 01       	movw	r22, r16
     b5a:	a7 01       	movw	r20, r14
     b5c:	02 2e       	mov	r0, r18
     b5e:	04 c0       	rjmp	.+8      	; 0xb68 <__pack_f+0x86>
     b60:	76 95       	lsr	r23
     b62:	67 95       	ror	r22
     b64:	57 95       	ror	r21
     b66:	47 95       	ror	r20
     b68:	0a 94       	dec	r0
     b6a:	d2 f7       	brpl	.-12     	; 0xb60 <__pack_f+0x7e>
     b6c:	81 e0       	ldi	r24, 0x01	; 1
     b6e:	90 e0       	ldi	r25, 0x00	; 0
     b70:	a0 e0       	ldi	r26, 0x00	; 0
     b72:	b0 e0       	ldi	r27, 0x00	; 0
     b74:	04 c0       	rjmp	.+8      	; 0xb7e <__pack_f+0x9c>
     b76:	88 0f       	add	r24, r24
     b78:	99 1f       	adc	r25, r25
     b7a:	aa 1f       	adc	r26, r26
     b7c:	bb 1f       	adc	r27, r27
     b7e:	2a 95       	dec	r18
     b80:	d2 f7       	brpl	.-12     	; 0xb76 <__pack_f+0x94>
     b82:	01 97       	sbiw	r24, 0x01	; 1
     b84:	a1 09       	sbc	r26, r1
     b86:	b1 09       	sbc	r27, r1
     b88:	8e 21       	and	r24, r14
     b8a:	9f 21       	and	r25, r15
     b8c:	a0 23       	and	r26, r16
     b8e:	b1 23       	and	r27, r17
     b90:	00 97       	sbiw	r24, 0x00	; 0
     b92:	a1 05       	cpc	r26, r1
     b94:	b1 05       	cpc	r27, r1
     b96:	21 f0       	breq	.+8      	; 0xba0 <__pack_f+0xbe>
     b98:	81 e0       	ldi	r24, 0x01	; 1
     b9a:	90 e0       	ldi	r25, 0x00	; 0
     b9c:	a0 e0       	ldi	r26, 0x00	; 0
     b9e:	b0 e0       	ldi	r27, 0x00	; 0
     ba0:	9a 01       	movw	r18, r20
     ba2:	ab 01       	movw	r20, r22
     ba4:	28 2b       	or	r18, r24
     ba6:	39 2b       	or	r19, r25
     ba8:	4a 2b       	or	r20, r26
     baa:	5b 2b       	or	r21, r27
     bac:	da 01       	movw	r26, r20
     bae:	c9 01       	movw	r24, r18
     bb0:	8f 77       	andi	r24, 0x7F	; 127
     bb2:	90 70       	andi	r25, 0x00	; 0
     bb4:	a0 70       	andi	r26, 0x00	; 0
     bb6:	b0 70       	andi	r27, 0x00	; 0
     bb8:	80 34       	cpi	r24, 0x40	; 64
     bba:	91 05       	cpc	r25, r1
     bbc:	a1 05       	cpc	r26, r1
     bbe:	b1 05       	cpc	r27, r1
     bc0:	39 f4       	brne	.+14     	; 0xbd0 <__pack_f+0xee>
     bc2:	27 ff       	sbrs	r18, 7
     bc4:	09 c0       	rjmp	.+18     	; 0xbd8 <__pack_f+0xf6>
     bc6:	20 5c       	subi	r18, 0xC0	; 192
     bc8:	3f 4f       	sbci	r19, 0xFF	; 255
     bca:	4f 4f       	sbci	r20, 0xFF	; 255
     bcc:	5f 4f       	sbci	r21, 0xFF	; 255
     bce:	04 c0       	rjmp	.+8      	; 0xbd8 <__pack_f+0xf6>
     bd0:	21 5c       	subi	r18, 0xC1	; 193
     bd2:	3f 4f       	sbci	r19, 0xFF	; 255
     bd4:	4f 4f       	sbci	r20, 0xFF	; 255
     bd6:	5f 4f       	sbci	r21, 0xFF	; 255
     bd8:	e0 e0       	ldi	r30, 0x00	; 0
     bda:	f0 e0       	ldi	r31, 0x00	; 0
     bdc:	20 30       	cpi	r18, 0x00	; 0
     bde:	a0 e0       	ldi	r26, 0x00	; 0
     be0:	3a 07       	cpc	r19, r26
     be2:	a0 e0       	ldi	r26, 0x00	; 0
     be4:	4a 07       	cpc	r20, r26
     be6:	a0 e4       	ldi	r26, 0x40	; 64
     be8:	5a 07       	cpc	r21, r26
     bea:	10 f0       	brcs	.+4      	; 0xbf0 <__pack_f+0x10e>
     bec:	e1 e0       	ldi	r30, 0x01	; 1
     bee:	f0 e0       	ldi	r31, 0x00	; 0
     bf0:	79 01       	movw	r14, r18
     bf2:	8a 01       	movw	r16, r20
     bf4:	27 c0       	rjmp	.+78     	; 0xc44 <__pack_f+0x162>
     bf6:	60 38       	cpi	r22, 0x80	; 128
     bf8:	71 05       	cpc	r23, r1
     bfa:	64 f5       	brge	.+88     	; 0xc54 <__pack_f+0x172>
     bfc:	fb 01       	movw	r30, r22
     bfe:	e1 58       	subi	r30, 0x81	; 129
     c00:	ff 4f       	sbci	r31, 0xFF	; 255
     c02:	d8 01       	movw	r26, r16
     c04:	c7 01       	movw	r24, r14
     c06:	8f 77       	andi	r24, 0x7F	; 127
     c08:	90 70       	andi	r25, 0x00	; 0
     c0a:	a0 70       	andi	r26, 0x00	; 0
     c0c:	b0 70       	andi	r27, 0x00	; 0
     c0e:	80 34       	cpi	r24, 0x40	; 64
     c10:	91 05       	cpc	r25, r1
     c12:	a1 05       	cpc	r26, r1
     c14:	b1 05       	cpc	r27, r1
     c16:	39 f4       	brne	.+14     	; 0xc26 <__pack_f+0x144>
     c18:	e7 fe       	sbrs	r14, 7
     c1a:	0d c0       	rjmp	.+26     	; 0xc36 <__pack_f+0x154>
     c1c:	80 e4       	ldi	r24, 0x40	; 64
     c1e:	90 e0       	ldi	r25, 0x00	; 0
     c20:	a0 e0       	ldi	r26, 0x00	; 0
     c22:	b0 e0       	ldi	r27, 0x00	; 0
     c24:	04 c0       	rjmp	.+8      	; 0xc2e <__pack_f+0x14c>
     c26:	8f e3       	ldi	r24, 0x3F	; 63
     c28:	90 e0       	ldi	r25, 0x00	; 0
     c2a:	a0 e0       	ldi	r26, 0x00	; 0
     c2c:	b0 e0       	ldi	r27, 0x00	; 0
     c2e:	e8 0e       	add	r14, r24
     c30:	f9 1e       	adc	r15, r25
     c32:	0a 1f       	adc	r16, r26
     c34:	1b 1f       	adc	r17, r27
     c36:	17 ff       	sbrs	r17, 7
     c38:	05 c0       	rjmp	.+10     	; 0xc44 <__pack_f+0x162>
     c3a:	16 95       	lsr	r17
     c3c:	07 95       	ror	r16
     c3e:	f7 94       	ror	r15
     c40:	e7 94       	ror	r14
     c42:	31 96       	adiw	r30, 0x01	; 1
     c44:	87 e0       	ldi	r24, 0x07	; 7
     c46:	16 95       	lsr	r17
     c48:	07 95       	ror	r16
     c4a:	f7 94       	ror	r15
     c4c:	e7 94       	ror	r14
     c4e:	8a 95       	dec	r24
     c50:	d1 f7       	brne	.-12     	; 0xc46 <__pack_f+0x164>
     c52:	05 c0       	rjmp	.+10     	; 0xc5e <__pack_f+0x17c>
     c54:	ee 24       	eor	r14, r14
     c56:	ff 24       	eor	r15, r15
     c58:	87 01       	movw	r16, r14
     c5a:	ef ef       	ldi	r30, 0xFF	; 255
     c5c:	f0 e0       	ldi	r31, 0x00	; 0
     c5e:	6e 2f       	mov	r22, r30
     c60:	67 95       	ror	r22
     c62:	66 27       	eor	r22, r22
     c64:	67 95       	ror	r22
     c66:	90 2f       	mov	r25, r16
     c68:	9f 77       	andi	r25, 0x7F	; 127
     c6a:	d7 94       	ror	r13
     c6c:	dd 24       	eor	r13, r13
     c6e:	d7 94       	ror	r13
     c70:	8e 2f       	mov	r24, r30
     c72:	86 95       	lsr	r24
     c74:	49 2f       	mov	r20, r25
     c76:	46 2b       	or	r20, r22
     c78:	58 2f       	mov	r21, r24
     c7a:	5d 29       	or	r21, r13
     c7c:	b7 01       	movw	r22, r14
     c7e:	ca 01       	movw	r24, r20
     c80:	1f 91       	pop	r17
     c82:	0f 91       	pop	r16
     c84:	ff 90       	pop	r15
     c86:	ef 90       	pop	r14
     c88:	df 90       	pop	r13
     c8a:	08 95       	ret

00000c8c <__unpack_f>:
     c8c:	fc 01       	movw	r30, r24
     c8e:	db 01       	movw	r26, r22
     c90:	40 81       	ld	r20, Z
     c92:	51 81       	ldd	r21, Z+1	; 0x01
     c94:	22 81       	ldd	r18, Z+2	; 0x02
     c96:	62 2f       	mov	r22, r18
     c98:	6f 77       	andi	r22, 0x7F	; 127
     c9a:	70 e0       	ldi	r23, 0x00	; 0
     c9c:	22 1f       	adc	r18, r18
     c9e:	22 27       	eor	r18, r18
     ca0:	22 1f       	adc	r18, r18
     ca2:	93 81       	ldd	r25, Z+3	; 0x03
     ca4:	89 2f       	mov	r24, r25
     ca6:	88 0f       	add	r24, r24
     ca8:	82 2b       	or	r24, r18
     caa:	28 2f       	mov	r18, r24
     cac:	30 e0       	ldi	r19, 0x00	; 0
     cae:	99 1f       	adc	r25, r25
     cb0:	99 27       	eor	r25, r25
     cb2:	99 1f       	adc	r25, r25
     cb4:	11 96       	adiw	r26, 0x01	; 1
     cb6:	9c 93       	st	X, r25
     cb8:	11 97       	sbiw	r26, 0x01	; 1
     cba:	21 15       	cp	r18, r1
     cbc:	31 05       	cpc	r19, r1
     cbe:	a9 f5       	brne	.+106    	; 0xd2a <__unpack_f+0x9e>
     cc0:	41 15       	cp	r20, r1
     cc2:	51 05       	cpc	r21, r1
     cc4:	61 05       	cpc	r22, r1
     cc6:	71 05       	cpc	r23, r1
     cc8:	11 f4       	brne	.+4      	; 0xcce <__unpack_f+0x42>
     cca:	82 e0       	ldi	r24, 0x02	; 2
     ccc:	37 c0       	rjmp	.+110    	; 0xd3c <__unpack_f+0xb0>
     cce:	82 e8       	ldi	r24, 0x82	; 130
     cd0:	9f ef       	ldi	r25, 0xFF	; 255
     cd2:	13 96       	adiw	r26, 0x03	; 3
     cd4:	9c 93       	st	X, r25
     cd6:	8e 93       	st	-X, r24
     cd8:	12 97       	sbiw	r26, 0x02	; 2
     cda:	9a 01       	movw	r18, r20
     cdc:	ab 01       	movw	r20, r22
     cde:	67 e0       	ldi	r22, 0x07	; 7
     ce0:	22 0f       	add	r18, r18
     ce2:	33 1f       	adc	r19, r19
     ce4:	44 1f       	adc	r20, r20
     ce6:	55 1f       	adc	r21, r21
     ce8:	6a 95       	dec	r22
     cea:	d1 f7       	brne	.-12     	; 0xce0 <__unpack_f+0x54>
     cec:	83 e0       	ldi	r24, 0x03	; 3
     cee:	8c 93       	st	X, r24
     cf0:	0d c0       	rjmp	.+26     	; 0xd0c <__unpack_f+0x80>
     cf2:	22 0f       	add	r18, r18
     cf4:	33 1f       	adc	r19, r19
     cf6:	44 1f       	adc	r20, r20
     cf8:	55 1f       	adc	r21, r21
     cfa:	12 96       	adiw	r26, 0x02	; 2
     cfc:	8d 91       	ld	r24, X+
     cfe:	9c 91       	ld	r25, X
     d00:	13 97       	sbiw	r26, 0x03	; 3
     d02:	01 97       	sbiw	r24, 0x01	; 1
     d04:	13 96       	adiw	r26, 0x03	; 3
     d06:	9c 93       	st	X, r25
     d08:	8e 93       	st	-X, r24
     d0a:	12 97       	sbiw	r26, 0x02	; 2
     d0c:	20 30       	cpi	r18, 0x00	; 0
     d0e:	80 e0       	ldi	r24, 0x00	; 0
     d10:	38 07       	cpc	r19, r24
     d12:	80 e0       	ldi	r24, 0x00	; 0
     d14:	48 07       	cpc	r20, r24
     d16:	80 e4       	ldi	r24, 0x40	; 64
     d18:	58 07       	cpc	r21, r24
     d1a:	58 f3       	brcs	.-42     	; 0xcf2 <__unpack_f+0x66>
     d1c:	14 96       	adiw	r26, 0x04	; 4
     d1e:	2d 93       	st	X+, r18
     d20:	3d 93       	st	X+, r19
     d22:	4d 93       	st	X+, r20
     d24:	5c 93       	st	X, r21
     d26:	17 97       	sbiw	r26, 0x07	; 7
     d28:	08 95       	ret
     d2a:	2f 3f       	cpi	r18, 0xFF	; 255
     d2c:	31 05       	cpc	r19, r1
     d2e:	79 f4       	brne	.+30     	; 0xd4e <__unpack_f+0xc2>
     d30:	41 15       	cp	r20, r1
     d32:	51 05       	cpc	r21, r1
     d34:	61 05       	cpc	r22, r1
     d36:	71 05       	cpc	r23, r1
     d38:	19 f4       	brne	.+6      	; 0xd40 <__unpack_f+0xb4>
     d3a:	84 e0       	ldi	r24, 0x04	; 4
     d3c:	8c 93       	st	X, r24
     d3e:	08 95       	ret
     d40:	64 ff       	sbrs	r22, 4
     d42:	03 c0       	rjmp	.+6      	; 0xd4a <__unpack_f+0xbe>
     d44:	81 e0       	ldi	r24, 0x01	; 1
     d46:	8c 93       	st	X, r24
     d48:	12 c0       	rjmp	.+36     	; 0xd6e <__unpack_f+0xe2>
     d4a:	1c 92       	st	X, r1
     d4c:	10 c0       	rjmp	.+32     	; 0xd6e <__unpack_f+0xe2>
     d4e:	2f 57       	subi	r18, 0x7F	; 127
     d50:	30 40       	sbci	r19, 0x00	; 0
     d52:	13 96       	adiw	r26, 0x03	; 3
     d54:	3c 93       	st	X, r19
     d56:	2e 93       	st	-X, r18
     d58:	12 97       	sbiw	r26, 0x02	; 2
     d5a:	83 e0       	ldi	r24, 0x03	; 3
     d5c:	8c 93       	st	X, r24
     d5e:	87 e0       	ldi	r24, 0x07	; 7
     d60:	44 0f       	add	r20, r20
     d62:	55 1f       	adc	r21, r21
     d64:	66 1f       	adc	r22, r22
     d66:	77 1f       	adc	r23, r23
     d68:	8a 95       	dec	r24
     d6a:	d1 f7       	brne	.-12     	; 0xd60 <__unpack_f+0xd4>
     d6c:	70 64       	ori	r23, 0x40	; 64
     d6e:	14 96       	adiw	r26, 0x04	; 4
     d70:	4d 93       	st	X+, r20
     d72:	5d 93       	st	X+, r21
     d74:	6d 93       	st	X+, r22
     d76:	7c 93       	st	X, r23
     d78:	17 97       	sbiw	r26, 0x07	; 7
     d7a:	08 95       	ret

00000d7c <__fpcmp_parts_f>:
     d7c:	1f 93       	push	r17
     d7e:	dc 01       	movw	r26, r24
     d80:	fb 01       	movw	r30, r22
     d82:	9c 91       	ld	r25, X
     d84:	92 30       	cpi	r25, 0x02	; 2
     d86:	08 f4       	brcc	.+2      	; 0xd8a <__fpcmp_parts_f+0xe>
     d88:	47 c0       	rjmp	.+142    	; 0xe18 <__fpcmp_parts_f+0x9c>
     d8a:	80 81       	ld	r24, Z
     d8c:	82 30       	cpi	r24, 0x02	; 2
     d8e:	08 f4       	brcc	.+2      	; 0xd92 <__fpcmp_parts_f+0x16>
     d90:	43 c0       	rjmp	.+134    	; 0xe18 <__fpcmp_parts_f+0x9c>
     d92:	94 30       	cpi	r25, 0x04	; 4
     d94:	51 f4       	brne	.+20     	; 0xdaa <__fpcmp_parts_f+0x2e>
     d96:	11 96       	adiw	r26, 0x01	; 1
     d98:	1c 91       	ld	r17, X
     d9a:	84 30       	cpi	r24, 0x04	; 4
     d9c:	99 f5       	brne	.+102    	; 0xe04 <__fpcmp_parts_f+0x88>
     d9e:	81 81       	ldd	r24, Z+1	; 0x01
     da0:	68 2f       	mov	r22, r24
     da2:	70 e0       	ldi	r23, 0x00	; 0
     da4:	61 1b       	sub	r22, r17
     da6:	71 09       	sbc	r23, r1
     da8:	3f c0       	rjmp	.+126    	; 0xe28 <__fpcmp_parts_f+0xac>
     daa:	84 30       	cpi	r24, 0x04	; 4
     dac:	21 f0       	breq	.+8      	; 0xdb6 <__fpcmp_parts_f+0x3a>
     dae:	92 30       	cpi	r25, 0x02	; 2
     db0:	31 f4       	brne	.+12     	; 0xdbe <__fpcmp_parts_f+0x42>
     db2:	82 30       	cpi	r24, 0x02	; 2
     db4:	b9 f1       	breq	.+110    	; 0xe24 <__fpcmp_parts_f+0xa8>
     db6:	81 81       	ldd	r24, Z+1	; 0x01
     db8:	88 23       	and	r24, r24
     dba:	89 f1       	breq	.+98     	; 0xe1e <__fpcmp_parts_f+0xa2>
     dbc:	2d c0       	rjmp	.+90     	; 0xe18 <__fpcmp_parts_f+0x9c>
     dbe:	11 96       	adiw	r26, 0x01	; 1
     dc0:	1c 91       	ld	r17, X
     dc2:	11 97       	sbiw	r26, 0x01	; 1
     dc4:	82 30       	cpi	r24, 0x02	; 2
     dc6:	f1 f0       	breq	.+60     	; 0xe04 <__fpcmp_parts_f+0x88>
     dc8:	81 81       	ldd	r24, Z+1	; 0x01
     dca:	18 17       	cp	r17, r24
     dcc:	d9 f4       	brne	.+54     	; 0xe04 <__fpcmp_parts_f+0x88>
     dce:	12 96       	adiw	r26, 0x02	; 2
     dd0:	2d 91       	ld	r18, X+
     dd2:	3c 91       	ld	r19, X
     dd4:	13 97       	sbiw	r26, 0x03	; 3
     dd6:	82 81       	ldd	r24, Z+2	; 0x02
     dd8:	93 81       	ldd	r25, Z+3	; 0x03
     dda:	82 17       	cp	r24, r18
     ddc:	93 07       	cpc	r25, r19
     dde:	94 f0       	brlt	.+36     	; 0xe04 <__fpcmp_parts_f+0x88>
     de0:	28 17       	cp	r18, r24
     de2:	39 07       	cpc	r19, r25
     de4:	bc f0       	brlt	.+46     	; 0xe14 <__fpcmp_parts_f+0x98>
     de6:	14 96       	adiw	r26, 0x04	; 4
     de8:	8d 91       	ld	r24, X+
     dea:	9d 91       	ld	r25, X+
     dec:	0d 90       	ld	r0, X+
     dee:	bc 91       	ld	r27, X
     df0:	a0 2d       	mov	r26, r0
     df2:	24 81       	ldd	r18, Z+4	; 0x04
     df4:	35 81       	ldd	r19, Z+5	; 0x05
     df6:	46 81       	ldd	r20, Z+6	; 0x06
     df8:	57 81       	ldd	r21, Z+7	; 0x07
     dfa:	28 17       	cp	r18, r24
     dfc:	39 07       	cpc	r19, r25
     dfe:	4a 07       	cpc	r20, r26
     e00:	5b 07       	cpc	r21, r27
     e02:	18 f4       	brcc	.+6      	; 0xe0a <__fpcmp_parts_f+0x8e>
     e04:	11 23       	and	r17, r17
     e06:	41 f0       	breq	.+16     	; 0xe18 <__fpcmp_parts_f+0x9c>
     e08:	0a c0       	rjmp	.+20     	; 0xe1e <__fpcmp_parts_f+0xa2>
     e0a:	82 17       	cp	r24, r18
     e0c:	93 07       	cpc	r25, r19
     e0e:	a4 07       	cpc	r26, r20
     e10:	b5 07       	cpc	r27, r21
     e12:	40 f4       	brcc	.+16     	; 0xe24 <__fpcmp_parts_f+0xa8>
     e14:	11 23       	and	r17, r17
     e16:	19 f0       	breq	.+6      	; 0xe1e <__fpcmp_parts_f+0xa2>
     e18:	61 e0       	ldi	r22, 0x01	; 1
     e1a:	70 e0       	ldi	r23, 0x00	; 0
     e1c:	05 c0       	rjmp	.+10     	; 0xe28 <__fpcmp_parts_f+0xac>
     e1e:	6f ef       	ldi	r22, 0xFF	; 255
     e20:	7f ef       	ldi	r23, 0xFF	; 255
     e22:	02 c0       	rjmp	.+4      	; 0xe28 <__fpcmp_parts_f+0xac>
     e24:	60 e0       	ldi	r22, 0x00	; 0
     e26:	70 e0       	ldi	r23, 0x00	; 0
     e28:	cb 01       	movw	r24, r22
     e2a:	1f 91       	pop	r17
     e2c:	08 95       	ret

00000e2e <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void * pvPortMalloc( size_t xWantedSize )
{
     e2e:	df 93       	push	r29
     e30:	cf 93       	push	r28
     e32:	00 d0       	rcall	.+0      	; 0xe34 <pvPortMalloc+0x6>
     e34:	00 d0       	rcall	.+0      	; 0xe36 <pvPortMalloc+0x8>
     e36:	cd b7       	in	r28, 0x3d	; 61
     e38:	de b7       	in	r29, 0x3e	; 62
     e3a:	9c 83       	std	Y+4, r25	; 0x04
     e3c:	8b 83       	std	Y+3, r24	; 0x03
    void * pvReturn = NULL;
     e3e:	1a 82       	std	Y+2, r1	; 0x02
     e40:	19 82       	std	Y+1, r1	; 0x01
                }
            }
        }
    #endif

    vTaskSuspendAll();
     e42:	0e 94 6c 1e 	call	0x3cd8	; 0x3cd8 <vTaskSuspendAll>
    {
        if( pucAlignedHeap == NULL )
     e46:	80 91 ac 01 	lds	r24, 0x01AC
     e4a:	90 91 ad 01 	lds	r25, 0x01AD
     e4e:	00 97       	sbiw	r24, 0x00	; 0
     e50:	31 f4       	brne	.+12     	; 0xe5e <pvPortMalloc+0x30>
        {
            /* Ensure the heap starts on a correctly aligned boundary. */
            pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) & ucHeap[ portBYTE_ALIGNMENT - 1 ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
     e52:	8e ea       	ldi	r24, 0xAE	; 174
     e54:	91 e0       	ldi	r25, 0x01	; 1
     e56:	90 93 ad 01 	sts	0x01AD, r25
     e5a:	80 93 ac 01 	sts	0x01AC, r24
        }

        /* Check there is enough room left for the allocation and. */
        if( ( xWantedSize > 0 ) && /* valid size */
     e5e:	8b 81       	ldd	r24, Y+3	; 0x03
     e60:	9c 81       	ldd	r25, Y+4	; 0x04
     e62:	00 97       	sbiw	r24, 0x00	; 0
     e64:	99 f1       	breq	.+102    	; 0xecc <pvPortMalloc+0x9e>
     e66:	80 91 aa 01 	lds	r24, 0x01AA
     e6a:	90 91 ab 01 	lds	r25, 0x01AB
     e6e:	2b 81       	ldd	r18, Y+3	; 0x03
     e70:	3c 81       	ldd	r19, Y+4	; 0x04
     e72:	82 0f       	add	r24, r18
     e74:	93 1f       	adc	r25, r19
     e76:	25 e0       	ldi	r18, 0x05	; 5
     e78:	8b 3d       	cpi	r24, 0xDB	; 219
     e7a:	92 07       	cpc	r25, r18
     e7c:	38 f5       	brcc	.+78     	; 0xecc <pvPortMalloc+0x9e>
     e7e:	20 91 aa 01 	lds	r18, 0x01AA
     e82:	30 91 ab 01 	lds	r19, 0x01AB
     e86:	8b 81       	ldd	r24, Y+3	; 0x03
     e88:	9c 81       	ldd	r25, Y+4	; 0x04
     e8a:	28 0f       	add	r18, r24
     e8c:	39 1f       	adc	r19, r25
     e8e:	80 91 aa 01 	lds	r24, 0x01AA
     e92:	90 91 ab 01 	lds	r25, 0x01AB
     e96:	82 17       	cp	r24, r18
     e98:	93 07       	cpc	r25, r19
     e9a:	c0 f4       	brcc	.+48     	; 0xecc <pvPortMalloc+0x9e>
            ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
            ( ( xNextFreeByte + xWantedSize ) > xNextFreeByte ) ) /* Check for overflow. */
        {
            /* Return the next free byte then increment the index past this
             * block. */
            pvReturn = pucAlignedHeap + xNextFreeByte;
     e9c:	20 91 ac 01 	lds	r18, 0x01AC
     ea0:	30 91 ad 01 	lds	r19, 0x01AD
     ea4:	80 91 aa 01 	lds	r24, 0x01AA
     ea8:	90 91 ab 01 	lds	r25, 0x01AB
     eac:	82 0f       	add	r24, r18
     eae:	93 1f       	adc	r25, r19
     eb0:	9a 83       	std	Y+2, r25	; 0x02
     eb2:	89 83       	std	Y+1, r24	; 0x01
            xNextFreeByte += xWantedSize;
     eb4:	20 91 aa 01 	lds	r18, 0x01AA
     eb8:	30 91 ab 01 	lds	r19, 0x01AB
     ebc:	8b 81       	ldd	r24, Y+3	; 0x03
     ebe:	9c 81       	ldd	r25, Y+4	; 0x04
     ec0:	82 0f       	add	r24, r18
     ec2:	93 1f       	adc	r25, r19
     ec4:	90 93 ab 01 	sts	0x01AB, r25
     ec8:	80 93 aa 01 	sts	0x01AA, r24
        }

        traceMALLOC( pvReturn, xWantedSize );
    }
    ( void ) xTaskResumeAll();
     ecc:	0e 94 78 1e 	call	0x3cf0	; 0x3cf0 <xTaskResumeAll>
                vApplicationMallocFailedHook();
            }
        }
    #endif

    return pvReturn;
     ed0:	89 81       	ldd	r24, Y+1	; 0x01
     ed2:	9a 81       	ldd	r25, Y+2	; 0x02
}
     ed4:	0f 90       	pop	r0
     ed6:	0f 90       	pop	r0
     ed8:	0f 90       	pop	r0
     eda:	0f 90       	pop	r0
     edc:	cf 91       	pop	r28
     ede:	df 91       	pop	r29
     ee0:	08 95       	ret

00000ee2 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void * pv )
{
     ee2:	df 93       	push	r29
     ee4:	cf 93       	push	r28
     ee6:	00 d0       	rcall	.+0      	; 0xee8 <vPortFree+0x6>
     ee8:	cd b7       	in	r28, 0x3d	; 61
     eea:	de b7       	in	r29, 0x3e	; 62
     eec:	9a 83       	std	Y+2, r25	; 0x02
     eee:	89 83       	std	Y+1, r24	; 0x01
     * https://www.FreeRTOS.org for more information. */
    ( void ) pv;

    /* Force an assert as it is invalid to call this function. */
    configASSERT( pv == NULL );
}
     ef0:	0f 90       	pop	r0
     ef2:	0f 90       	pop	r0
     ef4:	cf 91       	pop	r28
     ef6:	df 91       	pop	r29
     ef8:	08 95       	ret

00000efa <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
     efa:	df 93       	push	r29
     efc:	cf 93       	push	r28
     efe:	cd b7       	in	r28, 0x3d	; 61
     f00:	de b7       	in	r29, 0x3e	; 62
    /* Only required when static memory is not cleared. */
    xNextFreeByte = ( size_t ) 0;
     f02:	10 92 ab 01 	sts	0x01AB, r1
     f06:	10 92 aa 01 	sts	0x01AA, r1
}
     f0a:	cf 91       	pop	r28
     f0c:	df 91       	pop	r29
     f0e:	08 95       	ret

00000f10 <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
     f10:	df 93       	push	r29
     f12:	cf 93       	push	r28
     f14:	cd b7       	in	r28, 0x3d	; 61
     f16:	de b7       	in	r29, 0x3e	; 62
    return( configADJUSTED_HEAP_SIZE - xNextFreeByte );
     f18:	20 91 aa 01 	lds	r18, 0x01AA
     f1c:	30 91 ab 01 	lds	r19, 0x01AB
     f20:	8b ed       	ldi	r24, 0xDB	; 219
     f22:	95 e0       	ldi	r25, 0x05	; 5
     f24:	82 1b       	sub	r24, r18
     f26:	93 0b       	sbc	r25, r19
}
     f28:	cf 91       	pop	r28
     f2a:	df 91       	pop	r29
     f2c:	08 95       	ret

00000f2e <pxPortInitialiseStack>:

/* 
 * See header file for description. 
 */
StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
{
     f2e:	df 93       	push	r29
     f30:	cf 93       	push	r28
     f32:	cd b7       	in	r28, 0x3d	; 61
     f34:	de b7       	in	r29, 0x3e	; 62
     f36:	28 97       	sbiw	r28, 0x08	; 8
     f38:	0f b6       	in	r0, 0x3f	; 63
     f3a:	f8 94       	cli
     f3c:	de bf       	out	0x3e, r29	; 62
     f3e:	0f be       	out	0x3f, r0	; 63
     f40:	cd bf       	out	0x3d, r28	; 61
     f42:	9c 83       	std	Y+4, r25	; 0x04
     f44:	8b 83       	std	Y+3, r24	; 0x03
     f46:	7e 83       	std	Y+6, r23	; 0x06
     f48:	6d 83       	std	Y+5, r22	; 0x05
     f4a:	58 87       	std	Y+8, r21	; 0x08
     f4c:	4f 83       	std	Y+7, r20	; 0x07
uint16_t usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
     f4e:	eb 81       	ldd	r30, Y+3	; 0x03
     f50:	fc 81       	ldd	r31, Y+4	; 0x04
     f52:	81 e1       	ldi	r24, 0x11	; 17
     f54:	80 83       	st	Z, r24
	pxTopOfStack--;
     f56:	8b 81       	ldd	r24, Y+3	; 0x03
     f58:	9c 81       	ldd	r25, Y+4	; 0x04
     f5a:	01 97       	sbiw	r24, 0x01	; 1
     f5c:	9c 83       	std	Y+4, r25	; 0x04
     f5e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x22;
     f60:	eb 81       	ldd	r30, Y+3	; 0x03
     f62:	fc 81       	ldd	r31, Y+4	; 0x04
     f64:	82 e2       	ldi	r24, 0x22	; 34
     f66:	80 83       	st	Z, r24
	pxTopOfStack--;
     f68:	8b 81       	ldd	r24, Y+3	; 0x03
     f6a:	9c 81       	ldd	r25, Y+4	; 0x04
     f6c:	01 97       	sbiw	r24, 0x01	; 1
     f6e:	9c 83       	std	Y+4, r25	; 0x04
     f70:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x33;
     f72:	eb 81       	ldd	r30, Y+3	; 0x03
     f74:	fc 81       	ldd	r31, Y+4	; 0x04
     f76:	83 e3       	ldi	r24, 0x33	; 51
     f78:	80 83       	st	Z, r24
	pxTopOfStack--;
     f7a:	8b 81       	ldd	r24, Y+3	; 0x03
     f7c:	9c 81       	ldd	r25, Y+4	; 0x04
     f7e:	01 97       	sbiw	r24, 0x01	; 1
     f80:	9c 83       	std	Y+4, r25	; 0x04
     f82:	8b 83       	std	Y+3, r24	; 0x03

	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( uint16_t ) pxCode;
     f84:	8d 81       	ldd	r24, Y+5	; 0x05
     f86:	9e 81       	ldd	r25, Y+6	; 0x06
     f88:	9a 83       	std	Y+2, r25	; 0x02
     f8a:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     f8c:	89 81       	ldd	r24, Y+1	; 0x01
     f8e:	eb 81       	ldd	r30, Y+3	; 0x03
     f90:	fc 81       	ldd	r31, Y+4	; 0x04
     f92:	80 83       	st	Z, r24
	pxTopOfStack--;
     f94:	8b 81       	ldd	r24, Y+3	; 0x03
     f96:	9c 81       	ldd	r25, Y+4	; 0x04
     f98:	01 97       	sbiw	r24, 0x01	; 1
     f9a:	9c 83       	std	Y+4, r25	; 0x04
     f9c:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
     f9e:	89 81       	ldd	r24, Y+1	; 0x01
     fa0:	9a 81       	ldd	r25, Y+2	; 0x02
     fa2:	89 2f       	mov	r24, r25
     fa4:	99 27       	eor	r25, r25
     fa6:	9a 83       	std	Y+2, r25	; 0x02
     fa8:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     faa:	89 81       	ldd	r24, Y+1	; 0x01
     fac:	eb 81       	ldd	r30, Y+3	; 0x03
     fae:	fc 81       	ldd	r31, Y+4	; 0x04
     fb0:	80 83       	st	Z, r24
	pxTopOfStack--;
     fb2:	8b 81       	ldd	r24, Y+3	; 0x03
     fb4:	9c 81       	ldd	r25, Y+4	; 0x04
     fb6:	01 97       	sbiw	r24, 0x01	; 1
     fb8:	9c 83       	std	Y+4, r25	; 0x04
     fba:	8b 83       	std	Y+3, r24	; 0x03

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R0 */
     fbc:	eb 81       	ldd	r30, Y+3	; 0x03
     fbe:	fc 81       	ldd	r31, Y+4	; 0x04
     fc0:	10 82       	st	Z, r1
	pxTopOfStack--;
     fc2:	8b 81       	ldd	r24, Y+3	; 0x03
     fc4:	9c 81       	ldd	r25, Y+4	; 0x04
     fc6:	01 97       	sbiw	r24, 0x01	; 1
     fc8:	9c 83       	std	Y+4, r25	; 0x04
     fca:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = portFLAGS_INT_ENABLED;
     fcc:	eb 81       	ldd	r30, Y+3	; 0x03
     fce:	fc 81       	ldd	r31, Y+4	; 0x04
     fd0:	80 e8       	ldi	r24, 0x80	; 128
     fd2:	80 83       	st	Z, r24
	pxTopOfStack--;
     fd4:	8b 81       	ldd	r24, Y+3	; 0x03
     fd6:	9c 81       	ldd	r25, Y+4	; 0x04
     fd8:	01 97       	sbiw	r24, 0x01	; 1
     fda:	9c 83       	std	Y+4, r25	; 0x04
     fdc:	8b 83       	std	Y+3, r24	; 0x03


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R1 */
     fde:	eb 81       	ldd	r30, Y+3	; 0x03
     fe0:	fc 81       	ldd	r31, Y+4	; 0x04
     fe2:	10 82       	st	Z, r1
	pxTopOfStack--;
     fe4:	8b 81       	ldd	r24, Y+3	; 0x03
     fe6:	9c 81       	ldd	r25, Y+4	; 0x04
     fe8:	01 97       	sbiw	r24, 0x01	; 1
     fea:	9c 83       	std	Y+4, r25	; 0x04
     fec:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x02;	/* R2 */
     fee:	eb 81       	ldd	r30, Y+3	; 0x03
     ff0:	fc 81       	ldd	r31, Y+4	; 0x04
     ff2:	82 e0       	ldi	r24, 0x02	; 2
     ff4:	80 83       	st	Z, r24
	pxTopOfStack--;
     ff6:	8b 81       	ldd	r24, Y+3	; 0x03
     ff8:	9c 81       	ldd	r25, Y+4	; 0x04
     ffa:	01 97       	sbiw	r24, 0x01	; 1
     ffc:	9c 83       	std	Y+4, r25	; 0x04
     ffe:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x03;	/* R3 */
    1000:	eb 81       	ldd	r30, Y+3	; 0x03
    1002:	fc 81       	ldd	r31, Y+4	; 0x04
    1004:	83 e0       	ldi	r24, 0x03	; 3
    1006:	80 83       	st	Z, r24
	pxTopOfStack--;
    1008:	8b 81       	ldd	r24, Y+3	; 0x03
    100a:	9c 81       	ldd	r25, Y+4	; 0x04
    100c:	01 97       	sbiw	r24, 0x01	; 1
    100e:	9c 83       	std	Y+4, r25	; 0x04
    1010:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x04;	/* R4 */
    1012:	eb 81       	ldd	r30, Y+3	; 0x03
    1014:	fc 81       	ldd	r31, Y+4	; 0x04
    1016:	84 e0       	ldi	r24, 0x04	; 4
    1018:	80 83       	st	Z, r24
	pxTopOfStack--;
    101a:	8b 81       	ldd	r24, Y+3	; 0x03
    101c:	9c 81       	ldd	r25, Y+4	; 0x04
    101e:	01 97       	sbiw	r24, 0x01	; 1
    1020:	9c 83       	std	Y+4, r25	; 0x04
    1022:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x05;	/* R5 */
    1024:	eb 81       	ldd	r30, Y+3	; 0x03
    1026:	fc 81       	ldd	r31, Y+4	; 0x04
    1028:	85 e0       	ldi	r24, 0x05	; 5
    102a:	80 83       	st	Z, r24
	pxTopOfStack--;
    102c:	8b 81       	ldd	r24, Y+3	; 0x03
    102e:	9c 81       	ldd	r25, Y+4	; 0x04
    1030:	01 97       	sbiw	r24, 0x01	; 1
    1032:	9c 83       	std	Y+4, r25	; 0x04
    1034:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x06;	/* R6 */
    1036:	eb 81       	ldd	r30, Y+3	; 0x03
    1038:	fc 81       	ldd	r31, Y+4	; 0x04
    103a:	86 e0       	ldi	r24, 0x06	; 6
    103c:	80 83       	st	Z, r24
	pxTopOfStack--;
    103e:	8b 81       	ldd	r24, Y+3	; 0x03
    1040:	9c 81       	ldd	r25, Y+4	; 0x04
    1042:	01 97       	sbiw	r24, 0x01	; 1
    1044:	9c 83       	std	Y+4, r25	; 0x04
    1046:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x07;	/* R7 */
    1048:	eb 81       	ldd	r30, Y+3	; 0x03
    104a:	fc 81       	ldd	r31, Y+4	; 0x04
    104c:	87 e0       	ldi	r24, 0x07	; 7
    104e:	80 83       	st	Z, r24
	pxTopOfStack--;
    1050:	8b 81       	ldd	r24, Y+3	; 0x03
    1052:	9c 81       	ldd	r25, Y+4	; 0x04
    1054:	01 97       	sbiw	r24, 0x01	; 1
    1056:	9c 83       	std	Y+4, r25	; 0x04
    1058:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x08;	/* R8 */
    105a:	eb 81       	ldd	r30, Y+3	; 0x03
    105c:	fc 81       	ldd	r31, Y+4	; 0x04
    105e:	88 e0       	ldi	r24, 0x08	; 8
    1060:	80 83       	st	Z, r24
	pxTopOfStack--;
    1062:	8b 81       	ldd	r24, Y+3	; 0x03
    1064:	9c 81       	ldd	r25, Y+4	; 0x04
    1066:	01 97       	sbiw	r24, 0x01	; 1
    1068:	9c 83       	std	Y+4, r25	; 0x04
    106a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x09;	/* R9 */
    106c:	eb 81       	ldd	r30, Y+3	; 0x03
    106e:	fc 81       	ldd	r31, Y+4	; 0x04
    1070:	89 e0       	ldi	r24, 0x09	; 9
    1072:	80 83       	st	Z, r24
	pxTopOfStack--;
    1074:	8b 81       	ldd	r24, Y+3	; 0x03
    1076:	9c 81       	ldd	r25, Y+4	; 0x04
    1078:	01 97       	sbiw	r24, 0x01	; 1
    107a:	9c 83       	std	Y+4, r25	; 0x04
    107c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x10;	/* R10 */
    107e:	eb 81       	ldd	r30, Y+3	; 0x03
    1080:	fc 81       	ldd	r31, Y+4	; 0x04
    1082:	80 e1       	ldi	r24, 0x10	; 16
    1084:	80 83       	st	Z, r24
	pxTopOfStack--;
    1086:	8b 81       	ldd	r24, Y+3	; 0x03
    1088:	9c 81       	ldd	r25, Y+4	; 0x04
    108a:	01 97       	sbiw	r24, 0x01	; 1
    108c:	9c 83       	std	Y+4, r25	; 0x04
    108e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x11;	/* R11 */
    1090:	eb 81       	ldd	r30, Y+3	; 0x03
    1092:	fc 81       	ldd	r31, Y+4	; 0x04
    1094:	81 e1       	ldi	r24, 0x11	; 17
    1096:	80 83       	st	Z, r24
	pxTopOfStack--;
    1098:	8b 81       	ldd	r24, Y+3	; 0x03
    109a:	9c 81       	ldd	r25, Y+4	; 0x04
    109c:	01 97       	sbiw	r24, 0x01	; 1
    109e:	9c 83       	std	Y+4, r25	; 0x04
    10a0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x12;	/* R12 */
    10a2:	eb 81       	ldd	r30, Y+3	; 0x03
    10a4:	fc 81       	ldd	r31, Y+4	; 0x04
    10a6:	82 e1       	ldi	r24, 0x12	; 18
    10a8:	80 83       	st	Z, r24
	pxTopOfStack--;
    10aa:	8b 81       	ldd	r24, Y+3	; 0x03
    10ac:	9c 81       	ldd	r25, Y+4	; 0x04
    10ae:	01 97       	sbiw	r24, 0x01	; 1
    10b0:	9c 83       	std	Y+4, r25	; 0x04
    10b2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x13;	/* R13 */
    10b4:	eb 81       	ldd	r30, Y+3	; 0x03
    10b6:	fc 81       	ldd	r31, Y+4	; 0x04
    10b8:	83 e1       	ldi	r24, 0x13	; 19
    10ba:	80 83       	st	Z, r24
	pxTopOfStack--;
    10bc:	8b 81       	ldd	r24, Y+3	; 0x03
    10be:	9c 81       	ldd	r25, Y+4	; 0x04
    10c0:	01 97       	sbiw	r24, 0x01	; 1
    10c2:	9c 83       	std	Y+4, r25	; 0x04
    10c4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x14;	/* R14 */
    10c6:	eb 81       	ldd	r30, Y+3	; 0x03
    10c8:	fc 81       	ldd	r31, Y+4	; 0x04
    10ca:	84 e1       	ldi	r24, 0x14	; 20
    10cc:	80 83       	st	Z, r24
	pxTopOfStack--;
    10ce:	8b 81       	ldd	r24, Y+3	; 0x03
    10d0:	9c 81       	ldd	r25, Y+4	; 0x04
    10d2:	01 97       	sbiw	r24, 0x01	; 1
    10d4:	9c 83       	std	Y+4, r25	; 0x04
    10d6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x15;	/* R15 */
    10d8:	eb 81       	ldd	r30, Y+3	; 0x03
    10da:	fc 81       	ldd	r31, Y+4	; 0x04
    10dc:	85 e1       	ldi	r24, 0x15	; 21
    10de:	80 83       	st	Z, r24
	pxTopOfStack--;
    10e0:	8b 81       	ldd	r24, Y+3	; 0x03
    10e2:	9c 81       	ldd	r25, Y+4	; 0x04
    10e4:	01 97       	sbiw	r24, 0x01	; 1
    10e6:	9c 83       	std	Y+4, r25	; 0x04
    10e8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x16;	/* R16 */
    10ea:	eb 81       	ldd	r30, Y+3	; 0x03
    10ec:	fc 81       	ldd	r31, Y+4	; 0x04
    10ee:	86 e1       	ldi	r24, 0x16	; 22
    10f0:	80 83       	st	Z, r24
	pxTopOfStack--;
    10f2:	8b 81       	ldd	r24, Y+3	; 0x03
    10f4:	9c 81       	ldd	r25, Y+4	; 0x04
    10f6:	01 97       	sbiw	r24, 0x01	; 1
    10f8:	9c 83       	std	Y+4, r25	; 0x04
    10fa:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x17;	/* R17 */
    10fc:	eb 81       	ldd	r30, Y+3	; 0x03
    10fe:	fc 81       	ldd	r31, Y+4	; 0x04
    1100:	87 e1       	ldi	r24, 0x17	; 23
    1102:	80 83       	st	Z, r24
	pxTopOfStack--;
    1104:	8b 81       	ldd	r24, Y+3	; 0x03
    1106:	9c 81       	ldd	r25, Y+4	; 0x04
    1108:	01 97       	sbiw	r24, 0x01	; 1
    110a:	9c 83       	std	Y+4, r25	; 0x04
    110c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x18;	/* R18 */
    110e:	eb 81       	ldd	r30, Y+3	; 0x03
    1110:	fc 81       	ldd	r31, Y+4	; 0x04
    1112:	88 e1       	ldi	r24, 0x18	; 24
    1114:	80 83       	st	Z, r24
	pxTopOfStack--;
    1116:	8b 81       	ldd	r24, Y+3	; 0x03
    1118:	9c 81       	ldd	r25, Y+4	; 0x04
    111a:	01 97       	sbiw	r24, 0x01	; 1
    111c:	9c 83       	std	Y+4, r25	; 0x04
    111e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x19;	/* R19 */
    1120:	eb 81       	ldd	r30, Y+3	; 0x03
    1122:	fc 81       	ldd	r31, Y+4	; 0x04
    1124:	89 e1       	ldi	r24, 0x19	; 25
    1126:	80 83       	st	Z, r24
	pxTopOfStack--;
    1128:	8b 81       	ldd	r24, Y+3	; 0x03
    112a:	9c 81       	ldd	r25, Y+4	; 0x04
    112c:	01 97       	sbiw	r24, 0x01	; 1
    112e:	9c 83       	std	Y+4, r25	; 0x04
    1130:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x20;	/* R20 */
    1132:	eb 81       	ldd	r30, Y+3	; 0x03
    1134:	fc 81       	ldd	r31, Y+4	; 0x04
    1136:	80 e2       	ldi	r24, 0x20	; 32
    1138:	80 83       	st	Z, r24
	pxTopOfStack--;
    113a:	8b 81       	ldd	r24, Y+3	; 0x03
    113c:	9c 81       	ldd	r25, Y+4	; 0x04
    113e:	01 97       	sbiw	r24, 0x01	; 1
    1140:	9c 83       	std	Y+4, r25	; 0x04
    1142:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x21;	/* R21 */
    1144:	eb 81       	ldd	r30, Y+3	; 0x03
    1146:	fc 81       	ldd	r31, Y+4	; 0x04
    1148:	81 e2       	ldi	r24, 0x21	; 33
    114a:	80 83       	st	Z, r24
	pxTopOfStack--;
    114c:	8b 81       	ldd	r24, Y+3	; 0x03
    114e:	9c 81       	ldd	r25, Y+4	; 0x04
    1150:	01 97       	sbiw	r24, 0x01	; 1
    1152:	9c 83       	std	Y+4, r25	; 0x04
    1154:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x22;	/* R22 */
    1156:	eb 81       	ldd	r30, Y+3	; 0x03
    1158:	fc 81       	ldd	r31, Y+4	; 0x04
    115a:	82 e2       	ldi	r24, 0x22	; 34
    115c:	80 83       	st	Z, r24
	pxTopOfStack--;
    115e:	8b 81       	ldd	r24, Y+3	; 0x03
    1160:	9c 81       	ldd	r25, Y+4	; 0x04
    1162:	01 97       	sbiw	r24, 0x01	; 1
    1164:	9c 83       	std	Y+4, r25	; 0x04
    1166:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x23;	/* R23 */
    1168:	eb 81       	ldd	r30, Y+3	; 0x03
    116a:	fc 81       	ldd	r31, Y+4	; 0x04
    116c:	83 e2       	ldi	r24, 0x23	; 35
    116e:	80 83       	st	Z, r24
	pxTopOfStack--;
    1170:	8b 81       	ldd	r24, Y+3	; 0x03
    1172:	9c 81       	ldd	r25, Y+4	; 0x04
    1174:	01 97       	sbiw	r24, 0x01	; 1
    1176:	9c 83       	std	Y+4, r25	; 0x04
    1178:	8b 83       	std	Y+3, r24	; 0x03

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( uint16_t ) pvParameters;
    117a:	8f 81       	ldd	r24, Y+7	; 0x07
    117c:	98 85       	ldd	r25, Y+8	; 0x08
    117e:	9a 83       	std	Y+2, r25	; 0x02
    1180:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    1182:	89 81       	ldd	r24, Y+1	; 0x01
    1184:	eb 81       	ldd	r30, Y+3	; 0x03
    1186:	fc 81       	ldd	r31, Y+4	; 0x04
    1188:	80 83       	st	Z, r24
	pxTopOfStack--;
    118a:	8b 81       	ldd	r24, Y+3	; 0x03
    118c:	9c 81       	ldd	r25, Y+4	; 0x04
    118e:	01 97       	sbiw	r24, 0x01	; 1
    1190:	9c 83       	std	Y+4, r25	; 0x04
    1192:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    1194:	89 81       	ldd	r24, Y+1	; 0x01
    1196:	9a 81       	ldd	r25, Y+2	; 0x02
    1198:	89 2f       	mov	r24, r25
    119a:	99 27       	eor	r25, r25
    119c:	9a 83       	std	Y+2, r25	; 0x02
    119e:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    11a0:	89 81       	ldd	r24, Y+1	; 0x01
    11a2:	eb 81       	ldd	r30, Y+3	; 0x03
    11a4:	fc 81       	ldd	r31, Y+4	; 0x04
    11a6:	80 83       	st	Z, r24
	pxTopOfStack--;
    11a8:	8b 81       	ldd	r24, Y+3	; 0x03
    11aa:	9c 81       	ldd	r25, Y+4	; 0x04
    11ac:	01 97       	sbiw	r24, 0x01	; 1
    11ae:	9c 83       	std	Y+4, r25	; 0x04
    11b0:	8b 83       	std	Y+3, r24	; 0x03

	*pxTopOfStack = ( StackType_t ) 0x26;	/* R26 X */
    11b2:	eb 81       	ldd	r30, Y+3	; 0x03
    11b4:	fc 81       	ldd	r31, Y+4	; 0x04
    11b6:	86 e2       	ldi	r24, 0x26	; 38
    11b8:	80 83       	st	Z, r24
	pxTopOfStack--;
    11ba:	8b 81       	ldd	r24, Y+3	; 0x03
    11bc:	9c 81       	ldd	r25, Y+4	; 0x04
    11be:	01 97       	sbiw	r24, 0x01	; 1
    11c0:	9c 83       	std	Y+4, r25	; 0x04
    11c2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x27;	/* R27 */
    11c4:	eb 81       	ldd	r30, Y+3	; 0x03
    11c6:	fc 81       	ldd	r31, Y+4	; 0x04
    11c8:	87 e2       	ldi	r24, 0x27	; 39
    11ca:	80 83       	st	Z, r24
	pxTopOfStack--;
    11cc:	8b 81       	ldd	r24, Y+3	; 0x03
    11ce:	9c 81       	ldd	r25, Y+4	; 0x04
    11d0:	01 97       	sbiw	r24, 0x01	; 1
    11d2:	9c 83       	std	Y+4, r25	; 0x04
    11d4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x28;	/* R28 Y */
    11d6:	eb 81       	ldd	r30, Y+3	; 0x03
    11d8:	fc 81       	ldd	r31, Y+4	; 0x04
    11da:	88 e2       	ldi	r24, 0x28	; 40
    11dc:	80 83       	st	Z, r24
	pxTopOfStack--;
    11de:	8b 81       	ldd	r24, Y+3	; 0x03
    11e0:	9c 81       	ldd	r25, Y+4	; 0x04
    11e2:	01 97       	sbiw	r24, 0x01	; 1
    11e4:	9c 83       	std	Y+4, r25	; 0x04
    11e6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x29;	/* R29 */
    11e8:	eb 81       	ldd	r30, Y+3	; 0x03
    11ea:	fc 81       	ldd	r31, Y+4	; 0x04
    11ec:	89 e2       	ldi	r24, 0x29	; 41
    11ee:	80 83       	st	Z, r24
	pxTopOfStack--;
    11f0:	8b 81       	ldd	r24, Y+3	; 0x03
    11f2:	9c 81       	ldd	r25, Y+4	; 0x04
    11f4:	01 97       	sbiw	r24, 0x01	; 1
    11f6:	9c 83       	std	Y+4, r25	; 0x04
    11f8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x30;	/* R30 Z */
    11fa:	eb 81       	ldd	r30, Y+3	; 0x03
    11fc:	fc 81       	ldd	r31, Y+4	; 0x04
    11fe:	80 e3       	ldi	r24, 0x30	; 48
    1200:	80 83       	st	Z, r24
	pxTopOfStack--;
    1202:	8b 81       	ldd	r24, Y+3	; 0x03
    1204:	9c 81       	ldd	r25, Y+4	; 0x04
    1206:	01 97       	sbiw	r24, 0x01	; 1
    1208:	9c 83       	std	Y+4, r25	; 0x04
    120a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x031;	/* R31 */
    120c:	eb 81       	ldd	r30, Y+3	; 0x03
    120e:	fc 81       	ldd	r31, Y+4	; 0x04
    1210:	81 e3       	ldi	r24, 0x31	; 49
    1212:	80 83       	st	Z, r24
	pxTopOfStack--;
    1214:	8b 81       	ldd	r24, Y+3	; 0x03
    1216:	9c 81       	ldd	r25, Y+4	; 0x04
    1218:	01 97       	sbiw	r24, 0x01	; 1
    121a:	9c 83       	std	Y+4, r25	; 0x04
    121c:	8b 83       	std	Y+3, r24	; 0x03

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
    121e:	8b 81       	ldd	r24, Y+3	; 0x03
    1220:	9c 81       	ldd	r25, Y+4	; 0x04
}
    1222:	28 96       	adiw	r28, 0x08	; 8
    1224:	0f b6       	in	r0, 0x3f	; 63
    1226:	f8 94       	cli
    1228:	de bf       	out	0x3e, r29	; 62
    122a:	0f be       	out	0x3f, r0	; 63
    122c:	cd bf       	out	0x3d, r28	; 61
    122e:	cf 91       	pop	r28
    1230:	df 91       	pop	r29
    1232:	08 95       	ret

00001234 <xPortStartScheduler>:
/*-----------------------------------------------------------*/

BaseType_t xPortStartScheduler( void )
{
    1234:	df 93       	push	r29
    1236:	cf 93       	push	r28
    1238:	cd b7       	in	r28, 0x3d	; 61
    123a:	de b7       	in	r29, 0x3e	; 62
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();
    123c:	0e 94 0c 0a 	call	0x1418	; 0x1418 <prvSetupTimerInterrupt>

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    1240:	a0 91 c4 07 	lds	r26, 0x07C4
    1244:	b0 91 c5 07 	lds	r27, 0x07C5
    1248:	cd 91       	ld	r28, X+
    124a:	cd bf       	out	0x3d, r28	; 61
    124c:	dd 91       	ld	r29, X+
    124e:	de bf       	out	0x3e, r29	; 62
    1250:	ff 91       	pop	r31
    1252:	ef 91       	pop	r30
    1254:	df 91       	pop	r29
    1256:	cf 91       	pop	r28
    1258:	bf 91       	pop	r27
    125a:	af 91       	pop	r26
    125c:	9f 91       	pop	r25
    125e:	8f 91       	pop	r24
    1260:	7f 91       	pop	r23
    1262:	6f 91       	pop	r22
    1264:	5f 91       	pop	r21
    1266:	4f 91       	pop	r20
    1268:	3f 91       	pop	r19
    126a:	2f 91       	pop	r18
    126c:	1f 91       	pop	r17
    126e:	0f 91       	pop	r16
    1270:	ff 90       	pop	r15
    1272:	ef 90       	pop	r14
    1274:	df 90       	pop	r13
    1276:	cf 90       	pop	r12
    1278:	bf 90       	pop	r11
    127a:	af 90       	pop	r10
    127c:	9f 90       	pop	r9
    127e:	8f 90       	pop	r8
    1280:	7f 90       	pop	r7
    1282:	6f 90       	pop	r6
    1284:	5f 90       	pop	r5
    1286:	4f 90       	pop	r4
    1288:	3f 90       	pop	r3
    128a:	2f 90       	pop	r2
    128c:	1f 90       	pop	r1
    128e:	0f 90       	pop	r0
    1290:	0f be       	out	0x3f, r0	; 63
    1292:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
    1294:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
    1296:	81 e0       	ldi	r24, 0x01	; 1
}
    1298:	cf 91       	pop	r28
    129a:	df 91       	pop	r29
    129c:	08 95       	ret

0000129e <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    129e:	df 93       	push	r29
    12a0:	cf 93       	push	r28
    12a2:	cd b7       	in	r28, 0x3d	; 61
    12a4:	de b7       	in	r29, 0x3e	; 62
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
    12a6:	cf 91       	pop	r28
    12a8:	df 91       	pop	r29
    12aa:	08 95       	ret

000012ac <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    12ac:	0f 92       	push	r0
    12ae:	0f b6       	in	r0, 0x3f	; 63
    12b0:	f8 94       	cli
    12b2:	0f 92       	push	r0
    12b4:	1f 92       	push	r1
    12b6:	11 24       	eor	r1, r1
    12b8:	2f 92       	push	r2
    12ba:	3f 92       	push	r3
    12bc:	4f 92       	push	r4
    12be:	5f 92       	push	r5
    12c0:	6f 92       	push	r6
    12c2:	7f 92       	push	r7
    12c4:	8f 92       	push	r8
    12c6:	9f 92       	push	r9
    12c8:	af 92       	push	r10
    12ca:	bf 92       	push	r11
    12cc:	cf 92       	push	r12
    12ce:	df 92       	push	r13
    12d0:	ef 92       	push	r14
    12d2:	ff 92       	push	r15
    12d4:	0f 93       	push	r16
    12d6:	1f 93       	push	r17
    12d8:	2f 93       	push	r18
    12da:	3f 93       	push	r19
    12dc:	4f 93       	push	r20
    12de:	5f 93       	push	r21
    12e0:	6f 93       	push	r22
    12e2:	7f 93       	push	r23
    12e4:	8f 93       	push	r24
    12e6:	9f 93       	push	r25
    12e8:	af 93       	push	r26
    12ea:	bf 93       	push	r27
    12ec:	cf 93       	push	r28
    12ee:	df 93       	push	r29
    12f0:	ef 93       	push	r30
    12f2:	ff 93       	push	r31
    12f4:	a0 91 c4 07 	lds	r26, 0x07C4
    12f8:	b0 91 c5 07 	lds	r27, 0x07C5
    12fc:	0d b6       	in	r0, 0x3d	; 61
    12fe:	0d 92       	st	X+, r0
    1300:	0e b6       	in	r0, 0x3e	; 62
    1302:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    1304:	0e 94 dc 21 	call	0x43b8	; 0x43b8 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    1308:	a0 91 c4 07 	lds	r26, 0x07C4
    130c:	b0 91 c5 07 	lds	r27, 0x07C5
    1310:	cd 91       	ld	r28, X+
    1312:	cd bf       	out	0x3d, r28	; 61
    1314:	dd 91       	ld	r29, X+
    1316:	de bf       	out	0x3e, r29	; 62
    1318:	ff 91       	pop	r31
    131a:	ef 91       	pop	r30
    131c:	df 91       	pop	r29
    131e:	cf 91       	pop	r28
    1320:	bf 91       	pop	r27
    1322:	af 91       	pop	r26
    1324:	9f 91       	pop	r25
    1326:	8f 91       	pop	r24
    1328:	7f 91       	pop	r23
    132a:	6f 91       	pop	r22
    132c:	5f 91       	pop	r21
    132e:	4f 91       	pop	r20
    1330:	3f 91       	pop	r19
    1332:	2f 91       	pop	r18
    1334:	1f 91       	pop	r17
    1336:	0f 91       	pop	r16
    1338:	ff 90       	pop	r15
    133a:	ef 90       	pop	r14
    133c:	df 90       	pop	r13
    133e:	cf 90       	pop	r12
    1340:	bf 90       	pop	r11
    1342:	af 90       	pop	r10
    1344:	9f 90       	pop	r9
    1346:	8f 90       	pop	r8
    1348:	7f 90       	pop	r7
    134a:	6f 90       	pop	r6
    134c:	5f 90       	pop	r5
    134e:	4f 90       	pop	r4
    1350:	3f 90       	pop	r3
    1352:	2f 90       	pop	r2
    1354:	1f 90       	pop	r1
    1356:	0f 90       	pop	r0
    1358:	0f be       	out	0x3f, r0	; 63
    135a:	0f 90       	pop	r0

	asm volatile ( "ret" );
    135c:	08 95       	ret

0000135e <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    135e:	0f 92       	push	r0
    1360:	0f b6       	in	r0, 0x3f	; 63
    1362:	f8 94       	cli
    1364:	0f 92       	push	r0
    1366:	1f 92       	push	r1
    1368:	11 24       	eor	r1, r1
    136a:	2f 92       	push	r2
    136c:	3f 92       	push	r3
    136e:	4f 92       	push	r4
    1370:	5f 92       	push	r5
    1372:	6f 92       	push	r6
    1374:	7f 92       	push	r7
    1376:	8f 92       	push	r8
    1378:	9f 92       	push	r9
    137a:	af 92       	push	r10
    137c:	bf 92       	push	r11
    137e:	cf 92       	push	r12
    1380:	df 92       	push	r13
    1382:	ef 92       	push	r14
    1384:	ff 92       	push	r15
    1386:	0f 93       	push	r16
    1388:	1f 93       	push	r17
    138a:	2f 93       	push	r18
    138c:	3f 93       	push	r19
    138e:	4f 93       	push	r20
    1390:	5f 93       	push	r21
    1392:	6f 93       	push	r22
    1394:	7f 93       	push	r23
    1396:	8f 93       	push	r24
    1398:	9f 93       	push	r25
    139a:	af 93       	push	r26
    139c:	bf 93       	push	r27
    139e:	cf 93       	push	r28
    13a0:	df 93       	push	r29
    13a2:	ef 93       	push	r30
    13a4:	ff 93       	push	r31
    13a6:	a0 91 c4 07 	lds	r26, 0x07C4
    13aa:	b0 91 c5 07 	lds	r27, 0x07C5
    13ae:	0d b6       	in	r0, 0x3d	; 61
    13b0:	0d 92       	st	X+, r0
    13b2:	0e b6       	in	r0, 0x3e	; 62
    13b4:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
    13b6:	0e 94 45 20 	call	0x408a	; 0x408a <xTaskIncrementTick>
    13ba:	88 23       	and	r24, r24
    13bc:	11 f0       	breq	.+4      	; 0x13c2 <vPortYieldFromTick+0x64>
	{
		vTaskSwitchContext();
    13be:	0e 94 dc 21 	call	0x43b8	; 0x43b8 <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
    13c2:	a0 91 c4 07 	lds	r26, 0x07C4
    13c6:	b0 91 c5 07 	lds	r27, 0x07C5
    13ca:	cd 91       	ld	r28, X+
    13cc:	cd bf       	out	0x3d, r28	; 61
    13ce:	dd 91       	ld	r29, X+
    13d0:	de bf       	out	0x3e, r29	; 62
    13d2:	ff 91       	pop	r31
    13d4:	ef 91       	pop	r30
    13d6:	df 91       	pop	r29
    13d8:	cf 91       	pop	r28
    13da:	bf 91       	pop	r27
    13dc:	af 91       	pop	r26
    13de:	9f 91       	pop	r25
    13e0:	8f 91       	pop	r24
    13e2:	7f 91       	pop	r23
    13e4:	6f 91       	pop	r22
    13e6:	5f 91       	pop	r21
    13e8:	4f 91       	pop	r20
    13ea:	3f 91       	pop	r19
    13ec:	2f 91       	pop	r18
    13ee:	1f 91       	pop	r17
    13f0:	0f 91       	pop	r16
    13f2:	ff 90       	pop	r15
    13f4:	ef 90       	pop	r14
    13f6:	df 90       	pop	r13
    13f8:	cf 90       	pop	r12
    13fa:	bf 90       	pop	r11
    13fc:	af 90       	pop	r10
    13fe:	9f 90       	pop	r9
    1400:	8f 90       	pop	r8
    1402:	7f 90       	pop	r7
    1404:	6f 90       	pop	r6
    1406:	5f 90       	pop	r5
    1408:	4f 90       	pop	r4
    140a:	3f 90       	pop	r3
    140c:	2f 90       	pop	r2
    140e:	1f 90       	pop	r1
    1410:	0f 90       	pop	r0
    1412:	0f be       	out	0x3f, r0	; 63
    1414:	0f 90       	pop	r0

	asm volatile ( "ret" );
    1416:	08 95       	ret

00001418 <prvSetupTimerInterrupt>:

/*
 * Setup timer 1 compare match A to generate a tick interrupt.
 */
static void prvSetupTimerInterrupt( void )
{
    1418:	df 93       	push	r29
    141a:	cf 93       	push	r28
    141c:	00 d0       	rcall	.+0      	; 0x141e <prvSetupTimerInterrupt+0x6>
    141e:	00 d0       	rcall	.+0      	; 0x1420 <prvSetupTimerInterrupt+0x8>
    1420:	00 d0       	rcall	.+0      	; 0x1422 <prvSetupTimerInterrupt+0xa>
    1422:	cd b7       	in	r28, 0x3d	; 61
    1424:	de b7       	in	r29, 0x3e	; 62
uint8_t ucHighByte, ucLowByte;

	/* Using 16bit timer 1 to generate the tick.  Correct fuses must be
	selected for the configCPU_CLOCK_HZ clock. */

	ulCompareMatch = configCPU_CLOCK_HZ / configTICK_RATE_HZ;
    1426:	80 e8       	ldi	r24, 0x80	; 128
    1428:	9e e3       	ldi	r25, 0x3E	; 62
    142a:	a0 e0       	ldi	r26, 0x00	; 0
    142c:	b0 e0       	ldi	r27, 0x00	; 0
    142e:	8b 83       	std	Y+3, r24	; 0x03
    1430:	9c 83       	std	Y+4, r25	; 0x04
    1432:	ad 83       	std	Y+5, r26	; 0x05
    1434:	be 83       	std	Y+6, r27	; 0x06

	/* We only have 16 bits so have to scale to get our required tick rate. */
	ulCompareMatch /= portCLOCK_PRESCALER;
    1436:	8b 81       	ldd	r24, Y+3	; 0x03
    1438:	9c 81       	ldd	r25, Y+4	; 0x04
    143a:	ad 81       	ldd	r26, Y+5	; 0x05
    143c:	be 81       	ldd	r27, Y+6	; 0x06
    143e:	68 94       	set
    1440:	15 f8       	bld	r1, 5
    1442:	b6 95       	lsr	r27
    1444:	a7 95       	ror	r26
    1446:	97 95       	ror	r25
    1448:	87 95       	ror	r24
    144a:	16 94       	lsr	r1
    144c:	d1 f7       	brne	.-12     	; 0x1442 <prvSetupTimerInterrupt+0x2a>
    144e:	8b 83       	std	Y+3, r24	; 0x03
    1450:	9c 83       	std	Y+4, r25	; 0x04
    1452:	ad 83       	std	Y+5, r26	; 0x05
    1454:	be 83       	std	Y+6, r27	; 0x06

	/* Adjust for correct value. */
	ulCompareMatch -= ( uint32_t ) 1;
    1456:	8b 81       	ldd	r24, Y+3	; 0x03
    1458:	9c 81       	ldd	r25, Y+4	; 0x04
    145a:	ad 81       	ldd	r26, Y+5	; 0x05
    145c:	be 81       	ldd	r27, Y+6	; 0x06
    145e:	01 97       	sbiw	r24, 0x01	; 1
    1460:	a1 09       	sbc	r26, r1
    1462:	b1 09       	sbc	r27, r1
    1464:	8b 83       	std	Y+3, r24	; 0x03
    1466:	9c 83       	std	Y+4, r25	; 0x04
    1468:	ad 83       	std	Y+5, r26	; 0x05
    146a:	be 83       	std	Y+6, r27	; 0x06

	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
    146c:	8b 81       	ldd	r24, Y+3	; 0x03
    146e:	89 83       	std	Y+1, r24	; 0x01
	ulCompareMatch >>= 8;
    1470:	8b 81       	ldd	r24, Y+3	; 0x03
    1472:	9c 81       	ldd	r25, Y+4	; 0x04
    1474:	ad 81       	ldd	r26, Y+5	; 0x05
    1476:	be 81       	ldd	r27, Y+6	; 0x06
    1478:	89 2f       	mov	r24, r25
    147a:	9a 2f       	mov	r25, r26
    147c:	ab 2f       	mov	r26, r27
    147e:	bb 27       	eor	r27, r27
    1480:	8b 83       	std	Y+3, r24	; 0x03
    1482:	9c 83       	std	Y+4, r25	; 0x04
    1484:	ad 83       	std	Y+5, r26	; 0x05
    1486:	be 83       	std	Y+6, r27	; 0x06
	ucHighByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
    1488:	8b 81       	ldd	r24, Y+3	; 0x03
    148a:	8a 83       	std	Y+2, r24	; 0x02
	OCR1AH = ucHighByte;
    148c:	eb e4       	ldi	r30, 0x4B	; 75
    148e:	f0 e0       	ldi	r31, 0x00	; 0
    1490:	8a 81       	ldd	r24, Y+2	; 0x02
    1492:	80 83       	st	Z, r24
	OCR1AL = ucLowByte;
    1494:	ea e4       	ldi	r30, 0x4A	; 74
    1496:	f0 e0       	ldi	r31, 0x00	; 0
    1498:	89 81       	ldd	r24, Y+1	; 0x01
    149a:	80 83       	st	Z, r24

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
    149c:	8b e0       	ldi	r24, 0x0B	; 11
    149e:	89 83       	std	Y+1, r24	; 0x01
	TCCR1B = ucLowByte;
    14a0:	ee e4       	ldi	r30, 0x4E	; 78
    14a2:	f0 e0       	ldi	r31, 0x00	; 0
    14a4:	89 81       	ldd	r24, Y+1	; 0x01
    14a6:	80 83       	st	Z, r24

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK;
    14a8:	e9 e5       	ldi	r30, 0x59	; 89
    14aa:	f0 e0       	ldi	r31, 0x00	; 0
    14ac:	80 81       	ld	r24, Z
    14ae:	89 83       	std	Y+1, r24	; 0x01
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    14b0:	89 81       	ldd	r24, Y+1	; 0x01
    14b2:	80 61       	ori	r24, 0x10	; 16
    14b4:	89 83       	std	Y+1, r24	; 0x01
	TIMSK = ucLowByte;
    14b6:	e9 e5       	ldi	r30, 0x59	; 89
    14b8:	f0 e0       	ldi	r31, 0x00	; 0
    14ba:	89 81       	ldd	r24, Y+1	; 0x01
    14bc:	80 83       	st	Z, r24
}
    14be:	26 96       	adiw	r28, 0x06	; 6
    14c0:	0f b6       	in	r0, 0x3f	; 63
    14c2:	f8 94       	cli
    14c4:	de bf       	out	0x3e, r29	; 62
    14c6:	0f be       	out	0x3f, r0	; 63
    14c8:	cd bf       	out	0x3d, r28	; 61
    14ca:	cf 91       	pop	r28
    14cc:	df 91       	pop	r29
    14ce:	08 95       	ret

000014d0 <__vector_7>:
	 * count is incremented after the context is saved.
	 */
	void TIMER1_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
	void TIMER1_COMPA_vect( void )
	{
		vPortYieldFromTick();
    14d0:	0e 94 af 09 	call	0x135e	; 0x135e <vPortYieldFromTick>
		asm volatile ( "reti" );
    14d4:	18 95       	reti

000014d6 <xCoRoutineCreate>:
/*-----------------------------------------------------------*/

    BaseType_t xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode,
                                 UBaseType_t uxPriority,
                                 UBaseType_t uxIndex )
    {
    14d6:	df 93       	push	r29
    14d8:	cf 93       	push	r28
    14da:	cd b7       	in	r28, 0x3d	; 61
    14dc:	de b7       	in	r29, 0x3e	; 62
    14de:	27 97       	sbiw	r28, 0x07	; 7
    14e0:	0f b6       	in	r0, 0x3f	; 63
    14e2:	f8 94       	cli
    14e4:	de bf       	out	0x3e, r29	; 62
    14e6:	0f be       	out	0x3f, r0	; 63
    14e8:	cd bf       	out	0x3d, r28	; 61
    14ea:	9d 83       	std	Y+5, r25	; 0x05
    14ec:	8c 83       	std	Y+4, r24	; 0x04
    14ee:	6e 83       	std	Y+6, r22	; 0x06
    14f0:	4f 83       	std	Y+7, r20	; 0x07
        BaseType_t xReturn;
        CRCB_t * pxCoRoutine;

        /* Allocate the memory that will store the co-routine control block. */
        pxCoRoutine = ( CRCB_t * ) pvPortMalloc( sizeof( CRCB_t ) );
    14f2:	8a e1       	ldi	r24, 0x1A	; 26
    14f4:	90 e0       	ldi	r25, 0x00	; 0
    14f6:	0e 94 17 07 	call	0xe2e	; 0xe2e <pvPortMalloc>
    14fa:	9a 83       	std	Y+2, r25	; 0x02
    14fc:	89 83       	std	Y+1, r24	; 0x01

        if( pxCoRoutine )
    14fe:	89 81       	ldd	r24, Y+1	; 0x01
    1500:	9a 81       	ldd	r25, Y+2	; 0x02
    1502:	00 97       	sbiw	r24, 0x00	; 0
    1504:	09 f4       	brne	.+2      	; 0x1508 <xCoRoutineCreate+0x32>
    1506:	6f c0       	rjmp	.+222    	; 0x15e6 <xCoRoutineCreate+0x110>
        {
            /* If pxCurrentCoRoutine is NULL then this is the first co-routine to
            * be created and the co-routine data structures need initialising. */
            if( pxCurrentCoRoutine == NULL )
    1508:	80 91 8e 07 	lds	r24, 0x078E
    150c:	90 91 8f 07 	lds	r25, 0x078F
    1510:	00 97       	sbiw	r24, 0x00	; 0
    1512:	41 f4       	brne	.+16     	; 0x1524 <xCoRoutineCreate+0x4e>
            {
                pxCurrentCoRoutine = pxCoRoutine;
    1514:	89 81       	ldd	r24, Y+1	; 0x01
    1516:	9a 81       	ldd	r25, Y+2	; 0x02
    1518:	90 93 8f 07 	sts	0x078F, r25
    151c:	80 93 8e 07 	sts	0x078E, r24
                prvInitialiseCoRoutineLists();
    1520:	0e 94 d9 0c 	call	0x19b2	; 0x19b2 <prvInitialiseCoRoutineLists>
            }

            /* Check the priority is within limits. */
            if( uxPriority >= configMAX_CO_ROUTINE_PRIORITIES )
    1524:	8e 81       	ldd	r24, Y+6	; 0x06
    1526:	82 30       	cpi	r24, 0x02	; 2
    1528:	10 f0       	brcs	.+4      	; 0x152e <xCoRoutineCreate+0x58>
            {
                uxPriority = configMAX_CO_ROUTINE_PRIORITIES - 1;
    152a:	81 e0       	ldi	r24, 0x01	; 1
    152c:	8e 83       	std	Y+6, r24	; 0x06
            }

            /* Fill out the co-routine control block from the function parameters. */
            pxCoRoutine->uxState = corINITIAL_STATE;
    152e:	e9 81       	ldd	r30, Y+1	; 0x01
    1530:	fa 81       	ldd	r31, Y+2	; 0x02
    1532:	11 8e       	std	Z+25, r1	; 0x19
    1534:	10 8e       	std	Z+24, r1	; 0x18
            pxCoRoutine->uxPriority = uxPriority;
    1536:	e9 81       	ldd	r30, Y+1	; 0x01
    1538:	fa 81       	ldd	r31, Y+2	; 0x02
    153a:	8e 81       	ldd	r24, Y+6	; 0x06
    153c:	86 8b       	std	Z+22, r24	; 0x16
            pxCoRoutine->uxIndex = uxIndex;
    153e:	e9 81       	ldd	r30, Y+1	; 0x01
    1540:	fa 81       	ldd	r31, Y+2	; 0x02
    1542:	8f 81       	ldd	r24, Y+7	; 0x07
    1544:	87 8b       	std	Z+23, r24	; 0x17
            pxCoRoutine->pxCoRoutineFunction = pxCoRoutineCode;
    1546:	e9 81       	ldd	r30, Y+1	; 0x01
    1548:	fa 81       	ldd	r31, Y+2	; 0x02
    154a:	8c 81       	ldd	r24, Y+4	; 0x04
    154c:	9d 81       	ldd	r25, Y+5	; 0x05
    154e:	91 83       	std	Z+1, r25	; 0x01
    1550:	80 83       	st	Z, r24

            /* Initialise all the other co-routine control block parameters. */
            vListInitialiseItem( &( pxCoRoutine->xGenericListItem ) );
    1552:	89 81       	ldd	r24, Y+1	; 0x01
    1554:	9a 81       	ldd	r25, Y+2	; 0x02
    1556:	02 96       	adiw	r24, 0x02	; 2
    1558:	0e 94 b9 10 	call	0x2172	; 0x2172 <vListInitialiseItem>
            vListInitialiseItem( &( pxCoRoutine->xEventListItem ) );
    155c:	89 81       	ldd	r24, Y+1	; 0x01
    155e:	9a 81       	ldd	r25, Y+2	; 0x02
    1560:	0c 96       	adiw	r24, 0x0c	; 12
    1562:	0e 94 b9 10 	call	0x2172	; 0x2172 <vListInitialiseItem>

            /* Set the co-routine control block as a link back from the ListItem_t.
             * This is so we can get back to the containing CRCB from a generic item
             * in a list. */
            listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xGenericListItem ), pxCoRoutine );
    1566:	e9 81       	ldd	r30, Y+1	; 0x01
    1568:	fa 81       	ldd	r31, Y+2	; 0x02
    156a:	89 81       	ldd	r24, Y+1	; 0x01
    156c:	9a 81       	ldd	r25, Y+2	; 0x02
    156e:	91 87       	std	Z+9, r25	; 0x09
    1570:	80 87       	std	Z+8, r24	; 0x08
            listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xEventListItem ), pxCoRoutine );
    1572:	e9 81       	ldd	r30, Y+1	; 0x01
    1574:	fa 81       	ldd	r31, Y+2	; 0x02
    1576:	89 81       	ldd	r24, Y+1	; 0x01
    1578:	9a 81       	ldd	r25, Y+2	; 0x02
    157a:	93 8b       	std	Z+19, r25	; 0x13
    157c:	82 8b       	std	Z+18, r24	; 0x12

            /* Event lists are always in priority order. */
            listSET_LIST_ITEM_VALUE( &( pxCoRoutine->xEventListItem ), ( ( TickType_t ) configMAX_CO_ROUTINE_PRIORITIES - ( TickType_t ) uxPriority ) );
    157e:	8e 81       	ldd	r24, Y+6	; 0x06
    1580:	28 2f       	mov	r18, r24
    1582:	30 e0       	ldi	r19, 0x00	; 0
    1584:	82 e0       	ldi	r24, 0x02	; 2
    1586:	90 e0       	ldi	r25, 0x00	; 0
    1588:	82 1b       	sub	r24, r18
    158a:	93 0b       	sbc	r25, r19
    158c:	e9 81       	ldd	r30, Y+1	; 0x01
    158e:	fa 81       	ldd	r31, Y+2	; 0x02
    1590:	95 87       	std	Z+13, r25	; 0x0d
    1592:	84 87       	std	Z+12, r24	; 0x0c

            /* Now the co-routine has been initialised it can be added to the ready
             * list at the correct priority. */
            prvAddCoRoutineToReadyQueue( pxCoRoutine );
    1594:	e9 81       	ldd	r30, Y+1	; 0x01
    1596:	fa 81       	ldd	r31, Y+2	; 0x02
    1598:	96 89       	ldd	r25, Z+22	; 0x16
    159a:	80 91 90 07 	lds	r24, 0x0790
    159e:	89 17       	cp	r24, r25
    15a0:	28 f4       	brcc	.+10     	; 0x15ac <xCoRoutineCreate+0xd6>
    15a2:	e9 81       	ldd	r30, Y+1	; 0x01
    15a4:	fa 81       	ldd	r31, Y+2	; 0x02
    15a6:	86 89       	ldd	r24, Z+22	; 0x16
    15a8:	80 93 90 07 	sts	0x0790, r24
    15ac:	e9 81       	ldd	r30, Y+1	; 0x01
    15ae:	fa 81       	ldd	r31, Y+2	; 0x02
    15b0:	86 89       	ldd	r24, Z+22	; 0x16
    15b2:	28 2f       	mov	r18, r24
    15b4:	30 e0       	ldi	r19, 0x00	; 0
    15b6:	c9 01       	movw	r24, r18
    15b8:	88 0f       	add	r24, r24
    15ba:	99 1f       	adc	r25, r25
    15bc:	88 0f       	add	r24, r24
    15be:	99 1f       	adc	r25, r25
    15c0:	88 0f       	add	r24, r24
    15c2:	99 1f       	adc	r25, r25
    15c4:	82 0f       	add	r24, r18
    15c6:	93 1f       	adc	r25, r19
    15c8:	ac 01       	movw	r20, r24
    15ca:	49 56       	subi	r20, 0x69	; 105
    15cc:	58 4f       	sbci	r21, 0xF8	; 248
    15ce:	89 81       	ldd	r24, Y+1	; 0x01
    15d0:	9a 81       	ldd	r25, Y+2	; 0x02
    15d2:	9c 01       	movw	r18, r24
    15d4:	2e 5f       	subi	r18, 0xFE	; 254
    15d6:	3f 4f       	sbci	r19, 0xFF	; 255
    15d8:	ca 01       	movw	r24, r20
    15da:	b9 01       	movw	r22, r18
    15dc:	0e 94 c9 10 	call	0x2192	; 0x2192 <vListInsertEnd>

            xReturn = pdPASS;
    15e0:	81 e0       	ldi	r24, 0x01	; 1
    15e2:	8b 83       	std	Y+3, r24	; 0x03
    15e4:	02 c0       	rjmp	.+4      	; 0x15ea <xCoRoutineCreate+0x114>
        }
        else
        {
            xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    15e6:	8f ef       	ldi	r24, 0xFF	; 255
    15e8:	8b 83       	std	Y+3, r24	; 0x03
        }

        return xReturn;
    15ea:	8b 81       	ldd	r24, Y+3	; 0x03
    }
    15ec:	27 96       	adiw	r28, 0x07	; 7
    15ee:	0f b6       	in	r0, 0x3f	; 63
    15f0:	f8 94       	cli
    15f2:	de bf       	out	0x3e, r29	; 62
    15f4:	0f be       	out	0x3f, r0	; 63
    15f6:	cd bf       	out	0x3d, r28	; 61
    15f8:	cf 91       	pop	r28
    15fa:	df 91       	pop	r29
    15fc:	08 95       	ret

000015fe <vCoRoutineAddToDelayedList>:
/*-----------------------------------------------------------*/

    void vCoRoutineAddToDelayedList( TickType_t xTicksToDelay,
                                     List_t * pxEventList )
    {
    15fe:	df 93       	push	r29
    1600:	cf 93       	push	r28
    1602:	00 d0       	rcall	.+0      	; 0x1604 <vCoRoutineAddToDelayedList+0x6>
    1604:	00 d0       	rcall	.+0      	; 0x1606 <vCoRoutineAddToDelayedList+0x8>
    1606:	00 d0       	rcall	.+0      	; 0x1608 <vCoRoutineAddToDelayedList+0xa>
    1608:	cd b7       	in	r28, 0x3d	; 61
    160a:	de b7       	in	r29, 0x3e	; 62
    160c:	9c 83       	std	Y+4, r25	; 0x04
    160e:	8b 83       	std	Y+3, r24	; 0x03
    1610:	7e 83       	std	Y+6, r23	; 0x06
    1612:	6d 83       	std	Y+5, r22	; 0x05
        TickType_t xTimeToWake;

        /* Calculate the time to wake - this may overflow but this is
         * not a problem. */
        xTimeToWake = xCoRoutineTickCount + xTicksToDelay;
    1614:	20 91 91 07 	lds	r18, 0x0791
    1618:	30 91 92 07 	lds	r19, 0x0792
    161c:	8b 81       	ldd	r24, Y+3	; 0x03
    161e:	9c 81       	ldd	r25, Y+4	; 0x04
    1620:	82 0f       	add	r24, r18
    1622:	93 1f       	adc	r25, r19
    1624:	9a 83       	std	Y+2, r25	; 0x02
    1626:	89 83       	std	Y+1, r24	; 0x01

        /* We must remove ourselves from the ready list before adding
         * ourselves to the blocked list as the same list item is used for
         * both lists. */
        ( void ) uxListRemove( ( ListItem_t * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    1628:	80 91 8e 07 	lds	r24, 0x078E
    162c:	90 91 8f 07 	lds	r25, 0x078F
    1630:	02 96       	adiw	r24, 0x02	; 2
    1632:	0e 94 79 11 	call	0x22f2	; 0x22f2 <uxListRemove>

        /* The list item will be inserted in wake time order. */
        listSET_LIST_ITEM_VALUE( &( pxCurrentCoRoutine->xGenericListItem ), xTimeToWake );
    1636:	e0 91 8e 07 	lds	r30, 0x078E
    163a:	f0 91 8f 07 	lds	r31, 0x078F
    163e:	89 81       	ldd	r24, Y+1	; 0x01
    1640:	9a 81       	ldd	r25, Y+2	; 0x02
    1642:	93 83       	std	Z+3, r25	; 0x03
    1644:	82 83       	std	Z+2, r24	; 0x02

        if( xTimeToWake < xCoRoutineTickCount )
    1646:	20 91 91 07 	lds	r18, 0x0791
    164a:	30 91 92 07 	lds	r19, 0x0792
    164e:	89 81       	ldd	r24, Y+1	; 0x01
    1650:	9a 81       	ldd	r25, Y+2	; 0x02
    1652:	82 17       	cp	r24, r18
    1654:	93 07       	cpc	r25, r19
    1656:	70 f4       	brcc	.+28     	; 0x1674 <vCoRoutineAddToDelayedList+0x76>
        {
            /* Wake time has overflowed.  Place this item in the
             * overflow list. */
            vListInsert( ( List_t * ) pxOverflowDelayedCoRoutineList, ( ListItem_t * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    1658:	80 91 8c 07 	lds	r24, 0x078C
    165c:	90 91 8d 07 	lds	r25, 0x078D
    1660:	20 91 8e 07 	lds	r18, 0x078E
    1664:	30 91 8f 07 	lds	r19, 0x078F
    1668:	2e 5f       	subi	r18, 0xFE	; 254
    166a:	3f 4f       	sbci	r19, 0xFF	; 255
    166c:	b9 01       	movw	r22, r18
    166e:	0e 94 0d 11 	call	0x221a	; 0x221a <vListInsert>
    1672:	0d c0       	rjmp	.+26     	; 0x168e <vCoRoutineAddToDelayedList+0x90>
        }
        else
        {
            /* The wake time has not overflowed, so we can use the
             * current block list. */
            vListInsert( ( List_t * ) pxDelayedCoRoutineList, ( ListItem_t * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    1674:	80 91 8a 07 	lds	r24, 0x078A
    1678:	90 91 8b 07 	lds	r25, 0x078B
    167c:	20 91 8e 07 	lds	r18, 0x078E
    1680:	30 91 8f 07 	lds	r19, 0x078F
    1684:	2e 5f       	subi	r18, 0xFE	; 254
    1686:	3f 4f       	sbci	r19, 0xFF	; 255
    1688:	b9 01       	movw	r22, r18
    168a:	0e 94 0d 11 	call	0x221a	; 0x221a <vListInsert>
        }

        if( pxEventList )
    168e:	8d 81       	ldd	r24, Y+5	; 0x05
    1690:	9e 81       	ldd	r25, Y+6	; 0x06
    1692:	00 97       	sbiw	r24, 0x00	; 0
    1694:	61 f0       	breq	.+24     	; 0x16ae <vCoRoutineAddToDelayedList+0xb0>
        {
            /* Also add the co-routine to an event list.  If this is done then the
             * function must be called with interrupts disabled. */
            vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
    1696:	80 91 8e 07 	lds	r24, 0x078E
    169a:	90 91 8f 07 	lds	r25, 0x078F
    169e:	9c 01       	movw	r18, r24
    16a0:	24 5f       	subi	r18, 0xF4	; 244
    16a2:	3f 4f       	sbci	r19, 0xFF	; 255
    16a4:	8d 81       	ldd	r24, Y+5	; 0x05
    16a6:	9e 81       	ldd	r25, Y+6	; 0x06
    16a8:	b9 01       	movw	r22, r18
    16aa:	0e 94 0d 11 	call	0x221a	; 0x221a <vListInsert>
        }
    }
    16ae:	26 96       	adiw	r28, 0x06	; 6
    16b0:	0f b6       	in	r0, 0x3f	; 63
    16b2:	f8 94       	cli
    16b4:	de bf       	out	0x3e, r29	; 62
    16b6:	0f be       	out	0x3f, r0	; 63
    16b8:	cd bf       	out	0x3d, r28	; 61
    16ba:	cf 91       	pop	r28
    16bc:	df 91       	pop	r29
    16be:	08 95       	ret

000016c0 <prvCheckPendingReadyList>:
/*-----------------------------------------------------------*/

    static void prvCheckPendingReadyList( void )
    {
    16c0:	df 93       	push	r29
    16c2:	cf 93       	push	r28
    16c4:	00 d0       	rcall	.+0      	; 0x16c6 <prvCheckPendingReadyList+0x6>
    16c6:	cd b7       	in	r28, 0x3d	; 61
    16c8:	de b7       	in	r29, 0x3e	; 62
    16ca:	3a c0       	rjmp	.+116    	; 0x1740 <prvCheckPendingReadyList+0x80>
        while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
        {
            CRCB_t * pxUnblockedCRCB;

            /* The pending ready list can be accessed by an ISR. */
            portDISABLE_INTERRUPTS();
    16cc:	f8 94       	cli
            {
                pxUnblockedCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyCoRoutineList ) );
    16ce:	e0 91 c0 07 	lds	r30, 0x07C0
    16d2:	f0 91 c1 07 	lds	r31, 0x07C1
    16d6:	86 81       	ldd	r24, Z+6	; 0x06
    16d8:	97 81       	ldd	r25, Z+7	; 0x07
    16da:	9a 83       	std	Y+2, r25	; 0x02
    16dc:	89 83       	std	Y+1, r24	; 0x01
                ( void ) uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    16de:	89 81       	ldd	r24, Y+1	; 0x01
    16e0:	9a 81       	ldd	r25, Y+2	; 0x02
    16e2:	0c 96       	adiw	r24, 0x0c	; 12
    16e4:	0e 94 79 11 	call	0x22f2	; 0x22f2 <uxListRemove>
            }
            portENABLE_INTERRUPTS();
    16e8:	78 94       	sei

            ( void ) uxListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
    16ea:	89 81       	ldd	r24, Y+1	; 0x01
    16ec:	9a 81       	ldd	r25, Y+2	; 0x02
    16ee:	02 96       	adiw	r24, 0x02	; 2
    16f0:	0e 94 79 11 	call	0x22f2	; 0x22f2 <uxListRemove>
            prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );
    16f4:	e9 81       	ldd	r30, Y+1	; 0x01
    16f6:	fa 81       	ldd	r31, Y+2	; 0x02
    16f8:	96 89       	ldd	r25, Z+22	; 0x16
    16fa:	80 91 90 07 	lds	r24, 0x0790
    16fe:	89 17       	cp	r24, r25
    1700:	28 f4       	brcc	.+10     	; 0x170c <prvCheckPendingReadyList+0x4c>
    1702:	e9 81       	ldd	r30, Y+1	; 0x01
    1704:	fa 81       	ldd	r31, Y+2	; 0x02
    1706:	86 89       	ldd	r24, Z+22	; 0x16
    1708:	80 93 90 07 	sts	0x0790, r24
    170c:	e9 81       	ldd	r30, Y+1	; 0x01
    170e:	fa 81       	ldd	r31, Y+2	; 0x02
    1710:	86 89       	ldd	r24, Z+22	; 0x16
    1712:	28 2f       	mov	r18, r24
    1714:	30 e0       	ldi	r19, 0x00	; 0
    1716:	c9 01       	movw	r24, r18
    1718:	88 0f       	add	r24, r24
    171a:	99 1f       	adc	r25, r25
    171c:	88 0f       	add	r24, r24
    171e:	99 1f       	adc	r25, r25
    1720:	88 0f       	add	r24, r24
    1722:	99 1f       	adc	r25, r25
    1724:	82 0f       	add	r24, r18
    1726:	93 1f       	adc	r25, r19
    1728:	ac 01       	movw	r20, r24
    172a:	49 56       	subi	r20, 0x69	; 105
    172c:	58 4f       	sbci	r21, 0xF8	; 248
    172e:	89 81       	ldd	r24, Y+1	; 0x01
    1730:	9a 81       	ldd	r25, Y+2	; 0x02
    1732:	9c 01       	movw	r18, r24
    1734:	2e 5f       	subi	r18, 0xFE	; 254
    1736:	3f 4f       	sbci	r19, 0xFF	; 255
    1738:	ca 01       	movw	r24, r20
    173a:	b9 01       	movw	r22, r18
    173c:	0e 94 c9 10 	call	0x2192	; 0x2192 <vListInsertEnd>
    static void prvCheckPendingReadyList( void )
    {
        /* Are there any co-routines waiting to get moved to the ready list?  These
         * are co-routines that have been readied by an ISR.  The ISR cannot access
         * the ready lists itself. */
        while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
    1740:	80 91 bb 07 	lds	r24, 0x07BB
    1744:	88 23       	and	r24, r24
    1746:	09 f0       	breq	.+2      	; 0x174a <prvCheckPendingReadyList+0x8a>
    1748:	c1 cf       	rjmp	.-126    	; 0x16cc <prvCheckPendingReadyList+0xc>
            portENABLE_INTERRUPTS();

            ( void ) uxListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
            prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );
        }
    }
    174a:	0f 90       	pop	r0
    174c:	0f 90       	pop	r0
    174e:	cf 91       	pop	r28
    1750:	df 91       	pop	r29
    1752:	08 95       	ret

00001754 <prvCheckDelayedList>:
/*-----------------------------------------------------------*/

    static void prvCheckDelayedList( void )
    {
    1754:	df 93       	push	r29
    1756:	cf 93       	push	r28
    1758:	00 d0       	rcall	.+0      	; 0x175a <prvCheckDelayedList+0x6>
    175a:	00 d0       	rcall	.+0      	; 0x175c <prvCheckDelayedList+0x8>
    175c:	cd b7       	in	r28, 0x3d	; 61
    175e:	de b7       	in	r29, 0x3e	; 62
        CRCB_t * pxCRCB;

        xPassedTicks = xTaskGetTickCount() - xLastTickCount;
    1760:	0e 94 c8 1f 	call	0x3f90	; 0x3f90 <xTaskGetTickCount>
    1764:	20 91 93 07 	lds	r18, 0x0793
    1768:	30 91 94 07 	lds	r19, 0x0794
    176c:	82 1b       	sub	r24, r18
    176e:	93 0b       	sbc	r25, r19
    1770:	90 93 96 07 	sts	0x0796, r25
    1774:	80 93 95 07 	sts	0x0795, r24
    1778:	85 c0       	rjmp	.+266    	; 0x1884 <prvCheckDelayedList+0x130>

        while( xPassedTicks )
        {
            xCoRoutineTickCount++;
    177a:	80 91 91 07 	lds	r24, 0x0791
    177e:	90 91 92 07 	lds	r25, 0x0792
    1782:	01 96       	adiw	r24, 0x01	; 1
    1784:	90 93 92 07 	sts	0x0792, r25
    1788:	80 93 91 07 	sts	0x0791, r24
            xPassedTicks--;
    178c:	80 91 95 07 	lds	r24, 0x0795
    1790:	90 91 96 07 	lds	r25, 0x0796
    1794:	01 97       	sbiw	r24, 0x01	; 1
    1796:	90 93 96 07 	sts	0x0796, r25
    179a:	80 93 95 07 	sts	0x0795, r24

            /* If the tick count has overflowed we need to swap the ready lists. */
            if( xCoRoutineTickCount == 0 )
    179e:	80 91 91 07 	lds	r24, 0x0791
    17a2:	90 91 92 07 	lds	r25, 0x0792
    17a6:	00 97       	sbiw	r24, 0x00	; 0
    17a8:	09 f0       	breq	.+2      	; 0x17ac <prvCheckDelayedList+0x58>
    17aa:	64 c0       	rjmp	.+200    	; 0x1874 <prvCheckDelayedList+0x120>
            {
                List_t * pxTemp;

                /* Tick count has overflowed so we need to swap the delay lists.  If there are
                 * any items in pxDelayedCoRoutineList here then there is an error! */
                pxTemp = pxDelayedCoRoutineList;
    17ac:	80 91 8a 07 	lds	r24, 0x078A
    17b0:	90 91 8b 07 	lds	r25, 0x078B
    17b4:	9a 83       	std	Y+2, r25	; 0x02
    17b6:	89 83       	std	Y+1, r24	; 0x01
                pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
    17b8:	80 91 8c 07 	lds	r24, 0x078C
    17bc:	90 91 8d 07 	lds	r25, 0x078D
    17c0:	90 93 8b 07 	sts	0x078B, r25
    17c4:	80 93 8a 07 	sts	0x078A, r24
                pxOverflowDelayedCoRoutineList = pxTemp;
    17c8:	89 81       	ldd	r24, Y+1	; 0x01
    17ca:	9a 81       	ldd	r25, Y+2	; 0x02
    17cc:	90 93 8d 07 	sts	0x078D, r25
    17d0:	80 93 8c 07 	sts	0x078C, r24
    17d4:	4f c0       	rjmp	.+158    	; 0x1874 <prvCheckDelayedList+0x120>
            }

            /* See if this tick has made a timeout expire. */
            while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
            {
                pxCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList );
    17d6:	e0 91 8a 07 	lds	r30, 0x078A
    17da:	f0 91 8b 07 	lds	r31, 0x078B
    17de:	05 80       	ldd	r0, Z+5	; 0x05
    17e0:	f6 81       	ldd	r31, Z+6	; 0x06
    17e2:	e0 2d       	mov	r30, r0
    17e4:	86 81       	ldd	r24, Z+6	; 0x06
    17e6:	97 81       	ldd	r25, Z+7	; 0x07
    17e8:	9c 83       	std	Y+4, r25	; 0x04
    17ea:	8b 83       	std	Y+3, r24	; 0x03

                if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )
    17ec:	eb 81       	ldd	r30, Y+3	; 0x03
    17ee:	fc 81       	ldd	r31, Y+4	; 0x04
    17f0:	22 81       	ldd	r18, Z+2	; 0x02
    17f2:	33 81       	ldd	r19, Z+3	; 0x03
    17f4:	80 91 91 07 	lds	r24, 0x0791
    17f8:	90 91 92 07 	lds	r25, 0x0792
    17fc:	82 17       	cp	r24, r18
    17fe:	93 07       	cpc	r25, r19
    1800:	08 f4       	brcc	.+2      	; 0x1804 <prvCheckDelayedList+0xb0>
    1802:	40 c0       	rjmp	.+128    	; 0x1884 <prvCheckDelayedList+0x130>
                {
                    /* Timeout not yet expired. */
                    break;
                }

                portDISABLE_INTERRUPTS();
    1804:	f8 94       	cli
                    /* The event could have occurred just before this critical
                     *  section.  If this is the case then the generic list item will
                     *  have been moved to the pending ready list and the following
                     *  line is still valid.  Also the pvContainer parameter will have
                     *  been set to NULL so the following lines are also valid. */
                    ( void ) uxListRemove( &( pxCRCB->xGenericListItem ) );
    1806:	8b 81       	ldd	r24, Y+3	; 0x03
    1808:	9c 81       	ldd	r25, Y+4	; 0x04
    180a:	02 96       	adiw	r24, 0x02	; 2
    180c:	0e 94 79 11 	call	0x22f2	; 0x22f2 <uxListRemove>

                    /* Is the co-routine waiting on an event also? */
                    if( pxCRCB->xEventListItem.pxContainer )
    1810:	eb 81       	ldd	r30, Y+3	; 0x03
    1812:	fc 81       	ldd	r31, Y+4	; 0x04
    1814:	84 89       	ldd	r24, Z+20	; 0x14
    1816:	95 89       	ldd	r25, Z+21	; 0x15
    1818:	00 97       	sbiw	r24, 0x00	; 0
    181a:	29 f0       	breq	.+10     	; 0x1826 <prvCheckDelayedList+0xd2>
                    {
                        ( void ) uxListRemove( &( pxCRCB->xEventListItem ) );
    181c:	8b 81       	ldd	r24, Y+3	; 0x03
    181e:	9c 81       	ldd	r25, Y+4	; 0x04
    1820:	0c 96       	adiw	r24, 0x0c	; 12
    1822:	0e 94 79 11 	call	0x22f2	; 0x22f2 <uxListRemove>
                    }
                }
                portENABLE_INTERRUPTS();
    1826:	78 94       	sei

                prvAddCoRoutineToReadyQueue( pxCRCB );
    1828:	eb 81       	ldd	r30, Y+3	; 0x03
    182a:	fc 81       	ldd	r31, Y+4	; 0x04
    182c:	96 89       	ldd	r25, Z+22	; 0x16
    182e:	80 91 90 07 	lds	r24, 0x0790
    1832:	89 17       	cp	r24, r25
    1834:	28 f4       	brcc	.+10     	; 0x1840 <prvCheckDelayedList+0xec>
    1836:	eb 81       	ldd	r30, Y+3	; 0x03
    1838:	fc 81       	ldd	r31, Y+4	; 0x04
    183a:	86 89       	ldd	r24, Z+22	; 0x16
    183c:	80 93 90 07 	sts	0x0790, r24
    1840:	eb 81       	ldd	r30, Y+3	; 0x03
    1842:	fc 81       	ldd	r31, Y+4	; 0x04
    1844:	86 89       	ldd	r24, Z+22	; 0x16
    1846:	28 2f       	mov	r18, r24
    1848:	30 e0       	ldi	r19, 0x00	; 0
    184a:	c9 01       	movw	r24, r18
    184c:	88 0f       	add	r24, r24
    184e:	99 1f       	adc	r25, r25
    1850:	88 0f       	add	r24, r24
    1852:	99 1f       	adc	r25, r25
    1854:	88 0f       	add	r24, r24
    1856:	99 1f       	adc	r25, r25
    1858:	82 0f       	add	r24, r18
    185a:	93 1f       	adc	r25, r19
    185c:	ac 01       	movw	r20, r24
    185e:	49 56       	subi	r20, 0x69	; 105
    1860:	58 4f       	sbci	r21, 0xF8	; 248
    1862:	8b 81       	ldd	r24, Y+3	; 0x03
    1864:	9c 81       	ldd	r25, Y+4	; 0x04
    1866:	9c 01       	movw	r18, r24
    1868:	2e 5f       	subi	r18, 0xFE	; 254
    186a:	3f 4f       	sbci	r19, 0xFF	; 255
    186c:	ca 01       	movw	r24, r20
    186e:	b9 01       	movw	r22, r18
    1870:	0e 94 c9 10 	call	0x2192	; 0x2192 <vListInsertEnd>
                pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
                pxOverflowDelayedCoRoutineList = pxTemp;
            }

            /* See if this tick has made a timeout expire. */
            while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
    1874:	e0 91 8a 07 	lds	r30, 0x078A
    1878:	f0 91 8b 07 	lds	r31, 0x078B
    187c:	80 81       	ld	r24, Z
    187e:	88 23       	and	r24, r24
    1880:	09 f0       	breq	.+2      	; 0x1884 <prvCheckDelayedList+0x130>
    1882:	a9 cf       	rjmp	.-174    	; 0x17d6 <prvCheckDelayedList+0x82>
    {
        CRCB_t * pxCRCB;

        xPassedTicks = xTaskGetTickCount() - xLastTickCount;

        while( xPassedTicks )
    1884:	80 91 95 07 	lds	r24, 0x0795
    1888:	90 91 96 07 	lds	r25, 0x0796
    188c:	00 97       	sbiw	r24, 0x00	; 0
    188e:	09 f0       	breq	.+2      	; 0x1892 <prvCheckDelayedList+0x13e>
    1890:	74 cf       	rjmp	.-280    	; 0x177a <prvCheckDelayedList+0x26>

                prvAddCoRoutineToReadyQueue( pxCRCB );
            }
        }

        xLastTickCount = xCoRoutineTickCount;
    1892:	80 91 91 07 	lds	r24, 0x0791
    1896:	90 91 92 07 	lds	r25, 0x0792
    189a:	90 93 94 07 	sts	0x0794, r25
    189e:	80 93 93 07 	sts	0x0793, r24
    }
    18a2:	0f 90       	pop	r0
    18a4:	0f 90       	pop	r0
    18a6:	0f 90       	pop	r0
    18a8:	0f 90       	pop	r0
    18aa:	cf 91       	pop	r28
    18ac:	df 91       	pop	r29
    18ae:	08 95       	ret

000018b0 <vCoRoutineSchedule>:
/*-----------------------------------------------------------*/

    void vCoRoutineSchedule( void )
    {
    18b0:	df 93       	push	r29
    18b2:	cf 93       	push	r28
    18b4:	00 d0       	rcall	.+0      	; 0x18b6 <vCoRoutineSchedule+0x6>
    18b6:	cd b7       	in	r28, 0x3d	; 61
    18b8:	de b7       	in	r29, 0x3e	; 62
        /* Only run a co-routine after prvInitialiseCoRoutineLists() has been
         * called.  prvInitialiseCoRoutineLists() is called automatically when a
         * co-routine is created. */
        if( pxDelayedCoRoutineList != NULL )
    18ba:	80 91 8a 07 	lds	r24, 0x078A
    18be:	90 91 8b 07 	lds	r25, 0x078B
    18c2:	00 97       	sbiw	r24, 0x00	; 0
    18c4:	09 f4       	brne	.+2      	; 0x18c8 <vCoRoutineSchedule+0x18>
    18c6:	70 c0       	rjmp	.+224    	; 0x19a8 <vCoRoutineSchedule+0xf8>
        {
            /* See if any co-routines readied by events need moving to the ready lists. */
            prvCheckPendingReadyList();
    18c8:	0e 94 60 0b 	call	0x16c0	; 0x16c0 <prvCheckPendingReadyList>

            /* See if any delayed co-routines have timed out. */
            prvCheckDelayedList();
    18cc:	0e 94 aa 0b 	call	0x1754	; 0x1754 <prvCheckDelayedList>
    18d0:	0a c0       	rjmp	.+20     	; 0x18e6 <vCoRoutineSchedule+0x36>

            /* Find the highest priority queue that contains ready co-routines. */
            while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
            {
                if( uxTopCoRoutineReadyPriority == 0 )
    18d2:	80 91 90 07 	lds	r24, 0x0790
    18d6:	88 23       	and	r24, r24
    18d8:	09 f4       	brne	.+2      	; 0x18dc <vCoRoutineSchedule+0x2c>
    18da:	66 c0       	rjmp	.+204    	; 0x19a8 <vCoRoutineSchedule+0xf8>
                {
                    /* No more co-routines to check. */
                    return;
                }

                --uxTopCoRoutineReadyPriority;
    18dc:	80 91 90 07 	lds	r24, 0x0790
    18e0:	81 50       	subi	r24, 0x01	; 1
    18e2:	80 93 90 07 	sts	0x0790, r24

            /* See if any delayed co-routines have timed out. */
            prvCheckDelayedList();

            /* Find the highest priority queue that contains ready co-routines. */
            while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
    18e6:	80 91 90 07 	lds	r24, 0x0790
    18ea:	28 2f       	mov	r18, r24
    18ec:	30 e0       	ldi	r19, 0x00	; 0
    18ee:	c9 01       	movw	r24, r18
    18f0:	88 0f       	add	r24, r24
    18f2:	99 1f       	adc	r25, r25
    18f4:	88 0f       	add	r24, r24
    18f6:	99 1f       	adc	r25, r25
    18f8:	88 0f       	add	r24, r24
    18fa:	99 1f       	adc	r25, r25
    18fc:	82 0f       	add	r24, r18
    18fe:	93 1f       	adc	r25, r19
    1900:	fc 01       	movw	r30, r24
    1902:	e9 56       	subi	r30, 0x69	; 105
    1904:	f8 4f       	sbci	r31, 0xF8	; 248
    1906:	80 81       	ld	r24, Z
    1908:	88 23       	and	r24, r24
    190a:	19 f3       	breq	.-58     	; 0x18d2 <vCoRoutineSchedule+0x22>
                --uxTopCoRoutineReadyPriority;
            }

            /* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
             * of the same priority get an equal share of the processor time. */
            listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );
    190c:	80 91 90 07 	lds	r24, 0x0790
    1910:	28 2f       	mov	r18, r24
    1912:	30 e0       	ldi	r19, 0x00	; 0
    1914:	c9 01       	movw	r24, r18
    1916:	88 0f       	add	r24, r24
    1918:	99 1f       	adc	r25, r25
    191a:	88 0f       	add	r24, r24
    191c:	99 1f       	adc	r25, r25
    191e:	88 0f       	add	r24, r24
    1920:	99 1f       	adc	r25, r25
    1922:	82 0f       	add	r24, r18
    1924:	93 1f       	adc	r25, r19
    1926:	89 56       	subi	r24, 0x69	; 105
    1928:	98 4f       	sbci	r25, 0xF8	; 248
    192a:	9a 83       	std	Y+2, r25	; 0x02
    192c:	89 83       	std	Y+1, r24	; 0x01
    192e:	e9 81       	ldd	r30, Y+1	; 0x01
    1930:	fa 81       	ldd	r31, Y+2	; 0x02
    1932:	01 80       	ldd	r0, Z+1	; 0x01
    1934:	f2 81       	ldd	r31, Z+2	; 0x02
    1936:	e0 2d       	mov	r30, r0
    1938:	82 81       	ldd	r24, Z+2	; 0x02
    193a:	93 81       	ldd	r25, Z+3	; 0x03
    193c:	e9 81       	ldd	r30, Y+1	; 0x01
    193e:	fa 81       	ldd	r31, Y+2	; 0x02
    1940:	92 83       	std	Z+2, r25	; 0x02
    1942:	81 83       	std	Z+1, r24	; 0x01
    1944:	e9 81       	ldd	r30, Y+1	; 0x01
    1946:	fa 81       	ldd	r31, Y+2	; 0x02
    1948:	21 81       	ldd	r18, Z+1	; 0x01
    194a:	32 81       	ldd	r19, Z+2	; 0x02
    194c:	89 81       	ldd	r24, Y+1	; 0x01
    194e:	9a 81       	ldd	r25, Y+2	; 0x02
    1950:	03 96       	adiw	r24, 0x03	; 3
    1952:	28 17       	cp	r18, r24
    1954:	39 07       	cpc	r19, r25
    1956:	59 f4       	brne	.+22     	; 0x196e <vCoRoutineSchedule+0xbe>
    1958:	e9 81       	ldd	r30, Y+1	; 0x01
    195a:	fa 81       	ldd	r31, Y+2	; 0x02
    195c:	01 80       	ldd	r0, Z+1	; 0x01
    195e:	f2 81       	ldd	r31, Z+2	; 0x02
    1960:	e0 2d       	mov	r30, r0
    1962:	82 81       	ldd	r24, Z+2	; 0x02
    1964:	93 81       	ldd	r25, Z+3	; 0x03
    1966:	e9 81       	ldd	r30, Y+1	; 0x01
    1968:	fa 81       	ldd	r31, Y+2	; 0x02
    196a:	92 83       	std	Z+2, r25	; 0x02
    196c:	81 83       	std	Z+1, r24	; 0x01
    196e:	e9 81       	ldd	r30, Y+1	; 0x01
    1970:	fa 81       	ldd	r31, Y+2	; 0x02
    1972:	01 80       	ldd	r0, Z+1	; 0x01
    1974:	f2 81       	ldd	r31, Z+2	; 0x02
    1976:	e0 2d       	mov	r30, r0
    1978:	86 81       	ldd	r24, Z+6	; 0x06
    197a:	97 81       	ldd	r25, Z+7	; 0x07
    197c:	90 93 8f 07 	sts	0x078F, r25
    1980:	80 93 8e 07 	sts	0x078E, r24

            /* Call the co-routine. */
            ( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
    1984:	e0 91 8e 07 	lds	r30, 0x078E
    1988:	f0 91 8f 07 	lds	r31, 0x078F
    198c:	40 81       	ld	r20, Z
    198e:	51 81       	ldd	r21, Z+1	; 0x01
    1990:	80 91 8e 07 	lds	r24, 0x078E
    1994:	90 91 8f 07 	lds	r25, 0x078F
    1998:	e0 91 8e 07 	lds	r30, 0x078E
    199c:	f0 91 8f 07 	lds	r31, 0x078F
    19a0:	27 89       	ldd	r18, Z+23	; 0x17
    19a2:	62 2f       	mov	r22, r18
    19a4:	fa 01       	movw	r30, r20
    19a6:	09 95       	icall
        }
    }
    19a8:	0f 90       	pop	r0
    19aa:	0f 90       	pop	r0
    19ac:	cf 91       	pop	r28
    19ae:	df 91       	pop	r29
    19b0:	08 95       	ret

000019b2 <prvInitialiseCoRoutineLists>:
/*-----------------------------------------------------------*/

    static void prvInitialiseCoRoutineLists( void )
    {
    19b2:	df 93       	push	r29
    19b4:	cf 93       	push	r28
    19b6:	0f 92       	push	r0
    19b8:	cd b7       	in	r28, 0x3d	; 61
    19ba:	de b7       	in	r29, 0x3e	; 62
        UBaseType_t uxPriority;

        for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
    19bc:	19 82       	std	Y+1, r1	; 0x01
    19be:	13 c0       	rjmp	.+38     	; 0x19e6 <prvInitialiseCoRoutineLists+0x34>
        {
            vListInitialise( ( List_t * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
    19c0:	89 81       	ldd	r24, Y+1	; 0x01
    19c2:	28 2f       	mov	r18, r24
    19c4:	30 e0       	ldi	r19, 0x00	; 0
    19c6:	c9 01       	movw	r24, r18
    19c8:	88 0f       	add	r24, r24
    19ca:	99 1f       	adc	r25, r25
    19cc:	88 0f       	add	r24, r24
    19ce:	99 1f       	adc	r25, r25
    19d0:	88 0f       	add	r24, r24
    19d2:	99 1f       	adc	r25, r25
    19d4:	82 0f       	add	r24, r18
    19d6:	93 1f       	adc	r25, r19
    19d8:	89 56       	subi	r24, 0x69	; 105
    19da:	98 4f       	sbci	r25, 0xF8	; 248
    19dc:	0e 94 8f 10 	call	0x211e	; 0x211e <vListInitialise>

    static void prvInitialiseCoRoutineLists( void )
    {
        UBaseType_t uxPriority;

        for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
    19e0:	89 81       	ldd	r24, Y+1	; 0x01
    19e2:	8f 5f       	subi	r24, 0xFF	; 255
    19e4:	89 83       	std	Y+1, r24	; 0x01
    19e6:	89 81       	ldd	r24, Y+1	; 0x01
    19e8:	82 30       	cpi	r24, 0x02	; 2
    19ea:	50 f3       	brcs	.-44     	; 0x19c0 <prvInitialiseCoRoutineLists+0xe>
        {
            vListInitialise( ( List_t * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
        }

        vListInitialise( ( List_t * ) &xDelayedCoRoutineList1 );
    19ec:	89 ea       	ldi	r24, 0xA9	; 169
    19ee:	97 e0       	ldi	r25, 0x07	; 7
    19f0:	0e 94 8f 10 	call	0x211e	; 0x211e <vListInitialise>
        vListInitialise( ( List_t * ) &xDelayedCoRoutineList2 );
    19f4:	82 eb       	ldi	r24, 0xB2	; 178
    19f6:	97 e0       	ldi	r25, 0x07	; 7
    19f8:	0e 94 8f 10 	call	0x211e	; 0x211e <vListInitialise>
        vListInitialise( ( List_t * ) &xPendingReadyCoRoutineList );
    19fc:	8b eb       	ldi	r24, 0xBB	; 187
    19fe:	97 e0       	ldi	r25, 0x07	; 7
    1a00:	0e 94 8f 10 	call	0x211e	; 0x211e <vListInitialise>

        /* Start with pxDelayedCoRoutineList using list1 and the
         * pxOverflowDelayedCoRoutineList using list2. */
        pxDelayedCoRoutineList = &xDelayedCoRoutineList1;
    1a04:	89 ea       	ldi	r24, 0xA9	; 169
    1a06:	97 e0       	ldi	r25, 0x07	; 7
    1a08:	90 93 8b 07 	sts	0x078B, r25
    1a0c:	80 93 8a 07 	sts	0x078A, r24
        pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
    1a10:	82 eb       	ldi	r24, 0xB2	; 178
    1a12:	97 e0       	ldi	r25, 0x07	; 7
    1a14:	90 93 8d 07 	sts	0x078D, r25
    1a18:	80 93 8c 07 	sts	0x078C, r24
    }
    1a1c:	0f 90       	pop	r0
    1a1e:	cf 91       	pop	r28
    1a20:	df 91       	pop	r29
    1a22:	08 95       	ret

00001a24 <xCoRoutineRemoveFromEventList>:
/*-----------------------------------------------------------*/

    BaseType_t xCoRoutineRemoveFromEventList( const List_t * pxEventList )
    {
    1a24:	df 93       	push	r29
    1a26:	cf 93       	push	r28
    1a28:	00 d0       	rcall	.+0      	; 0x1a2a <xCoRoutineRemoveFromEventList+0x6>
    1a2a:	00 d0       	rcall	.+0      	; 0x1a2c <xCoRoutineRemoveFromEventList+0x8>
    1a2c:	0f 92       	push	r0
    1a2e:	cd b7       	in	r28, 0x3d	; 61
    1a30:	de b7       	in	r29, 0x3e	; 62
    1a32:	9d 83       	std	Y+5, r25	; 0x05
    1a34:	8c 83       	std	Y+4, r24	; 0x04
        BaseType_t xReturn;

        /* This function is called from within an interrupt.  It can only access
         * event lists and the pending ready list.  This function assumes that a
         * check has already been made to ensure pxEventList is not empty. */
        pxUnblockedCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    1a36:	ec 81       	ldd	r30, Y+4	; 0x04
    1a38:	fd 81       	ldd	r31, Y+5	; 0x05
    1a3a:	05 80       	ldd	r0, Z+5	; 0x05
    1a3c:	f6 81       	ldd	r31, Z+6	; 0x06
    1a3e:	e0 2d       	mov	r30, r0
    1a40:	86 81       	ldd	r24, Z+6	; 0x06
    1a42:	97 81       	ldd	r25, Z+7	; 0x07
    1a44:	9b 83       	std	Y+3, r25	; 0x03
    1a46:	8a 83       	std	Y+2, r24	; 0x02
        ( void ) uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    1a48:	8a 81       	ldd	r24, Y+2	; 0x02
    1a4a:	9b 81       	ldd	r25, Y+3	; 0x03
    1a4c:	0c 96       	adiw	r24, 0x0c	; 12
    1a4e:	0e 94 79 11 	call	0x22f2	; 0x22f2 <uxListRemove>
        vListInsertEnd( ( List_t * ) &( xPendingReadyCoRoutineList ), &( pxUnblockedCRCB->xEventListItem ) );
    1a52:	8a 81       	ldd	r24, Y+2	; 0x02
    1a54:	9b 81       	ldd	r25, Y+3	; 0x03
    1a56:	9c 01       	movw	r18, r24
    1a58:	24 5f       	subi	r18, 0xF4	; 244
    1a5a:	3f 4f       	sbci	r19, 0xFF	; 255
    1a5c:	8b eb       	ldi	r24, 0xBB	; 187
    1a5e:	97 e0       	ldi	r25, 0x07	; 7
    1a60:	b9 01       	movw	r22, r18
    1a62:	0e 94 c9 10 	call	0x2192	; 0x2192 <vListInsertEnd>

        if( pxUnblockedCRCB->uxPriority >= pxCurrentCoRoutine->uxPriority )
    1a66:	ea 81       	ldd	r30, Y+2	; 0x02
    1a68:	fb 81       	ldd	r31, Y+3	; 0x03
    1a6a:	96 89       	ldd	r25, Z+22	; 0x16
    1a6c:	e0 91 8e 07 	lds	r30, 0x078E
    1a70:	f0 91 8f 07 	lds	r31, 0x078F
    1a74:	86 89       	ldd	r24, Z+22	; 0x16
    1a76:	98 17       	cp	r25, r24
    1a78:	18 f0       	brcs	.+6      	; 0x1a80 <xCoRoutineRemoveFromEventList+0x5c>
        {
            xReturn = pdTRUE;
    1a7a:	81 e0       	ldi	r24, 0x01	; 1
    1a7c:	89 83       	std	Y+1, r24	; 0x01
    1a7e:	01 c0       	rjmp	.+2      	; 0x1a82 <xCoRoutineRemoveFromEventList+0x5e>
        }
        else
        {
            xReturn = pdFALSE;
    1a80:	19 82       	std	Y+1, r1	; 0x01
        }

        return xReturn;
    1a82:	89 81       	ldd	r24, Y+1	; 0x01
    }
    1a84:	0f 90       	pop	r0
    1a86:	0f 90       	pop	r0
    1a88:	0f 90       	pop	r0
    1a8a:	0f 90       	pop	r0
    1a8c:	0f 90       	pop	r0
    1a8e:	cf 91       	pop	r28
    1a90:	df 91       	pop	r29
    1a92:	08 95       	ret

00001a94 <xEventGroupCreate>:
/*-----------------------------------------------------------*/

#if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

    EventGroupHandle_t xEventGroupCreate( void )
    {
    1a94:	df 93       	push	r29
    1a96:	cf 93       	push	r28
    1a98:	00 d0       	rcall	.+0      	; 0x1a9a <xEventGroupCreate+0x6>
    1a9a:	cd b7       	in	r28, 0x3d	; 61
    1a9c:	de b7       	in	r29, 0x3e	; 62
         * TickType_t alignment requirements the cast is safe.  In other cases,
         * where the natural word size of the architecture is less than
         * sizeof( TickType_t ), the TickType_t variables will be accessed in two
         * or more reads operations, and the alignment requirements is only that
         * of each individual read. */
        pxEventBits = ( EventGroup_t * ) pvPortMalloc( sizeof( EventGroup_t ) ); /*lint !e9087 !e9079 see comment above. */
    1a9e:	8b e0       	ldi	r24, 0x0B	; 11
    1aa0:	90 e0       	ldi	r25, 0x00	; 0
    1aa2:	0e 94 17 07 	call	0xe2e	; 0xe2e <pvPortMalloc>
    1aa6:	9a 83       	std	Y+2, r25	; 0x02
    1aa8:	89 83       	std	Y+1, r24	; 0x01

        if( pxEventBits != NULL )
    1aaa:	89 81       	ldd	r24, Y+1	; 0x01
    1aac:	9a 81       	ldd	r25, Y+2	; 0x02
    1aae:	00 97       	sbiw	r24, 0x00	; 0
    1ab0:	49 f0       	breq	.+18     	; 0x1ac4 <xEventGroupCreate+0x30>
        {
            pxEventBits->uxEventBits = 0;
    1ab2:	e9 81       	ldd	r30, Y+1	; 0x01
    1ab4:	fa 81       	ldd	r31, Y+2	; 0x02
    1ab6:	11 82       	std	Z+1, r1	; 0x01
    1ab8:	10 82       	st	Z, r1
            vListInitialise( &( pxEventBits->xTasksWaitingForBits ) );
    1aba:	89 81       	ldd	r24, Y+1	; 0x01
    1abc:	9a 81       	ldd	r25, Y+2	; 0x02
    1abe:	02 96       	adiw	r24, 0x02	; 2
    1ac0:	0e 94 8f 10 	call	0x211e	; 0x211e <vListInitialise>
        else
        {
            traceEVENT_GROUP_CREATE_FAILED(); /*lint !e9063 Else branch only exists to allow tracing and does not generate code if trace macros are not defined. */
        }

        return pxEventBits;
    1ac4:	89 81       	ldd	r24, Y+1	; 0x01
    1ac6:	9a 81       	ldd	r25, Y+2	; 0x02
    }
    1ac8:	0f 90       	pop	r0
    1aca:	0f 90       	pop	r0
    1acc:	cf 91       	pop	r28
    1ace:	df 91       	pop	r29
    1ad0:	08 95       	ret

00001ad2 <xEventGroupSync>:

EventBits_t xEventGroupSync( EventGroupHandle_t xEventGroup,
                             const EventBits_t uxBitsToSet,
                             const EventBits_t uxBitsToWaitFor,
                             TickType_t xTicksToWait )
{
    1ad2:	df 93       	push	r29
    1ad4:	cf 93       	push	r28
    1ad6:	cd b7       	in	r28, 0x3d	; 61
    1ad8:	de b7       	in	r29, 0x3e	; 62
    1ada:	60 97       	sbiw	r28, 0x10	; 16
    1adc:	0f b6       	in	r0, 0x3f	; 63
    1ade:	f8 94       	cli
    1ae0:	de bf       	out	0x3e, r29	; 62
    1ae2:	0f be       	out	0x3f, r0	; 63
    1ae4:	cd bf       	out	0x3d, r28	; 61
    1ae6:	9a 87       	std	Y+10, r25	; 0x0a
    1ae8:	89 87       	std	Y+9, r24	; 0x09
    1aea:	7c 87       	std	Y+12, r23	; 0x0c
    1aec:	6b 87       	std	Y+11, r22	; 0x0b
    1aee:	5e 87       	std	Y+14, r21	; 0x0e
    1af0:	4d 87       	std	Y+13, r20	; 0x0d
    1af2:	38 8b       	std	Y+16, r19	; 0x10
    1af4:	2f 87       	std	Y+15, r18	; 0x0f
    EventBits_t uxOriginalBitValue, uxReturn;
    EventGroup_t * pxEventBits = xEventGroup;
    1af6:	89 85       	ldd	r24, Y+9	; 0x09
    1af8:	9a 85       	ldd	r25, Y+10	; 0x0a
    1afa:	9c 83       	std	Y+4, r25	; 0x04
    1afc:	8b 83       	std	Y+3, r24	; 0x03
    BaseType_t xAlreadyYielded;
    BaseType_t xTimeoutOccurred = pdFALSE;
    1afe:	19 82       	std	Y+1, r1	; 0x01
        {
            configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
        }
    #endif

    vTaskSuspendAll();
    1b00:	0e 94 6c 1e 	call	0x3cd8	; 0x3cd8 <vTaskSuspendAll>
    {
        uxOriginalBitValue = pxEventBits->uxEventBits;
    1b04:	eb 81       	ldd	r30, Y+3	; 0x03
    1b06:	fc 81       	ldd	r31, Y+4	; 0x04
    1b08:	80 81       	ld	r24, Z
    1b0a:	91 81       	ldd	r25, Z+1	; 0x01
    1b0c:	98 87       	std	Y+8, r25	; 0x08
    1b0e:	8f 83       	std	Y+7, r24	; 0x07

        ( void ) xEventGroupSetBits( xEventGroup, uxBitsToSet );
    1b10:	89 85       	ldd	r24, Y+9	; 0x09
    1b12:	9a 85       	ldd	r25, Y+10	; 0x0a
    1b14:	2b 85       	ldd	r18, Y+11	; 0x0b
    1b16:	3c 85       	ldd	r19, Y+12	; 0x0c
    1b18:	b9 01       	movw	r22, r18
    1b1a:	0e 94 40 0f 	call	0x1e80	; 0x1e80 <xEventGroupSetBits>

        if( ( ( uxOriginalBitValue | uxBitsToSet ) & uxBitsToWaitFor ) == uxBitsToWaitFor )
    1b1e:	2f 81       	ldd	r18, Y+7	; 0x07
    1b20:	38 85       	ldd	r19, Y+8	; 0x08
    1b22:	8b 85       	ldd	r24, Y+11	; 0x0b
    1b24:	9c 85       	ldd	r25, Y+12	; 0x0c
    1b26:	28 2b       	or	r18, r24
    1b28:	39 2b       	or	r19, r25
    1b2a:	8d 85       	ldd	r24, Y+13	; 0x0d
    1b2c:	9e 85       	ldd	r25, Y+14	; 0x0e
    1b2e:	28 23       	and	r18, r24
    1b30:	39 23       	and	r19, r25
    1b32:	8d 85       	ldd	r24, Y+13	; 0x0d
    1b34:	9e 85       	ldd	r25, Y+14	; 0x0e
    1b36:	28 17       	cp	r18, r24
    1b38:	39 07       	cpc	r19, r25
    1b3a:	c9 f4       	brne	.+50     	; 0x1b6e <xEventGroupSync+0x9c>
        {
            /* All the rendezvous bits are now set - no need to block. */
            uxReturn = ( uxOriginalBitValue | uxBitsToSet );
    1b3c:	2f 81       	ldd	r18, Y+7	; 0x07
    1b3e:	38 85       	ldd	r19, Y+8	; 0x08
    1b40:	8b 85       	ldd	r24, Y+11	; 0x0b
    1b42:	9c 85       	ldd	r25, Y+12	; 0x0c
    1b44:	82 2b       	or	r24, r18
    1b46:	93 2b       	or	r25, r19
    1b48:	9e 83       	std	Y+6, r25	; 0x06
    1b4a:	8d 83       	std	Y+5, r24	; 0x05

            /* Rendezvous always clear the bits.  They will have been cleared
             * already unless this is the only task in the rendezvous. */
            pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    1b4c:	eb 81       	ldd	r30, Y+3	; 0x03
    1b4e:	fc 81       	ldd	r31, Y+4	; 0x04
    1b50:	20 81       	ld	r18, Z
    1b52:	31 81       	ldd	r19, Z+1	; 0x01
    1b54:	8d 85       	ldd	r24, Y+13	; 0x0d
    1b56:	9e 85       	ldd	r25, Y+14	; 0x0e
    1b58:	80 95       	com	r24
    1b5a:	90 95       	com	r25
    1b5c:	82 23       	and	r24, r18
    1b5e:	93 23       	and	r25, r19
    1b60:	eb 81       	ldd	r30, Y+3	; 0x03
    1b62:	fc 81       	ldd	r31, Y+4	; 0x04
    1b64:	91 83       	std	Z+1, r25	; 0x01
    1b66:	80 83       	st	Z, r24

            xTicksToWait = 0;
    1b68:	18 8a       	std	Y+16, r1	; 0x10
    1b6a:	1f 86       	std	Y+15, r1	; 0x0f
    1b6c:	1e c0       	rjmp	.+60     	; 0x1baa <xEventGroupSync+0xd8>
        }
        else
        {
            if( xTicksToWait != ( TickType_t ) 0 )
    1b6e:	8f 85       	ldd	r24, Y+15	; 0x0f
    1b70:	98 89       	ldd	r25, Y+16	; 0x10
    1b72:	00 97       	sbiw	r24, 0x00	; 0
    1b74:	91 f0       	breq	.+36     	; 0x1b9a <xEventGroupSync+0xc8>
                traceEVENT_GROUP_SYNC_BLOCK( xEventGroup, uxBitsToSet, uxBitsToWaitFor );

                /* Store the bits that the calling task is waiting for in the
                 * task's event list item so the kernel knows when a match is
                 * found.  Then enter the blocked state. */
                vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | eventCLEAR_EVENTS_ON_EXIT_BIT | eventWAIT_FOR_ALL_BITS ), xTicksToWait );
    1b76:	8b 81       	ldd	r24, Y+3	; 0x03
    1b78:	9c 81       	ldd	r25, Y+4	; 0x04
    1b7a:	bc 01       	movw	r22, r24
    1b7c:	6e 5f       	subi	r22, 0xFE	; 254
    1b7e:	7f 4f       	sbci	r23, 0xFF	; 255
    1b80:	8d 85       	ldd	r24, Y+13	; 0x0d
    1b82:	9e 85       	ldd	r25, Y+14	; 0x0e
    1b84:	9c 01       	movw	r18, r24
    1b86:	35 60       	ori	r19, 0x05	; 5
    1b88:	4f 85       	ldd	r20, Y+15	; 0x0f
    1b8a:	58 89       	ldd	r21, Y+16	; 0x10
    1b8c:	cb 01       	movw	r24, r22
    1b8e:	b9 01       	movw	r22, r18
    1b90:	0e 94 6b 22 	call	0x44d6	; 0x44d6 <vTaskPlaceOnUnorderedEventList>

                /* This assignment is obsolete as uxReturn will get set after
                 * the task unblocks, but some compilers mistakenly generate a
                 * warning about uxReturn being returned without being set if the
                 * assignment is omitted. */
                uxReturn = 0;
    1b94:	1e 82       	std	Y+6, r1	; 0x06
    1b96:	1d 82       	std	Y+5, r1	; 0x05
    1b98:	08 c0       	rjmp	.+16     	; 0x1baa <xEventGroupSync+0xd8>
            }
            else
            {
                /* The rendezvous bits were not set, but no block time was
                 * specified - just return the current event bit value. */
                uxReturn = pxEventBits->uxEventBits;
    1b9a:	eb 81       	ldd	r30, Y+3	; 0x03
    1b9c:	fc 81       	ldd	r31, Y+4	; 0x04
    1b9e:	80 81       	ld	r24, Z
    1ba0:	91 81       	ldd	r25, Z+1	; 0x01
    1ba2:	9e 83       	std	Y+6, r25	; 0x06
    1ba4:	8d 83       	std	Y+5, r24	; 0x05
                xTimeoutOccurred = pdTRUE;
    1ba6:	81 e0       	ldi	r24, 0x01	; 1
    1ba8:	89 83       	std	Y+1, r24	; 0x01
            }
        }
    }
    xAlreadyYielded = xTaskResumeAll();
    1baa:	0e 94 78 1e 	call	0x3cf0	; 0x3cf0 <xTaskResumeAll>
    1bae:	8a 83       	std	Y+2, r24	; 0x02

    if( xTicksToWait != ( TickType_t ) 0 )
    1bb0:	8f 85       	ldd	r24, Y+15	; 0x0f
    1bb2:	98 89       	ldd	r25, Y+16	; 0x10
    1bb4:	00 97       	sbiw	r24, 0x00	; 0
    1bb6:	09 f4       	brne	.+2      	; 0x1bba <xEventGroupSync+0xe8>
    1bb8:	3a c0       	rjmp	.+116    	; 0x1c2e <xEventGroupSync+0x15c>
    {
        if( xAlreadyYielded == pdFALSE )
    1bba:	8a 81       	ldd	r24, Y+2	; 0x02
    1bbc:	88 23       	and	r24, r24
    1bbe:	11 f4       	brne	.+4      	; 0x1bc4 <xEventGroupSync+0xf2>
        {
            portYIELD_WITHIN_API();
    1bc0:	0e 94 56 09 	call	0x12ac	; 0x12ac <vPortYield>

        /* The task blocked to wait for its required bits to be set - at this
         * point either the required bits were set or the block time expired.  If
         * the required bits were set they will have been stored in the task's
         * event list item, and they should now be retrieved then cleared. */
        uxReturn = uxTaskResetEventItemValue();
    1bc4:	0e 94 f9 26 	call	0x4df2	; 0x4df2 <uxTaskResetEventItemValue>
    1bc8:	9e 83       	std	Y+6, r25	; 0x06
    1bca:	8d 83       	std	Y+5, r24	; 0x05

        if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
    1bcc:	8d 81       	ldd	r24, Y+5	; 0x05
    1bce:	9e 81       	ldd	r25, Y+6	; 0x06
    1bd0:	80 70       	andi	r24, 0x00	; 0
    1bd2:	92 70       	andi	r25, 0x02	; 2
    1bd4:	00 97       	sbiw	r24, 0x00	; 0
    1bd6:	31 f5       	brne	.+76     	; 0x1c24 <xEventGroupSync+0x152>
        {
            /* The task timed out, just return the current event bit value. */
            taskENTER_CRITICAL();
    1bd8:	0f b6       	in	r0, 0x3f	; 63
    1bda:	f8 94       	cli
    1bdc:	0f 92       	push	r0
            {
                uxReturn = pxEventBits->uxEventBits;
    1bde:	eb 81       	ldd	r30, Y+3	; 0x03
    1be0:	fc 81       	ldd	r31, Y+4	; 0x04
    1be2:	80 81       	ld	r24, Z
    1be4:	91 81       	ldd	r25, Z+1	; 0x01
    1be6:	9e 83       	std	Y+6, r25	; 0x06
    1be8:	8d 83       	std	Y+5, r24	; 0x05

                /* Although the task got here because it timed out before the
                 * bits it was waiting for were set, it is possible that since it
                 * unblocked another task has set the bits.  If this is the case
                 * then it needs to clear the bits before exiting. */
                if( ( uxReturn & uxBitsToWaitFor ) == uxBitsToWaitFor )
    1bea:	2d 81       	ldd	r18, Y+5	; 0x05
    1bec:	3e 81       	ldd	r19, Y+6	; 0x06
    1bee:	8d 85       	ldd	r24, Y+13	; 0x0d
    1bf0:	9e 85       	ldd	r25, Y+14	; 0x0e
    1bf2:	28 23       	and	r18, r24
    1bf4:	39 23       	and	r19, r25
    1bf6:	8d 85       	ldd	r24, Y+13	; 0x0d
    1bf8:	9e 85       	ldd	r25, Y+14	; 0x0e
    1bfa:	28 17       	cp	r18, r24
    1bfc:	39 07       	cpc	r19, r25
    1bfe:	71 f4       	brne	.+28     	; 0x1c1c <xEventGroupSync+0x14a>
                {
                    pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    1c00:	eb 81       	ldd	r30, Y+3	; 0x03
    1c02:	fc 81       	ldd	r31, Y+4	; 0x04
    1c04:	20 81       	ld	r18, Z
    1c06:	31 81       	ldd	r19, Z+1	; 0x01
    1c08:	8d 85       	ldd	r24, Y+13	; 0x0d
    1c0a:	9e 85       	ldd	r25, Y+14	; 0x0e
    1c0c:	80 95       	com	r24
    1c0e:	90 95       	com	r25
    1c10:	82 23       	and	r24, r18
    1c12:	93 23       	and	r25, r19
    1c14:	eb 81       	ldd	r30, Y+3	; 0x03
    1c16:	fc 81       	ldd	r31, Y+4	; 0x04
    1c18:	91 83       	std	Z+1, r25	; 0x01
    1c1a:	80 83       	st	Z, r24
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }
            }
            taskEXIT_CRITICAL();
    1c1c:	0f 90       	pop	r0
    1c1e:	0f be       	out	0x3f, r0	; 63

            xTimeoutOccurred = pdTRUE;
    1c20:	81 e0       	ldi	r24, 0x01	; 1
    1c22:	89 83       	std	Y+1, r24	; 0x01
            /* The task unblocked because the bits were set. */
        }

        /* Control bits might be set as the task had blocked should not be
         * returned. */
        uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
    1c24:	8d 81       	ldd	r24, Y+5	; 0x05
    1c26:	9e 81       	ldd	r25, Y+6	; 0x06
    1c28:	90 70       	andi	r25, 0x00	; 0
    1c2a:	9e 83       	std	Y+6, r25	; 0x06
    1c2c:	8d 83       	std	Y+5, r24	; 0x05
    traceEVENT_GROUP_SYNC_END( xEventGroup, uxBitsToSet, uxBitsToWaitFor, xTimeoutOccurred );

    /* Prevent compiler warnings when trace macros are not used. */
    ( void ) xTimeoutOccurred;

    return uxReturn;
    1c2e:	8d 81       	ldd	r24, Y+5	; 0x05
    1c30:	9e 81       	ldd	r25, Y+6	; 0x06
}
    1c32:	60 96       	adiw	r28, 0x10	; 16
    1c34:	0f b6       	in	r0, 0x3f	; 63
    1c36:	f8 94       	cli
    1c38:	de bf       	out	0x3e, r29	; 62
    1c3a:	0f be       	out	0x3f, r0	; 63
    1c3c:	cd bf       	out	0x3d, r28	; 61
    1c3e:	cf 91       	pop	r28
    1c40:	df 91       	pop	r29
    1c42:	08 95       	ret

00001c44 <xEventGroupWaitBits>:
EventBits_t xEventGroupWaitBits( EventGroupHandle_t xEventGroup,
                                 const EventBits_t uxBitsToWaitFor,
                                 const BaseType_t xClearOnExit,
                                 const BaseType_t xWaitForAllBits,
                                 TickType_t xTicksToWait )
{
    1c44:	0f 93       	push	r16
    1c46:	1f 93       	push	r17
    1c48:	df 93       	push	r29
    1c4a:	cf 93       	push	r28
    1c4c:	cd b7       	in	r28, 0x3d	; 61
    1c4e:	de b7       	in	r29, 0x3e	; 62
    1c50:	63 97       	sbiw	r28, 0x13	; 19
    1c52:	0f b6       	in	r0, 0x3f	; 63
    1c54:	f8 94       	cli
    1c56:	de bf       	out	0x3e, r29	; 62
    1c58:	0f be       	out	0x3f, r0	; 63
    1c5a:	cd bf       	out	0x3d, r28	; 61
    1c5c:	9d 87       	std	Y+13, r25	; 0x0d
    1c5e:	8c 87       	std	Y+12, r24	; 0x0c
    1c60:	7f 87       	std	Y+15, r23	; 0x0f
    1c62:	6e 87       	std	Y+14, r22	; 0x0e
    1c64:	48 8b       	std	Y+16, r20	; 0x10
    1c66:	29 8b       	std	Y+17, r18	; 0x11
    1c68:	1b 8b       	std	Y+19, r17	; 0x13
    1c6a:	0a 8b       	std	Y+18, r16	; 0x12
    EventGroup_t * pxEventBits = xEventGroup;
    1c6c:	8c 85       	ldd	r24, Y+12	; 0x0c
    1c6e:	9d 85       	ldd	r25, Y+13	; 0x0d
    1c70:	9b 87       	std	Y+11, r25	; 0x0b
    1c72:	8a 87       	std	Y+10, r24	; 0x0a
    EventBits_t uxReturn, uxControlBits = 0;
    1c74:	1f 82       	std	Y+7, r1	; 0x07
    1c76:	1e 82       	std	Y+6, r1	; 0x06
    BaseType_t xWaitConditionMet, xAlreadyYielded;
    BaseType_t xTimeoutOccurred = pdFALSE;
    1c78:	1b 82       	std	Y+3, r1	; 0x03
        {
            configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
        }
    #endif

    vTaskSuspendAll();
    1c7a:	0e 94 6c 1e 	call	0x3cd8	; 0x3cd8 <vTaskSuspendAll>
    {
        const EventBits_t uxCurrentEventBits = pxEventBits->uxEventBits;
    1c7e:	ea 85       	ldd	r30, Y+10	; 0x0a
    1c80:	fb 85       	ldd	r31, Y+11	; 0x0b
    1c82:	80 81       	ld	r24, Z
    1c84:	91 81       	ldd	r25, Z+1	; 0x01
    1c86:	9a 83       	std	Y+2, r25	; 0x02
    1c88:	89 83       	std	Y+1, r24	; 0x01

        /* Check to see if the wait condition is already met or not. */
        xWaitConditionMet = prvTestWaitCondition( uxCurrentEventBits, uxBitsToWaitFor, xWaitForAllBits );
    1c8a:	89 81       	ldd	r24, Y+1	; 0x01
    1c8c:	9a 81       	ldd	r25, Y+2	; 0x02
    1c8e:	2e 85       	ldd	r18, Y+14	; 0x0e
    1c90:	3f 85       	ldd	r19, Y+15	; 0x0f
    1c92:	b9 01       	movw	r22, r18
    1c94:	49 89       	ldd	r20, Y+17	; 0x11
    1c96:	0e 94 5d 10 	call	0x20ba	; 0x20ba <prvTestWaitCondition>
    1c9a:	8d 83       	std	Y+5, r24	; 0x05

        if( xWaitConditionMet != pdFALSE )
    1c9c:	8d 81       	ldd	r24, Y+5	; 0x05
    1c9e:	88 23       	and	r24, r24
    1ca0:	c1 f0       	breq	.+48     	; 0x1cd2 <xEventGroupWaitBits+0x8e>
        {
            /* The wait condition has already been met so there is no need to
             * block. */
            uxReturn = uxCurrentEventBits;
    1ca2:	89 81       	ldd	r24, Y+1	; 0x01
    1ca4:	9a 81       	ldd	r25, Y+2	; 0x02
    1ca6:	99 87       	std	Y+9, r25	; 0x09
    1ca8:	88 87       	std	Y+8, r24	; 0x08
            xTicksToWait = ( TickType_t ) 0;
    1caa:	1b 8a       	std	Y+19, r1	; 0x13
    1cac:	1a 8a       	std	Y+18, r1	; 0x12

            /* Clear the wait bits if requested to do so. */
            if( xClearOnExit != pdFALSE )
    1cae:	88 89       	ldd	r24, Y+16	; 0x10
    1cb0:	88 23       	and	r24, r24
    1cb2:	e9 f1       	breq	.+122    	; 0x1d2e <xEventGroupWaitBits+0xea>
            {
                pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    1cb4:	ea 85       	ldd	r30, Y+10	; 0x0a
    1cb6:	fb 85       	ldd	r31, Y+11	; 0x0b
    1cb8:	20 81       	ld	r18, Z
    1cba:	31 81       	ldd	r19, Z+1	; 0x01
    1cbc:	8e 85       	ldd	r24, Y+14	; 0x0e
    1cbe:	9f 85       	ldd	r25, Y+15	; 0x0f
    1cc0:	80 95       	com	r24
    1cc2:	90 95       	com	r25
    1cc4:	82 23       	and	r24, r18
    1cc6:	93 23       	and	r25, r19
    1cc8:	ea 85       	ldd	r30, Y+10	; 0x0a
    1cca:	fb 85       	ldd	r31, Y+11	; 0x0b
    1ccc:	91 83       	std	Z+1, r25	; 0x01
    1cce:	80 83       	st	Z, r24
    1cd0:	2e c0       	rjmp	.+92     	; 0x1d2e <xEventGroupWaitBits+0xea>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        else if( xTicksToWait == ( TickType_t ) 0 )
    1cd2:	8a 89       	ldd	r24, Y+18	; 0x12
    1cd4:	9b 89       	ldd	r25, Y+19	; 0x13
    1cd6:	00 97       	sbiw	r24, 0x00	; 0
    1cd8:	39 f4       	brne	.+14     	; 0x1ce8 <xEventGroupWaitBits+0xa4>
        {
            /* The wait condition has not been met, but no block time was
             * specified, so just return the current value. */
            uxReturn = uxCurrentEventBits;
    1cda:	89 81       	ldd	r24, Y+1	; 0x01
    1cdc:	9a 81       	ldd	r25, Y+2	; 0x02
    1cde:	99 87       	std	Y+9, r25	; 0x09
    1ce0:	88 87       	std	Y+8, r24	; 0x08
            xTimeoutOccurred = pdTRUE;
    1ce2:	81 e0       	ldi	r24, 0x01	; 1
    1ce4:	8b 83       	std	Y+3, r24	; 0x03
    1ce6:	23 c0       	rjmp	.+70     	; 0x1d2e <xEventGroupWaitBits+0xea>
        {
            /* The task is going to block to wait for its required bits to be
             * set.  uxControlBits are used to remember the specified behaviour of
             * this call to xEventGroupWaitBits() - for use when the event bits
             * unblock the task. */
            if( xClearOnExit != pdFALSE )
    1ce8:	88 89       	ldd	r24, Y+16	; 0x10
    1cea:	88 23       	and	r24, r24
    1cec:	29 f0       	breq	.+10     	; 0x1cf8 <xEventGroupWaitBits+0xb4>
            {
                uxControlBits |= eventCLEAR_EVENTS_ON_EXIT_BIT;
    1cee:	8e 81       	ldd	r24, Y+6	; 0x06
    1cf0:	9f 81       	ldd	r25, Y+7	; 0x07
    1cf2:	91 60       	ori	r25, 0x01	; 1
    1cf4:	9f 83       	std	Y+7, r25	; 0x07
    1cf6:	8e 83       	std	Y+6, r24	; 0x06
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }

            if( xWaitForAllBits != pdFALSE )
    1cf8:	89 89       	ldd	r24, Y+17	; 0x11
    1cfa:	88 23       	and	r24, r24
    1cfc:	29 f0       	breq	.+10     	; 0x1d08 <xEventGroupWaitBits+0xc4>
            {
                uxControlBits |= eventWAIT_FOR_ALL_BITS;
    1cfe:	8e 81       	ldd	r24, Y+6	; 0x06
    1d00:	9f 81       	ldd	r25, Y+7	; 0x07
    1d02:	94 60       	ori	r25, 0x04	; 4
    1d04:	9f 83       	std	Y+7, r25	; 0x07
    1d06:	8e 83       	std	Y+6, r24	; 0x06
            }

            /* Store the bits that the calling task is waiting for in the
             * task's event list item so the kernel knows when a match is
             * found.  Then enter the blocked state. */
            vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | uxControlBits ), xTicksToWait );
    1d08:	8a 85       	ldd	r24, Y+10	; 0x0a
    1d0a:	9b 85       	ldd	r25, Y+11	; 0x0b
    1d0c:	bc 01       	movw	r22, r24
    1d0e:	6e 5f       	subi	r22, 0xFE	; 254
    1d10:	7f 4f       	sbci	r23, 0xFF	; 255
    1d12:	2e 85       	ldd	r18, Y+14	; 0x0e
    1d14:	3f 85       	ldd	r19, Y+15	; 0x0f
    1d16:	8e 81       	ldd	r24, Y+6	; 0x06
    1d18:	9f 81       	ldd	r25, Y+7	; 0x07
    1d1a:	28 2b       	or	r18, r24
    1d1c:	39 2b       	or	r19, r25
    1d1e:	4a 89       	ldd	r20, Y+18	; 0x12
    1d20:	5b 89       	ldd	r21, Y+19	; 0x13
    1d22:	cb 01       	movw	r24, r22
    1d24:	b9 01       	movw	r22, r18
    1d26:	0e 94 6b 22 	call	0x44d6	; 0x44d6 <vTaskPlaceOnUnorderedEventList>

            /* This is obsolete as it will get set after the task unblocks, but
             * some compilers mistakenly generate a warning about the variable
             * being returned without being set if it is not done. */
            uxReturn = 0;
    1d2a:	19 86       	std	Y+9, r1	; 0x09
    1d2c:	18 86       	std	Y+8, r1	; 0x08

            traceEVENT_GROUP_WAIT_BITS_BLOCK( xEventGroup, uxBitsToWaitFor );
        }
    }
    xAlreadyYielded = xTaskResumeAll();
    1d2e:	0e 94 78 1e 	call	0x3cf0	; 0x3cf0 <xTaskResumeAll>
    1d32:	8c 83       	std	Y+4, r24	; 0x04

    if( xTicksToWait != ( TickType_t ) 0 )
    1d34:	8a 89       	ldd	r24, Y+18	; 0x12
    1d36:	9b 89       	ldd	r25, Y+19	; 0x13
    1d38:	00 97       	sbiw	r24, 0x00	; 0
    1d3a:	09 f4       	brne	.+2      	; 0x1d3e <xEventGroupWaitBits+0xfa>
    1d3c:	3c c0       	rjmp	.+120    	; 0x1db6 <xEventGroupWaitBits+0x172>
    {
        if( xAlreadyYielded == pdFALSE )
    1d3e:	8c 81       	ldd	r24, Y+4	; 0x04
    1d40:	88 23       	and	r24, r24
    1d42:	11 f4       	brne	.+4      	; 0x1d48 <xEventGroupWaitBits+0x104>
        {
            portYIELD_WITHIN_API();
    1d44:	0e 94 56 09 	call	0x12ac	; 0x12ac <vPortYield>

        /* The task blocked to wait for its required bits to be set - at this
         * point either the required bits were set or the block time expired.  If
         * the required bits were set they will have been stored in the task's
         * event list item, and they should now be retrieved then cleared. */
        uxReturn = uxTaskResetEventItemValue();
    1d48:	0e 94 f9 26 	call	0x4df2	; 0x4df2 <uxTaskResetEventItemValue>
    1d4c:	99 87       	std	Y+9, r25	; 0x09
    1d4e:	88 87       	std	Y+8, r24	; 0x08

        if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
    1d50:	88 85       	ldd	r24, Y+8	; 0x08
    1d52:	99 85       	ldd	r25, Y+9	; 0x09
    1d54:	80 70       	andi	r24, 0x00	; 0
    1d56:	92 70       	andi	r25, 0x02	; 2
    1d58:	00 97       	sbiw	r24, 0x00	; 0
    1d5a:	41 f5       	brne	.+80     	; 0x1dac <xEventGroupWaitBits+0x168>
        {
            taskENTER_CRITICAL();
    1d5c:	0f b6       	in	r0, 0x3f	; 63
    1d5e:	f8 94       	cli
    1d60:	0f 92       	push	r0
            {
                /* The task timed out, just return the current event bit value. */
                uxReturn = pxEventBits->uxEventBits;
    1d62:	ea 85       	ldd	r30, Y+10	; 0x0a
    1d64:	fb 85       	ldd	r31, Y+11	; 0x0b
    1d66:	80 81       	ld	r24, Z
    1d68:	91 81       	ldd	r25, Z+1	; 0x01
    1d6a:	99 87       	std	Y+9, r25	; 0x09
    1d6c:	88 87       	std	Y+8, r24	; 0x08

                /* It is possible that the event bits were updated between this
                 * task leaving the Blocked state and running again. */
                if( prvTestWaitCondition( uxReturn, uxBitsToWaitFor, xWaitForAllBits ) != pdFALSE )
    1d6e:	88 85       	ldd	r24, Y+8	; 0x08
    1d70:	99 85       	ldd	r25, Y+9	; 0x09
    1d72:	2e 85       	ldd	r18, Y+14	; 0x0e
    1d74:	3f 85       	ldd	r19, Y+15	; 0x0f
    1d76:	b9 01       	movw	r22, r18
    1d78:	49 89       	ldd	r20, Y+17	; 0x11
    1d7a:	0e 94 5d 10 	call	0x20ba	; 0x20ba <prvTestWaitCondition>
    1d7e:	88 23       	and	r24, r24
    1d80:	89 f0       	breq	.+34     	; 0x1da4 <xEventGroupWaitBits+0x160>
                {
                    if( xClearOnExit != pdFALSE )
    1d82:	88 89       	ldd	r24, Y+16	; 0x10
    1d84:	88 23       	and	r24, r24
    1d86:	71 f0       	breq	.+28     	; 0x1da4 <xEventGroupWaitBits+0x160>
                    {
                        pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    1d88:	ea 85       	ldd	r30, Y+10	; 0x0a
    1d8a:	fb 85       	ldd	r31, Y+11	; 0x0b
    1d8c:	20 81       	ld	r18, Z
    1d8e:	31 81       	ldd	r19, Z+1	; 0x01
    1d90:	8e 85       	ldd	r24, Y+14	; 0x0e
    1d92:	9f 85       	ldd	r25, Y+15	; 0x0f
    1d94:	80 95       	com	r24
    1d96:	90 95       	com	r25
    1d98:	82 23       	and	r24, r18
    1d9a:	93 23       	and	r25, r19
    1d9c:	ea 85       	ldd	r30, Y+10	; 0x0a
    1d9e:	fb 85       	ldd	r31, Y+11	; 0x0b
    1da0:	91 83       	std	Z+1, r25	; 0x01
    1da2:	80 83       	st	Z, r24
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                xTimeoutOccurred = pdTRUE;
    1da4:	81 e0       	ldi	r24, 0x01	; 1
    1da6:	8b 83       	std	Y+3, r24	; 0x03
            }
            taskEXIT_CRITICAL();
    1da8:	0f 90       	pop	r0
    1daa:	0f be       	out	0x3f, r0	; 63
        {
            /* The task unblocked because the bits were set. */
        }

        /* The task blocked so control bits may have been set. */
        uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
    1dac:	88 85       	ldd	r24, Y+8	; 0x08
    1dae:	99 85       	ldd	r25, Y+9	; 0x09
    1db0:	90 70       	andi	r25, 0x00	; 0
    1db2:	99 87       	std	Y+9, r25	; 0x09
    1db4:	88 87       	std	Y+8, r24	; 0x08
    traceEVENT_GROUP_WAIT_BITS_END( xEventGroup, uxBitsToWaitFor, xTimeoutOccurred );

    /* Prevent compiler warnings when trace macros are not used. */
    ( void ) xTimeoutOccurred;

    return uxReturn;
    1db6:	88 85       	ldd	r24, Y+8	; 0x08
    1db8:	99 85       	ldd	r25, Y+9	; 0x09
}
    1dba:	63 96       	adiw	r28, 0x13	; 19
    1dbc:	0f b6       	in	r0, 0x3f	; 63
    1dbe:	f8 94       	cli
    1dc0:	de bf       	out	0x3e, r29	; 62
    1dc2:	0f be       	out	0x3f, r0	; 63
    1dc4:	cd bf       	out	0x3d, r28	; 61
    1dc6:	cf 91       	pop	r28
    1dc8:	df 91       	pop	r29
    1dca:	1f 91       	pop	r17
    1dcc:	0f 91       	pop	r16
    1dce:	08 95       	ret

00001dd0 <xEventGroupClearBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupClearBits( EventGroupHandle_t xEventGroup,
                                  const EventBits_t uxBitsToClear )
{
    1dd0:	df 93       	push	r29
    1dd2:	cf 93       	push	r28
    1dd4:	cd b7       	in	r28, 0x3d	; 61
    1dd6:	de b7       	in	r29, 0x3e	; 62
    1dd8:	28 97       	sbiw	r28, 0x08	; 8
    1dda:	0f b6       	in	r0, 0x3f	; 63
    1ddc:	f8 94       	cli
    1dde:	de bf       	out	0x3e, r29	; 62
    1de0:	0f be       	out	0x3f, r0	; 63
    1de2:	cd bf       	out	0x3d, r28	; 61
    1de4:	9e 83       	std	Y+6, r25	; 0x06
    1de6:	8d 83       	std	Y+5, r24	; 0x05
    1de8:	78 87       	std	Y+8, r23	; 0x08
    1dea:	6f 83       	std	Y+7, r22	; 0x07
    EventGroup_t * pxEventBits = xEventGroup;
    1dec:	8d 81       	ldd	r24, Y+5	; 0x05
    1dee:	9e 81       	ldd	r25, Y+6	; 0x06
    1df0:	9c 83       	std	Y+4, r25	; 0x04
    1df2:	8b 83       	std	Y+3, r24	; 0x03
    /* Check the user is not attempting to clear the bits used by the kernel
     * itself. */
    configASSERT( xEventGroup );
    configASSERT( ( uxBitsToClear & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

    taskENTER_CRITICAL();
    1df4:	0f b6       	in	r0, 0x3f	; 63
    1df6:	f8 94       	cli
    1df8:	0f 92       	push	r0
    {
        traceEVENT_GROUP_CLEAR_BITS( xEventGroup, uxBitsToClear );

        /* The value returned is the event group value prior to the bits being
         * cleared. */
        uxReturn = pxEventBits->uxEventBits;
    1dfa:	eb 81       	ldd	r30, Y+3	; 0x03
    1dfc:	fc 81       	ldd	r31, Y+4	; 0x04
    1dfe:	80 81       	ld	r24, Z
    1e00:	91 81       	ldd	r25, Z+1	; 0x01
    1e02:	9a 83       	std	Y+2, r25	; 0x02
    1e04:	89 83       	std	Y+1, r24	; 0x01

        /* Clear the bits. */
        pxEventBits->uxEventBits &= ~uxBitsToClear;
    1e06:	eb 81       	ldd	r30, Y+3	; 0x03
    1e08:	fc 81       	ldd	r31, Y+4	; 0x04
    1e0a:	20 81       	ld	r18, Z
    1e0c:	31 81       	ldd	r19, Z+1	; 0x01
    1e0e:	8f 81       	ldd	r24, Y+7	; 0x07
    1e10:	98 85       	ldd	r25, Y+8	; 0x08
    1e12:	80 95       	com	r24
    1e14:	90 95       	com	r25
    1e16:	82 23       	and	r24, r18
    1e18:	93 23       	and	r25, r19
    1e1a:	eb 81       	ldd	r30, Y+3	; 0x03
    1e1c:	fc 81       	ldd	r31, Y+4	; 0x04
    1e1e:	91 83       	std	Z+1, r25	; 0x01
    1e20:	80 83       	st	Z, r24
    }
    taskEXIT_CRITICAL();
    1e22:	0f 90       	pop	r0
    1e24:	0f be       	out	0x3f, r0	; 63

    return uxReturn;
    1e26:	89 81       	ldd	r24, Y+1	; 0x01
    1e28:	9a 81       	ldd	r25, Y+2	; 0x02
}
    1e2a:	28 96       	adiw	r28, 0x08	; 8
    1e2c:	0f b6       	in	r0, 0x3f	; 63
    1e2e:	f8 94       	cli
    1e30:	de bf       	out	0x3e, r29	; 62
    1e32:	0f be       	out	0x3f, r0	; 63
    1e34:	cd bf       	out	0x3d, r28	; 61
    1e36:	cf 91       	pop	r28
    1e38:	df 91       	pop	r29
    1e3a:	08 95       	ret

00001e3c <xEventGroupGetBitsFromISR>:

#endif /* if ( ( configUSE_TRACE_FACILITY == 1 ) && ( INCLUDE_xTimerPendFunctionCall == 1 ) && ( configUSE_TIMERS == 1 ) ) */
/*-----------------------------------------------------------*/

EventBits_t xEventGroupGetBitsFromISR( EventGroupHandle_t xEventGroup )
{
    1e3c:	df 93       	push	r29
    1e3e:	cf 93       	push	r28
    1e40:	cd b7       	in	r28, 0x3d	; 61
    1e42:	de b7       	in	r29, 0x3e	; 62
    1e44:	27 97       	sbiw	r28, 0x07	; 7
    1e46:	0f b6       	in	r0, 0x3f	; 63
    1e48:	f8 94       	cli
    1e4a:	de bf       	out	0x3e, r29	; 62
    1e4c:	0f be       	out	0x3f, r0	; 63
    1e4e:	cd bf       	out	0x3d, r28	; 61
    1e50:	9f 83       	std	Y+7, r25	; 0x07
    1e52:	8e 83       	std	Y+6, r24	; 0x06
    UBaseType_t uxSavedInterruptStatus;
    EventGroup_t const * const pxEventBits = xEventGroup;
    1e54:	8e 81       	ldd	r24, Y+6	; 0x06
    1e56:	9f 81       	ldd	r25, Y+7	; 0x07
    1e58:	9c 83       	std	Y+4, r25	; 0x04
    1e5a:	8b 83       	std	Y+3, r24	; 0x03
    EventBits_t uxReturn;

    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    1e5c:	1d 82       	std	Y+5, r1	; 0x05
    {
        uxReturn = pxEventBits->uxEventBits;
    1e5e:	eb 81       	ldd	r30, Y+3	; 0x03
    1e60:	fc 81       	ldd	r31, Y+4	; 0x04
    1e62:	80 81       	ld	r24, Z
    1e64:	91 81       	ldd	r25, Z+1	; 0x01
    1e66:	9a 83       	std	Y+2, r25	; 0x02
    1e68:	89 83       	std	Y+1, r24	; 0x01
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return uxReturn;
    1e6a:	89 81       	ldd	r24, Y+1	; 0x01
    1e6c:	9a 81       	ldd	r25, Y+2	; 0x02
} /*lint !e818 EventGroupHandle_t is a typedef used in other functions to so can't be pointer to const. */
    1e6e:	27 96       	adiw	r28, 0x07	; 7
    1e70:	0f b6       	in	r0, 0x3f	; 63
    1e72:	f8 94       	cli
    1e74:	de bf       	out	0x3e, r29	; 62
    1e76:	0f be       	out	0x3f, r0	; 63
    1e78:	cd bf       	out	0x3d, r28	; 61
    1e7a:	cf 91       	pop	r28
    1e7c:	df 91       	pop	r29
    1e7e:	08 95       	ret

00001e80 <xEventGroupSetBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup,
                                const EventBits_t uxBitsToSet )
{
    1e80:	df 93       	push	r29
    1e82:	cf 93       	push	r28
    1e84:	cd b7       	in	r28, 0x3d	; 61
    1e86:	de b7       	in	r29, 0x3e	; 62
    1e88:	65 97       	sbiw	r28, 0x15	; 21
    1e8a:	0f b6       	in	r0, 0x3f	; 63
    1e8c:	f8 94       	cli
    1e8e:	de bf       	out	0x3e, r29	; 62
    1e90:	0f be       	out	0x3f, r0	; 63
    1e92:	cd bf       	out	0x3d, r28	; 61
    1e94:	9b 8b       	std	Y+19, r25	; 0x13
    1e96:	8a 8b       	std	Y+18, r24	; 0x12
    1e98:	7d 8b       	std	Y+21, r23	; 0x15
    1e9a:	6c 8b       	std	Y+20, r22	; 0x14
    ListItem_t * pxListItem, * pxNext;
    ListItem_t const * pxListEnd;
    List_t const * pxList;
    EventBits_t uxBitsToClear = 0, uxBitsWaitedFor, uxControlBits;
    1e9c:	19 86       	std	Y+9, r1	; 0x09
    1e9e:	18 86       	std	Y+8, r1	; 0x08
    EventGroup_t * pxEventBits = xEventGroup;
    1ea0:	8a 89       	ldd	r24, Y+18	; 0x12
    1ea2:	9b 89       	ldd	r25, Y+19	; 0x13
    1ea4:	9b 83       	std	Y+3, r25	; 0x03
    1ea6:	8a 83       	std	Y+2, r24	; 0x02
    BaseType_t xMatchFound = pdFALSE;
    1ea8:	19 82       	std	Y+1, r1	; 0x01
    /* Check the user is not attempting to set the bits used by the kernel
     * itself. */
    configASSERT( xEventGroup );
    configASSERT( ( uxBitsToSet & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

    pxList = &( pxEventBits->xTasksWaitingForBits );
    1eaa:	8a 81       	ldd	r24, Y+2	; 0x02
    1eac:	9b 81       	ldd	r25, Y+3	; 0x03
    1eae:	02 96       	adiw	r24, 0x02	; 2
    1eb0:	9b 87       	std	Y+11, r25	; 0x0b
    1eb2:	8a 87       	std	Y+10, r24	; 0x0a
    pxListEnd = listGET_END_MARKER( pxList ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1eb4:	8a 85       	ldd	r24, Y+10	; 0x0a
    1eb6:	9b 85       	ldd	r25, Y+11	; 0x0b
    1eb8:	03 96       	adiw	r24, 0x03	; 3
    1eba:	9d 87       	std	Y+13, r25	; 0x0d
    1ebc:	8c 87       	std	Y+12, r24	; 0x0c
    vTaskSuspendAll();
    1ebe:	0e 94 6c 1e 	call	0x3cd8	; 0x3cd8 <vTaskSuspendAll>
    {
        traceEVENT_GROUP_SET_BITS( xEventGroup, uxBitsToSet );

        pxListItem = listGET_HEAD_ENTRY( pxList );
    1ec2:	ea 85       	ldd	r30, Y+10	; 0x0a
    1ec4:	fb 85       	ldd	r31, Y+11	; 0x0b
    1ec6:	85 81       	ldd	r24, Z+5	; 0x05
    1ec8:	96 81       	ldd	r25, Z+6	; 0x06
    1eca:	99 8b       	std	Y+17, r25	; 0x11
    1ecc:	88 8b       	std	Y+16, r24	; 0x10

        /* Set the bits. */
        pxEventBits->uxEventBits |= uxBitsToSet;
    1ece:	ea 81       	ldd	r30, Y+2	; 0x02
    1ed0:	fb 81       	ldd	r31, Y+3	; 0x03
    1ed2:	20 81       	ld	r18, Z
    1ed4:	31 81       	ldd	r19, Z+1	; 0x01
    1ed6:	8c 89       	ldd	r24, Y+20	; 0x14
    1ed8:	9d 89       	ldd	r25, Y+21	; 0x15
    1eda:	82 2b       	or	r24, r18
    1edc:	93 2b       	or	r25, r19
    1ede:	ea 81       	ldd	r30, Y+2	; 0x02
    1ee0:	fb 81       	ldd	r31, Y+3	; 0x03
    1ee2:	91 83       	std	Z+1, r25	; 0x01
    1ee4:	80 83       	st	Z, r24
    1ee6:	59 c0       	rjmp	.+178    	; 0x1f9a <xEventGroupSetBits+0x11a>

        /* See if the new bit value should unblock any tasks. */
        while( pxListItem != pxListEnd )
        {
            pxNext = listGET_NEXT( pxListItem );
    1ee8:	e8 89       	ldd	r30, Y+16	; 0x10
    1eea:	f9 89       	ldd	r31, Y+17	; 0x11
    1eec:	82 81       	ldd	r24, Z+2	; 0x02
    1eee:	93 81       	ldd	r25, Z+3	; 0x03
    1ef0:	9f 87       	std	Y+15, r25	; 0x0f
    1ef2:	8e 87       	std	Y+14, r24	; 0x0e
            uxBitsWaitedFor = listGET_LIST_ITEM_VALUE( pxListItem );
    1ef4:	e8 89       	ldd	r30, Y+16	; 0x10
    1ef6:	f9 89       	ldd	r31, Y+17	; 0x11
    1ef8:	80 81       	ld	r24, Z
    1efa:	91 81       	ldd	r25, Z+1	; 0x01
    1efc:	9f 83       	std	Y+7, r25	; 0x07
    1efe:	8e 83       	std	Y+6, r24	; 0x06
            xMatchFound = pdFALSE;
    1f00:	19 82       	std	Y+1, r1	; 0x01

            /* Split the bits waited for from the control bits. */
            uxControlBits = uxBitsWaitedFor & eventEVENT_BITS_CONTROL_BYTES;
    1f02:	8e 81       	ldd	r24, Y+6	; 0x06
    1f04:	9f 81       	ldd	r25, Y+7	; 0x07
    1f06:	80 70       	andi	r24, 0x00	; 0
    1f08:	9d 83       	std	Y+5, r25	; 0x05
    1f0a:	8c 83       	std	Y+4, r24	; 0x04
            uxBitsWaitedFor &= ~eventEVENT_BITS_CONTROL_BYTES;
    1f0c:	8e 81       	ldd	r24, Y+6	; 0x06
    1f0e:	9f 81       	ldd	r25, Y+7	; 0x07
    1f10:	90 70       	andi	r25, 0x00	; 0
    1f12:	9f 83       	std	Y+7, r25	; 0x07
    1f14:	8e 83       	std	Y+6, r24	; 0x06

            if( ( uxControlBits & eventWAIT_FOR_ALL_BITS ) == ( EventBits_t ) 0 )
    1f16:	8c 81       	ldd	r24, Y+4	; 0x04
    1f18:	9d 81       	ldd	r25, Y+5	; 0x05
    1f1a:	80 70       	andi	r24, 0x00	; 0
    1f1c:	94 70       	andi	r25, 0x04	; 4
    1f1e:	00 97       	sbiw	r24, 0x00	; 0
    1f20:	69 f4       	brne	.+26     	; 0x1f3c <xEventGroupSetBits+0xbc>
            {
                /* Just looking for single bit being set. */
                if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) != ( EventBits_t ) 0 )
    1f22:	ea 81       	ldd	r30, Y+2	; 0x02
    1f24:	fb 81       	ldd	r31, Y+3	; 0x03
    1f26:	20 81       	ld	r18, Z
    1f28:	31 81       	ldd	r19, Z+1	; 0x01
    1f2a:	8e 81       	ldd	r24, Y+6	; 0x06
    1f2c:	9f 81       	ldd	r25, Y+7	; 0x07
    1f2e:	82 23       	and	r24, r18
    1f30:	93 23       	and	r25, r19
    1f32:	00 97       	sbiw	r24, 0x00	; 0
    1f34:	91 f0       	breq	.+36     	; 0x1f5a <xEventGroupSetBits+0xda>
                {
                    xMatchFound = pdTRUE;
    1f36:	81 e0       	ldi	r24, 0x01	; 1
    1f38:	89 83       	std	Y+1, r24	; 0x01
    1f3a:	0f c0       	rjmp	.+30     	; 0x1f5a <xEventGroupSetBits+0xda>
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }
            }
            else if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) == uxBitsWaitedFor )
    1f3c:	ea 81       	ldd	r30, Y+2	; 0x02
    1f3e:	fb 81       	ldd	r31, Y+3	; 0x03
    1f40:	20 81       	ld	r18, Z
    1f42:	31 81       	ldd	r19, Z+1	; 0x01
    1f44:	8e 81       	ldd	r24, Y+6	; 0x06
    1f46:	9f 81       	ldd	r25, Y+7	; 0x07
    1f48:	28 23       	and	r18, r24
    1f4a:	39 23       	and	r19, r25
    1f4c:	8e 81       	ldd	r24, Y+6	; 0x06
    1f4e:	9f 81       	ldd	r25, Y+7	; 0x07
    1f50:	28 17       	cp	r18, r24
    1f52:	39 07       	cpc	r19, r25
    1f54:	11 f4       	brne	.+4      	; 0x1f5a <xEventGroupSetBits+0xda>
            {
                /* All bits are set. */
                xMatchFound = pdTRUE;
    1f56:	81 e0       	ldi	r24, 0x01	; 1
    1f58:	89 83       	std	Y+1, r24	; 0x01
            else
            {
                /* Need all bits to be set, but not all the bits were set. */
            }

            if( xMatchFound != pdFALSE )
    1f5a:	89 81       	ldd	r24, Y+1	; 0x01
    1f5c:	88 23       	and	r24, r24
    1f5e:	c9 f0       	breq	.+50     	; 0x1f92 <xEventGroupSetBits+0x112>
            {
                /* The bits match.  Should the bits be cleared on exit? */
                if( ( uxControlBits & eventCLEAR_EVENTS_ON_EXIT_BIT ) != ( EventBits_t ) 0 )
    1f60:	8c 81       	ldd	r24, Y+4	; 0x04
    1f62:	9d 81       	ldd	r25, Y+5	; 0x05
    1f64:	80 70       	andi	r24, 0x00	; 0
    1f66:	91 70       	andi	r25, 0x01	; 1
    1f68:	00 97       	sbiw	r24, 0x00	; 0
    1f6a:	41 f0       	breq	.+16     	; 0x1f7c <xEventGroupSetBits+0xfc>
                {
                    uxBitsToClear |= uxBitsWaitedFor;
    1f6c:	88 85       	ldd	r24, Y+8	; 0x08
    1f6e:	99 85       	ldd	r25, Y+9	; 0x09
    1f70:	2e 81       	ldd	r18, Y+6	; 0x06
    1f72:	3f 81       	ldd	r19, Y+7	; 0x07
    1f74:	82 2b       	or	r24, r18
    1f76:	93 2b       	or	r25, r19
    1f78:	99 87       	std	Y+9, r25	; 0x09
    1f7a:	88 87       	std	Y+8, r24	; 0x08
                /* Store the actual event flag value in the task's event list
                 * item before removing the task from the event list.  The
                 * eventUNBLOCKED_DUE_TO_BIT_SET bit is set so the task knows
                 * that is was unblocked due to its required bits matching, rather
                 * than because it timed out. */
                vTaskRemoveFromUnorderedEventList( pxListItem, pxEventBits->uxEventBits | eventUNBLOCKED_DUE_TO_BIT_SET );
    1f7c:	ea 81       	ldd	r30, Y+2	; 0x02
    1f7e:	fb 81       	ldd	r31, Y+3	; 0x03
    1f80:	80 81       	ld	r24, Z
    1f82:	91 81       	ldd	r25, Z+1	; 0x01
    1f84:	9c 01       	movw	r18, r24
    1f86:	32 60       	ori	r19, 0x02	; 2
    1f88:	88 89       	ldd	r24, Y+16	; 0x10
    1f8a:	99 89       	ldd	r25, Y+17	; 0x11
    1f8c:	b9 01       	movw	r22, r18
    1f8e:	0e 94 76 24 	call	0x48ec	; 0x48ec <vTaskRemoveFromUnorderedEventList>
            }

            /* Move onto the next list item.  Note pxListItem->pxNext is not
             * used here as the list item may have been removed from the event list
             * and inserted into the ready/pending reading list. */
            pxListItem = pxNext;
    1f92:	8e 85       	ldd	r24, Y+14	; 0x0e
    1f94:	9f 85       	ldd	r25, Y+15	; 0x0f
    1f96:	99 8b       	std	Y+17, r25	; 0x11
    1f98:	88 8b       	std	Y+16, r24	; 0x10

        /* Set the bits. */
        pxEventBits->uxEventBits |= uxBitsToSet;

        /* See if the new bit value should unblock any tasks. */
        while( pxListItem != pxListEnd )
    1f9a:	28 89       	ldd	r18, Y+16	; 0x10
    1f9c:	39 89       	ldd	r19, Y+17	; 0x11
    1f9e:	8c 85       	ldd	r24, Y+12	; 0x0c
    1fa0:	9d 85       	ldd	r25, Y+13	; 0x0d
    1fa2:	28 17       	cp	r18, r24
    1fa4:	39 07       	cpc	r19, r25
    1fa6:	09 f0       	breq	.+2      	; 0x1faa <xEventGroupSetBits+0x12a>
    1fa8:	9f cf       	rjmp	.-194    	; 0x1ee8 <xEventGroupSetBits+0x68>
            pxListItem = pxNext;
        }

        /* Clear any bits that matched when the eventCLEAR_EVENTS_ON_EXIT_BIT
         * bit was set in the control word. */
        pxEventBits->uxEventBits &= ~uxBitsToClear;
    1faa:	ea 81       	ldd	r30, Y+2	; 0x02
    1fac:	fb 81       	ldd	r31, Y+3	; 0x03
    1fae:	20 81       	ld	r18, Z
    1fb0:	31 81       	ldd	r19, Z+1	; 0x01
    1fb2:	88 85       	ldd	r24, Y+8	; 0x08
    1fb4:	99 85       	ldd	r25, Y+9	; 0x09
    1fb6:	80 95       	com	r24
    1fb8:	90 95       	com	r25
    1fba:	82 23       	and	r24, r18
    1fbc:	93 23       	and	r25, r19
    1fbe:	ea 81       	ldd	r30, Y+2	; 0x02
    1fc0:	fb 81       	ldd	r31, Y+3	; 0x03
    1fc2:	91 83       	std	Z+1, r25	; 0x01
    1fc4:	80 83       	st	Z, r24
    }
    ( void ) xTaskResumeAll();
    1fc6:	0e 94 78 1e 	call	0x3cf0	; 0x3cf0 <xTaskResumeAll>

    return pxEventBits->uxEventBits;
    1fca:	ea 81       	ldd	r30, Y+2	; 0x02
    1fcc:	fb 81       	ldd	r31, Y+3	; 0x03
    1fce:	80 81       	ld	r24, Z
    1fd0:	91 81       	ldd	r25, Z+1	; 0x01
}
    1fd2:	65 96       	adiw	r28, 0x15	; 21
    1fd4:	0f b6       	in	r0, 0x3f	; 63
    1fd6:	f8 94       	cli
    1fd8:	de bf       	out	0x3e, r29	; 62
    1fda:	0f be       	out	0x3f, r0	; 63
    1fdc:	cd bf       	out	0x3d, r28	; 61
    1fde:	cf 91       	pop	r28
    1fe0:	df 91       	pop	r29
    1fe2:	08 95       	ret

00001fe4 <vEventGroupDelete>:
/*-----------------------------------------------------------*/

void vEventGroupDelete( EventGroupHandle_t xEventGroup )
{
    1fe4:	df 93       	push	r29
    1fe6:	cf 93       	push	r28
    1fe8:	00 d0       	rcall	.+0      	; 0x1fea <vEventGroupDelete+0x6>
    1fea:	00 d0       	rcall	.+0      	; 0x1fec <vEventGroupDelete+0x8>
    1fec:	00 d0       	rcall	.+0      	; 0x1fee <vEventGroupDelete+0xa>
    1fee:	cd b7       	in	r28, 0x3d	; 61
    1ff0:	de b7       	in	r29, 0x3e	; 62
    1ff2:	9e 83       	std	Y+6, r25	; 0x06
    1ff4:	8d 83       	std	Y+5, r24	; 0x05
    EventGroup_t * pxEventBits = xEventGroup;
    1ff6:	8d 81       	ldd	r24, Y+5	; 0x05
    1ff8:	9e 81       	ldd	r25, Y+6	; 0x06
    1ffa:	9c 83       	std	Y+4, r25	; 0x04
    1ffc:	8b 83       	std	Y+3, r24	; 0x03
    const List_t * pxTasksWaitingForBits;

    configASSERT( pxEventBits );

    pxTasksWaitingForBits = &( pxEventBits->xTasksWaitingForBits );
    1ffe:	8b 81       	ldd	r24, Y+3	; 0x03
    2000:	9c 81       	ldd	r25, Y+4	; 0x04
    2002:	02 96       	adiw	r24, 0x02	; 2
    2004:	9a 83       	std	Y+2, r25	; 0x02
    2006:	89 83       	std	Y+1, r24	; 0x01

    vTaskSuspendAll();
    2008:	0e 94 6c 1e 	call	0x3cd8	; 0x3cd8 <vTaskSuspendAll>
    200c:	08 c0       	rjmp	.+16     	; 0x201e <vEventGroupDelete+0x3a>
        while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
        {
            /* Unblock the task, returning 0 as the event list is being deleted
             * and cannot therefore have any bits set. */
            configASSERT( pxTasksWaitingForBits->xListEnd.pxNext != ( const ListItem_t * ) &( pxTasksWaitingForBits->xListEnd ) );
            vTaskRemoveFromUnorderedEventList( pxTasksWaitingForBits->xListEnd.pxNext, eventUNBLOCKED_DUE_TO_BIT_SET );
    200e:	e9 81       	ldd	r30, Y+1	; 0x01
    2010:	fa 81       	ldd	r31, Y+2	; 0x02
    2012:	85 81       	ldd	r24, Z+5	; 0x05
    2014:	96 81       	ldd	r25, Z+6	; 0x06
    2016:	60 e0       	ldi	r22, 0x00	; 0
    2018:	72 e0       	ldi	r23, 0x02	; 2
    201a:	0e 94 76 24 	call	0x48ec	; 0x48ec <vTaskRemoveFromUnorderedEventList>

    vTaskSuspendAll();
    {
        traceEVENT_GROUP_DELETE( xEventGroup );

        while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
    201e:	e9 81       	ldd	r30, Y+1	; 0x01
    2020:	fa 81       	ldd	r31, Y+2	; 0x02
    2022:	80 81       	ld	r24, Z
    2024:	88 23       	and	r24, r24
    2026:	99 f7       	brne	.-26     	; 0x200e <vEventGroupDelete+0x2a>

        #if ( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
            {
                /* The event group can only have been allocated dynamically - free
                 * it again. */
                vPortFree( pxEventBits );
    2028:	8b 81       	ldd	r24, Y+3	; 0x03
    202a:	9c 81       	ldd	r25, Y+4	; 0x04
    202c:	0e 94 71 07 	call	0xee2	; 0xee2 <vPortFree>
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        #endif /* configSUPPORT_DYNAMIC_ALLOCATION */
    }
    ( void ) xTaskResumeAll();
    2030:	0e 94 78 1e 	call	0x3cf0	; 0x3cf0 <xTaskResumeAll>
}
    2034:	26 96       	adiw	r28, 0x06	; 6
    2036:	0f b6       	in	r0, 0x3f	; 63
    2038:	f8 94       	cli
    203a:	de bf       	out	0x3e, r29	; 62
    203c:	0f be       	out	0x3f, r0	; 63
    203e:	cd bf       	out	0x3d, r28	; 61
    2040:	cf 91       	pop	r28
    2042:	df 91       	pop	r29
    2044:	08 95       	ret

00002046 <vEventGroupSetBitsCallback>:

/* For internal use only - execute a 'set bits' command that was pended from
 * an interrupt. */
void vEventGroupSetBitsCallback( void * pvEventGroup,
                                 const uint32_t ulBitsToSet )
{
    2046:	df 93       	push	r29
    2048:	cf 93       	push	r28
    204a:	00 d0       	rcall	.+0      	; 0x204c <vEventGroupSetBitsCallback+0x6>
    204c:	00 d0       	rcall	.+0      	; 0x204e <vEventGroupSetBitsCallback+0x8>
    204e:	00 d0       	rcall	.+0      	; 0x2050 <vEventGroupSetBitsCallback+0xa>
    2050:	cd b7       	in	r28, 0x3d	; 61
    2052:	de b7       	in	r29, 0x3e	; 62
    2054:	9a 83       	std	Y+2, r25	; 0x02
    2056:	89 83       	std	Y+1, r24	; 0x01
    2058:	4b 83       	std	Y+3, r20	; 0x03
    205a:	5c 83       	std	Y+4, r21	; 0x04
    205c:	6d 83       	std	Y+5, r22	; 0x05
    205e:	7e 83       	std	Y+6, r23	; 0x06
    ( void ) xEventGroupSetBits( pvEventGroup, ( EventBits_t ) ulBitsToSet ); /*lint !e9079 Can't avoid cast to void* as a generic timer callback prototype. Callback casts back to original type so safe. */
    2060:	89 81       	ldd	r24, Y+1	; 0x01
    2062:	9a 81       	ldd	r25, Y+2	; 0x02
    2064:	2b 81       	ldd	r18, Y+3	; 0x03
    2066:	3c 81       	ldd	r19, Y+4	; 0x04
    2068:	b9 01       	movw	r22, r18
    206a:	0e 94 40 0f 	call	0x1e80	; 0x1e80 <xEventGroupSetBits>
}
    206e:	26 96       	adiw	r28, 0x06	; 6
    2070:	0f b6       	in	r0, 0x3f	; 63
    2072:	f8 94       	cli
    2074:	de bf       	out	0x3e, r29	; 62
    2076:	0f be       	out	0x3f, r0	; 63
    2078:	cd bf       	out	0x3d, r28	; 61
    207a:	cf 91       	pop	r28
    207c:	df 91       	pop	r29
    207e:	08 95       	ret

00002080 <vEventGroupClearBitsCallback>:

/* For internal use only - execute a 'clear bits' command that was pended from
 * an interrupt. */
void vEventGroupClearBitsCallback( void * pvEventGroup,
                                   const uint32_t ulBitsToClear )
{
    2080:	df 93       	push	r29
    2082:	cf 93       	push	r28
    2084:	00 d0       	rcall	.+0      	; 0x2086 <vEventGroupClearBitsCallback+0x6>
    2086:	00 d0       	rcall	.+0      	; 0x2088 <vEventGroupClearBitsCallback+0x8>
    2088:	00 d0       	rcall	.+0      	; 0x208a <vEventGroupClearBitsCallback+0xa>
    208a:	cd b7       	in	r28, 0x3d	; 61
    208c:	de b7       	in	r29, 0x3e	; 62
    208e:	9a 83       	std	Y+2, r25	; 0x02
    2090:	89 83       	std	Y+1, r24	; 0x01
    2092:	4b 83       	std	Y+3, r20	; 0x03
    2094:	5c 83       	std	Y+4, r21	; 0x04
    2096:	6d 83       	std	Y+5, r22	; 0x05
    2098:	7e 83       	std	Y+6, r23	; 0x06
    ( void ) xEventGroupClearBits( pvEventGroup, ( EventBits_t ) ulBitsToClear ); /*lint !e9079 Can't avoid cast to void* as a generic timer callback prototype. Callback casts back to original type so safe. */
    209a:	89 81       	ldd	r24, Y+1	; 0x01
    209c:	9a 81       	ldd	r25, Y+2	; 0x02
    209e:	2b 81       	ldd	r18, Y+3	; 0x03
    20a0:	3c 81       	ldd	r19, Y+4	; 0x04
    20a2:	b9 01       	movw	r22, r18
    20a4:	0e 94 e8 0e 	call	0x1dd0	; 0x1dd0 <xEventGroupClearBits>
}
    20a8:	26 96       	adiw	r28, 0x06	; 6
    20aa:	0f b6       	in	r0, 0x3f	; 63
    20ac:	f8 94       	cli
    20ae:	de bf       	out	0x3e, r29	; 62
    20b0:	0f be       	out	0x3f, r0	; 63
    20b2:	cd bf       	out	0x3d, r28	; 61
    20b4:	cf 91       	pop	r28
    20b6:	df 91       	pop	r29
    20b8:	08 95       	ret

000020ba <prvTestWaitCondition>:
/*-----------------------------------------------------------*/

static BaseType_t prvTestWaitCondition( const EventBits_t uxCurrentEventBits,
                                        const EventBits_t uxBitsToWaitFor,
                                        const BaseType_t xWaitForAllBits )
{
    20ba:	df 93       	push	r29
    20bc:	cf 93       	push	r28
    20be:	00 d0       	rcall	.+0      	; 0x20c0 <prvTestWaitCondition+0x6>
    20c0:	00 d0       	rcall	.+0      	; 0x20c2 <prvTestWaitCondition+0x8>
    20c2:	00 d0       	rcall	.+0      	; 0x20c4 <prvTestWaitCondition+0xa>
    20c4:	cd b7       	in	r28, 0x3d	; 61
    20c6:	de b7       	in	r29, 0x3e	; 62
    20c8:	9b 83       	std	Y+3, r25	; 0x03
    20ca:	8a 83       	std	Y+2, r24	; 0x02
    20cc:	7d 83       	std	Y+5, r23	; 0x05
    20ce:	6c 83       	std	Y+4, r22	; 0x04
    20d0:	4e 83       	std	Y+6, r20	; 0x06
    BaseType_t xWaitConditionMet = pdFALSE;
    20d2:	19 82       	std	Y+1, r1	; 0x01

    if( xWaitForAllBits == pdFALSE )
    20d4:	8e 81       	ldd	r24, Y+6	; 0x06
    20d6:	88 23       	and	r24, r24
    20d8:	59 f4       	brne	.+22     	; 0x20f0 <prvTestWaitCondition+0x36>
    {
        /* Task only has to wait for one bit within uxBitsToWaitFor to be
         * set.  Is one already set? */
        if( ( uxCurrentEventBits & uxBitsToWaitFor ) != ( EventBits_t ) 0 )
    20da:	8a 81       	ldd	r24, Y+2	; 0x02
    20dc:	9b 81       	ldd	r25, Y+3	; 0x03
    20de:	2c 81       	ldd	r18, Y+4	; 0x04
    20e0:	3d 81       	ldd	r19, Y+5	; 0x05
    20e2:	82 23       	and	r24, r18
    20e4:	93 23       	and	r25, r19
    20e6:	00 97       	sbiw	r24, 0x00	; 0
    20e8:	81 f0       	breq	.+32     	; 0x210a <prvTestWaitCondition+0x50>
        {
            xWaitConditionMet = pdTRUE;
    20ea:	81 e0       	ldi	r24, 0x01	; 1
    20ec:	89 83       	std	Y+1, r24	; 0x01
    20ee:	0d c0       	rjmp	.+26     	; 0x210a <prvTestWaitCondition+0x50>
    }
    else
    {
        /* Task has to wait for all the bits in uxBitsToWaitFor to be set.
         * Are they set already? */
        if( ( uxCurrentEventBits & uxBitsToWaitFor ) == uxBitsToWaitFor )
    20f0:	2a 81       	ldd	r18, Y+2	; 0x02
    20f2:	3b 81       	ldd	r19, Y+3	; 0x03
    20f4:	8c 81       	ldd	r24, Y+4	; 0x04
    20f6:	9d 81       	ldd	r25, Y+5	; 0x05
    20f8:	28 23       	and	r18, r24
    20fa:	39 23       	and	r19, r25
    20fc:	8c 81       	ldd	r24, Y+4	; 0x04
    20fe:	9d 81       	ldd	r25, Y+5	; 0x05
    2100:	28 17       	cp	r18, r24
    2102:	39 07       	cpc	r19, r25
    2104:	11 f4       	brne	.+4      	; 0x210a <prvTestWaitCondition+0x50>
        {
            xWaitConditionMet = pdTRUE;
    2106:	81 e0       	ldi	r24, 0x01	; 1
    2108:	89 83       	std	Y+1, r24	; 0x01
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }

    return xWaitConditionMet;
    210a:	89 81       	ldd	r24, Y+1	; 0x01
}
    210c:	26 96       	adiw	r28, 0x06	; 6
    210e:	0f b6       	in	r0, 0x3f	; 63
    2110:	f8 94       	cli
    2112:	de bf       	out	0x3e, r29	; 62
    2114:	0f be       	out	0x3f, r0	; 63
    2116:	cd bf       	out	0x3d, r28	; 61
    2118:	cf 91       	pop	r28
    211a:	df 91       	pop	r29
    211c:	08 95       	ret

0000211e <vListInitialise>:
/*-----------------------------------------------------------
* PUBLIC LIST API documented in list.h
*----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
    211e:	df 93       	push	r29
    2120:	cf 93       	push	r28
    2122:	00 d0       	rcall	.+0      	; 0x2124 <vListInitialise+0x6>
    2124:	cd b7       	in	r28, 0x3d	; 61
    2126:	de b7       	in	r29, 0x3e	; 62
    2128:	9a 83       	std	Y+2, r25	; 0x02
    212a:	89 83       	std	Y+1, r24	; 0x01
    /* The list structure contains a list item which is used to mark the
     * end of the list.  To initialise the list the list end is inserted
     * as the only list entry. */
    pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    212c:	89 81       	ldd	r24, Y+1	; 0x01
    212e:	9a 81       	ldd	r25, Y+2	; 0x02
    2130:	03 96       	adiw	r24, 0x03	; 3
    2132:	e9 81       	ldd	r30, Y+1	; 0x01
    2134:	fa 81       	ldd	r31, Y+2	; 0x02
    2136:	92 83       	std	Z+2, r25	; 0x02
    2138:	81 83       	std	Z+1, r24	; 0x01

    /* The list end value is the highest possible value in the list to
     * ensure it remains at the end of the list. */
    pxList->xListEnd.xItemValue = portMAX_DELAY;
    213a:	e9 81       	ldd	r30, Y+1	; 0x01
    213c:	fa 81       	ldd	r31, Y+2	; 0x02
    213e:	8f ef       	ldi	r24, 0xFF	; 255
    2140:	9f ef       	ldi	r25, 0xFF	; 255
    2142:	94 83       	std	Z+4, r25	; 0x04
    2144:	83 83       	std	Z+3, r24	; 0x03

    /* The list end next and previous pointers point to itself so we know
     * when the list is empty. */
    pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );     /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    2146:	89 81       	ldd	r24, Y+1	; 0x01
    2148:	9a 81       	ldd	r25, Y+2	; 0x02
    214a:	03 96       	adiw	r24, 0x03	; 3
    214c:	e9 81       	ldd	r30, Y+1	; 0x01
    214e:	fa 81       	ldd	r31, Y+2	; 0x02
    2150:	96 83       	std	Z+6, r25	; 0x06
    2152:	85 83       	std	Z+5, r24	; 0x05
    pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    2154:	89 81       	ldd	r24, Y+1	; 0x01
    2156:	9a 81       	ldd	r25, Y+2	; 0x02
    2158:	03 96       	adiw	r24, 0x03	; 3
    215a:	e9 81       	ldd	r30, Y+1	; 0x01
    215c:	fa 81       	ldd	r31, Y+2	; 0x02
    215e:	90 87       	std	Z+8, r25	; 0x08
    2160:	87 83       	std	Z+7, r24	; 0x07

    pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    2162:	e9 81       	ldd	r30, Y+1	; 0x01
    2164:	fa 81       	ldd	r31, Y+2	; 0x02
    2166:	10 82       	st	Z, r1

    /* Write known values into the list if
     * configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
    listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
    listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
    2168:	0f 90       	pop	r0
    216a:	0f 90       	pop	r0
    216c:	cf 91       	pop	r28
    216e:	df 91       	pop	r29
    2170:	08 95       	ret

00002172 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
    2172:	df 93       	push	r29
    2174:	cf 93       	push	r28
    2176:	00 d0       	rcall	.+0      	; 0x2178 <vListInitialiseItem+0x6>
    2178:	cd b7       	in	r28, 0x3d	; 61
    217a:	de b7       	in	r29, 0x3e	; 62
    217c:	9a 83       	std	Y+2, r25	; 0x02
    217e:	89 83       	std	Y+1, r24	; 0x01
    /* Make sure the list item is not recorded as being on a list. */
    pxItem->pxContainer = NULL;
    2180:	e9 81       	ldd	r30, Y+1	; 0x01
    2182:	fa 81       	ldd	r31, Y+2	; 0x02
    2184:	11 86       	std	Z+9, r1	; 0x09
    2186:	10 86       	std	Z+8, r1	; 0x08

    /* Write known values into the list item if
     * configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
    listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
    listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
    2188:	0f 90       	pop	r0
    218a:	0f 90       	pop	r0
    218c:	cf 91       	pop	r28
    218e:	df 91       	pop	r29
    2190:	08 95       	ret

00002192 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList,
                     ListItem_t * const pxNewListItem )
{
    2192:	df 93       	push	r29
    2194:	cf 93       	push	r28
    2196:	00 d0       	rcall	.+0      	; 0x2198 <vListInsertEnd+0x6>
    2198:	00 d0       	rcall	.+0      	; 0x219a <vListInsertEnd+0x8>
    219a:	00 d0       	rcall	.+0      	; 0x219c <vListInsertEnd+0xa>
    219c:	cd b7       	in	r28, 0x3d	; 61
    219e:	de b7       	in	r29, 0x3e	; 62
    21a0:	9c 83       	std	Y+4, r25	; 0x04
    21a2:	8b 83       	std	Y+3, r24	; 0x03
    21a4:	7e 83       	std	Y+6, r23	; 0x06
    21a6:	6d 83       	std	Y+5, r22	; 0x05
    ListItem_t * const pxIndex = pxList->pxIndex;
    21a8:	eb 81       	ldd	r30, Y+3	; 0x03
    21aa:	fc 81       	ldd	r31, Y+4	; 0x04
    21ac:	81 81       	ldd	r24, Z+1	; 0x01
    21ae:	92 81       	ldd	r25, Z+2	; 0x02
    21b0:	9a 83       	std	Y+2, r25	; 0x02
    21b2:	89 83       	std	Y+1, r24	; 0x01
    listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

    /* Insert a new list item into pxList, but rather than sort the list,
     * makes the new list item the last item to be removed by a call to
     * listGET_OWNER_OF_NEXT_ENTRY(). */
    pxNewListItem->pxNext = pxIndex;
    21b4:	ed 81       	ldd	r30, Y+5	; 0x05
    21b6:	fe 81       	ldd	r31, Y+6	; 0x06
    21b8:	89 81       	ldd	r24, Y+1	; 0x01
    21ba:	9a 81       	ldd	r25, Y+2	; 0x02
    21bc:	93 83       	std	Z+3, r25	; 0x03
    21be:	82 83       	std	Z+2, r24	; 0x02
    pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    21c0:	e9 81       	ldd	r30, Y+1	; 0x01
    21c2:	fa 81       	ldd	r31, Y+2	; 0x02
    21c4:	84 81       	ldd	r24, Z+4	; 0x04
    21c6:	95 81       	ldd	r25, Z+5	; 0x05
    21c8:	ed 81       	ldd	r30, Y+5	; 0x05
    21ca:	fe 81       	ldd	r31, Y+6	; 0x06
    21cc:	95 83       	std	Z+5, r25	; 0x05
    21ce:	84 83       	std	Z+4, r24	; 0x04

    /* Only used during decision coverage testing. */
    mtCOVERAGE_TEST_DELAY();

    pxIndex->pxPrevious->pxNext = pxNewListItem;
    21d0:	e9 81       	ldd	r30, Y+1	; 0x01
    21d2:	fa 81       	ldd	r31, Y+2	; 0x02
    21d4:	04 80       	ldd	r0, Z+4	; 0x04
    21d6:	f5 81       	ldd	r31, Z+5	; 0x05
    21d8:	e0 2d       	mov	r30, r0
    21da:	8d 81       	ldd	r24, Y+5	; 0x05
    21dc:	9e 81       	ldd	r25, Y+6	; 0x06
    21de:	93 83       	std	Z+3, r25	; 0x03
    21e0:	82 83       	std	Z+2, r24	; 0x02
    pxIndex->pxPrevious = pxNewListItem;
    21e2:	e9 81       	ldd	r30, Y+1	; 0x01
    21e4:	fa 81       	ldd	r31, Y+2	; 0x02
    21e6:	8d 81       	ldd	r24, Y+5	; 0x05
    21e8:	9e 81       	ldd	r25, Y+6	; 0x06
    21ea:	95 83       	std	Z+5, r25	; 0x05
    21ec:	84 83       	std	Z+4, r24	; 0x04

    /* Remember which list the item is in. */
    pxNewListItem->pxContainer = pxList;
    21ee:	ed 81       	ldd	r30, Y+5	; 0x05
    21f0:	fe 81       	ldd	r31, Y+6	; 0x06
    21f2:	8b 81       	ldd	r24, Y+3	; 0x03
    21f4:	9c 81       	ldd	r25, Y+4	; 0x04
    21f6:	91 87       	std	Z+9, r25	; 0x09
    21f8:	80 87       	std	Z+8, r24	; 0x08

    ( pxList->uxNumberOfItems )++;
    21fa:	eb 81       	ldd	r30, Y+3	; 0x03
    21fc:	fc 81       	ldd	r31, Y+4	; 0x04
    21fe:	80 81       	ld	r24, Z
    2200:	8f 5f       	subi	r24, 0xFF	; 255
    2202:	eb 81       	ldd	r30, Y+3	; 0x03
    2204:	fc 81       	ldd	r31, Y+4	; 0x04
    2206:	80 83       	st	Z, r24
}
    2208:	26 96       	adiw	r28, 0x06	; 6
    220a:	0f b6       	in	r0, 0x3f	; 63
    220c:	f8 94       	cli
    220e:	de bf       	out	0x3e, r29	; 62
    2210:	0f be       	out	0x3f, r0	; 63
    2212:	cd bf       	out	0x3d, r28	; 61
    2214:	cf 91       	pop	r28
    2216:	df 91       	pop	r29
    2218:	08 95       	ret

0000221a <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList,
                  ListItem_t * const pxNewListItem )
{
    221a:	df 93       	push	r29
    221c:	cf 93       	push	r28
    221e:	cd b7       	in	r28, 0x3d	; 61
    2220:	de b7       	in	r29, 0x3e	; 62
    2222:	28 97       	sbiw	r28, 0x08	; 8
    2224:	0f b6       	in	r0, 0x3f	; 63
    2226:	f8 94       	cli
    2228:	de bf       	out	0x3e, r29	; 62
    222a:	0f be       	out	0x3f, r0	; 63
    222c:	cd bf       	out	0x3d, r28	; 61
    222e:	9e 83       	std	Y+6, r25	; 0x06
    2230:	8d 83       	std	Y+5, r24	; 0x05
    2232:	78 87       	std	Y+8, r23	; 0x08
    2234:	6f 83       	std	Y+7, r22	; 0x07
    ListItem_t * pxIterator;
    const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    2236:	ef 81       	ldd	r30, Y+7	; 0x07
    2238:	f8 85       	ldd	r31, Y+8	; 0x08
    223a:	80 81       	ld	r24, Z
    223c:	91 81       	ldd	r25, Z+1	; 0x01
    223e:	9a 83       	std	Y+2, r25	; 0x02
    2240:	89 83       	std	Y+1, r24	; 0x01
     * new list item should be placed after it.  This ensures that TCBs which are
     * stored in ready lists (all of which have the same xItemValue value) get a
     * share of the CPU.  However, if the xItemValue is the same as the back marker
     * the iteration loop below will not end.  Therefore the value is checked
     * first, and the algorithm slightly modified if necessary. */
    if( xValueOfInsertion == portMAX_DELAY )
    2242:	89 81       	ldd	r24, Y+1	; 0x01
    2244:	9a 81       	ldd	r25, Y+2	; 0x02
    2246:	2f ef       	ldi	r18, 0xFF	; 255
    2248:	8f 3f       	cpi	r24, 0xFF	; 255
    224a:	92 07       	cpc	r25, r18
    224c:	39 f4       	brne	.+14     	; 0x225c <vListInsert+0x42>
    {
        pxIterator = pxList->xListEnd.pxPrevious;
    224e:	ed 81       	ldd	r30, Y+5	; 0x05
    2250:	fe 81       	ldd	r31, Y+6	; 0x06
    2252:	87 81       	ldd	r24, Z+7	; 0x07
    2254:	90 85       	ldd	r25, Z+8	; 0x08
    2256:	9c 83       	std	Y+4, r25	; 0x04
    2258:	8b 83       	std	Y+3, r24	; 0x03
    225a:	18 c0       	rjmp	.+48     	; 0x228c <vListInsert+0x72>
        *   5) If the FreeRTOS port supports interrupt nesting then ensure that
        *      the priority of the tick interrupt is at or below
        *      configMAX_SYSCALL_INTERRUPT_PRIORITY.
        **********************************************************************/

        for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
    225c:	8d 81       	ldd	r24, Y+5	; 0x05
    225e:	9e 81       	ldd	r25, Y+6	; 0x06
    2260:	03 96       	adiw	r24, 0x03	; 3
    2262:	9c 83       	std	Y+4, r25	; 0x04
    2264:	8b 83       	std	Y+3, r24	; 0x03
    2266:	06 c0       	rjmp	.+12     	; 0x2274 <vListInsert+0x5a>
    2268:	eb 81       	ldd	r30, Y+3	; 0x03
    226a:	fc 81       	ldd	r31, Y+4	; 0x04
    226c:	82 81       	ldd	r24, Z+2	; 0x02
    226e:	93 81       	ldd	r25, Z+3	; 0x03
    2270:	9c 83       	std	Y+4, r25	; 0x04
    2272:	8b 83       	std	Y+3, r24	; 0x03
    2274:	eb 81       	ldd	r30, Y+3	; 0x03
    2276:	fc 81       	ldd	r31, Y+4	; 0x04
    2278:	02 80       	ldd	r0, Z+2	; 0x02
    227a:	f3 81       	ldd	r31, Z+3	; 0x03
    227c:	e0 2d       	mov	r30, r0
    227e:	20 81       	ld	r18, Z
    2280:	31 81       	ldd	r19, Z+1	; 0x01
    2282:	89 81       	ldd	r24, Y+1	; 0x01
    2284:	9a 81       	ldd	r25, Y+2	; 0x02
    2286:	82 17       	cp	r24, r18
    2288:	93 07       	cpc	r25, r19
    228a:	70 f7       	brcc	.-36     	; 0x2268 <vListInsert+0x4e>
            /* There is nothing to do here, just iterating to the wanted
             * insertion position. */
        }
    }

    pxNewListItem->pxNext = pxIterator->pxNext;
    228c:	eb 81       	ldd	r30, Y+3	; 0x03
    228e:	fc 81       	ldd	r31, Y+4	; 0x04
    2290:	82 81       	ldd	r24, Z+2	; 0x02
    2292:	93 81       	ldd	r25, Z+3	; 0x03
    2294:	ef 81       	ldd	r30, Y+7	; 0x07
    2296:	f8 85       	ldd	r31, Y+8	; 0x08
    2298:	93 83       	std	Z+3, r25	; 0x03
    229a:	82 83       	std	Z+2, r24	; 0x02
    pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    229c:	ef 81       	ldd	r30, Y+7	; 0x07
    229e:	f8 85       	ldd	r31, Y+8	; 0x08
    22a0:	02 80       	ldd	r0, Z+2	; 0x02
    22a2:	f3 81       	ldd	r31, Z+3	; 0x03
    22a4:	e0 2d       	mov	r30, r0
    22a6:	8f 81       	ldd	r24, Y+7	; 0x07
    22a8:	98 85       	ldd	r25, Y+8	; 0x08
    22aa:	95 83       	std	Z+5, r25	; 0x05
    22ac:	84 83       	std	Z+4, r24	; 0x04
    pxNewListItem->pxPrevious = pxIterator;
    22ae:	ef 81       	ldd	r30, Y+7	; 0x07
    22b0:	f8 85       	ldd	r31, Y+8	; 0x08
    22b2:	8b 81       	ldd	r24, Y+3	; 0x03
    22b4:	9c 81       	ldd	r25, Y+4	; 0x04
    22b6:	95 83       	std	Z+5, r25	; 0x05
    22b8:	84 83       	std	Z+4, r24	; 0x04
    pxIterator->pxNext = pxNewListItem;
    22ba:	eb 81       	ldd	r30, Y+3	; 0x03
    22bc:	fc 81       	ldd	r31, Y+4	; 0x04
    22be:	8f 81       	ldd	r24, Y+7	; 0x07
    22c0:	98 85       	ldd	r25, Y+8	; 0x08
    22c2:	93 83       	std	Z+3, r25	; 0x03
    22c4:	82 83       	std	Z+2, r24	; 0x02

    /* Remember which list the item is in.  This allows fast removal of the
     * item later. */
    pxNewListItem->pxContainer = pxList;
    22c6:	ef 81       	ldd	r30, Y+7	; 0x07
    22c8:	f8 85       	ldd	r31, Y+8	; 0x08
    22ca:	8d 81       	ldd	r24, Y+5	; 0x05
    22cc:	9e 81       	ldd	r25, Y+6	; 0x06
    22ce:	91 87       	std	Z+9, r25	; 0x09
    22d0:	80 87       	std	Z+8, r24	; 0x08

    ( pxList->uxNumberOfItems )++;
    22d2:	ed 81       	ldd	r30, Y+5	; 0x05
    22d4:	fe 81       	ldd	r31, Y+6	; 0x06
    22d6:	80 81       	ld	r24, Z
    22d8:	8f 5f       	subi	r24, 0xFF	; 255
    22da:	ed 81       	ldd	r30, Y+5	; 0x05
    22dc:	fe 81       	ldd	r31, Y+6	; 0x06
    22de:	80 83       	st	Z, r24
}
    22e0:	28 96       	adiw	r28, 0x08	; 8
    22e2:	0f b6       	in	r0, 0x3f	; 63
    22e4:	f8 94       	cli
    22e6:	de bf       	out	0x3e, r29	; 62
    22e8:	0f be       	out	0x3f, r0	; 63
    22ea:	cd bf       	out	0x3d, r28	; 61
    22ec:	cf 91       	pop	r28
    22ee:	df 91       	pop	r29
    22f0:	08 95       	ret

000022f2 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    22f2:	df 93       	push	r29
    22f4:	cf 93       	push	r28
    22f6:	00 d0       	rcall	.+0      	; 0x22f8 <uxListRemove+0x6>
    22f8:	00 d0       	rcall	.+0      	; 0x22fa <uxListRemove+0x8>
    22fa:	cd b7       	in	r28, 0x3d	; 61
    22fc:	de b7       	in	r29, 0x3e	; 62
    22fe:	9c 83       	std	Y+4, r25	; 0x04
    2300:	8b 83       	std	Y+3, r24	; 0x03
/* The list item knows which list it is in.  Obtain the list from the list
 * item. */
    List_t * const pxList = pxItemToRemove->pxContainer;
    2302:	eb 81       	ldd	r30, Y+3	; 0x03
    2304:	fc 81       	ldd	r31, Y+4	; 0x04
    2306:	80 85       	ldd	r24, Z+8	; 0x08
    2308:	91 85       	ldd	r25, Z+9	; 0x09
    230a:	9a 83       	std	Y+2, r25	; 0x02
    230c:	89 83       	std	Y+1, r24	; 0x01

    pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    230e:	eb 81       	ldd	r30, Y+3	; 0x03
    2310:	fc 81       	ldd	r31, Y+4	; 0x04
    2312:	a2 81       	ldd	r26, Z+2	; 0x02
    2314:	b3 81       	ldd	r27, Z+3	; 0x03
    2316:	eb 81       	ldd	r30, Y+3	; 0x03
    2318:	fc 81       	ldd	r31, Y+4	; 0x04
    231a:	84 81       	ldd	r24, Z+4	; 0x04
    231c:	95 81       	ldd	r25, Z+5	; 0x05
    231e:	15 96       	adiw	r26, 0x05	; 5
    2320:	9c 93       	st	X, r25
    2322:	8e 93       	st	-X, r24
    2324:	14 97       	sbiw	r26, 0x04	; 4
    pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    2326:	eb 81       	ldd	r30, Y+3	; 0x03
    2328:	fc 81       	ldd	r31, Y+4	; 0x04
    232a:	a4 81       	ldd	r26, Z+4	; 0x04
    232c:	b5 81       	ldd	r27, Z+5	; 0x05
    232e:	eb 81       	ldd	r30, Y+3	; 0x03
    2330:	fc 81       	ldd	r31, Y+4	; 0x04
    2332:	82 81       	ldd	r24, Z+2	; 0x02
    2334:	93 81       	ldd	r25, Z+3	; 0x03
    2336:	13 96       	adiw	r26, 0x03	; 3
    2338:	9c 93       	st	X, r25
    233a:	8e 93       	st	-X, r24
    233c:	12 97       	sbiw	r26, 0x02	; 2

    /* Only used during decision coverage testing. */
    mtCOVERAGE_TEST_DELAY();

    /* Make sure the index is left pointing to a valid item. */
    if( pxList->pxIndex == pxItemToRemove )
    233e:	e9 81       	ldd	r30, Y+1	; 0x01
    2340:	fa 81       	ldd	r31, Y+2	; 0x02
    2342:	21 81       	ldd	r18, Z+1	; 0x01
    2344:	32 81       	ldd	r19, Z+2	; 0x02
    2346:	8b 81       	ldd	r24, Y+3	; 0x03
    2348:	9c 81       	ldd	r25, Y+4	; 0x04
    234a:	28 17       	cp	r18, r24
    234c:	39 07       	cpc	r19, r25
    234e:	41 f4       	brne	.+16     	; 0x2360 <uxListRemove+0x6e>
    {
        pxList->pxIndex = pxItemToRemove->pxPrevious;
    2350:	eb 81       	ldd	r30, Y+3	; 0x03
    2352:	fc 81       	ldd	r31, Y+4	; 0x04
    2354:	84 81       	ldd	r24, Z+4	; 0x04
    2356:	95 81       	ldd	r25, Z+5	; 0x05
    2358:	e9 81       	ldd	r30, Y+1	; 0x01
    235a:	fa 81       	ldd	r31, Y+2	; 0x02
    235c:	92 83       	std	Z+2, r25	; 0x02
    235e:	81 83       	std	Z+1, r24	; 0x01
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    pxItemToRemove->pxContainer = NULL;
    2360:	eb 81       	ldd	r30, Y+3	; 0x03
    2362:	fc 81       	ldd	r31, Y+4	; 0x04
    2364:	11 86       	std	Z+9, r1	; 0x09
    2366:	10 86       	std	Z+8, r1	; 0x08
    ( pxList->uxNumberOfItems )--;
    2368:	e9 81       	ldd	r30, Y+1	; 0x01
    236a:	fa 81       	ldd	r31, Y+2	; 0x02
    236c:	80 81       	ld	r24, Z
    236e:	81 50       	subi	r24, 0x01	; 1
    2370:	e9 81       	ldd	r30, Y+1	; 0x01
    2372:	fa 81       	ldd	r31, Y+2	; 0x02
    2374:	80 83       	st	Z, r24

    return pxList->uxNumberOfItems;
    2376:	e9 81       	ldd	r30, Y+1	; 0x01
    2378:	fa 81       	ldd	r31, Y+2	; 0x02
    237a:	80 81       	ld	r24, Z
}
    237c:	0f 90       	pop	r0
    237e:	0f 90       	pop	r0
    2380:	0f 90       	pop	r0
    2382:	0f 90       	pop	r0
    2384:	cf 91       	pop	r28
    2386:	df 91       	pop	r29
    2388:	08 95       	ret

0000238a <xQueueGenericReset>:
    taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue,
                               BaseType_t xNewQueue )
{
    238a:	df 93       	push	r29
    238c:	cf 93       	push	r28
    238e:	00 d0       	rcall	.+0      	; 0x2390 <xQueueGenericReset+0x6>
    2390:	00 d0       	rcall	.+0      	; 0x2392 <xQueueGenericReset+0x8>
    2392:	00 d0       	rcall	.+0      	; 0x2394 <xQueueGenericReset+0xa>
    2394:	cd b7       	in	r28, 0x3d	; 61
    2396:	de b7       	in	r29, 0x3e	; 62
    2398:	9d 83       	std	Y+5, r25	; 0x05
    239a:	8c 83       	std	Y+4, r24	; 0x04
    239c:	6e 83       	std	Y+6, r22	; 0x06
    BaseType_t xReturn = pdPASS;
    239e:	81 e0       	ldi	r24, 0x01	; 1
    23a0:	8b 83       	std	Y+3, r24	; 0x03
    Queue_t * const pxQueue = xQueue;
    23a2:	8c 81       	ldd	r24, Y+4	; 0x04
    23a4:	9d 81       	ldd	r25, Y+5	; 0x05
    23a6:	9a 83       	std	Y+2, r25	; 0x02
    23a8:	89 83       	std	Y+1, r24	; 0x01

    configASSERT( pxQueue );

    if( ( pxQueue != NULL ) &&
    23aa:	89 81       	ldd	r24, Y+1	; 0x01
    23ac:	9a 81       	ldd	r25, Y+2	; 0x02
    23ae:	00 97       	sbiw	r24, 0x00	; 0
    23b0:	09 f4       	brne	.+2      	; 0x23b4 <xQueueGenericReset+0x2a>
    23b2:	8b c0       	rjmp	.+278    	; 0x24ca <xQueueGenericReset+0x140>
    23b4:	e9 81       	ldd	r30, Y+1	; 0x01
    23b6:	fa 81       	ldd	r31, Y+2	; 0x02
    23b8:	83 8d       	ldd	r24, Z+27	; 0x1b
    23ba:	88 23       	and	r24, r24
    23bc:	09 f4       	brne	.+2      	; 0x23c0 <xQueueGenericReset+0x36>
    23be:	85 c0       	rjmp	.+266    	; 0x24ca <xQueueGenericReset+0x140>
    23c0:	e9 81       	ldd	r30, Y+1	; 0x01
    23c2:	fa 81       	ldd	r31, Y+2	; 0x02
    23c4:	83 8d       	ldd	r24, Z+27	; 0x1b
    23c6:	28 2f       	mov	r18, r24
    23c8:	30 e0       	ldi	r19, 0x00	; 0
    23ca:	8f ef       	ldi	r24, 0xFF	; 255
    23cc:	9f e7       	ldi	r25, 0x7F	; 127
    23ce:	b9 01       	movw	r22, r18
    23d0:	0e 94 ba 4a 	call	0x9574	; 0x9574 <__udivmodhi4>
    23d4:	cb 01       	movw	r24, r22
    23d6:	9c 01       	movw	r18, r24
    23d8:	e9 81       	ldd	r30, Y+1	; 0x01
    23da:	fa 81       	ldd	r31, Y+2	; 0x02
    23dc:	84 8d       	ldd	r24, Z+28	; 0x1c
    23de:	88 2f       	mov	r24, r24
    23e0:	90 e0       	ldi	r25, 0x00	; 0
    23e2:	28 17       	cp	r18, r24
    23e4:	39 07       	cpc	r19, r25
    23e6:	08 f4       	brcc	.+2      	; 0x23ea <xQueueGenericReset+0x60>
    23e8:	70 c0       	rjmp	.+224    	; 0x24ca <xQueueGenericReset+0x140>
        ( pxQueue->uxLength >= 1U ) &&
        /* Check for multiplication overflow. */
        ( ( SIZE_MAX / pxQueue->uxLength ) >= pxQueue->uxItemSize ) )
    {
        taskENTER_CRITICAL();
    23ea:	0f b6       	in	r0, 0x3f	; 63
    23ec:	f8 94       	cli
    23ee:	0f 92       	push	r0
        {
            pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    23f0:	e9 81       	ldd	r30, Y+1	; 0x01
    23f2:	fa 81       	ldd	r31, Y+2	; 0x02
    23f4:	40 81       	ld	r20, Z
    23f6:	51 81       	ldd	r21, Z+1	; 0x01
    23f8:	e9 81       	ldd	r30, Y+1	; 0x01
    23fa:	fa 81       	ldd	r31, Y+2	; 0x02
    23fc:	83 8d       	ldd	r24, Z+27	; 0x1b
    23fe:	28 2f       	mov	r18, r24
    2400:	30 e0       	ldi	r19, 0x00	; 0
    2402:	e9 81       	ldd	r30, Y+1	; 0x01
    2404:	fa 81       	ldd	r31, Y+2	; 0x02
    2406:	84 8d       	ldd	r24, Z+28	; 0x1c
    2408:	88 2f       	mov	r24, r24
    240a:	90 e0       	ldi	r25, 0x00	; 0
    240c:	bc 01       	movw	r22, r24
    240e:	26 9f       	mul	r18, r22
    2410:	c0 01       	movw	r24, r0
    2412:	27 9f       	mul	r18, r23
    2414:	90 0d       	add	r25, r0
    2416:	36 9f       	mul	r19, r22
    2418:	90 0d       	add	r25, r0
    241a:	11 24       	eor	r1, r1
    241c:	84 0f       	add	r24, r20
    241e:	95 1f       	adc	r25, r21
    2420:	e9 81       	ldd	r30, Y+1	; 0x01
    2422:	fa 81       	ldd	r31, Y+2	; 0x02
    2424:	95 83       	std	Z+5, r25	; 0x05
    2426:	84 83       	std	Z+4, r24	; 0x04
            pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    2428:	e9 81       	ldd	r30, Y+1	; 0x01
    242a:	fa 81       	ldd	r31, Y+2	; 0x02
    242c:	12 8e       	std	Z+26, r1	; 0x1a
            pxQueue->pcWriteTo = pxQueue->pcHead;
    242e:	e9 81       	ldd	r30, Y+1	; 0x01
    2430:	fa 81       	ldd	r31, Y+2	; 0x02
    2432:	80 81       	ld	r24, Z
    2434:	91 81       	ldd	r25, Z+1	; 0x01
    2436:	e9 81       	ldd	r30, Y+1	; 0x01
    2438:	fa 81       	ldd	r31, Y+2	; 0x02
    243a:	93 83       	std	Z+3, r25	; 0x03
    243c:	82 83       	std	Z+2, r24	; 0x02
            pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    243e:	e9 81       	ldd	r30, Y+1	; 0x01
    2440:	fa 81       	ldd	r31, Y+2	; 0x02
    2442:	40 81       	ld	r20, Z
    2444:	51 81       	ldd	r21, Z+1	; 0x01
    2446:	e9 81       	ldd	r30, Y+1	; 0x01
    2448:	fa 81       	ldd	r31, Y+2	; 0x02
    244a:	83 8d       	ldd	r24, Z+27	; 0x1b
    244c:	88 2f       	mov	r24, r24
    244e:	90 e0       	ldi	r25, 0x00	; 0
    2450:	9c 01       	movw	r18, r24
    2452:	21 50       	subi	r18, 0x01	; 1
    2454:	30 40       	sbci	r19, 0x00	; 0
    2456:	e9 81       	ldd	r30, Y+1	; 0x01
    2458:	fa 81       	ldd	r31, Y+2	; 0x02
    245a:	84 8d       	ldd	r24, Z+28	; 0x1c
    245c:	88 2f       	mov	r24, r24
    245e:	90 e0       	ldi	r25, 0x00	; 0
    2460:	bc 01       	movw	r22, r24
    2462:	26 9f       	mul	r18, r22
    2464:	c0 01       	movw	r24, r0
    2466:	27 9f       	mul	r18, r23
    2468:	90 0d       	add	r25, r0
    246a:	36 9f       	mul	r19, r22
    246c:	90 0d       	add	r25, r0
    246e:	11 24       	eor	r1, r1
    2470:	84 0f       	add	r24, r20
    2472:	95 1f       	adc	r25, r21
    2474:	e9 81       	ldd	r30, Y+1	; 0x01
    2476:	fa 81       	ldd	r31, Y+2	; 0x02
    2478:	97 83       	std	Z+7, r25	; 0x07
    247a:	86 83       	std	Z+6, r24	; 0x06
            pxQueue->cRxLock = queueUNLOCKED;
    247c:	e9 81       	ldd	r30, Y+1	; 0x01
    247e:	fa 81       	ldd	r31, Y+2	; 0x02
    2480:	8f ef       	ldi	r24, 0xFF	; 255
    2482:	85 8f       	std	Z+29, r24	; 0x1d
            pxQueue->cTxLock = queueUNLOCKED;
    2484:	e9 81       	ldd	r30, Y+1	; 0x01
    2486:	fa 81       	ldd	r31, Y+2	; 0x02
    2488:	8f ef       	ldi	r24, 0xFF	; 255
    248a:	86 8f       	std	Z+30, r24	; 0x1e

            if( xNewQueue == pdFALSE )
    248c:	8e 81       	ldd	r24, Y+6	; 0x06
    248e:	88 23       	and	r24, r24
    2490:	79 f4       	brne	.+30     	; 0x24b0 <xQueueGenericReset+0x126>
                /* If there are tasks blocked waiting to read from the queue, then
                 * the tasks will remain blocked as after this function exits the queue
                 * will still be empty.  If there are tasks blocked waiting to write to
                 * the queue, then one should be unblocked as after this function exits
                 * it will be possible to write to it. */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    2492:	e9 81       	ldd	r30, Y+1	; 0x01
    2494:	fa 81       	ldd	r31, Y+2	; 0x02
    2496:	80 85       	ldd	r24, Z+8	; 0x08
    2498:	88 23       	and	r24, r24
    249a:	a1 f0       	breq	.+40     	; 0x24c4 <xQueueGenericReset+0x13a>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    249c:	89 81       	ldd	r24, Y+1	; 0x01
    249e:	9a 81       	ldd	r25, Y+2	; 0x02
    24a0:	08 96       	adiw	r24, 0x08	; 8
    24a2:	0e 94 32 23 	call	0x4664	; 0x4664 <xTaskRemoveFromEventList>
    24a6:	88 23       	and	r24, r24
    24a8:	69 f0       	breq	.+26     	; 0x24c4 <xQueueGenericReset+0x13a>
                    {
                        queueYIELD_IF_USING_PREEMPTION();
    24aa:	0e 94 56 09 	call	0x12ac	; 0x12ac <vPortYield>
    24ae:	0a c0       	rjmp	.+20     	; 0x24c4 <xQueueGenericReset+0x13a>
                }
            }
            else
            {
                /* Ensure the event queues start in the correct state. */
                vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    24b0:	89 81       	ldd	r24, Y+1	; 0x01
    24b2:	9a 81       	ldd	r25, Y+2	; 0x02
    24b4:	08 96       	adiw	r24, 0x08	; 8
    24b6:	0e 94 8f 10 	call	0x211e	; 0x211e <vListInitialise>
                vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
    24ba:	89 81       	ldd	r24, Y+1	; 0x01
    24bc:	9a 81       	ldd	r25, Y+2	; 0x02
    24be:	41 96       	adiw	r24, 0x11	; 17
    24c0:	0e 94 8f 10 	call	0x211e	; 0x211e <vListInitialise>
            }
        }
        taskEXIT_CRITICAL();
    24c4:	0f 90       	pop	r0
    24c6:	0f be       	out	0x3f, r0	; 63
    24c8:	01 c0       	rjmp	.+2      	; 0x24cc <xQueueGenericReset+0x142>
    }
    else
    {
        xReturn = pdFAIL;
    24ca:	1b 82       	std	Y+3, r1	; 0x03

    configASSERT( xReturn != pdFAIL );

    /* A value is returned for calling semantic consistency with previous
     * versions. */
    return xReturn;
    24cc:	8b 81       	ldd	r24, Y+3	; 0x03
}
    24ce:	26 96       	adiw	r28, 0x06	; 6
    24d0:	0f b6       	in	r0, 0x3f	; 63
    24d2:	f8 94       	cli
    24d4:	de bf       	out	0x3e, r29	; 62
    24d6:	0f be       	out	0x3f, r0	; 63
    24d8:	cd bf       	out	0x3d, r28	; 61
    24da:	cf 91       	pop	r28
    24dc:	df 91       	pop	r29
    24de:	08 95       	ret

000024e0 <xQueueGenericCreate>:
#if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

    QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength,
                                       const UBaseType_t uxItemSize,
                                       const uint8_t ucQueueType )
    {
    24e0:	0f 93       	push	r16
    24e2:	1f 93       	push	r17
    24e4:	df 93       	push	r29
    24e6:	cf 93       	push	r28
    24e8:	cd b7       	in	r28, 0x3d	; 61
    24ea:	de b7       	in	r29, 0x3e	; 62
    24ec:	29 97       	sbiw	r28, 0x09	; 9
    24ee:	0f b6       	in	r0, 0x3f	; 63
    24f0:	f8 94       	cli
    24f2:	de bf       	out	0x3e, r29	; 62
    24f4:	0f be       	out	0x3f, r0	; 63
    24f6:	cd bf       	out	0x3d, r28	; 61
    24f8:	8f 83       	std	Y+7, r24	; 0x07
    24fa:	68 87       	std	Y+8, r22	; 0x08
    24fc:	49 87       	std	Y+9, r20	; 0x09
        Queue_t * pxNewQueue = NULL;
    24fe:	1e 82       	std	Y+6, r1	; 0x06
    2500:	1d 82       	std	Y+5, r1	; 0x05
        size_t xQueueSizeInBytes;
        uint8_t * pucQueueStorage;

        if( ( uxQueueLength > ( UBaseType_t ) 0 ) &&
    2502:	8f 81       	ldd	r24, Y+7	; 0x07
    2504:	88 23       	and	r24, r24
    2506:	09 f4       	brne	.+2      	; 0x250a <xQueueGenericCreate+0x2a>
    2508:	52 c0       	rjmp	.+164    	; 0x25ae <xQueueGenericCreate+0xce>
    250a:	8f 81       	ldd	r24, Y+7	; 0x07
    250c:	28 2f       	mov	r18, r24
    250e:	30 e0       	ldi	r19, 0x00	; 0
    2510:	8f ef       	ldi	r24, 0xFF	; 255
    2512:	9f e7       	ldi	r25, 0x7F	; 127
    2514:	b9 01       	movw	r22, r18
    2516:	0e 94 ba 4a 	call	0x9574	; 0x9574 <__udivmodhi4>
    251a:	cb 01       	movw	r24, r22
    251c:	9c 01       	movw	r18, r24
    251e:	88 85       	ldd	r24, Y+8	; 0x08
    2520:	88 2f       	mov	r24, r24
    2522:	90 e0       	ldi	r25, 0x00	; 0
    2524:	28 17       	cp	r18, r24
    2526:	39 07       	cpc	r19, r25
    2528:	08 f4       	brcc	.+2      	; 0x252c <xQueueGenericCreate+0x4c>
    252a:	41 c0       	rjmp	.+130    	; 0x25ae <xQueueGenericCreate+0xce>
    252c:	8f 81       	ldd	r24, Y+7	; 0x07
    252e:	28 2f       	mov	r18, r24
    2530:	30 e0       	ldi	r19, 0x00	; 0
    2532:	88 85       	ldd	r24, Y+8	; 0x08
    2534:	88 2f       	mov	r24, r24
    2536:	90 e0       	ldi	r25, 0x00	; 0
    2538:	ac 01       	movw	r20, r24
    253a:	24 9f       	mul	r18, r20
    253c:	c0 01       	movw	r24, r0
    253e:	25 9f       	mul	r18, r21
    2540:	90 0d       	add	r25, r0
    2542:	34 9f       	mul	r19, r20
    2544:	90 0d       	add	r25, r0
    2546:	11 24       	eor	r1, r1
    2548:	5f e7       	ldi	r21, 0x7F	; 127
    254a:	81 3e       	cpi	r24, 0xE1	; 225
    254c:	95 07       	cpc	r25, r21
    254e:	78 f5       	brcc	.+94     	; 0x25ae <xQueueGenericCreate+0xce>
            ( ( SIZE_MAX - sizeof( Queue_t ) ) >= ( uxQueueLength * uxItemSize ) ) )
        {
            /* Allocate enough space to hold the maximum number of items that
             * can be in the queue at any time.  It is valid for uxItemSize to be
             * zero in the case the queue is used as a semaphore. */
            xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    2550:	8f 81       	ldd	r24, Y+7	; 0x07
    2552:	28 2f       	mov	r18, r24
    2554:	30 e0       	ldi	r19, 0x00	; 0
    2556:	88 85       	ldd	r24, Y+8	; 0x08
    2558:	88 2f       	mov	r24, r24
    255a:	90 e0       	ldi	r25, 0x00	; 0
    255c:	ac 01       	movw	r20, r24
    255e:	24 9f       	mul	r18, r20
    2560:	c0 01       	movw	r24, r0
    2562:	25 9f       	mul	r18, r21
    2564:	90 0d       	add	r25, r0
    2566:	34 9f       	mul	r19, r20
    2568:	90 0d       	add	r25, r0
    256a:	11 24       	eor	r1, r1
    256c:	9c 83       	std	Y+4, r25	; 0x04
    256e:	8b 83       	std	Y+3, r24	; 0x03
             * alignment requirements of the Queue_t structure - which in this case
             * is an int8_t *.  Therefore, whenever the stack alignment requirements
             * are greater than or equal to the pointer to char requirements the cast
             * is safe.  In other cases alignment requirements are not strict (one or
             * two bytes). */
            pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !e9079 see comment above. */
    2570:	8b 81       	ldd	r24, Y+3	; 0x03
    2572:	9c 81       	ldd	r25, Y+4	; 0x04
    2574:	4f 96       	adiw	r24, 0x1f	; 31
    2576:	0e 94 17 07 	call	0xe2e	; 0xe2e <pvPortMalloc>
    257a:	9e 83       	std	Y+6, r25	; 0x06
    257c:	8d 83       	std	Y+5, r24	; 0x05

            if( pxNewQueue != NULL )
    257e:	8d 81       	ldd	r24, Y+5	; 0x05
    2580:	9e 81       	ldd	r25, Y+6	; 0x06
    2582:	00 97       	sbiw	r24, 0x00	; 0
    2584:	a1 f0       	breq	.+40     	; 0x25ae <xQueueGenericCreate+0xce>
            {
                /* Jump past the queue structure to find the location of the queue
                 * storage area. */
                pucQueueStorage = ( uint8_t * ) pxNewQueue;
    2586:	8d 81       	ldd	r24, Y+5	; 0x05
    2588:	9e 81       	ldd	r25, Y+6	; 0x06
    258a:	9a 83       	std	Y+2, r25	; 0x02
    258c:	89 83       	std	Y+1, r24	; 0x01
                pucQueueStorage += sizeof( Queue_t ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    258e:	89 81       	ldd	r24, Y+1	; 0x01
    2590:	9a 81       	ldd	r25, Y+2	; 0x02
    2592:	4f 96       	adiw	r24, 0x1f	; 31
    2594:	9a 83       	std	Y+2, r25	; 0x02
    2596:	89 83       	std	Y+1, r24	; 0x01
                         * deleted. */
                        pxNewQueue->ucStaticallyAllocated = pdFALSE;
                    }
                #endif /* configSUPPORT_STATIC_ALLOCATION */

                prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
    2598:	29 81       	ldd	r18, Y+1	; 0x01
    259a:	3a 81       	ldd	r19, Y+2	; 0x02
    259c:	ed 81       	ldd	r30, Y+5	; 0x05
    259e:	fe 81       	ldd	r31, Y+6	; 0x06
    25a0:	8f 81       	ldd	r24, Y+7	; 0x07
    25a2:	68 85       	ldd	r22, Y+8	; 0x08
    25a4:	a9 01       	movw	r20, r18
    25a6:	29 85       	ldd	r18, Y+9	; 0x09
    25a8:	8f 01       	movw	r16, r30
    25aa:	0e 94 e4 12 	call	0x25c8	; 0x25c8 <prvInitialiseNewQueue>
        {
            configASSERT( pxNewQueue );
            mtCOVERAGE_TEST_MARKER();
        }

        return pxNewQueue;
    25ae:	8d 81       	ldd	r24, Y+5	; 0x05
    25b0:	9e 81       	ldd	r25, Y+6	; 0x06
    }
    25b2:	29 96       	adiw	r28, 0x09	; 9
    25b4:	0f b6       	in	r0, 0x3f	; 63
    25b6:	f8 94       	cli
    25b8:	de bf       	out	0x3e, r29	; 62
    25ba:	0f be       	out	0x3f, r0	; 63
    25bc:	cd bf       	out	0x3d, r28	; 61
    25be:	cf 91       	pop	r28
    25c0:	df 91       	pop	r29
    25c2:	1f 91       	pop	r17
    25c4:	0f 91       	pop	r16
    25c6:	08 95       	ret

000025c8 <prvInitialiseNewQueue>:
static void prvInitialiseNewQueue( const UBaseType_t uxQueueLength,
                                   const UBaseType_t uxItemSize,
                                   uint8_t * pucQueueStorage,
                                   const uint8_t ucQueueType,
                                   Queue_t * pxNewQueue )
{
    25c8:	0f 93       	push	r16
    25ca:	1f 93       	push	r17
    25cc:	df 93       	push	r29
    25ce:	cf 93       	push	r28
    25d0:	cd b7       	in	r28, 0x3d	; 61
    25d2:	de b7       	in	r29, 0x3e	; 62
    25d4:	27 97       	sbiw	r28, 0x07	; 7
    25d6:	0f b6       	in	r0, 0x3f	; 63
    25d8:	f8 94       	cli
    25da:	de bf       	out	0x3e, r29	; 62
    25dc:	0f be       	out	0x3f, r0	; 63
    25de:	cd bf       	out	0x3d, r28	; 61
    25e0:	89 83       	std	Y+1, r24	; 0x01
    25e2:	6a 83       	std	Y+2, r22	; 0x02
    25e4:	5c 83       	std	Y+4, r21	; 0x04
    25e6:	4b 83       	std	Y+3, r20	; 0x03
    25e8:	2d 83       	std	Y+5, r18	; 0x05
    25ea:	1f 83       	std	Y+7, r17	; 0x07
    25ec:	0e 83       	std	Y+6, r16	; 0x06
    /* Remove compiler warnings about unused parameters should
     * configUSE_TRACE_FACILITY not be set to 1. */
    ( void ) ucQueueType;

    if( uxItemSize == ( UBaseType_t ) 0 )
    25ee:	8a 81       	ldd	r24, Y+2	; 0x02
    25f0:	88 23       	and	r24, r24
    25f2:	39 f4       	brne	.+14     	; 0x2602 <prvInitialiseNewQueue+0x3a>
    {
        /* No RAM was allocated for the queue storage area, but PC head cannot
         * be set to NULL because NULL is used as a key to say the queue is used as
         * a mutex.  Therefore just set pcHead to point to the queue as a benign
         * value that is known to be within the memory map. */
        pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
    25f4:	8e 81       	ldd	r24, Y+6	; 0x06
    25f6:	9f 81       	ldd	r25, Y+7	; 0x07
    25f8:	ee 81       	ldd	r30, Y+6	; 0x06
    25fa:	ff 81       	ldd	r31, Y+7	; 0x07
    25fc:	91 83       	std	Z+1, r25	; 0x01
    25fe:	80 83       	st	Z, r24
    2600:	06 c0       	rjmp	.+12     	; 0x260e <prvInitialiseNewQueue+0x46>
    }
    else
    {
        /* Set the head to the start of the queue storage area. */
        pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
    2602:	8b 81       	ldd	r24, Y+3	; 0x03
    2604:	9c 81       	ldd	r25, Y+4	; 0x04
    2606:	ee 81       	ldd	r30, Y+6	; 0x06
    2608:	ff 81       	ldd	r31, Y+7	; 0x07
    260a:	91 83       	std	Z+1, r25	; 0x01
    260c:	80 83       	st	Z, r24
    }

    /* Initialise the queue members as described where the queue type is
     * defined. */
    pxNewQueue->uxLength = uxQueueLength;
    260e:	ee 81       	ldd	r30, Y+6	; 0x06
    2610:	ff 81       	ldd	r31, Y+7	; 0x07
    2612:	89 81       	ldd	r24, Y+1	; 0x01
    2614:	83 8f       	std	Z+27, r24	; 0x1b
    pxNewQueue->uxItemSize = uxItemSize;
    2616:	ee 81       	ldd	r30, Y+6	; 0x06
    2618:	ff 81       	ldd	r31, Y+7	; 0x07
    261a:	8a 81       	ldd	r24, Y+2	; 0x02
    261c:	84 8f       	std	Z+28, r24	; 0x1c
    ( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
    261e:	8e 81       	ldd	r24, Y+6	; 0x06
    2620:	9f 81       	ldd	r25, Y+7	; 0x07
    2622:	61 e0       	ldi	r22, 0x01	; 1
    2624:	0e 94 c5 11 	call	0x238a	; 0x238a <xQueueGenericReset>
            pxNewQueue->pxQueueSetContainer = NULL;
        }
    #endif /* configUSE_QUEUE_SETS */

    traceQUEUE_CREATE( pxNewQueue );
}
    2628:	27 96       	adiw	r28, 0x07	; 7
    262a:	0f b6       	in	r0, 0x3f	; 63
    262c:	f8 94       	cli
    262e:	de bf       	out	0x3e, r29	; 62
    2630:	0f be       	out	0x3f, r0	; 63
    2632:	cd bf       	out	0x3d, r28	; 61
    2634:	cf 91       	pop	r28
    2636:	df 91       	pop	r29
    2638:	1f 91       	pop	r17
    263a:	0f 91       	pop	r16
    263c:	08 95       	ret

0000263e <xQueueGenericSend>:

BaseType_t xQueueGenericSend( QueueHandle_t xQueue,
                              const void * const pvItemToQueue,
                              TickType_t xTicksToWait,
                              const BaseType_t xCopyPosition )
{
    263e:	df 93       	push	r29
    2640:	cf 93       	push	r28
    2642:	cd b7       	in	r28, 0x3d	; 61
    2644:	de b7       	in	r29, 0x3e	; 62
    2646:	2f 97       	sbiw	r28, 0x0f	; 15
    2648:	0f b6       	in	r0, 0x3f	; 63
    264a:	f8 94       	cli
    264c:	de bf       	out	0x3e, r29	; 62
    264e:	0f be       	out	0x3f, r0	; 63
    2650:	cd bf       	out	0x3d, r28	; 61
    2652:	99 87       	std	Y+9, r25	; 0x09
    2654:	88 87       	std	Y+8, r24	; 0x08
    2656:	7b 87       	std	Y+11, r23	; 0x0b
    2658:	6a 87       	std	Y+10, r22	; 0x0a
    265a:	5d 87       	std	Y+13, r21	; 0x0d
    265c:	4c 87       	std	Y+12, r20	; 0x0c
    265e:	2e 87       	std	Y+14, r18	; 0x0e
    BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
    2660:	1c 82       	std	Y+4, r1	; 0x04
    TimeOut_t xTimeOut;
    Queue_t * const pxQueue = xQueue;
    2662:	88 85       	ldd	r24, Y+8	; 0x08
    2664:	99 85       	ldd	r25, Y+9	; 0x09
    2666:	9a 83       	std	Y+2, r25	; 0x02
    2668:	89 83       	std	Y+1, r24	; 0x01
    /*lint -save -e904 This function relaxes the coding standard somewhat to
     * allow return statements within the function itself.  This is done in the
     * interest of execution time efficiency. */
    for( ; ; )
    {
        taskENTER_CRITICAL();
    266a:	0f b6       	in	r0, 0x3f	; 63
    266c:	f8 94       	cli
    266e:	0f 92       	push	r0
        {
            /* Is there room on the queue now?  The running task must be the
             * highest priority task wanting to access the queue.  If the head item
             * in the queue is to be overwritten then it does not matter if the
             * queue is full. */
            if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    2670:	e9 81       	ldd	r30, Y+1	; 0x01
    2672:	fa 81       	ldd	r31, Y+2	; 0x02
    2674:	92 8d       	ldd	r25, Z+26	; 0x1a
    2676:	e9 81       	ldd	r30, Y+1	; 0x01
    2678:	fa 81       	ldd	r31, Y+2	; 0x02
    267a:	83 8d       	ldd	r24, Z+27	; 0x1b
    267c:	98 17       	cp	r25, r24
    267e:	18 f0       	brcs	.+6      	; 0x2686 <xQueueGenericSend+0x48>
    2680:	8e 85       	ldd	r24, Y+14	; 0x0e
    2682:	82 30       	cpi	r24, 0x02	; 2
    2684:	11 f5       	brne	.+68     	; 0x26ca <xQueueGenericSend+0x8c>
                            }
                        }
                    }
                #else /* configUSE_QUEUE_SETS */
                    {
                        xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    2686:	89 81       	ldd	r24, Y+1	; 0x01
    2688:	9a 81       	ldd	r25, Y+2	; 0x02
    268a:	2a 85       	ldd	r18, Y+10	; 0x0a
    268c:	3b 85       	ldd	r19, Y+11	; 0x0b
    268e:	b9 01       	movw	r22, r18
    2690:	4e 85       	ldd	r20, Y+14	; 0x0e
    2692:	0e 94 75 17 	call	0x2eea	; 0x2eea <prvCopyDataToQueue>
    2696:	8b 83       	std	Y+3, r24	; 0x03

                        /* If there was a task waiting for data to arrive on the
                         * queue then unblock it now. */
                        if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    2698:	e9 81       	ldd	r30, Y+1	; 0x01
    269a:	fa 81       	ldd	r31, Y+2	; 0x02
    269c:	81 89       	ldd	r24, Z+17	; 0x11
    269e:	88 23       	and	r24, r24
    26a0:	51 f0       	breq	.+20     	; 0x26b6 <xQueueGenericSend+0x78>
                        {
                            if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    26a2:	89 81       	ldd	r24, Y+1	; 0x01
    26a4:	9a 81       	ldd	r25, Y+2	; 0x02
    26a6:	41 96       	adiw	r24, 0x11	; 17
    26a8:	0e 94 32 23 	call	0x4664	; 0x4664 <xTaskRemoveFromEventList>
    26ac:	88 23       	and	r24, r24
    26ae:	41 f0       	breq	.+16     	; 0x26c0 <xQueueGenericSend+0x82>
                            {
                                /* The unblocked task has a priority higher than
                                 * our own so yield immediately.  Yes it is ok to do
                                 * this from within the critical section - the kernel
                                 * takes care of that. */
                                queueYIELD_IF_USING_PREEMPTION();
    26b0:	0e 94 56 09 	call	0x12ac	; 0x12ac <vPortYield>
    26b4:	05 c0       	rjmp	.+10     	; 0x26c0 <xQueueGenericSend+0x82>
                            else
                            {
                                mtCOVERAGE_TEST_MARKER();
                            }
                        }
                        else if( xYieldRequired != pdFALSE )
    26b6:	8b 81       	ldd	r24, Y+3	; 0x03
    26b8:	88 23       	and	r24, r24
    26ba:	11 f0       	breq	.+4      	; 0x26c0 <xQueueGenericSend+0x82>
                        {
                            /* This path is a special case that will only get
                             * executed if the task was holding multiple mutexes and
                             * the mutexes were given back in an order that is
                             * different to that in which they were taken. */
                            queueYIELD_IF_USING_PREEMPTION();
    26bc:	0e 94 56 09 	call	0x12ac	; 0x12ac <vPortYield>
                            mtCOVERAGE_TEST_MARKER();
                        }
                    }
                #endif /* configUSE_QUEUE_SETS */

                taskEXIT_CRITICAL();
    26c0:	0f 90       	pop	r0
    26c2:	0f be       	out	0x3f, r0	; 63
                return pdPASS;
    26c4:	81 e0       	ldi	r24, 0x01	; 1
    26c6:	8f 87       	std	Y+15, r24	; 0x0f
    26c8:	5c c0       	rjmp	.+184    	; 0x2782 <xQueueGenericSend+0x144>
            }
            else
            {
                if( xTicksToWait == ( TickType_t ) 0 )
    26ca:	8c 85       	ldd	r24, Y+12	; 0x0c
    26cc:	9d 85       	ldd	r25, Y+13	; 0x0d
    26ce:	00 97       	sbiw	r24, 0x00	; 0
    26d0:	21 f4       	brne	.+8      	; 0x26da <xQueueGenericSend+0x9c>
                {
                    /* The queue was full and no block time is specified (or
                     * the block time has expired) so leave now. */
                    taskEXIT_CRITICAL();
    26d2:	0f 90       	pop	r0
    26d4:	0f be       	out	0x3f, r0	; 63

                    /* Return to the original privilege level before exiting
                     * the function. */
                    traceQUEUE_SEND_FAILED( pxQueue );
                    return errQUEUE_FULL;
    26d6:	1f 86       	std	Y+15, r1	; 0x0f
    26d8:	54 c0       	rjmp	.+168    	; 0x2782 <xQueueGenericSend+0x144>
                }
                else if( xEntryTimeSet == pdFALSE )
    26da:	8c 81       	ldd	r24, Y+4	; 0x04
    26dc:	88 23       	and	r24, r24
    26de:	31 f4       	brne	.+12     	; 0x26ec <xQueueGenericSend+0xae>
                {
                    /* The queue was full and a block time was specified so
                     * configure the timeout structure. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
    26e0:	ce 01       	movw	r24, r28
    26e2:	05 96       	adiw	r24, 0x05	; 5
    26e4:	0e 94 a2 25 	call	0x4b44	; 0x4b44 <vTaskInternalSetTimeOutState>
                    xEntryTimeSet = pdTRUE;
    26e8:	81 e0       	ldi	r24, 0x01	; 1
    26ea:	8c 83       	std	Y+4, r24	; 0x04
                    /* Entry time was already set. */
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        taskEXIT_CRITICAL();
    26ec:	0f 90       	pop	r0
    26ee:	0f be       	out	0x3f, r0	; 63

        /* Interrupts and other tasks can send to and receive from the queue
         * now the critical section has been exited. */

        vTaskSuspendAll();
    26f0:	0e 94 6c 1e 	call	0x3cd8	; 0x3cd8 <vTaskSuspendAll>
        prvLockQueue( pxQueue );
    26f4:	0f b6       	in	r0, 0x3f	; 63
    26f6:	f8 94       	cli
    26f8:	0f 92       	push	r0
    26fa:	e9 81       	ldd	r30, Y+1	; 0x01
    26fc:	fa 81       	ldd	r31, Y+2	; 0x02
    26fe:	85 8d       	ldd	r24, Z+29	; 0x1d
    2700:	8f 3f       	cpi	r24, 0xFF	; 255
    2702:	19 f4       	brne	.+6      	; 0x270a <xQueueGenericSend+0xcc>
    2704:	e9 81       	ldd	r30, Y+1	; 0x01
    2706:	fa 81       	ldd	r31, Y+2	; 0x02
    2708:	15 8e       	std	Z+29, r1	; 0x1d
    270a:	e9 81       	ldd	r30, Y+1	; 0x01
    270c:	fa 81       	ldd	r31, Y+2	; 0x02
    270e:	86 8d       	ldd	r24, Z+30	; 0x1e
    2710:	8f 3f       	cpi	r24, 0xFF	; 255
    2712:	19 f4       	brne	.+6      	; 0x271a <xQueueGenericSend+0xdc>
    2714:	e9 81       	ldd	r30, Y+1	; 0x01
    2716:	fa 81       	ldd	r31, Y+2	; 0x02
    2718:	16 8e       	std	Z+30, r1	; 0x1e
    271a:	0f 90       	pop	r0
    271c:	0f be       	out	0x3f, r0	; 63

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    271e:	ce 01       	movw	r24, r28
    2720:	05 96       	adiw	r24, 0x05	; 5
    2722:	9e 01       	movw	r18, r28
    2724:	24 5f       	subi	r18, 0xF4	; 244
    2726:	3f 4f       	sbci	r19, 0xFF	; 255
    2728:	b9 01       	movw	r22, r18
    272a:	0e 94 bb 25 	call	0x4b76	; 0x4b76 <xTaskCheckForTimeOut>
    272e:	88 23       	and	r24, r24
    2730:	09 f5       	brne	.+66     	; 0x2774 <xQueueGenericSend+0x136>
        {
            if( prvIsQueueFull( pxQueue ) != pdFALSE )
    2732:	89 81       	ldd	r24, Y+1	; 0x01
    2734:	9a 81       	ldd	r25, Y+2	; 0x02
    2736:	0e 94 f1 18 	call	0x31e2	; 0x31e2 <prvIsQueueFull>
    273a:	88 23       	and	r24, r24
    273c:	a1 f0       	breq	.+40     	; 0x2766 <xQueueGenericSend+0x128>
            {
                traceBLOCKING_ON_QUEUE_SEND( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    273e:	89 81       	ldd	r24, Y+1	; 0x01
    2740:	9a 81       	ldd	r25, Y+2	; 0x02
    2742:	08 96       	adiw	r24, 0x08	; 8
    2744:	2c 85       	ldd	r18, Y+12	; 0x0c
    2746:	3d 85       	ldd	r19, Y+13	; 0x0d
    2748:	b9 01       	movw	r22, r18
    274a:	0e 94 49 22 	call	0x4492	; 0x4492 <vTaskPlaceOnEventList>
                /* Unlocking the queue means queue events can effect the
                 * event list. It is possible that interrupts occurring now
                 * remove this task from the event list again - but as the
                 * scheduler is suspended the task will go onto the pending
                 * ready list instead of the actual ready list. */
                prvUnlockQueue( pxQueue );
    274e:	89 81       	ldd	r24, Y+1	; 0x01
    2750:	9a 81       	ldd	r25, Y+2	; 0x02
    2752:	0e 94 62 18 	call	0x30c4	; 0x30c4 <prvUnlockQueue>
                /* Resuming the scheduler will move tasks from the pending
                 * ready list into the ready list - so it is feasible that this
                 * task is already in the ready list before it yields - in which
                 * case the yield will not cause a context switch unless there
                 * is also a higher priority task in the pending ready list. */
                if( xTaskResumeAll() == pdFALSE )
    2756:	0e 94 78 1e 	call	0x3cf0	; 0x3cf0 <xTaskResumeAll>
    275a:	88 23       	and	r24, r24
    275c:	09 f0       	breq	.+2      	; 0x2760 <xQueueGenericSend+0x122>
    275e:	85 cf       	rjmp	.-246    	; 0x266a <xQueueGenericSend+0x2c>
                {
                    portYIELD_WITHIN_API();
    2760:	0e 94 56 09 	call	0x12ac	; 0x12ac <vPortYield>
    2764:	82 cf       	rjmp	.-252    	; 0x266a <xQueueGenericSend+0x2c>
                }
            }
            else
            {
                /* Try again. */
                prvUnlockQueue( pxQueue );
    2766:	89 81       	ldd	r24, Y+1	; 0x01
    2768:	9a 81       	ldd	r25, Y+2	; 0x02
    276a:	0e 94 62 18 	call	0x30c4	; 0x30c4 <prvUnlockQueue>
                ( void ) xTaskResumeAll();
    276e:	0e 94 78 1e 	call	0x3cf0	; 0x3cf0 <xTaskResumeAll>
    2772:	7b cf       	rjmp	.-266    	; 0x266a <xQueueGenericSend+0x2c>
            }
        }
        else
        {
            /* The timeout has expired. */
            prvUnlockQueue( pxQueue );
    2774:	89 81       	ldd	r24, Y+1	; 0x01
    2776:	9a 81       	ldd	r25, Y+2	; 0x02
    2778:	0e 94 62 18 	call	0x30c4	; 0x30c4 <prvUnlockQueue>
            ( void ) xTaskResumeAll();
    277c:	0e 94 78 1e 	call	0x3cf0	; 0x3cf0 <xTaskResumeAll>

            traceQUEUE_SEND_FAILED( pxQueue );
            return errQUEUE_FULL;
    2780:	1f 86       	std	Y+15, r1	; 0x0f
    2782:	8f 85       	ldd	r24, Y+15	; 0x0f
        }
    } /*lint -restore */
}
    2784:	2f 96       	adiw	r28, 0x0f	; 15
    2786:	0f b6       	in	r0, 0x3f	; 63
    2788:	f8 94       	cli
    278a:	de bf       	out	0x3e, r29	; 62
    278c:	0f be       	out	0x3f, r0	; 63
    278e:	cd bf       	out	0x3d, r28	; 61
    2790:	cf 91       	pop	r28
    2792:	df 91       	pop	r29
    2794:	08 95       	ret

00002796 <xQueueGenericSendFromISR>:

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue,
                                     const void * const pvItemToQueue,
                                     BaseType_t * const pxHigherPriorityTaskWoken,
                                     const BaseType_t xCopyPosition )
{
    2796:	df 93       	push	r29
    2798:	cf 93       	push	r28
    279a:	cd b7       	in	r28, 0x3d	; 61
    279c:	de b7       	in	r29, 0x3e	; 62
    279e:	2d 97       	sbiw	r28, 0x0d	; 13
    27a0:	0f b6       	in	r0, 0x3f	; 63
    27a2:	f8 94       	cli
    27a4:	de bf       	out	0x3e, r29	; 62
    27a6:	0f be       	out	0x3f, r0	; 63
    27a8:	cd bf       	out	0x3d, r28	; 61
    27aa:	98 87       	std	Y+8, r25	; 0x08
    27ac:	8f 83       	std	Y+7, r24	; 0x07
    27ae:	7a 87       	std	Y+10, r23	; 0x0a
    27b0:	69 87       	std	Y+9, r22	; 0x09
    27b2:	5c 87       	std	Y+12, r21	; 0x0c
    27b4:	4b 87       	std	Y+11, r20	; 0x0b
    27b6:	2d 87       	std	Y+13, r18	; 0x0d
    BaseType_t xReturn;
    UBaseType_t uxSavedInterruptStatus;
    Queue_t * const pxQueue = xQueue;
    27b8:	8f 81       	ldd	r24, Y+7	; 0x07
    27ba:	98 85       	ldd	r25, Y+8	; 0x08
    27bc:	9c 83       	std	Y+4, r25	; 0x04
    27be:	8b 83       	std	Y+3, r24	; 0x03
    /* Similar to xQueueGenericSend, except without blocking if there is no room
     * in the queue.  Also don't directly wake a task that was blocked on a queue
     * read, instead return a flag to say whether a context switch is required or
     * not (i.e. has a task with a higher priority than us been woken by this
     * post). */
    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    27c0:	1d 82       	std	Y+5, r1	; 0x05
    {
        if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    27c2:	eb 81       	ldd	r30, Y+3	; 0x03
    27c4:	fc 81       	ldd	r31, Y+4	; 0x04
    27c6:	92 8d       	ldd	r25, Z+26	; 0x1a
    27c8:	eb 81       	ldd	r30, Y+3	; 0x03
    27ca:	fc 81       	ldd	r31, Y+4	; 0x04
    27cc:	83 8d       	ldd	r24, Z+27	; 0x1b
    27ce:	98 17       	cp	r25, r24
    27d0:	18 f0       	brcs	.+6      	; 0x27d8 <xQueueGenericSendFromISR+0x42>
    27d2:	8d 85       	ldd	r24, Y+13	; 0x0d
    27d4:	82 30       	cpi	r24, 0x02	; 2
    27d6:	81 f5       	brne	.+96     	; 0x2838 <xQueueGenericSendFromISR+0xa2>
        {
            const int8_t cTxLock = pxQueue->cTxLock;
    27d8:	eb 81       	ldd	r30, Y+3	; 0x03
    27da:	fc 81       	ldd	r31, Y+4	; 0x04
    27dc:	86 8d       	ldd	r24, Z+30	; 0x1e
    27de:	8a 83       	std	Y+2, r24	; 0x02
            const UBaseType_t uxPreviousMessagesWaiting = pxQueue->uxMessagesWaiting;
    27e0:	eb 81       	ldd	r30, Y+3	; 0x03
    27e2:	fc 81       	ldd	r31, Y+4	; 0x04
    27e4:	82 8d       	ldd	r24, Z+26	; 0x1a
    27e6:	89 83       	std	Y+1, r24	; 0x01
            /* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
             *  semaphore or mutex.  That means prvCopyDataToQueue() cannot result
             *  in a task disinheriting a priority and prvCopyDataToQueue() can be
             *  called here even though the disinherit function does not check if
             *  the scheduler is suspended before accessing the ready lists. */
            ( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    27e8:	8b 81       	ldd	r24, Y+3	; 0x03
    27ea:	9c 81       	ldd	r25, Y+4	; 0x04
    27ec:	29 85       	ldd	r18, Y+9	; 0x09
    27ee:	3a 85       	ldd	r19, Y+10	; 0x0a
    27f0:	b9 01       	movw	r22, r18
    27f2:	4d 85       	ldd	r20, Y+13	; 0x0d
    27f4:	0e 94 75 17 	call	0x2eea	; 0x2eea <prvCopyDataToQueue>

            /* The event list is not altered if the queue is locked.  This will
             * be done when the queue is unlocked later. */
            if( cTxLock == queueUNLOCKED )
    27f8:	8a 81       	ldd	r24, Y+2	; 0x02
    27fa:	8f 3f       	cpi	r24, 0xFF	; 255
    27fc:	a9 f4       	brne	.+42     	; 0x2828 <xQueueGenericSendFromISR+0x92>
                            }
                        }
                    }
                #else /* configUSE_QUEUE_SETS */
                    {
                        if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    27fe:	eb 81       	ldd	r30, Y+3	; 0x03
    2800:	fc 81       	ldd	r31, Y+4	; 0x04
    2802:	81 89       	ldd	r24, Z+17	; 0x11
    2804:	88 23       	and	r24, r24
    2806:	a9 f0       	breq	.+42     	; 0x2832 <xQueueGenericSendFromISR+0x9c>
                        {
                            if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    2808:	8b 81       	ldd	r24, Y+3	; 0x03
    280a:	9c 81       	ldd	r25, Y+4	; 0x04
    280c:	41 96       	adiw	r24, 0x11	; 17
    280e:	0e 94 32 23 	call	0x4664	; 0x4664 <xTaskRemoveFromEventList>
    2812:	88 23       	and	r24, r24
    2814:	71 f0       	breq	.+28     	; 0x2832 <xQueueGenericSendFromISR+0x9c>
                            {
                                /* The task waiting has a higher priority so record that a
                                 * context switch is required. */
                                if( pxHigherPriorityTaskWoken != NULL )
    2816:	8b 85       	ldd	r24, Y+11	; 0x0b
    2818:	9c 85       	ldd	r25, Y+12	; 0x0c
    281a:	00 97       	sbiw	r24, 0x00	; 0
    281c:	51 f0       	breq	.+20     	; 0x2832 <xQueueGenericSendFromISR+0x9c>
                                {
                                    *pxHigherPriorityTaskWoken = pdTRUE;
    281e:	eb 85       	ldd	r30, Y+11	; 0x0b
    2820:	fc 85       	ldd	r31, Y+12	; 0x0c
    2822:	81 e0       	ldi	r24, 0x01	; 1
    2824:	80 83       	st	Z, r24
    2826:	05 c0       	rjmp	.+10     	; 0x2832 <xQueueGenericSendFromISR+0x9c>
            {
                /* Increment the lock count so the task that unlocks the queue
                 * knows that data was posted while it was locked. */
                configASSERT( cTxLock != queueINT8_MAX );

                pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    2828:	8a 81       	ldd	r24, Y+2	; 0x02
    282a:	8f 5f       	subi	r24, 0xFF	; 255
    282c:	eb 81       	ldd	r30, Y+3	; 0x03
    282e:	fc 81       	ldd	r31, Y+4	; 0x04
    2830:	86 8f       	std	Z+30, r24	; 0x1e
            }

            xReturn = pdPASS;
    2832:	81 e0       	ldi	r24, 0x01	; 1
    2834:	8e 83       	std	Y+6, r24	; 0x06
    2836:	01 c0       	rjmp	.+2      	; 0x283a <xQueueGenericSendFromISR+0xa4>
        }
        else
        {
            traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
            xReturn = errQUEUE_FULL;
    2838:	1e 82       	std	Y+6, r1	; 0x06
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
    283a:	8e 81       	ldd	r24, Y+6	; 0x06
}
    283c:	2d 96       	adiw	r28, 0x0d	; 13
    283e:	0f b6       	in	r0, 0x3f	; 63
    2840:	f8 94       	cli
    2842:	de bf       	out	0x3e, r29	; 62
    2844:	0f be       	out	0x3f, r0	; 63
    2846:	cd bf       	out	0x3d, r28	; 61
    2848:	cf 91       	pop	r28
    284a:	df 91       	pop	r29
    284c:	08 95       	ret

0000284e <xQueueGiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue,
                              BaseType_t * const pxHigherPriorityTaskWoken )
{
    284e:	df 93       	push	r29
    2850:	cf 93       	push	r28
    2852:	cd b7       	in	r28, 0x3d	; 61
    2854:	de b7       	in	r29, 0x3e	; 62
    2856:	2a 97       	sbiw	r28, 0x0a	; 10
    2858:	0f b6       	in	r0, 0x3f	; 63
    285a:	f8 94       	cli
    285c:	de bf       	out	0x3e, r29	; 62
    285e:	0f be       	out	0x3f, r0	; 63
    2860:	cd bf       	out	0x3d, r28	; 61
    2862:	98 87       	std	Y+8, r25	; 0x08
    2864:	8f 83       	std	Y+7, r24	; 0x07
    2866:	7a 87       	std	Y+10, r23	; 0x0a
    2868:	69 87       	std	Y+9, r22	; 0x09
    BaseType_t xReturn;
    UBaseType_t uxSavedInterruptStatus;
    Queue_t * const pxQueue = xQueue;
    286a:	8f 81       	ldd	r24, Y+7	; 0x07
    286c:	98 85       	ldd	r25, Y+8	; 0x08
    286e:	9c 83       	std	Y+4, r25	; 0x04
    2870:	8b 83       	std	Y+3, r24	; 0x03
     * safe API to ensure interrupt entry is as fast and as simple as possible.
     * More information (albeit Cortex-M specific) is provided on the following
     * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    2872:	1d 82       	std	Y+5, r1	; 0x05
    {
        const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    2874:	eb 81       	ldd	r30, Y+3	; 0x03
    2876:	fc 81       	ldd	r31, Y+4	; 0x04
    2878:	82 8d       	ldd	r24, Z+26	; 0x1a
    287a:	8a 83       	std	Y+2, r24	; 0x02

        /* When the queue is used to implement a semaphore no data is ever
         * moved through the queue but it is still valid to see if the queue 'has
         * space'. */
        if( uxMessagesWaiting < pxQueue->uxLength )
    287c:	eb 81       	ldd	r30, Y+3	; 0x03
    287e:	fc 81       	ldd	r31, Y+4	; 0x04
    2880:	93 8d       	ldd	r25, Z+27	; 0x1b
    2882:	8a 81       	ldd	r24, Y+2	; 0x02
    2884:	89 17       	cp	r24, r25
    2886:	48 f5       	brcc	.+82     	; 0x28da <xQueueGiveFromISR+0x8c>
        {
            const int8_t cTxLock = pxQueue->cTxLock;
    2888:	eb 81       	ldd	r30, Y+3	; 0x03
    288a:	fc 81       	ldd	r31, Y+4	; 0x04
    288c:	86 8d       	ldd	r24, Z+30	; 0x1e
    288e:	89 83       	std	Y+1, r24	; 0x01
             * holder - and if there is a mutex holder then the mutex cannot be
             * given from an ISR.  As this is the ISR version of the function it
             * can be assumed there is no mutex holder and no need to determine if
             * priority disinheritance is needed.  Simply increase the count of
             * messages (semaphores) available. */
            pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
    2890:	8a 81       	ldd	r24, Y+2	; 0x02
    2892:	8f 5f       	subi	r24, 0xFF	; 255
    2894:	eb 81       	ldd	r30, Y+3	; 0x03
    2896:	fc 81       	ldd	r31, Y+4	; 0x04
    2898:	82 8f       	std	Z+26, r24	; 0x1a

            /* The event list is not altered if the queue is locked.  This will
             * be done when the queue is unlocked later. */
            if( cTxLock == queueUNLOCKED )
    289a:	89 81       	ldd	r24, Y+1	; 0x01
    289c:	8f 3f       	cpi	r24, 0xFF	; 255
    289e:	a9 f4       	brne	.+42     	; 0x28ca <xQueueGiveFromISR+0x7c>
                            }
                        }
                    }
                #else /* configUSE_QUEUE_SETS */
                    {
                        if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    28a0:	eb 81       	ldd	r30, Y+3	; 0x03
    28a2:	fc 81       	ldd	r31, Y+4	; 0x04
    28a4:	81 89       	ldd	r24, Z+17	; 0x11
    28a6:	88 23       	and	r24, r24
    28a8:	a9 f0       	breq	.+42     	; 0x28d4 <xQueueGiveFromISR+0x86>
                        {
                            if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    28aa:	8b 81       	ldd	r24, Y+3	; 0x03
    28ac:	9c 81       	ldd	r25, Y+4	; 0x04
    28ae:	41 96       	adiw	r24, 0x11	; 17
    28b0:	0e 94 32 23 	call	0x4664	; 0x4664 <xTaskRemoveFromEventList>
    28b4:	88 23       	and	r24, r24
    28b6:	71 f0       	breq	.+28     	; 0x28d4 <xQueueGiveFromISR+0x86>
                            {
                                /* The task waiting has a higher priority so record that a
                                 * context switch is required. */
                                if( pxHigherPriorityTaskWoken != NULL )
    28b8:	89 85       	ldd	r24, Y+9	; 0x09
    28ba:	9a 85       	ldd	r25, Y+10	; 0x0a
    28bc:	00 97       	sbiw	r24, 0x00	; 0
    28be:	51 f0       	breq	.+20     	; 0x28d4 <xQueueGiveFromISR+0x86>
                                {
                                    *pxHigherPriorityTaskWoken = pdTRUE;
    28c0:	e9 85       	ldd	r30, Y+9	; 0x09
    28c2:	fa 85       	ldd	r31, Y+10	; 0x0a
    28c4:	81 e0       	ldi	r24, 0x01	; 1
    28c6:	80 83       	st	Z, r24
    28c8:	05 c0       	rjmp	.+10     	; 0x28d4 <xQueueGiveFromISR+0x86>
            {
                /* Increment the lock count so the task that unlocks the queue
                 * knows that data was posted while it was locked. */
                configASSERT( cTxLock != queueINT8_MAX );

                pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    28ca:	89 81       	ldd	r24, Y+1	; 0x01
    28cc:	8f 5f       	subi	r24, 0xFF	; 255
    28ce:	eb 81       	ldd	r30, Y+3	; 0x03
    28d0:	fc 81       	ldd	r31, Y+4	; 0x04
    28d2:	86 8f       	std	Z+30, r24	; 0x1e
            }

            xReturn = pdPASS;
    28d4:	81 e0       	ldi	r24, 0x01	; 1
    28d6:	8e 83       	std	Y+6, r24	; 0x06
    28d8:	01 c0       	rjmp	.+2      	; 0x28dc <xQueueGiveFromISR+0x8e>
        }
        else
        {
            traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
            xReturn = errQUEUE_FULL;
    28da:	1e 82       	std	Y+6, r1	; 0x06
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
    28dc:	8e 81       	ldd	r24, Y+6	; 0x06
}
    28de:	2a 96       	adiw	r28, 0x0a	; 10
    28e0:	0f b6       	in	r0, 0x3f	; 63
    28e2:	f8 94       	cli
    28e4:	de bf       	out	0x3e, r29	; 62
    28e6:	0f be       	out	0x3f, r0	; 63
    28e8:	cd bf       	out	0x3d, r28	; 61
    28ea:	cf 91       	pop	r28
    28ec:	df 91       	pop	r29
    28ee:	08 95       	ret

000028f0 <xQueueReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceive( QueueHandle_t xQueue,
                          void * const pvBuffer,
                          TickType_t xTicksToWait )
{
    28f0:	df 93       	push	r29
    28f2:	cf 93       	push	r28
    28f4:	cd b7       	in	r28, 0x3d	; 61
    28f6:	de b7       	in	r29, 0x3e	; 62
    28f8:	2e 97       	sbiw	r28, 0x0e	; 14
    28fa:	0f b6       	in	r0, 0x3f	; 63
    28fc:	f8 94       	cli
    28fe:	de bf       	out	0x3e, r29	; 62
    2900:	0f be       	out	0x3f, r0	; 63
    2902:	cd bf       	out	0x3d, r28	; 61
    2904:	99 87       	std	Y+9, r25	; 0x09
    2906:	88 87       	std	Y+8, r24	; 0x08
    2908:	7b 87       	std	Y+11, r23	; 0x0b
    290a:	6a 87       	std	Y+10, r22	; 0x0a
    290c:	5d 87       	std	Y+13, r21	; 0x0d
    290e:	4c 87       	std	Y+12, r20	; 0x0c
    BaseType_t xEntryTimeSet = pdFALSE;
    2910:	1c 82       	std	Y+4, r1	; 0x04
    TimeOut_t xTimeOut;
    Queue_t * const pxQueue = xQueue;
    2912:	88 85       	ldd	r24, Y+8	; 0x08
    2914:	99 85       	ldd	r25, Y+9	; 0x09
    2916:	9b 83       	std	Y+3, r25	; 0x03
    2918:	8a 83       	std	Y+2, r24	; 0x02
    /*lint -save -e904  This function relaxes the coding standard somewhat to
     * allow return statements within the function itself.  This is done in the
     * interest of execution time efficiency. */
    for( ; ; )
    {
        taskENTER_CRITICAL();
    291a:	0f b6       	in	r0, 0x3f	; 63
    291c:	f8 94       	cli
    291e:	0f 92       	push	r0
        {
            const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    2920:	ea 81       	ldd	r30, Y+2	; 0x02
    2922:	fb 81       	ldd	r31, Y+3	; 0x03
    2924:	82 8d       	ldd	r24, Z+26	; 0x1a
    2926:	89 83       	std	Y+1, r24	; 0x01

            /* Is there data in the queue now?  To be running the calling task
             * must be the highest priority task wanting to access the queue. */
            if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    2928:	89 81       	ldd	r24, Y+1	; 0x01
    292a:	88 23       	and	r24, r24
    292c:	f9 f0       	breq	.+62     	; 0x296c <xQueueReceive+0x7c>
            {
                /* Data available, remove one item. */
                prvCopyDataFromQueue( pxQueue, pvBuffer );
    292e:	8a 81       	ldd	r24, Y+2	; 0x02
    2930:	9b 81       	ldd	r25, Y+3	; 0x03
    2932:	2a 85       	ldd	r18, Y+10	; 0x0a
    2934:	3b 85       	ldd	r19, Y+11	; 0x0b
    2936:	b9 01       	movw	r22, r18
    2938:	0e 94 1b 18 	call	0x3036	; 0x3036 <prvCopyDataFromQueue>
                traceQUEUE_RECEIVE( pxQueue );
                pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
    293c:	89 81       	ldd	r24, Y+1	; 0x01
    293e:	81 50       	subi	r24, 0x01	; 1
    2940:	ea 81       	ldd	r30, Y+2	; 0x02
    2942:	fb 81       	ldd	r31, Y+3	; 0x03
    2944:	82 8f       	std	Z+26, r24	; 0x1a

                /* There is now space in the queue, were any tasks waiting to
                 * post to the queue?  If so, unblock the highest priority waiting
                 * task. */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    2946:	ea 81       	ldd	r30, Y+2	; 0x02
    2948:	fb 81       	ldd	r31, Y+3	; 0x03
    294a:	80 85       	ldd	r24, Z+8	; 0x08
    294c:	88 23       	and	r24, r24
    294e:	49 f0       	breq	.+18     	; 0x2962 <xQueueReceive+0x72>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    2950:	8a 81       	ldd	r24, Y+2	; 0x02
    2952:	9b 81       	ldd	r25, Y+3	; 0x03
    2954:	08 96       	adiw	r24, 0x08	; 8
    2956:	0e 94 32 23 	call	0x4664	; 0x4664 <xTaskRemoveFromEventList>
    295a:	88 23       	and	r24, r24
    295c:	11 f0       	breq	.+4      	; 0x2962 <xQueueReceive+0x72>
                    {
                        queueYIELD_IF_USING_PREEMPTION();
    295e:	0e 94 56 09 	call	0x12ac	; 0x12ac <vPortYield>
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                taskEXIT_CRITICAL();
    2962:	0f 90       	pop	r0
    2964:	0f be       	out	0x3f, r0	; 63
                return pdPASS;
    2966:	81 e0       	ldi	r24, 0x01	; 1
    2968:	8e 87       	std	Y+14, r24	; 0x0e
    296a:	63 c0       	rjmp	.+198    	; 0x2a32 <xQueueReceive+0x142>
            }
            else
            {
                if( xTicksToWait == ( TickType_t ) 0 )
    296c:	8c 85       	ldd	r24, Y+12	; 0x0c
    296e:	9d 85       	ldd	r25, Y+13	; 0x0d
    2970:	00 97       	sbiw	r24, 0x00	; 0
    2972:	21 f4       	brne	.+8      	; 0x297c <xQueueReceive+0x8c>
                {
                    /* The queue was empty and no block time is specified (or
                     * the block time has expired) so leave now. */
                    taskEXIT_CRITICAL();
    2974:	0f 90       	pop	r0
    2976:	0f be       	out	0x3f, r0	; 63
                    traceQUEUE_RECEIVE_FAILED( pxQueue );
                    return errQUEUE_EMPTY;
    2978:	1e 86       	std	Y+14, r1	; 0x0e
    297a:	5b c0       	rjmp	.+182    	; 0x2a32 <xQueueReceive+0x142>
                }
                else if( xEntryTimeSet == pdFALSE )
    297c:	8c 81       	ldd	r24, Y+4	; 0x04
    297e:	88 23       	and	r24, r24
    2980:	31 f4       	brne	.+12     	; 0x298e <xQueueReceive+0x9e>
                {
                    /* The queue was empty and a block time was specified so
                     * configure the timeout structure. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
    2982:	ce 01       	movw	r24, r28
    2984:	05 96       	adiw	r24, 0x05	; 5
    2986:	0e 94 a2 25 	call	0x4b44	; 0x4b44 <vTaskInternalSetTimeOutState>
                    xEntryTimeSet = pdTRUE;
    298a:	81 e0       	ldi	r24, 0x01	; 1
    298c:	8c 83       	std	Y+4, r24	; 0x04
                    /* Entry time was already set. */
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        taskEXIT_CRITICAL();
    298e:	0f 90       	pop	r0
    2990:	0f be       	out	0x3f, r0	; 63

        /* Interrupts and other tasks can send to and receive from the queue
         * now the critical section has been exited. */

        vTaskSuspendAll();
    2992:	0e 94 6c 1e 	call	0x3cd8	; 0x3cd8 <vTaskSuspendAll>
        prvLockQueue( pxQueue );
    2996:	0f b6       	in	r0, 0x3f	; 63
    2998:	f8 94       	cli
    299a:	0f 92       	push	r0
    299c:	ea 81       	ldd	r30, Y+2	; 0x02
    299e:	fb 81       	ldd	r31, Y+3	; 0x03
    29a0:	85 8d       	ldd	r24, Z+29	; 0x1d
    29a2:	8f 3f       	cpi	r24, 0xFF	; 255
    29a4:	19 f4       	brne	.+6      	; 0x29ac <xQueueReceive+0xbc>
    29a6:	ea 81       	ldd	r30, Y+2	; 0x02
    29a8:	fb 81       	ldd	r31, Y+3	; 0x03
    29aa:	15 8e       	std	Z+29, r1	; 0x1d
    29ac:	ea 81       	ldd	r30, Y+2	; 0x02
    29ae:	fb 81       	ldd	r31, Y+3	; 0x03
    29b0:	86 8d       	ldd	r24, Z+30	; 0x1e
    29b2:	8f 3f       	cpi	r24, 0xFF	; 255
    29b4:	19 f4       	brne	.+6      	; 0x29bc <xQueueReceive+0xcc>
    29b6:	ea 81       	ldd	r30, Y+2	; 0x02
    29b8:	fb 81       	ldd	r31, Y+3	; 0x03
    29ba:	16 8e       	std	Z+30, r1	; 0x1e
    29bc:	0f 90       	pop	r0
    29be:	0f be       	out	0x3f, r0	; 63

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    29c0:	ce 01       	movw	r24, r28
    29c2:	05 96       	adiw	r24, 0x05	; 5
    29c4:	9e 01       	movw	r18, r28
    29c6:	24 5f       	subi	r18, 0xF4	; 244
    29c8:	3f 4f       	sbci	r19, 0xFF	; 255
    29ca:	b9 01       	movw	r22, r18
    29cc:	0e 94 bb 25 	call	0x4b76	; 0x4b76 <xTaskCheckForTimeOut>
    29d0:	88 23       	and	r24, r24
    29d2:	09 f5       	brne	.+66     	; 0x2a16 <xQueueReceive+0x126>
        {
            /* The timeout has not expired.  If the queue is still empty place
             * the task on the list of tasks waiting to receive from the queue. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    29d4:	8a 81       	ldd	r24, Y+2	; 0x02
    29d6:	9b 81       	ldd	r25, Y+3	; 0x03
    29d8:	0e 94 b5 18 	call	0x316a	; 0x316a <prvIsQueueEmpty>
    29dc:	88 23       	and	r24, r24
    29de:	a1 f0       	breq	.+40     	; 0x2a08 <xQueueReceive+0x118>
            {
                traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    29e0:	8a 81       	ldd	r24, Y+2	; 0x02
    29e2:	9b 81       	ldd	r25, Y+3	; 0x03
    29e4:	41 96       	adiw	r24, 0x11	; 17
    29e6:	2c 85       	ldd	r18, Y+12	; 0x0c
    29e8:	3d 85       	ldd	r19, Y+13	; 0x0d
    29ea:	b9 01       	movw	r22, r18
    29ec:	0e 94 49 22 	call	0x4492	; 0x4492 <vTaskPlaceOnEventList>
                prvUnlockQueue( pxQueue );
    29f0:	8a 81       	ldd	r24, Y+2	; 0x02
    29f2:	9b 81       	ldd	r25, Y+3	; 0x03
    29f4:	0e 94 62 18 	call	0x30c4	; 0x30c4 <prvUnlockQueue>

                if( xTaskResumeAll() == pdFALSE )
    29f8:	0e 94 78 1e 	call	0x3cf0	; 0x3cf0 <xTaskResumeAll>
    29fc:	88 23       	and	r24, r24
    29fe:	09 f0       	breq	.+2      	; 0x2a02 <xQueueReceive+0x112>
    2a00:	8c cf       	rjmp	.-232    	; 0x291a <xQueueReceive+0x2a>
                {
                    portYIELD_WITHIN_API();
    2a02:	0e 94 56 09 	call	0x12ac	; 0x12ac <vPortYield>
    2a06:	89 cf       	rjmp	.-238    	; 0x291a <xQueueReceive+0x2a>
            }
            else
            {
                /* The queue contains data again.  Loop back to try and read the
                 * data. */
                prvUnlockQueue( pxQueue );
    2a08:	8a 81       	ldd	r24, Y+2	; 0x02
    2a0a:	9b 81       	ldd	r25, Y+3	; 0x03
    2a0c:	0e 94 62 18 	call	0x30c4	; 0x30c4 <prvUnlockQueue>
                ( void ) xTaskResumeAll();
    2a10:	0e 94 78 1e 	call	0x3cf0	; 0x3cf0 <xTaskResumeAll>
    2a14:	82 cf       	rjmp	.-252    	; 0x291a <xQueueReceive+0x2a>
        }
        else
        {
            /* Timed out.  If there is no data in the queue exit, otherwise loop
             * back and attempt to read the data. */
            prvUnlockQueue( pxQueue );
    2a16:	8a 81       	ldd	r24, Y+2	; 0x02
    2a18:	9b 81       	ldd	r25, Y+3	; 0x03
    2a1a:	0e 94 62 18 	call	0x30c4	; 0x30c4 <prvUnlockQueue>
            ( void ) xTaskResumeAll();
    2a1e:	0e 94 78 1e 	call	0x3cf0	; 0x3cf0 <xTaskResumeAll>

            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    2a22:	8a 81       	ldd	r24, Y+2	; 0x02
    2a24:	9b 81       	ldd	r25, Y+3	; 0x03
    2a26:	0e 94 b5 18 	call	0x316a	; 0x316a <prvIsQueueEmpty>
    2a2a:	88 23       	and	r24, r24
    2a2c:	09 f4       	brne	.+2      	; 0x2a30 <xQueueReceive+0x140>
    2a2e:	75 cf       	rjmp	.-278    	; 0x291a <xQueueReceive+0x2a>
            {
                traceQUEUE_RECEIVE_FAILED( pxQueue );
                return errQUEUE_EMPTY;
    2a30:	1e 86       	std	Y+14, r1	; 0x0e
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
    } /*lint -restore */
    2a32:	8e 85       	ldd	r24, Y+14	; 0x0e
}
    2a34:	2e 96       	adiw	r28, 0x0e	; 14
    2a36:	0f b6       	in	r0, 0x3f	; 63
    2a38:	f8 94       	cli
    2a3a:	de bf       	out	0x3e, r29	; 62
    2a3c:	0f be       	out	0x3f, r0	; 63
    2a3e:	cd bf       	out	0x3d, r28	; 61
    2a40:	cf 91       	pop	r28
    2a42:	df 91       	pop	r29
    2a44:	08 95       	ret

00002a46 <xQueueSemaphoreTake>:
/*-----------------------------------------------------------*/

BaseType_t xQueueSemaphoreTake( QueueHandle_t xQueue,
                                TickType_t xTicksToWait )
{
    2a46:	df 93       	push	r29
    2a48:	cf 93       	push	r28
    2a4a:	cd b7       	in	r28, 0x3d	; 61
    2a4c:	de b7       	in	r29, 0x3e	; 62
    2a4e:	2c 97       	sbiw	r28, 0x0c	; 12
    2a50:	0f b6       	in	r0, 0x3f	; 63
    2a52:	f8 94       	cli
    2a54:	de bf       	out	0x3e, r29	; 62
    2a56:	0f be       	out	0x3f, r0	; 63
    2a58:	cd bf       	out	0x3d, r28	; 61
    2a5a:	99 87       	std	Y+9, r25	; 0x09
    2a5c:	88 87       	std	Y+8, r24	; 0x08
    2a5e:	7b 87       	std	Y+11, r23	; 0x0b
    2a60:	6a 87       	std	Y+10, r22	; 0x0a
    BaseType_t xEntryTimeSet = pdFALSE;
    2a62:	1c 82       	std	Y+4, r1	; 0x04
    TimeOut_t xTimeOut;
    Queue_t * const pxQueue = xQueue;
    2a64:	88 85       	ldd	r24, Y+8	; 0x08
    2a66:	99 85       	ldd	r25, Y+9	; 0x09
    2a68:	9b 83       	std	Y+3, r25	; 0x03
    2a6a:	8a 83       	std	Y+2, r24	; 0x02
    /*lint -save -e904 This function relaxes the coding standard somewhat to allow return
     * statements within the function itself.  This is done in the interest
     * of execution time efficiency. */
    for( ; ; )
    {
        taskENTER_CRITICAL();
    2a6c:	0f b6       	in	r0, 0x3f	; 63
    2a6e:	f8 94       	cli
    2a70:	0f 92       	push	r0
        {
            /* Semaphores are queues with an item size of 0, and where the
             * number of messages in the queue is the semaphore's count value. */
            const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;
    2a72:	ea 81       	ldd	r30, Y+2	; 0x02
    2a74:	fb 81       	ldd	r31, Y+3	; 0x03
    2a76:	82 8d       	ldd	r24, Z+26	; 0x1a
    2a78:	89 83       	std	Y+1, r24	; 0x01

            /* Is there data in the queue now?  To be running the calling task
             * must be the highest priority task wanting to access the queue. */
            if( uxSemaphoreCount > ( UBaseType_t ) 0 )
    2a7a:	89 81       	ldd	r24, Y+1	; 0x01
    2a7c:	88 23       	and	r24, r24
    2a7e:	c1 f0       	breq	.+48     	; 0x2ab0 <xQueueSemaphoreTake+0x6a>
            {
                traceQUEUE_RECEIVE( pxQueue );

                /* Semaphores are queues with a data size of zero and where the
                 * messages waiting is the semaphore's count.  Reduce the count. */
                pxQueue->uxMessagesWaiting = uxSemaphoreCount - ( UBaseType_t ) 1;
    2a80:	89 81       	ldd	r24, Y+1	; 0x01
    2a82:	81 50       	subi	r24, 0x01	; 1
    2a84:	ea 81       	ldd	r30, Y+2	; 0x02
    2a86:	fb 81       	ldd	r31, Y+3	; 0x03
    2a88:	82 8f       	std	Z+26, r24	; 0x1a
                    }
                #endif /* configUSE_MUTEXES */

                /* Check to see if other tasks are blocked waiting to give the
                 * semaphore, and if so, unblock the highest priority such task. */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    2a8a:	ea 81       	ldd	r30, Y+2	; 0x02
    2a8c:	fb 81       	ldd	r31, Y+3	; 0x03
    2a8e:	80 85       	ldd	r24, Z+8	; 0x08
    2a90:	88 23       	and	r24, r24
    2a92:	49 f0       	breq	.+18     	; 0x2aa6 <xQueueSemaphoreTake+0x60>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    2a94:	8a 81       	ldd	r24, Y+2	; 0x02
    2a96:	9b 81       	ldd	r25, Y+3	; 0x03
    2a98:	08 96       	adiw	r24, 0x08	; 8
    2a9a:	0e 94 32 23 	call	0x4664	; 0x4664 <xTaskRemoveFromEventList>
    2a9e:	88 23       	and	r24, r24
    2aa0:	11 f0       	breq	.+4      	; 0x2aa6 <xQueueSemaphoreTake+0x60>
                    {
                        queueYIELD_IF_USING_PREEMPTION();
    2aa2:	0e 94 56 09 	call	0x12ac	; 0x12ac <vPortYield>
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                taskEXIT_CRITICAL();
    2aa6:	0f 90       	pop	r0
    2aa8:	0f be       	out	0x3f, r0	; 63
                return pdPASS;
    2aaa:	81 e0       	ldi	r24, 0x01	; 1
    2aac:	8c 87       	std	Y+12, r24	; 0x0c
    2aae:	63 c0       	rjmp	.+198    	; 0x2b76 <xQueueSemaphoreTake+0x130>
            }
            else
            {
                if( xTicksToWait == ( TickType_t ) 0 )
    2ab0:	8a 85       	ldd	r24, Y+10	; 0x0a
    2ab2:	9b 85       	ldd	r25, Y+11	; 0x0b
    2ab4:	00 97       	sbiw	r24, 0x00	; 0
    2ab6:	21 f4       	brne	.+8      	; 0x2ac0 <xQueueSemaphoreTake+0x7a>
                        }
                    #endif /* configUSE_MUTEXES */

                    /* The semaphore count was 0 and no block time is specified
                     * (or the block time has expired) so exit now. */
                    taskEXIT_CRITICAL();
    2ab8:	0f 90       	pop	r0
    2aba:	0f be       	out	0x3f, r0	; 63
                    traceQUEUE_RECEIVE_FAILED( pxQueue );
                    return errQUEUE_EMPTY;
    2abc:	1c 86       	std	Y+12, r1	; 0x0c
    2abe:	5b c0       	rjmp	.+182    	; 0x2b76 <xQueueSemaphoreTake+0x130>
                }
                else if( xEntryTimeSet == pdFALSE )
    2ac0:	8c 81       	ldd	r24, Y+4	; 0x04
    2ac2:	88 23       	and	r24, r24
    2ac4:	31 f4       	brne	.+12     	; 0x2ad2 <xQueueSemaphoreTake+0x8c>
                {
                    /* The semaphore count was 0 and a block time was specified
                     * so configure the timeout structure ready to block. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
    2ac6:	ce 01       	movw	r24, r28
    2ac8:	05 96       	adiw	r24, 0x05	; 5
    2aca:	0e 94 a2 25 	call	0x4b44	; 0x4b44 <vTaskInternalSetTimeOutState>
                    xEntryTimeSet = pdTRUE;
    2ace:	81 e0       	ldi	r24, 0x01	; 1
    2ad0:	8c 83       	std	Y+4, r24	; 0x04
                    /* Entry time was already set. */
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        taskEXIT_CRITICAL();
    2ad2:	0f 90       	pop	r0
    2ad4:	0f be       	out	0x3f, r0	; 63

        /* Interrupts and other tasks can give to and take from the semaphore
         * now the critical section has been exited. */

        vTaskSuspendAll();
    2ad6:	0e 94 6c 1e 	call	0x3cd8	; 0x3cd8 <vTaskSuspendAll>
        prvLockQueue( pxQueue );
    2ada:	0f b6       	in	r0, 0x3f	; 63
    2adc:	f8 94       	cli
    2ade:	0f 92       	push	r0
    2ae0:	ea 81       	ldd	r30, Y+2	; 0x02
    2ae2:	fb 81       	ldd	r31, Y+3	; 0x03
    2ae4:	85 8d       	ldd	r24, Z+29	; 0x1d
    2ae6:	8f 3f       	cpi	r24, 0xFF	; 255
    2ae8:	19 f4       	brne	.+6      	; 0x2af0 <xQueueSemaphoreTake+0xaa>
    2aea:	ea 81       	ldd	r30, Y+2	; 0x02
    2aec:	fb 81       	ldd	r31, Y+3	; 0x03
    2aee:	15 8e       	std	Z+29, r1	; 0x1d
    2af0:	ea 81       	ldd	r30, Y+2	; 0x02
    2af2:	fb 81       	ldd	r31, Y+3	; 0x03
    2af4:	86 8d       	ldd	r24, Z+30	; 0x1e
    2af6:	8f 3f       	cpi	r24, 0xFF	; 255
    2af8:	19 f4       	brne	.+6      	; 0x2b00 <xQueueSemaphoreTake+0xba>
    2afa:	ea 81       	ldd	r30, Y+2	; 0x02
    2afc:	fb 81       	ldd	r31, Y+3	; 0x03
    2afe:	16 8e       	std	Z+30, r1	; 0x1e
    2b00:	0f 90       	pop	r0
    2b02:	0f be       	out	0x3f, r0	; 63

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    2b04:	ce 01       	movw	r24, r28
    2b06:	05 96       	adiw	r24, 0x05	; 5
    2b08:	9e 01       	movw	r18, r28
    2b0a:	26 5f       	subi	r18, 0xF6	; 246
    2b0c:	3f 4f       	sbci	r19, 0xFF	; 255
    2b0e:	b9 01       	movw	r22, r18
    2b10:	0e 94 bb 25 	call	0x4b76	; 0x4b76 <xTaskCheckForTimeOut>
    2b14:	88 23       	and	r24, r24
    2b16:	09 f5       	brne	.+66     	; 0x2b5a <xQueueSemaphoreTake+0x114>
        {
            /* A block time is specified and not expired.  If the semaphore
             * count is 0 then enter the Blocked state to wait for a semaphore to
             * become available.  As semaphores are implemented with queues the
             * queue being empty is equivalent to the semaphore count being 0. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    2b18:	8a 81       	ldd	r24, Y+2	; 0x02
    2b1a:	9b 81       	ldd	r25, Y+3	; 0x03
    2b1c:	0e 94 b5 18 	call	0x316a	; 0x316a <prvIsQueueEmpty>
    2b20:	88 23       	and	r24, r24
    2b22:	a1 f0       	breq	.+40     	; 0x2b4c <xQueueSemaphoreTake+0x106>
                            mtCOVERAGE_TEST_MARKER();
                        }
                    }
                #endif /* if ( configUSE_MUTEXES == 1 ) */

                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    2b24:	8a 81       	ldd	r24, Y+2	; 0x02
    2b26:	9b 81       	ldd	r25, Y+3	; 0x03
    2b28:	41 96       	adiw	r24, 0x11	; 17
    2b2a:	2a 85       	ldd	r18, Y+10	; 0x0a
    2b2c:	3b 85       	ldd	r19, Y+11	; 0x0b
    2b2e:	b9 01       	movw	r22, r18
    2b30:	0e 94 49 22 	call	0x4492	; 0x4492 <vTaskPlaceOnEventList>
                prvUnlockQueue( pxQueue );
    2b34:	8a 81       	ldd	r24, Y+2	; 0x02
    2b36:	9b 81       	ldd	r25, Y+3	; 0x03
    2b38:	0e 94 62 18 	call	0x30c4	; 0x30c4 <prvUnlockQueue>

                if( xTaskResumeAll() == pdFALSE )
    2b3c:	0e 94 78 1e 	call	0x3cf0	; 0x3cf0 <xTaskResumeAll>
    2b40:	88 23       	and	r24, r24
    2b42:	09 f0       	breq	.+2      	; 0x2b46 <xQueueSemaphoreTake+0x100>
    2b44:	93 cf       	rjmp	.-218    	; 0x2a6c <xQueueSemaphoreTake+0x26>
                {
                    portYIELD_WITHIN_API();
    2b46:	0e 94 56 09 	call	0x12ac	; 0x12ac <vPortYield>
    2b4a:	90 cf       	rjmp	.-224    	; 0x2a6c <xQueueSemaphoreTake+0x26>
            }
            else
            {
                /* There was no timeout and the semaphore count was not 0, so
                 * attempt to take the semaphore again. */
                prvUnlockQueue( pxQueue );
    2b4c:	8a 81       	ldd	r24, Y+2	; 0x02
    2b4e:	9b 81       	ldd	r25, Y+3	; 0x03
    2b50:	0e 94 62 18 	call	0x30c4	; 0x30c4 <prvUnlockQueue>
                ( void ) xTaskResumeAll();
    2b54:	0e 94 78 1e 	call	0x3cf0	; 0x3cf0 <xTaskResumeAll>
    2b58:	89 cf       	rjmp	.-238    	; 0x2a6c <xQueueSemaphoreTake+0x26>
            }
        }
        else
        {
            /* Timed out. */
            prvUnlockQueue( pxQueue );
    2b5a:	8a 81       	ldd	r24, Y+2	; 0x02
    2b5c:	9b 81       	ldd	r25, Y+3	; 0x03
    2b5e:	0e 94 62 18 	call	0x30c4	; 0x30c4 <prvUnlockQueue>
            ( void ) xTaskResumeAll();
    2b62:	0e 94 78 1e 	call	0x3cf0	; 0x3cf0 <xTaskResumeAll>

            /* If the semaphore count is 0 exit now as the timeout has
             * expired.  Otherwise return to attempt to take the semaphore that is
             * known to be available.  As semaphores are implemented by queues the
             * queue being empty is equivalent to the semaphore count being 0. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    2b66:	8a 81       	ldd	r24, Y+2	; 0x02
    2b68:	9b 81       	ldd	r25, Y+3	; 0x03
    2b6a:	0e 94 b5 18 	call	0x316a	; 0x316a <prvIsQueueEmpty>
    2b6e:	88 23       	and	r24, r24
    2b70:	09 f4       	brne	.+2      	; 0x2b74 <xQueueSemaphoreTake+0x12e>
    2b72:	7c cf       	rjmp	.-264    	; 0x2a6c <xQueueSemaphoreTake+0x26>
                        }
                    }
                #endif /* configUSE_MUTEXES */

                traceQUEUE_RECEIVE_FAILED( pxQueue );
                return errQUEUE_EMPTY;
    2b74:	1c 86       	std	Y+12, r1	; 0x0c
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
    } /*lint -restore */
    2b76:	8c 85       	ldd	r24, Y+12	; 0x0c
}
    2b78:	2c 96       	adiw	r28, 0x0c	; 12
    2b7a:	0f b6       	in	r0, 0x3f	; 63
    2b7c:	f8 94       	cli
    2b7e:	de bf       	out	0x3e, r29	; 62
    2b80:	0f be       	out	0x3f, r0	; 63
    2b82:	cd bf       	out	0x3d, r28	; 61
    2b84:	cf 91       	pop	r28
    2b86:	df 91       	pop	r29
    2b88:	08 95       	ret

00002b8a <xQueuePeek>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeek( QueueHandle_t xQueue,
                       void * const pvBuffer,
                       TickType_t xTicksToWait )
{
    2b8a:	df 93       	push	r29
    2b8c:	cf 93       	push	r28
    2b8e:	cd b7       	in	r28, 0x3d	; 61
    2b90:	de b7       	in	r29, 0x3e	; 62
    2b92:	60 97       	sbiw	r28, 0x10	; 16
    2b94:	0f b6       	in	r0, 0x3f	; 63
    2b96:	f8 94       	cli
    2b98:	de bf       	out	0x3e, r29	; 62
    2b9a:	0f be       	out	0x3f, r0	; 63
    2b9c:	cd bf       	out	0x3d, r28	; 61
    2b9e:	9b 87       	std	Y+11, r25	; 0x0b
    2ba0:	8a 87       	std	Y+10, r24	; 0x0a
    2ba2:	7d 87       	std	Y+13, r23	; 0x0d
    2ba4:	6c 87       	std	Y+12, r22	; 0x0c
    2ba6:	5f 87       	std	Y+15, r21	; 0x0f
    2ba8:	4e 87       	std	Y+14, r20	; 0x0e
    BaseType_t xEntryTimeSet = pdFALSE;
    2baa:	1e 82       	std	Y+6, r1	; 0x06
    TimeOut_t xTimeOut;
    int8_t * pcOriginalReadPosition;
    Queue_t * const pxQueue = xQueue;
    2bac:	8a 85       	ldd	r24, Y+10	; 0x0a
    2bae:	9b 85       	ldd	r25, Y+11	; 0x0b
    2bb0:	9b 83       	std	Y+3, r25	; 0x03
    2bb2:	8a 83       	std	Y+2, r24	; 0x02
    /*lint -save -e904  This function relaxes the coding standard somewhat to
     * allow return statements within the function itself.  This is done in the
     * interest of execution time efficiency. */
    for( ; ; )
    {
        taskENTER_CRITICAL();
    2bb4:	0f b6       	in	r0, 0x3f	; 63
    2bb6:	f8 94       	cli
    2bb8:	0f 92       	push	r0
        {
            const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    2bba:	ea 81       	ldd	r30, Y+2	; 0x02
    2bbc:	fb 81       	ldd	r31, Y+3	; 0x03
    2bbe:	82 8d       	ldd	r24, Z+26	; 0x1a
    2bc0:	89 83       	std	Y+1, r24	; 0x01

            /* Is there data in the queue now?  To be running the calling task
             * must be the highest priority task wanting to access the queue. */
            if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    2bc2:	89 81       	ldd	r24, Y+1	; 0x01
    2bc4:	88 23       	and	r24, r24
    2bc6:	31 f1       	breq	.+76     	; 0x2c14 <xQueuePeek+0x8a>
            {
                /* Remember the read position so it can be reset after the data
                 * is read from the queue as this function is only peeking the
                 * data, not removing it. */
                pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
    2bc8:	ea 81       	ldd	r30, Y+2	; 0x02
    2bca:	fb 81       	ldd	r31, Y+3	; 0x03
    2bcc:	86 81       	ldd	r24, Z+6	; 0x06
    2bce:	97 81       	ldd	r25, Z+7	; 0x07
    2bd0:	9d 83       	std	Y+5, r25	; 0x05
    2bd2:	8c 83       	std	Y+4, r24	; 0x04

                prvCopyDataFromQueue( pxQueue, pvBuffer );
    2bd4:	8a 81       	ldd	r24, Y+2	; 0x02
    2bd6:	9b 81       	ldd	r25, Y+3	; 0x03
    2bd8:	2c 85       	ldd	r18, Y+12	; 0x0c
    2bda:	3d 85       	ldd	r19, Y+13	; 0x0d
    2bdc:	b9 01       	movw	r22, r18
    2bde:	0e 94 1b 18 	call	0x3036	; 0x3036 <prvCopyDataFromQueue>
                traceQUEUE_PEEK( pxQueue );

                /* The data is not being removed, so reset the read pointer. */
                pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
    2be2:	ea 81       	ldd	r30, Y+2	; 0x02
    2be4:	fb 81       	ldd	r31, Y+3	; 0x03
    2be6:	8c 81       	ldd	r24, Y+4	; 0x04
    2be8:	9d 81       	ldd	r25, Y+5	; 0x05
    2bea:	97 83       	std	Z+7, r25	; 0x07
    2bec:	86 83       	std	Z+6, r24	; 0x06

                /* The data is being left in the queue, so see if there are
                 * any other tasks waiting for the data. */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    2bee:	ea 81       	ldd	r30, Y+2	; 0x02
    2bf0:	fb 81       	ldd	r31, Y+3	; 0x03
    2bf2:	81 89       	ldd	r24, Z+17	; 0x11
    2bf4:	88 23       	and	r24, r24
    2bf6:	49 f0       	breq	.+18     	; 0x2c0a <xQueuePeek+0x80>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    2bf8:	8a 81       	ldd	r24, Y+2	; 0x02
    2bfa:	9b 81       	ldd	r25, Y+3	; 0x03
    2bfc:	41 96       	adiw	r24, 0x11	; 17
    2bfe:	0e 94 32 23 	call	0x4664	; 0x4664 <xTaskRemoveFromEventList>
    2c02:	88 23       	and	r24, r24
    2c04:	11 f0       	breq	.+4      	; 0x2c0a <xQueuePeek+0x80>
                    {
                        /* The task waiting has a higher priority than this task. */
                        queueYIELD_IF_USING_PREEMPTION();
    2c06:	0e 94 56 09 	call	0x12ac	; 0x12ac <vPortYield>
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                taskEXIT_CRITICAL();
    2c0a:	0f 90       	pop	r0
    2c0c:	0f be       	out	0x3f, r0	; 63
                return pdPASS;
    2c0e:	81 e0       	ldi	r24, 0x01	; 1
    2c10:	88 8b       	std	Y+16, r24	; 0x10
    2c12:	63 c0       	rjmp	.+198    	; 0x2cda <xQueuePeek+0x150>
            }
            else
            {
                if( xTicksToWait == ( TickType_t ) 0 )
    2c14:	8e 85       	ldd	r24, Y+14	; 0x0e
    2c16:	9f 85       	ldd	r25, Y+15	; 0x0f
    2c18:	00 97       	sbiw	r24, 0x00	; 0
    2c1a:	21 f4       	brne	.+8      	; 0x2c24 <xQueuePeek+0x9a>
                {
                    /* The queue was empty and no block time is specified (or
                     * the block time has expired) so leave now. */
                    taskEXIT_CRITICAL();
    2c1c:	0f 90       	pop	r0
    2c1e:	0f be       	out	0x3f, r0	; 63
                    traceQUEUE_PEEK_FAILED( pxQueue );
                    return errQUEUE_EMPTY;
    2c20:	18 8a       	std	Y+16, r1	; 0x10
    2c22:	5b c0       	rjmp	.+182    	; 0x2cda <xQueuePeek+0x150>
                }
                else if( xEntryTimeSet == pdFALSE )
    2c24:	8e 81       	ldd	r24, Y+6	; 0x06
    2c26:	88 23       	and	r24, r24
    2c28:	31 f4       	brne	.+12     	; 0x2c36 <xQueuePeek+0xac>
                {
                    /* The queue was empty and a block time was specified so
                     * configure the timeout structure ready to enter the blocked
                     * state. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
    2c2a:	ce 01       	movw	r24, r28
    2c2c:	07 96       	adiw	r24, 0x07	; 7
    2c2e:	0e 94 a2 25 	call	0x4b44	; 0x4b44 <vTaskInternalSetTimeOutState>
                    xEntryTimeSet = pdTRUE;
    2c32:	81 e0       	ldi	r24, 0x01	; 1
    2c34:	8e 83       	std	Y+6, r24	; 0x06
                    /* Entry time was already set. */
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        taskEXIT_CRITICAL();
    2c36:	0f 90       	pop	r0
    2c38:	0f be       	out	0x3f, r0	; 63

        /* Interrupts and other tasks can send to and receive from the queue
         * now that the critical section has been exited. */

        vTaskSuspendAll();
    2c3a:	0e 94 6c 1e 	call	0x3cd8	; 0x3cd8 <vTaskSuspendAll>
        prvLockQueue( pxQueue );
    2c3e:	0f b6       	in	r0, 0x3f	; 63
    2c40:	f8 94       	cli
    2c42:	0f 92       	push	r0
    2c44:	ea 81       	ldd	r30, Y+2	; 0x02
    2c46:	fb 81       	ldd	r31, Y+3	; 0x03
    2c48:	85 8d       	ldd	r24, Z+29	; 0x1d
    2c4a:	8f 3f       	cpi	r24, 0xFF	; 255
    2c4c:	19 f4       	brne	.+6      	; 0x2c54 <xQueuePeek+0xca>
    2c4e:	ea 81       	ldd	r30, Y+2	; 0x02
    2c50:	fb 81       	ldd	r31, Y+3	; 0x03
    2c52:	15 8e       	std	Z+29, r1	; 0x1d
    2c54:	ea 81       	ldd	r30, Y+2	; 0x02
    2c56:	fb 81       	ldd	r31, Y+3	; 0x03
    2c58:	86 8d       	ldd	r24, Z+30	; 0x1e
    2c5a:	8f 3f       	cpi	r24, 0xFF	; 255
    2c5c:	19 f4       	brne	.+6      	; 0x2c64 <xQueuePeek+0xda>
    2c5e:	ea 81       	ldd	r30, Y+2	; 0x02
    2c60:	fb 81       	ldd	r31, Y+3	; 0x03
    2c62:	16 8e       	std	Z+30, r1	; 0x1e
    2c64:	0f 90       	pop	r0
    2c66:	0f be       	out	0x3f, r0	; 63

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    2c68:	ce 01       	movw	r24, r28
    2c6a:	07 96       	adiw	r24, 0x07	; 7
    2c6c:	9e 01       	movw	r18, r28
    2c6e:	22 5f       	subi	r18, 0xF2	; 242
    2c70:	3f 4f       	sbci	r19, 0xFF	; 255
    2c72:	b9 01       	movw	r22, r18
    2c74:	0e 94 bb 25 	call	0x4b76	; 0x4b76 <xTaskCheckForTimeOut>
    2c78:	88 23       	and	r24, r24
    2c7a:	09 f5       	brne	.+66     	; 0x2cbe <xQueuePeek+0x134>
        {
            /* Timeout has not expired yet, check to see if there is data in the
            * queue now, and if not enter the Blocked state to wait for data. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    2c7c:	8a 81       	ldd	r24, Y+2	; 0x02
    2c7e:	9b 81       	ldd	r25, Y+3	; 0x03
    2c80:	0e 94 b5 18 	call	0x316a	; 0x316a <prvIsQueueEmpty>
    2c84:	88 23       	and	r24, r24
    2c86:	a1 f0       	breq	.+40     	; 0x2cb0 <xQueuePeek+0x126>
            {
                traceBLOCKING_ON_QUEUE_PEEK( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    2c88:	8a 81       	ldd	r24, Y+2	; 0x02
    2c8a:	9b 81       	ldd	r25, Y+3	; 0x03
    2c8c:	41 96       	adiw	r24, 0x11	; 17
    2c8e:	2e 85       	ldd	r18, Y+14	; 0x0e
    2c90:	3f 85       	ldd	r19, Y+15	; 0x0f
    2c92:	b9 01       	movw	r22, r18
    2c94:	0e 94 49 22 	call	0x4492	; 0x4492 <vTaskPlaceOnEventList>
                prvUnlockQueue( pxQueue );
    2c98:	8a 81       	ldd	r24, Y+2	; 0x02
    2c9a:	9b 81       	ldd	r25, Y+3	; 0x03
    2c9c:	0e 94 62 18 	call	0x30c4	; 0x30c4 <prvUnlockQueue>

                if( xTaskResumeAll() == pdFALSE )
    2ca0:	0e 94 78 1e 	call	0x3cf0	; 0x3cf0 <xTaskResumeAll>
    2ca4:	88 23       	and	r24, r24
    2ca6:	09 f0       	breq	.+2      	; 0x2caa <xQueuePeek+0x120>
    2ca8:	85 cf       	rjmp	.-246    	; 0x2bb4 <xQueuePeek+0x2a>
                {
                    portYIELD_WITHIN_API();
    2caa:	0e 94 56 09 	call	0x12ac	; 0x12ac <vPortYield>
    2cae:	82 cf       	rjmp	.-252    	; 0x2bb4 <xQueuePeek+0x2a>
            }
            else
            {
                /* There is data in the queue now, so don't enter the blocked
                 * state, instead return to try and obtain the data. */
                prvUnlockQueue( pxQueue );
    2cb0:	8a 81       	ldd	r24, Y+2	; 0x02
    2cb2:	9b 81       	ldd	r25, Y+3	; 0x03
    2cb4:	0e 94 62 18 	call	0x30c4	; 0x30c4 <prvUnlockQueue>
                ( void ) xTaskResumeAll();
    2cb8:	0e 94 78 1e 	call	0x3cf0	; 0x3cf0 <xTaskResumeAll>
    2cbc:	7b cf       	rjmp	.-266    	; 0x2bb4 <xQueuePeek+0x2a>
        }
        else
        {
            /* The timeout has expired.  If there is still no data in the queue
             * exit, otherwise go back and try to read the data again. */
            prvUnlockQueue( pxQueue );
    2cbe:	8a 81       	ldd	r24, Y+2	; 0x02
    2cc0:	9b 81       	ldd	r25, Y+3	; 0x03
    2cc2:	0e 94 62 18 	call	0x30c4	; 0x30c4 <prvUnlockQueue>
            ( void ) xTaskResumeAll();
    2cc6:	0e 94 78 1e 	call	0x3cf0	; 0x3cf0 <xTaskResumeAll>

            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    2cca:	8a 81       	ldd	r24, Y+2	; 0x02
    2ccc:	9b 81       	ldd	r25, Y+3	; 0x03
    2cce:	0e 94 b5 18 	call	0x316a	; 0x316a <prvIsQueueEmpty>
    2cd2:	88 23       	and	r24, r24
    2cd4:	09 f4       	brne	.+2      	; 0x2cd8 <xQueuePeek+0x14e>
    2cd6:	6e cf       	rjmp	.-292    	; 0x2bb4 <xQueuePeek+0x2a>
            {
                traceQUEUE_PEEK_FAILED( pxQueue );
                return errQUEUE_EMPTY;
    2cd8:	18 8a       	std	Y+16, r1	; 0x10
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
    } /*lint -restore */
    2cda:	88 89       	ldd	r24, Y+16	; 0x10
}
    2cdc:	60 96       	adiw	r28, 0x10	; 16
    2cde:	0f b6       	in	r0, 0x3f	; 63
    2ce0:	f8 94       	cli
    2ce2:	de bf       	out	0x3e, r29	; 62
    2ce4:	0f be       	out	0x3f, r0	; 63
    2ce6:	cd bf       	out	0x3d, r28	; 61
    2ce8:	cf 91       	pop	r28
    2cea:	df 91       	pop	r29
    2cec:	08 95       	ret

00002cee <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue,
                                 void * const pvBuffer,
                                 BaseType_t * const pxHigherPriorityTaskWoken )
{
    2cee:	df 93       	push	r29
    2cf0:	cf 93       	push	r28
    2cf2:	cd b7       	in	r28, 0x3d	; 61
    2cf4:	de b7       	in	r29, 0x3e	; 62
    2cf6:	2c 97       	sbiw	r28, 0x0c	; 12
    2cf8:	0f b6       	in	r0, 0x3f	; 63
    2cfa:	f8 94       	cli
    2cfc:	de bf       	out	0x3e, r29	; 62
    2cfe:	0f be       	out	0x3f, r0	; 63
    2d00:	cd bf       	out	0x3d, r28	; 61
    2d02:	98 87       	std	Y+8, r25	; 0x08
    2d04:	8f 83       	std	Y+7, r24	; 0x07
    2d06:	7a 87       	std	Y+10, r23	; 0x0a
    2d08:	69 87       	std	Y+9, r22	; 0x09
    2d0a:	5c 87       	std	Y+12, r21	; 0x0c
    2d0c:	4b 87       	std	Y+11, r20	; 0x0b
    BaseType_t xReturn;
    UBaseType_t uxSavedInterruptStatus;
    Queue_t * const pxQueue = xQueue;
    2d0e:	8f 81       	ldd	r24, Y+7	; 0x07
    2d10:	98 85       	ldd	r25, Y+8	; 0x08
    2d12:	9c 83       	std	Y+4, r25	; 0x04
    2d14:	8b 83       	std	Y+3, r24	; 0x03
     * safe API to ensure interrupt entry is as fast and as simple as possible.
     * More information (albeit Cortex-M specific) is provided on the following
     * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    2d16:	1d 82       	std	Y+5, r1	; 0x05
    {
        const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    2d18:	eb 81       	ldd	r30, Y+3	; 0x03
    2d1a:	fc 81       	ldd	r31, Y+4	; 0x04
    2d1c:	82 8d       	ldd	r24, Z+26	; 0x1a
    2d1e:	8a 83       	std	Y+2, r24	; 0x02

        /* Cannot block in an ISR, so check there is data available. */
        if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    2d20:	8a 81       	ldd	r24, Y+2	; 0x02
    2d22:	88 23       	and	r24, r24
    2d24:	81 f1       	breq	.+96     	; 0x2d86 <xQueueReceiveFromISR+0x98>
        {
            const int8_t cRxLock = pxQueue->cRxLock;
    2d26:	eb 81       	ldd	r30, Y+3	; 0x03
    2d28:	fc 81       	ldd	r31, Y+4	; 0x04
    2d2a:	85 8d       	ldd	r24, Z+29	; 0x1d
    2d2c:	89 83       	std	Y+1, r24	; 0x01

            traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

            prvCopyDataFromQueue( pxQueue, pvBuffer );
    2d2e:	8b 81       	ldd	r24, Y+3	; 0x03
    2d30:	9c 81       	ldd	r25, Y+4	; 0x04
    2d32:	29 85       	ldd	r18, Y+9	; 0x09
    2d34:	3a 85       	ldd	r19, Y+10	; 0x0a
    2d36:	b9 01       	movw	r22, r18
    2d38:	0e 94 1b 18 	call	0x3036	; 0x3036 <prvCopyDataFromQueue>
            pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
    2d3c:	8a 81       	ldd	r24, Y+2	; 0x02
    2d3e:	81 50       	subi	r24, 0x01	; 1
    2d40:	eb 81       	ldd	r30, Y+3	; 0x03
    2d42:	fc 81       	ldd	r31, Y+4	; 0x04
    2d44:	82 8f       	std	Z+26, r24	; 0x1a

            /* If the queue is locked the event list will not be modified.
             * Instead update the lock count so the task that unlocks the queue
             * will know that an ISR has removed data while the queue was
             * locked. */
            if( cRxLock == queueUNLOCKED )
    2d46:	89 81       	ldd	r24, Y+1	; 0x01
    2d48:	8f 3f       	cpi	r24, 0xFF	; 255
    2d4a:	a9 f4       	brne	.+42     	; 0x2d76 <xQueueReceiveFromISR+0x88>
            {
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    2d4c:	eb 81       	ldd	r30, Y+3	; 0x03
    2d4e:	fc 81       	ldd	r31, Y+4	; 0x04
    2d50:	80 85       	ldd	r24, Z+8	; 0x08
    2d52:	88 23       	and	r24, r24
    2d54:	a9 f0       	breq	.+42     	; 0x2d80 <xQueueReceiveFromISR+0x92>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    2d56:	8b 81       	ldd	r24, Y+3	; 0x03
    2d58:	9c 81       	ldd	r25, Y+4	; 0x04
    2d5a:	08 96       	adiw	r24, 0x08	; 8
    2d5c:	0e 94 32 23 	call	0x4664	; 0x4664 <xTaskRemoveFromEventList>
    2d60:	88 23       	and	r24, r24
    2d62:	71 f0       	breq	.+28     	; 0x2d80 <xQueueReceiveFromISR+0x92>
                    {
                        /* The task waiting has a higher priority than us so
                         * force a context switch. */
                        if( pxHigherPriorityTaskWoken != NULL )
    2d64:	8b 85       	ldd	r24, Y+11	; 0x0b
    2d66:	9c 85       	ldd	r25, Y+12	; 0x0c
    2d68:	00 97       	sbiw	r24, 0x00	; 0
    2d6a:	51 f0       	breq	.+20     	; 0x2d80 <xQueueReceiveFromISR+0x92>
                        {
                            *pxHigherPriorityTaskWoken = pdTRUE;
    2d6c:	eb 85       	ldd	r30, Y+11	; 0x0b
    2d6e:	fc 85       	ldd	r31, Y+12	; 0x0c
    2d70:	81 e0       	ldi	r24, 0x01	; 1
    2d72:	80 83       	st	Z, r24
    2d74:	05 c0       	rjmp	.+10     	; 0x2d80 <xQueueReceiveFromISR+0x92>
            {
                /* Increment the lock count so the task that unlocks the queue
                 * knows that data was removed while it was locked. */
                configASSERT( cRxLock != queueINT8_MAX );

                pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
    2d76:	89 81       	ldd	r24, Y+1	; 0x01
    2d78:	8f 5f       	subi	r24, 0xFF	; 255
    2d7a:	eb 81       	ldd	r30, Y+3	; 0x03
    2d7c:	fc 81       	ldd	r31, Y+4	; 0x04
    2d7e:	85 8f       	std	Z+29, r24	; 0x1d
            }

            xReturn = pdPASS;
    2d80:	81 e0       	ldi	r24, 0x01	; 1
    2d82:	8e 83       	std	Y+6, r24	; 0x06
    2d84:	01 c0       	rjmp	.+2      	; 0x2d88 <xQueueReceiveFromISR+0x9a>
        }
        else
        {
            xReturn = pdFAIL;
    2d86:	1e 82       	std	Y+6, r1	; 0x06
            traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
    2d88:	8e 81       	ldd	r24, Y+6	; 0x06
}
    2d8a:	2c 96       	adiw	r28, 0x0c	; 12
    2d8c:	0f b6       	in	r0, 0x3f	; 63
    2d8e:	f8 94       	cli
    2d90:	de bf       	out	0x3e, r29	; 62
    2d92:	0f be       	out	0x3f, r0	; 63
    2d94:	cd bf       	out	0x3d, r28	; 61
    2d96:	cf 91       	pop	r28
    2d98:	df 91       	pop	r29
    2d9a:	08 95       	ret

00002d9c <xQueuePeekFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,
                              void * const pvBuffer )
{
    2d9c:	df 93       	push	r29
    2d9e:	cf 93       	push	r28
    2da0:	cd b7       	in	r28, 0x3d	; 61
    2da2:	de b7       	in	r29, 0x3e	; 62
    2da4:	2a 97       	sbiw	r28, 0x0a	; 10
    2da6:	0f b6       	in	r0, 0x3f	; 63
    2da8:	f8 94       	cli
    2daa:	de bf       	out	0x3e, r29	; 62
    2dac:	0f be       	out	0x3f, r0	; 63
    2dae:	cd bf       	out	0x3d, r28	; 61
    2db0:	98 87       	std	Y+8, r25	; 0x08
    2db2:	8f 83       	std	Y+7, r24	; 0x07
    2db4:	7a 87       	std	Y+10, r23	; 0x0a
    2db6:	69 87       	std	Y+9, r22	; 0x09
    BaseType_t xReturn;
    UBaseType_t uxSavedInterruptStatus;
    int8_t * pcOriginalReadPosition;
    Queue_t * const pxQueue = xQueue;
    2db8:	8f 81       	ldd	r24, Y+7	; 0x07
    2dba:	98 85       	ldd	r25, Y+8	; 0x08
    2dbc:	9a 83       	std	Y+2, r25	; 0x02
    2dbe:	89 83       	std	Y+1, r24	; 0x01
     * safe API to ensure interrupt entry is as fast and as simple as possible.
     * More information (albeit Cortex-M specific) is provided on the following
     * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    2dc0:	1d 82       	std	Y+5, r1	; 0x05
    {
        /* Cannot block in an ISR, so check there is data available. */
        if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    2dc2:	e9 81       	ldd	r30, Y+1	; 0x01
    2dc4:	fa 81       	ldd	r31, Y+2	; 0x02
    2dc6:	82 8d       	ldd	r24, Z+26	; 0x1a
    2dc8:	88 23       	and	r24, r24
    2dca:	b1 f0       	breq	.+44     	; 0x2df8 <xQueuePeekFromISR+0x5c>
        {
            traceQUEUE_PEEK_FROM_ISR( pxQueue );

            /* Remember the read position so it can be reset as nothing is
             * actually being removed from the queue. */
            pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
    2dcc:	e9 81       	ldd	r30, Y+1	; 0x01
    2dce:	fa 81       	ldd	r31, Y+2	; 0x02
    2dd0:	86 81       	ldd	r24, Z+6	; 0x06
    2dd2:	97 81       	ldd	r25, Z+7	; 0x07
    2dd4:	9c 83       	std	Y+4, r25	; 0x04
    2dd6:	8b 83       	std	Y+3, r24	; 0x03
            prvCopyDataFromQueue( pxQueue, pvBuffer );
    2dd8:	89 81       	ldd	r24, Y+1	; 0x01
    2dda:	9a 81       	ldd	r25, Y+2	; 0x02
    2ddc:	29 85       	ldd	r18, Y+9	; 0x09
    2dde:	3a 85       	ldd	r19, Y+10	; 0x0a
    2de0:	b9 01       	movw	r22, r18
    2de2:	0e 94 1b 18 	call	0x3036	; 0x3036 <prvCopyDataFromQueue>
            pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
    2de6:	e9 81       	ldd	r30, Y+1	; 0x01
    2de8:	fa 81       	ldd	r31, Y+2	; 0x02
    2dea:	8b 81       	ldd	r24, Y+3	; 0x03
    2dec:	9c 81       	ldd	r25, Y+4	; 0x04
    2dee:	97 83       	std	Z+7, r25	; 0x07
    2df0:	86 83       	std	Z+6, r24	; 0x06

            xReturn = pdPASS;
    2df2:	81 e0       	ldi	r24, 0x01	; 1
    2df4:	8e 83       	std	Y+6, r24	; 0x06
    2df6:	01 c0       	rjmp	.+2      	; 0x2dfa <xQueuePeekFromISR+0x5e>
        }
        else
        {
            xReturn = pdFAIL;
    2df8:	1e 82       	std	Y+6, r1	; 0x06
            traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue );
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
    2dfa:	8e 81       	ldd	r24, Y+6	; 0x06
}
    2dfc:	2a 96       	adiw	r28, 0x0a	; 10
    2dfe:	0f b6       	in	r0, 0x3f	; 63
    2e00:	f8 94       	cli
    2e02:	de bf       	out	0x3e, r29	; 62
    2e04:	0f be       	out	0x3f, r0	; 63
    2e06:	cd bf       	out	0x3d, r28	; 61
    2e08:	cf 91       	pop	r28
    2e0a:	df 91       	pop	r29
    2e0c:	08 95       	ret

00002e0e <uxQueueMessagesWaiting>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue )
{
    2e0e:	df 93       	push	r29
    2e10:	cf 93       	push	r28
    2e12:	00 d0       	rcall	.+0      	; 0x2e14 <uxQueueMessagesWaiting+0x6>
    2e14:	0f 92       	push	r0
    2e16:	cd b7       	in	r28, 0x3d	; 61
    2e18:	de b7       	in	r29, 0x3e	; 62
    2e1a:	9b 83       	std	Y+3, r25	; 0x03
    2e1c:	8a 83       	std	Y+2, r24	; 0x02
    UBaseType_t uxReturn;

    configASSERT( xQueue );

    taskENTER_CRITICAL();
    2e1e:	0f b6       	in	r0, 0x3f	; 63
    2e20:	f8 94       	cli
    2e22:	0f 92       	push	r0
    {
        uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
    2e24:	ea 81       	ldd	r30, Y+2	; 0x02
    2e26:	fb 81       	ldd	r31, Y+3	; 0x03
    2e28:	82 8d       	ldd	r24, Z+26	; 0x1a
    2e2a:	89 83       	std	Y+1, r24	; 0x01
    }
    taskEXIT_CRITICAL();
    2e2c:	0f 90       	pop	r0
    2e2e:	0f be       	out	0x3f, r0	; 63

    return uxReturn;
    2e30:	89 81       	ldd	r24, Y+1	; 0x01
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    2e32:	0f 90       	pop	r0
    2e34:	0f 90       	pop	r0
    2e36:	0f 90       	pop	r0
    2e38:	cf 91       	pop	r28
    2e3a:	df 91       	pop	r29
    2e3c:	08 95       	ret

00002e3e <uxQueueSpacesAvailable>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )
{
    2e3e:	df 93       	push	r29
    2e40:	cf 93       	push	r28
    2e42:	00 d0       	rcall	.+0      	; 0x2e44 <uxQueueSpacesAvailable+0x6>
    2e44:	00 d0       	rcall	.+0      	; 0x2e46 <uxQueueSpacesAvailable+0x8>
    2e46:	0f 92       	push	r0
    2e48:	cd b7       	in	r28, 0x3d	; 61
    2e4a:	de b7       	in	r29, 0x3e	; 62
    2e4c:	9d 83       	std	Y+5, r25	; 0x05
    2e4e:	8c 83       	std	Y+4, r24	; 0x04
    UBaseType_t uxReturn;
    Queue_t * const pxQueue = xQueue;
    2e50:	8c 81       	ldd	r24, Y+4	; 0x04
    2e52:	9d 81       	ldd	r25, Y+5	; 0x05
    2e54:	9a 83       	std	Y+2, r25	; 0x02
    2e56:	89 83       	std	Y+1, r24	; 0x01

    configASSERT( pxQueue );

    taskENTER_CRITICAL();
    2e58:	0f b6       	in	r0, 0x3f	; 63
    2e5a:	f8 94       	cli
    2e5c:	0f 92       	push	r0
    {
        uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
    2e5e:	e9 81       	ldd	r30, Y+1	; 0x01
    2e60:	fa 81       	ldd	r31, Y+2	; 0x02
    2e62:	93 8d       	ldd	r25, Z+27	; 0x1b
    2e64:	e9 81       	ldd	r30, Y+1	; 0x01
    2e66:	fa 81       	ldd	r31, Y+2	; 0x02
    2e68:	82 8d       	ldd	r24, Z+26	; 0x1a
    2e6a:	29 2f       	mov	r18, r25
    2e6c:	28 1b       	sub	r18, r24
    2e6e:	82 2f       	mov	r24, r18
    2e70:	8b 83       	std	Y+3, r24	; 0x03
    }
    taskEXIT_CRITICAL();
    2e72:	0f 90       	pop	r0
    2e74:	0f be       	out	0x3f, r0	; 63

    return uxReturn;
    2e76:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    2e78:	0f 90       	pop	r0
    2e7a:	0f 90       	pop	r0
    2e7c:	0f 90       	pop	r0
    2e7e:	0f 90       	pop	r0
    2e80:	0f 90       	pop	r0
    2e82:	cf 91       	pop	r28
    2e84:	df 91       	pop	r29
    2e86:	08 95       	ret

00002e88 <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue )
{
    2e88:	df 93       	push	r29
    2e8a:	cf 93       	push	r28
    2e8c:	00 d0       	rcall	.+0      	; 0x2e8e <uxQueueMessagesWaitingFromISR+0x6>
    2e8e:	00 d0       	rcall	.+0      	; 0x2e90 <uxQueueMessagesWaitingFromISR+0x8>
    2e90:	0f 92       	push	r0
    2e92:	cd b7       	in	r28, 0x3d	; 61
    2e94:	de b7       	in	r29, 0x3e	; 62
    2e96:	9d 83       	std	Y+5, r25	; 0x05
    2e98:	8c 83       	std	Y+4, r24	; 0x04
    UBaseType_t uxReturn;
    Queue_t * const pxQueue = xQueue;
    2e9a:	8c 81       	ldd	r24, Y+4	; 0x04
    2e9c:	9d 81       	ldd	r25, Y+5	; 0x05
    2e9e:	9a 83       	std	Y+2, r25	; 0x02
    2ea0:	89 83       	std	Y+1, r24	; 0x01

    configASSERT( pxQueue );
    uxReturn = pxQueue->uxMessagesWaiting;
    2ea2:	e9 81       	ldd	r30, Y+1	; 0x01
    2ea4:	fa 81       	ldd	r31, Y+2	; 0x02
    2ea6:	82 8d       	ldd	r24, Z+26	; 0x1a
    2ea8:	8b 83       	std	Y+3, r24	; 0x03

    return uxReturn;
    2eaa:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    2eac:	0f 90       	pop	r0
    2eae:	0f 90       	pop	r0
    2eb0:	0f 90       	pop	r0
    2eb2:	0f 90       	pop	r0
    2eb4:	0f 90       	pop	r0
    2eb6:	cf 91       	pop	r28
    2eb8:	df 91       	pop	r29
    2eba:	08 95       	ret

00002ebc <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( QueueHandle_t xQueue )
{
    2ebc:	df 93       	push	r29
    2ebe:	cf 93       	push	r28
    2ec0:	00 d0       	rcall	.+0      	; 0x2ec2 <vQueueDelete+0x6>
    2ec2:	00 d0       	rcall	.+0      	; 0x2ec4 <vQueueDelete+0x8>
    2ec4:	cd b7       	in	r28, 0x3d	; 61
    2ec6:	de b7       	in	r29, 0x3e	; 62
    2ec8:	9c 83       	std	Y+4, r25	; 0x04
    2eca:	8b 83       	std	Y+3, r24	; 0x03
    Queue_t * const pxQueue = xQueue;
    2ecc:	8b 81       	ldd	r24, Y+3	; 0x03
    2ece:	9c 81       	ldd	r25, Y+4	; 0x04
    2ed0:	9a 83       	std	Y+2, r25	; 0x02
    2ed2:	89 83       	std	Y+1, r24	; 0x01

    #if ( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
        {
            /* The queue can only have been allocated dynamically - free it
             * again. */
            vPortFree( pxQueue );
    2ed4:	89 81       	ldd	r24, Y+1	; 0x01
    2ed6:	9a 81       	ldd	r25, Y+2	; 0x02
    2ed8:	0e 94 71 07 	call	0xee2	; 0xee2 <vPortFree>
            /* The queue must have been statically allocated, so is not going to be
             * deleted.  Avoid compiler warnings about the unused parameter. */
            ( void ) pxQueue;
        }
    #endif /* configSUPPORT_DYNAMIC_ALLOCATION */
}
    2edc:	0f 90       	pop	r0
    2ede:	0f 90       	pop	r0
    2ee0:	0f 90       	pop	r0
    2ee2:	0f 90       	pop	r0
    2ee4:	cf 91       	pop	r28
    2ee6:	df 91       	pop	r29
    2ee8:	08 95       	ret

00002eea <prvCopyDataToQueue>:
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue,
                                      const void * pvItemToQueue,
                                      const BaseType_t xPosition )
{
    2eea:	df 93       	push	r29
    2eec:	cf 93       	push	r28
    2eee:	cd b7       	in	r28, 0x3d	; 61
    2ef0:	de b7       	in	r29, 0x3e	; 62
    2ef2:	27 97       	sbiw	r28, 0x07	; 7
    2ef4:	0f b6       	in	r0, 0x3f	; 63
    2ef6:	f8 94       	cli
    2ef8:	de bf       	out	0x3e, r29	; 62
    2efa:	0f be       	out	0x3f, r0	; 63
    2efc:	cd bf       	out	0x3d, r28	; 61
    2efe:	9c 83       	std	Y+4, r25	; 0x04
    2f00:	8b 83       	std	Y+3, r24	; 0x03
    2f02:	7e 83       	std	Y+6, r23	; 0x06
    2f04:	6d 83       	std	Y+5, r22	; 0x05
    2f06:	4f 83       	std	Y+7, r20	; 0x07
    BaseType_t xReturn = pdFALSE;
    2f08:	1a 82       	std	Y+2, r1	; 0x02
    UBaseType_t uxMessagesWaiting;

    /* This function is called from a critical section. */

    uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    2f0a:	eb 81       	ldd	r30, Y+3	; 0x03
    2f0c:	fc 81       	ldd	r31, Y+4	; 0x04
    2f0e:	82 8d       	ldd	r24, Z+26	; 0x1a
    2f10:	89 83       	std	Y+1, r24	; 0x01

    if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
    2f12:	eb 81       	ldd	r30, Y+3	; 0x03
    2f14:	fc 81       	ldd	r31, Y+4	; 0x04
    2f16:	84 8d       	ldd	r24, Z+28	; 0x1c
    2f18:	88 23       	and	r24, r24
    2f1a:	09 f4       	brne	.+2      	; 0x2f1e <prvCopyDataToQueue+0x34>
    2f1c:	7d c0       	rjmp	.+250    	; 0x3018 <prvCopyDataToQueue+0x12e>
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        #endif /* configUSE_MUTEXES */
    }
    else if( xPosition == queueSEND_TO_BACK )
    2f1e:	8f 81       	ldd	r24, Y+7	; 0x07
    2f20:	88 23       	and	r24, r24
    2f22:	99 f5       	brne	.+102    	; 0x2f8a <prvCopyDataToQueue+0xa0>
    {
        ( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
    2f24:	eb 81       	ldd	r30, Y+3	; 0x03
    2f26:	fc 81       	ldd	r31, Y+4	; 0x04
    2f28:	62 81       	ldd	r22, Z+2	; 0x02
    2f2a:	73 81       	ldd	r23, Z+3	; 0x03
    2f2c:	eb 81       	ldd	r30, Y+3	; 0x03
    2f2e:	fc 81       	ldd	r31, Y+4	; 0x04
    2f30:	84 8d       	ldd	r24, Z+28	; 0x1c
    2f32:	48 2f       	mov	r20, r24
    2f34:	50 e0       	ldi	r21, 0x00	; 0
    2f36:	2d 81       	ldd	r18, Y+5	; 0x05
    2f38:	3e 81       	ldd	r19, Y+6	; 0x06
    2f3a:	cb 01       	movw	r24, r22
    2f3c:	b9 01       	movw	r22, r18
    2f3e:	0e 94 18 4b 	call	0x9630	; 0x9630 <memcpy>
        pxQueue->pcWriteTo += pxQueue->uxItemSize;                                                       /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
    2f42:	eb 81       	ldd	r30, Y+3	; 0x03
    2f44:	fc 81       	ldd	r31, Y+4	; 0x04
    2f46:	22 81       	ldd	r18, Z+2	; 0x02
    2f48:	33 81       	ldd	r19, Z+3	; 0x03
    2f4a:	eb 81       	ldd	r30, Y+3	; 0x03
    2f4c:	fc 81       	ldd	r31, Y+4	; 0x04
    2f4e:	84 8d       	ldd	r24, Z+28	; 0x1c
    2f50:	88 2f       	mov	r24, r24
    2f52:	90 e0       	ldi	r25, 0x00	; 0
    2f54:	82 0f       	add	r24, r18
    2f56:	93 1f       	adc	r25, r19
    2f58:	eb 81       	ldd	r30, Y+3	; 0x03
    2f5a:	fc 81       	ldd	r31, Y+4	; 0x04
    2f5c:	93 83       	std	Z+3, r25	; 0x03
    2f5e:	82 83       	std	Z+2, r24	; 0x02

        if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail )                                             /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    2f60:	eb 81       	ldd	r30, Y+3	; 0x03
    2f62:	fc 81       	ldd	r31, Y+4	; 0x04
    2f64:	22 81       	ldd	r18, Z+2	; 0x02
    2f66:	33 81       	ldd	r19, Z+3	; 0x03
    2f68:	eb 81       	ldd	r30, Y+3	; 0x03
    2f6a:	fc 81       	ldd	r31, Y+4	; 0x04
    2f6c:	84 81       	ldd	r24, Z+4	; 0x04
    2f6e:	95 81       	ldd	r25, Z+5	; 0x05
    2f70:	28 17       	cp	r18, r24
    2f72:	39 07       	cpc	r19, r25
    2f74:	08 f4       	brcc	.+2      	; 0x2f78 <prvCopyDataToQueue+0x8e>
    2f76:	50 c0       	rjmp	.+160    	; 0x3018 <prvCopyDataToQueue+0x12e>
        {
            pxQueue->pcWriteTo = pxQueue->pcHead;
    2f78:	eb 81       	ldd	r30, Y+3	; 0x03
    2f7a:	fc 81       	ldd	r31, Y+4	; 0x04
    2f7c:	80 81       	ld	r24, Z
    2f7e:	91 81       	ldd	r25, Z+1	; 0x01
    2f80:	eb 81       	ldd	r30, Y+3	; 0x03
    2f82:	fc 81       	ldd	r31, Y+4	; 0x04
    2f84:	93 83       	std	Z+3, r25	; 0x03
    2f86:	82 83       	std	Z+2, r24	; 0x02
    2f88:	47 c0       	rjmp	.+142    	; 0x3018 <prvCopyDataToQueue+0x12e>
            mtCOVERAGE_TEST_MARKER();
        }
    }
    else
    {
        ( void ) memcpy( ( void * ) pxQueue->u.xQueue.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e9087 !e418 MISRA exception as the casts are only redundant for some ports.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes.  Assert checks null pointer only used when length is 0. */
    2f8a:	eb 81       	ldd	r30, Y+3	; 0x03
    2f8c:	fc 81       	ldd	r31, Y+4	; 0x04
    2f8e:	66 81       	ldd	r22, Z+6	; 0x06
    2f90:	77 81       	ldd	r23, Z+7	; 0x07
    2f92:	eb 81       	ldd	r30, Y+3	; 0x03
    2f94:	fc 81       	ldd	r31, Y+4	; 0x04
    2f96:	84 8d       	ldd	r24, Z+28	; 0x1c
    2f98:	48 2f       	mov	r20, r24
    2f9a:	50 e0       	ldi	r21, 0x00	; 0
    2f9c:	2d 81       	ldd	r18, Y+5	; 0x05
    2f9e:	3e 81       	ldd	r19, Y+6	; 0x06
    2fa0:	cb 01       	movw	r24, r22
    2fa2:	b9 01       	movw	r22, r18
    2fa4:	0e 94 18 4b 	call	0x9630	; 0x9630 <memcpy>
        pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
    2fa8:	eb 81       	ldd	r30, Y+3	; 0x03
    2faa:	fc 81       	ldd	r31, Y+4	; 0x04
    2fac:	26 81       	ldd	r18, Z+6	; 0x06
    2fae:	37 81       	ldd	r19, Z+7	; 0x07
    2fb0:	eb 81       	ldd	r30, Y+3	; 0x03
    2fb2:	fc 81       	ldd	r31, Y+4	; 0x04
    2fb4:	84 8d       	ldd	r24, Z+28	; 0x1c
    2fb6:	88 2f       	mov	r24, r24
    2fb8:	90 e0       	ldi	r25, 0x00	; 0
    2fba:	90 95       	com	r25
    2fbc:	81 95       	neg	r24
    2fbe:	9f 4f       	sbci	r25, 0xFF	; 255
    2fc0:	82 0f       	add	r24, r18
    2fc2:	93 1f       	adc	r25, r19
    2fc4:	eb 81       	ldd	r30, Y+3	; 0x03
    2fc6:	fc 81       	ldd	r31, Y+4	; 0x04
    2fc8:	97 83       	std	Z+7, r25	; 0x07
    2fca:	86 83       	std	Z+6, r24	; 0x06

        if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    2fcc:	eb 81       	ldd	r30, Y+3	; 0x03
    2fce:	fc 81       	ldd	r31, Y+4	; 0x04
    2fd0:	26 81       	ldd	r18, Z+6	; 0x06
    2fd2:	37 81       	ldd	r19, Z+7	; 0x07
    2fd4:	eb 81       	ldd	r30, Y+3	; 0x03
    2fd6:	fc 81       	ldd	r31, Y+4	; 0x04
    2fd8:	80 81       	ld	r24, Z
    2fda:	91 81       	ldd	r25, Z+1	; 0x01
    2fdc:	28 17       	cp	r18, r24
    2fde:	39 07       	cpc	r19, r25
    2fe0:	90 f4       	brcc	.+36     	; 0x3006 <prvCopyDataToQueue+0x11c>
        {
            pxQueue->u.xQueue.pcReadFrom = ( pxQueue->u.xQueue.pcTail - pxQueue->uxItemSize );
    2fe2:	eb 81       	ldd	r30, Y+3	; 0x03
    2fe4:	fc 81       	ldd	r31, Y+4	; 0x04
    2fe6:	24 81       	ldd	r18, Z+4	; 0x04
    2fe8:	35 81       	ldd	r19, Z+5	; 0x05
    2fea:	eb 81       	ldd	r30, Y+3	; 0x03
    2fec:	fc 81       	ldd	r31, Y+4	; 0x04
    2fee:	84 8d       	ldd	r24, Z+28	; 0x1c
    2ff0:	88 2f       	mov	r24, r24
    2ff2:	90 e0       	ldi	r25, 0x00	; 0
    2ff4:	90 95       	com	r25
    2ff6:	81 95       	neg	r24
    2ff8:	9f 4f       	sbci	r25, 0xFF	; 255
    2ffa:	82 0f       	add	r24, r18
    2ffc:	93 1f       	adc	r25, r19
    2ffe:	eb 81       	ldd	r30, Y+3	; 0x03
    3000:	fc 81       	ldd	r31, Y+4	; 0x04
    3002:	97 83       	std	Z+7, r25	; 0x07
    3004:	86 83       	std	Z+6, r24	; 0x06
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        if( xPosition == queueOVERWRITE )
    3006:	8f 81       	ldd	r24, Y+7	; 0x07
    3008:	82 30       	cpi	r24, 0x02	; 2
    300a:	31 f4       	brne	.+12     	; 0x3018 <prvCopyDataToQueue+0x12e>
        {
            if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    300c:	89 81       	ldd	r24, Y+1	; 0x01
    300e:	88 23       	and	r24, r24
    3010:	19 f0       	breq	.+6      	; 0x3018 <prvCopyDataToQueue+0x12e>
            {
                /* An item is not being added but overwritten, so subtract
                 * one from the recorded number of items in the queue so when
                 * one is added again below the number of recorded items remains
                 * correct. */
                --uxMessagesWaiting;
    3012:	89 81       	ldd	r24, Y+1	; 0x01
    3014:	81 50       	subi	r24, 0x01	; 1
    3016:	89 83       	std	Y+1, r24	; 0x01
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }

    pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
    3018:	89 81       	ldd	r24, Y+1	; 0x01
    301a:	8f 5f       	subi	r24, 0xFF	; 255
    301c:	eb 81       	ldd	r30, Y+3	; 0x03
    301e:	fc 81       	ldd	r31, Y+4	; 0x04
    3020:	82 8f       	std	Z+26, r24	; 0x1a

    return xReturn;
    3022:	8a 81       	ldd	r24, Y+2	; 0x02
}
    3024:	27 96       	adiw	r28, 0x07	; 7
    3026:	0f b6       	in	r0, 0x3f	; 63
    3028:	f8 94       	cli
    302a:	de bf       	out	0x3e, r29	; 62
    302c:	0f be       	out	0x3f, r0	; 63
    302e:	cd bf       	out	0x3d, r28	; 61
    3030:	cf 91       	pop	r28
    3032:	df 91       	pop	r29
    3034:	08 95       	ret

00003036 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue,
                                  void * const pvBuffer )
{
    3036:	df 93       	push	r29
    3038:	cf 93       	push	r28
    303a:	00 d0       	rcall	.+0      	; 0x303c <prvCopyDataFromQueue+0x6>
    303c:	00 d0       	rcall	.+0      	; 0x303e <prvCopyDataFromQueue+0x8>
    303e:	cd b7       	in	r28, 0x3d	; 61
    3040:	de b7       	in	r29, 0x3e	; 62
    3042:	9a 83       	std	Y+2, r25	; 0x02
    3044:	89 83       	std	Y+1, r24	; 0x01
    3046:	7c 83       	std	Y+4, r23	; 0x04
    3048:	6b 83       	std	Y+3, r22	; 0x03
    if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
    304a:	e9 81       	ldd	r30, Y+1	; 0x01
    304c:	fa 81       	ldd	r31, Y+2	; 0x02
    304e:	84 8d       	ldd	r24, Z+28	; 0x1c
    3050:	88 23       	and	r24, r24
    3052:	89 f1       	breq	.+98     	; 0x30b6 <prvCopyDataFromQueue+0x80>
    {
        pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;           /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
    3054:	e9 81       	ldd	r30, Y+1	; 0x01
    3056:	fa 81       	ldd	r31, Y+2	; 0x02
    3058:	26 81       	ldd	r18, Z+6	; 0x06
    305a:	37 81       	ldd	r19, Z+7	; 0x07
    305c:	e9 81       	ldd	r30, Y+1	; 0x01
    305e:	fa 81       	ldd	r31, Y+2	; 0x02
    3060:	84 8d       	ldd	r24, Z+28	; 0x1c
    3062:	88 2f       	mov	r24, r24
    3064:	90 e0       	ldi	r25, 0x00	; 0
    3066:	82 0f       	add	r24, r18
    3068:	93 1f       	adc	r25, r19
    306a:	e9 81       	ldd	r30, Y+1	; 0x01
    306c:	fa 81       	ldd	r31, Y+2	; 0x02
    306e:	97 83       	std	Z+7, r25	; 0x07
    3070:	86 83       	std	Z+6, r24	; 0x06

        if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
    3072:	e9 81       	ldd	r30, Y+1	; 0x01
    3074:	fa 81       	ldd	r31, Y+2	; 0x02
    3076:	26 81       	ldd	r18, Z+6	; 0x06
    3078:	37 81       	ldd	r19, Z+7	; 0x07
    307a:	e9 81       	ldd	r30, Y+1	; 0x01
    307c:	fa 81       	ldd	r31, Y+2	; 0x02
    307e:	84 81       	ldd	r24, Z+4	; 0x04
    3080:	95 81       	ldd	r25, Z+5	; 0x05
    3082:	28 17       	cp	r18, r24
    3084:	39 07       	cpc	r19, r25
    3086:	40 f0       	brcs	.+16     	; 0x3098 <prvCopyDataFromQueue+0x62>
        {
            pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
    3088:	e9 81       	ldd	r30, Y+1	; 0x01
    308a:	fa 81       	ldd	r31, Y+2	; 0x02
    308c:	80 81       	ld	r24, Z
    308e:	91 81       	ldd	r25, Z+1	; 0x01
    3090:	e9 81       	ldd	r30, Y+1	; 0x01
    3092:	fa 81       	ldd	r31, Y+2	; 0x02
    3094:	97 83       	std	Z+7, r25	; 0x07
    3096:	86 83       	std	Z+6, r24	; 0x06
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        ( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
    3098:	e9 81       	ldd	r30, Y+1	; 0x01
    309a:	fa 81       	ldd	r31, Y+2	; 0x02
    309c:	46 81       	ldd	r20, Z+6	; 0x06
    309e:	57 81       	ldd	r21, Z+7	; 0x07
    30a0:	e9 81       	ldd	r30, Y+1	; 0x01
    30a2:	fa 81       	ldd	r31, Y+2	; 0x02
    30a4:	84 8d       	ldd	r24, Z+28	; 0x1c
    30a6:	28 2f       	mov	r18, r24
    30a8:	30 e0       	ldi	r19, 0x00	; 0
    30aa:	8b 81       	ldd	r24, Y+3	; 0x03
    30ac:	9c 81       	ldd	r25, Y+4	; 0x04
    30ae:	ba 01       	movw	r22, r20
    30b0:	a9 01       	movw	r20, r18
    30b2:	0e 94 18 4b 	call	0x9630	; 0x9630 <memcpy>
    }
}
    30b6:	0f 90       	pop	r0
    30b8:	0f 90       	pop	r0
    30ba:	0f 90       	pop	r0
    30bc:	0f 90       	pop	r0
    30be:	cf 91       	pop	r28
    30c0:	df 91       	pop	r29
    30c2:	08 95       	ret

000030c4 <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
    30c4:	df 93       	push	r29
    30c6:	cf 93       	push	r28
    30c8:	00 d0       	rcall	.+0      	; 0x30ca <prvUnlockQueue+0x6>
    30ca:	00 d0       	rcall	.+0      	; 0x30cc <prvUnlockQueue+0x8>
    30cc:	cd b7       	in	r28, 0x3d	; 61
    30ce:	de b7       	in	r29, 0x3e	; 62
    30d0:	9c 83       	std	Y+4, r25	; 0x04
    30d2:	8b 83       	std	Y+3, r24	; 0x03

    /* The lock counts contains the number of extra data items placed or
     * removed from the queue while the queue was locked.  When a queue is
     * locked items can be added or removed, but the event lists cannot be
     * updated. */
    taskENTER_CRITICAL();
    30d4:	0f b6       	in	r0, 0x3f	; 63
    30d6:	f8 94       	cli
    30d8:	0f 92       	push	r0
    {
        int8_t cTxLock = pxQueue->cTxLock;
    30da:	eb 81       	ldd	r30, Y+3	; 0x03
    30dc:	fc 81       	ldd	r31, Y+4	; 0x04
    30de:	86 8d       	ldd	r24, Z+30	; 0x1e
    30e0:	8a 83       	std	Y+2, r24	; 0x02
    30e2:	11 c0       	rjmp	.+34     	; 0x3106 <prvUnlockQueue+0x42>
                }
            #else /* configUSE_QUEUE_SETS */
                {
                    /* Tasks that are removed from the event list will get added to
                     * the pending ready list as the scheduler is still suspended. */
                    if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    30e4:	eb 81       	ldd	r30, Y+3	; 0x03
    30e6:	fc 81       	ldd	r31, Y+4	; 0x04
    30e8:	81 89       	ldd	r24, Z+17	; 0x11
    30ea:	88 23       	and	r24, r24
    30ec:	79 f0       	breq	.+30     	; 0x310c <prvUnlockQueue+0x48>
                    {
                        if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    30ee:	8b 81       	ldd	r24, Y+3	; 0x03
    30f0:	9c 81       	ldd	r25, Y+4	; 0x04
    30f2:	41 96       	adiw	r24, 0x11	; 17
    30f4:	0e 94 32 23 	call	0x4664	; 0x4664 <xTaskRemoveFromEventList>
    30f8:	88 23       	and	r24, r24
    30fa:	11 f0       	breq	.+4      	; 0x3100 <prvUnlockQueue+0x3c>
                        {
                            /* The task waiting has a higher priority so record that
                             * a context switch is required. */
                            vTaskMissedYield();
    30fc:	0e 94 22 26 	call	0x4c44	; 0x4c44 <vTaskMissedYield>
                        break;
                    }
                }
            #endif /* configUSE_QUEUE_SETS */

            --cTxLock;
    3100:	8a 81       	ldd	r24, Y+2	; 0x02
    3102:	81 50       	subi	r24, 0x01	; 1
    3104:	8a 83       	std	Y+2, r24	; 0x02
    taskENTER_CRITICAL();
    {
        int8_t cTxLock = pxQueue->cTxLock;

        /* See if data was added to the queue while it was locked. */
        while( cTxLock > queueLOCKED_UNMODIFIED )
    3106:	8a 81       	ldd	r24, Y+2	; 0x02
    3108:	18 16       	cp	r1, r24
    310a:	64 f3       	brlt	.-40     	; 0x30e4 <prvUnlockQueue+0x20>
            #endif /* configUSE_QUEUE_SETS */

            --cTxLock;
        }

        pxQueue->cTxLock = queueUNLOCKED;
    310c:	eb 81       	ldd	r30, Y+3	; 0x03
    310e:	fc 81       	ldd	r31, Y+4	; 0x04
    3110:	8f ef       	ldi	r24, 0xFF	; 255
    3112:	86 8f       	std	Z+30, r24	; 0x1e
    }
    taskEXIT_CRITICAL();
    3114:	0f 90       	pop	r0
    3116:	0f be       	out	0x3f, r0	; 63

    /* Do the same for the Rx lock. */
    taskENTER_CRITICAL();
    3118:	0f b6       	in	r0, 0x3f	; 63
    311a:	f8 94       	cli
    311c:	0f 92       	push	r0
    {
        int8_t cRxLock = pxQueue->cRxLock;
    311e:	eb 81       	ldd	r30, Y+3	; 0x03
    3120:	fc 81       	ldd	r31, Y+4	; 0x04
    3122:	85 8d       	ldd	r24, Z+29	; 0x1d
    3124:	89 83       	std	Y+1, r24	; 0x01
    3126:	11 c0       	rjmp	.+34     	; 0x314a <prvUnlockQueue+0x86>

        while( cRxLock > queueLOCKED_UNMODIFIED )
        {
            if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    3128:	eb 81       	ldd	r30, Y+3	; 0x03
    312a:	fc 81       	ldd	r31, Y+4	; 0x04
    312c:	80 85       	ldd	r24, Z+8	; 0x08
    312e:	88 23       	and	r24, r24
    3130:	79 f0       	breq	.+30     	; 0x3150 <prvUnlockQueue+0x8c>
            {
                if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    3132:	8b 81       	ldd	r24, Y+3	; 0x03
    3134:	9c 81       	ldd	r25, Y+4	; 0x04
    3136:	08 96       	adiw	r24, 0x08	; 8
    3138:	0e 94 32 23 	call	0x4664	; 0x4664 <xTaskRemoveFromEventList>
    313c:	88 23       	and	r24, r24
    313e:	11 f0       	breq	.+4      	; 0x3144 <prvUnlockQueue+0x80>
                {
                    vTaskMissedYield();
    3140:	0e 94 22 26 	call	0x4c44	; 0x4c44 <vTaskMissedYield>
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                --cRxLock;
    3144:	89 81       	ldd	r24, Y+1	; 0x01
    3146:	81 50       	subi	r24, 0x01	; 1
    3148:	89 83       	std	Y+1, r24	; 0x01
    /* Do the same for the Rx lock. */
    taskENTER_CRITICAL();
    {
        int8_t cRxLock = pxQueue->cRxLock;

        while( cRxLock > queueLOCKED_UNMODIFIED )
    314a:	89 81       	ldd	r24, Y+1	; 0x01
    314c:	18 16       	cp	r1, r24
    314e:	64 f3       	brlt	.-40     	; 0x3128 <prvUnlockQueue+0x64>
            {
                break;
            }
        }

        pxQueue->cRxLock = queueUNLOCKED;
    3150:	eb 81       	ldd	r30, Y+3	; 0x03
    3152:	fc 81       	ldd	r31, Y+4	; 0x04
    3154:	8f ef       	ldi	r24, 0xFF	; 255
    3156:	85 8f       	std	Z+29, r24	; 0x1d
    }
    taskEXIT_CRITICAL();
    3158:	0f 90       	pop	r0
    315a:	0f be       	out	0x3f, r0	; 63
}
    315c:	0f 90       	pop	r0
    315e:	0f 90       	pop	r0
    3160:	0f 90       	pop	r0
    3162:	0f 90       	pop	r0
    3164:	cf 91       	pop	r28
    3166:	df 91       	pop	r29
    3168:	08 95       	ret

0000316a <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueEmpty( const Queue_t * pxQueue )
{
    316a:	df 93       	push	r29
    316c:	cf 93       	push	r28
    316e:	00 d0       	rcall	.+0      	; 0x3170 <prvIsQueueEmpty+0x6>
    3170:	0f 92       	push	r0
    3172:	cd b7       	in	r28, 0x3d	; 61
    3174:	de b7       	in	r29, 0x3e	; 62
    3176:	9b 83       	std	Y+3, r25	; 0x03
    3178:	8a 83       	std	Y+2, r24	; 0x02
    BaseType_t xReturn;

    taskENTER_CRITICAL();
    317a:	0f b6       	in	r0, 0x3f	; 63
    317c:	f8 94       	cli
    317e:	0f 92       	push	r0
    {
        if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    3180:	ea 81       	ldd	r30, Y+2	; 0x02
    3182:	fb 81       	ldd	r31, Y+3	; 0x03
    3184:	82 8d       	ldd	r24, Z+26	; 0x1a
    3186:	88 23       	and	r24, r24
    3188:	19 f4       	brne	.+6      	; 0x3190 <prvIsQueueEmpty+0x26>
        {
            xReturn = pdTRUE;
    318a:	81 e0       	ldi	r24, 0x01	; 1
    318c:	89 83       	std	Y+1, r24	; 0x01
    318e:	01 c0       	rjmp	.+2      	; 0x3192 <prvIsQueueEmpty+0x28>
        }
        else
        {
            xReturn = pdFALSE;
    3190:	19 82       	std	Y+1, r1	; 0x01
        }
    }
    taskEXIT_CRITICAL();
    3192:	0f 90       	pop	r0
    3194:	0f be       	out	0x3f, r0	; 63

    return xReturn;
    3196:	89 81       	ldd	r24, Y+1	; 0x01
}
    3198:	0f 90       	pop	r0
    319a:	0f 90       	pop	r0
    319c:	0f 90       	pop	r0
    319e:	cf 91       	pop	r28
    31a0:	df 91       	pop	r29
    31a2:	08 95       	ret

000031a4 <xQueueIsQueueEmptyFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )
{
    31a4:	df 93       	push	r29
    31a6:	cf 93       	push	r28
    31a8:	00 d0       	rcall	.+0      	; 0x31aa <xQueueIsQueueEmptyFromISR+0x6>
    31aa:	00 d0       	rcall	.+0      	; 0x31ac <xQueueIsQueueEmptyFromISR+0x8>
    31ac:	0f 92       	push	r0
    31ae:	cd b7       	in	r28, 0x3d	; 61
    31b0:	de b7       	in	r29, 0x3e	; 62
    31b2:	9d 83       	std	Y+5, r25	; 0x05
    31b4:	8c 83       	std	Y+4, r24	; 0x04
    BaseType_t xReturn;
    Queue_t * const pxQueue = xQueue;
    31b6:	8c 81       	ldd	r24, Y+4	; 0x04
    31b8:	9d 81       	ldd	r25, Y+5	; 0x05
    31ba:	9a 83       	std	Y+2, r25	; 0x02
    31bc:	89 83       	std	Y+1, r24	; 0x01

    configASSERT( pxQueue );

    if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    31be:	e9 81       	ldd	r30, Y+1	; 0x01
    31c0:	fa 81       	ldd	r31, Y+2	; 0x02
    31c2:	82 8d       	ldd	r24, Z+26	; 0x1a
    31c4:	88 23       	and	r24, r24
    31c6:	19 f4       	brne	.+6      	; 0x31ce <xQueueIsQueueEmptyFromISR+0x2a>
    {
        xReturn = pdTRUE;
    31c8:	81 e0       	ldi	r24, 0x01	; 1
    31ca:	8b 83       	std	Y+3, r24	; 0x03
    31cc:	01 c0       	rjmp	.+2      	; 0x31d0 <xQueueIsQueueEmptyFromISR+0x2c>
    }
    else
    {
        xReturn = pdFALSE;
    31ce:	1b 82       	std	Y+3, r1	; 0x03
    }

    return xReturn;
    31d0:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    31d2:	0f 90       	pop	r0
    31d4:	0f 90       	pop	r0
    31d6:	0f 90       	pop	r0
    31d8:	0f 90       	pop	r0
    31da:	0f 90       	pop	r0
    31dc:	cf 91       	pop	r28
    31de:	df 91       	pop	r29
    31e0:	08 95       	ret

000031e2 <prvIsQueueFull>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueFull( const Queue_t * pxQueue )
{
    31e2:	df 93       	push	r29
    31e4:	cf 93       	push	r28
    31e6:	00 d0       	rcall	.+0      	; 0x31e8 <prvIsQueueFull+0x6>
    31e8:	0f 92       	push	r0
    31ea:	cd b7       	in	r28, 0x3d	; 61
    31ec:	de b7       	in	r29, 0x3e	; 62
    31ee:	9b 83       	std	Y+3, r25	; 0x03
    31f0:	8a 83       	std	Y+2, r24	; 0x02
    BaseType_t xReturn;

    taskENTER_CRITICAL();
    31f2:	0f b6       	in	r0, 0x3f	; 63
    31f4:	f8 94       	cli
    31f6:	0f 92       	push	r0
    {
        if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    31f8:	ea 81       	ldd	r30, Y+2	; 0x02
    31fa:	fb 81       	ldd	r31, Y+3	; 0x03
    31fc:	92 8d       	ldd	r25, Z+26	; 0x1a
    31fe:	ea 81       	ldd	r30, Y+2	; 0x02
    3200:	fb 81       	ldd	r31, Y+3	; 0x03
    3202:	83 8d       	ldd	r24, Z+27	; 0x1b
    3204:	98 17       	cp	r25, r24
    3206:	19 f4       	brne	.+6      	; 0x320e <prvIsQueueFull+0x2c>
        {
            xReturn = pdTRUE;
    3208:	81 e0       	ldi	r24, 0x01	; 1
    320a:	89 83       	std	Y+1, r24	; 0x01
    320c:	01 c0       	rjmp	.+2      	; 0x3210 <prvIsQueueFull+0x2e>
        }
        else
        {
            xReturn = pdFALSE;
    320e:	19 82       	std	Y+1, r1	; 0x01
        }
    }
    taskEXIT_CRITICAL();
    3210:	0f 90       	pop	r0
    3212:	0f be       	out	0x3f, r0	; 63

    return xReturn;
    3214:	89 81       	ldd	r24, Y+1	; 0x01
}
    3216:	0f 90       	pop	r0
    3218:	0f 90       	pop	r0
    321a:	0f 90       	pop	r0
    321c:	cf 91       	pop	r28
    321e:	df 91       	pop	r29
    3220:	08 95       	ret

00003222 <xQueueIsQueueFullFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
{
    3222:	df 93       	push	r29
    3224:	cf 93       	push	r28
    3226:	00 d0       	rcall	.+0      	; 0x3228 <xQueueIsQueueFullFromISR+0x6>
    3228:	00 d0       	rcall	.+0      	; 0x322a <xQueueIsQueueFullFromISR+0x8>
    322a:	0f 92       	push	r0
    322c:	cd b7       	in	r28, 0x3d	; 61
    322e:	de b7       	in	r29, 0x3e	; 62
    3230:	9d 83       	std	Y+5, r25	; 0x05
    3232:	8c 83       	std	Y+4, r24	; 0x04
    BaseType_t xReturn;
    Queue_t * const pxQueue = xQueue;
    3234:	8c 81       	ldd	r24, Y+4	; 0x04
    3236:	9d 81       	ldd	r25, Y+5	; 0x05
    3238:	9a 83       	std	Y+2, r25	; 0x02
    323a:	89 83       	std	Y+1, r24	; 0x01

    configASSERT( pxQueue );

    if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    323c:	e9 81       	ldd	r30, Y+1	; 0x01
    323e:	fa 81       	ldd	r31, Y+2	; 0x02
    3240:	92 8d       	ldd	r25, Z+26	; 0x1a
    3242:	e9 81       	ldd	r30, Y+1	; 0x01
    3244:	fa 81       	ldd	r31, Y+2	; 0x02
    3246:	83 8d       	ldd	r24, Z+27	; 0x1b
    3248:	98 17       	cp	r25, r24
    324a:	19 f4       	brne	.+6      	; 0x3252 <xQueueIsQueueFullFromISR+0x30>
    {
        xReturn = pdTRUE;
    324c:	81 e0       	ldi	r24, 0x01	; 1
    324e:	8b 83       	std	Y+3, r24	; 0x03
    3250:	01 c0       	rjmp	.+2      	; 0x3254 <xQueueIsQueueFullFromISR+0x32>
    }
    else
    {
        xReturn = pdFALSE;
    3252:	1b 82       	std	Y+3, r1	; 0x03
    }

    return xReturn;
    3254:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    3256:	0f 90       	pop	r0
    3258:	0f 90       	pop	r0
    325a:	0f 90       	pop	r0
    325c:	0f 90       	pop	r0
    325e:	0f 90       	pop	r0
    3260:	cf 91       	pop	r28
    3262:	df 91       	pop	r29
    3264:	08 95       	ret

00003266 <xQueueCRSend>:
#if ( configUSE_CO_ROUTINES == 1 )

    BaseType_t xQueueCRSend( QueueHandle_t xQueue,
                             const void * pvItemToQueue,
                             TickType_t xTicksToWait )
    {
    3266:	df 93       	push	r29
    3268:	cf 93       	push	r28
    326a:	cd b7       	in	r28, 0x3d	; 61
    326c:	de b7       	in	r29, 0x3e	; 62
    326e:	2a 97       	sbiw	r28, 0x0a	; 10
    3270:	0f b6       	in	r0, 0x3f	; 63
    3272:	f8 94       	cli
    3274:	de bf       	out	0x3e, r29	; 62
    3276:	0f be       	out	0x3f, r0	; 63
    3278:	cd bf       	out	0x3d, r28	; 61
    327a:	9d 83       	std	Y+5, r25	; 0x05
    327c:	8c 83       	std	Y+4, r24	; 0x04
    327e:	7f 83       	std	Y+7, r23	; 0x07
    3280:	6e 83       	std	Y+6, r22	; 0x06
    3282:	59 87       	std	Y+9, r21	; 0x09
    3284:	48 87       	std	Y+8, r20	; 0x08
        BaseType_t xReturn;
        Queue_t * const pxQueue = xQueue;
    3286:	8c 81       	ldd	r24, Y+4	; 0x04
    3288:	9d 81       	ldd	r25, Y+5	; 0x05
    328a:	9a 83       	std	Y+2, r25	; 0x02
    328c:	89 83       	std	Y+1, r24	; 0x01

        /* If the queue is already full we may have to block.  A critical section
         * is required to prevent an interrupt removing something from the queue
         * between the check to see if the queue is full and blocking on the queue. */
        portDISABLE_INTERRUPTS();
    328e:	f8 94       	cli
        {
            if( prvIsQueueFull( pxQueue ) != pdFALSE )
    3290:	89 81       	ldd	r24, Y+1	; 0x01
    3292:	9a 81       	ldd	r25, Y+2	; 0x02
    3294:	0e 94 f1 18 	call	0x31e2	; 0x31e2 <prvIsQueueFull>
    3298:	88 23       	and	r24, r24
    329a:	a9 f0       	breq	.+42     	; 0x32c6 <xQueueCRSend+0x60>
            {
                /* The queue is full - do we want to block or just leave without
                 * posting? */
                if( xTicksToWait > ( TickType_t ) 0 )
    329c:	88 85       	ldd	r24, Y+8	; 0x08
    329e:	99 85       	ldd	r25, Y+9	; 0x09
    32a0:	00 97       	sbiw	r24, 0x00	; 0
    32a2:	71 f0       	breq	.+28     	; 0x32c0 <xQueueCRSend+0x5a>
                {
                    /* As this is called from a coroutine we cannot block directly, but
                     * return indicating that we need to block. */
                    vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToSend ) );
    32a4:	89 81       	ldd	r24, Y+1	; 0x01
    32a6:	9a 81       	ldd	r25, Y+2	; 0x02
    32a8:	9c 01       	movw	r18, r24
    32aa:	28 5f       	subi	r18, 0xF8	; 248
    32ac:	3f 4f       	sbci	r19, 0xFF	; 255
    32ae:	88 85       	ldd	r24, Y+8	; 0x08
    32b0:	99 85       	ldd	r25, Y+9	; 0x09
    32b2:	b9 01       	movw	r22, r18
    32b4:	0e 94 ff 0a 	call	0x15fe	; 0x15fe <vCoRoutineAddToDelayedList>
                    portENABLE_INTERRUPTS();
    32b8:	78 94       	sei
                    return errQUEUE_BLOCKED;
    32ba:	8c ef       	ldi	r24, 0xFC	; 252
    32bc:	8a 87       	std	Y+10, r24	; 0x0a
    32be:	2a c0       	rjmp	.+84     	; 0x3314 <xQueueCRSend+0xae>
                }
                else
                {
                    portENABLE_INTERRUPTS();
    32c0:	78 94       	sei
                    return errQUEUE_FULL;
    32c2:	1a 86       	std	Y+10, r1	; 0x0a
    32c4:	27 c0       	rjmp	.+78     	; 0x3314 <xQueueCRSend+0xae>
                }
            }
        }
        portENABLE_INTERRUPTS();
    32c6:	78 94       	sei

        portDISABLE_INTERRUPTS();
    32c8:	f8 94       	cli
        {
            if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    32ca:	e9 81       	ldd	r30, Y+1	; 0x01
    32cc:	fa 81       	ldd	r31, Y+2	; 0x02
    32ce:	92 8d       	ldd	r25, Z+26	; 0x1a
    32d0:	e9 81       	ldd	r30, Y+1	; 0x01
    32d2:	fa 81       	ldd	r31, Y+2	; 0x02
    32d4:	83 8d       	ldd	r24, Z+27	; 0x1b
    32d6:	98 17       	cp	r25, r24
    32d8:	c8 f4       	brcc	.+50     	; 0x330c <xQueueCRSend+0xa6>
            {
                /* There is room in the queue, copy the data into the queue. */
                prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
    32da:	89 81       	ldd	r24, Y+1	; 0x01
    32dc:	9a 81       	ldd	r25, Y+2	; 0x02
    32de:	2e 81       	ldd	r18, Y+6	; 0x06
    32e0:	3f 81       	ldd	r19, Y+7	; 0x07
    32e2:	b9 01       	movw	r22, r18
    32e4:	40 e0       	ldi	r20, 0x00	; 0
    32e6:	0e 94 75 17 	call	0x2eea	; 0x2eea <prvCopyDataToQueue>
                xReturn = pdPASS;
    32ea:	81 e0       	ldi	r24, 0x01	; 1
    32ec:	8b 83       	std	Y+3, r24	; 0x03

                /* Were any co-routines waiting for data to become available? */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    32ee:	e9 81       	ldd	r30, Y+1	; 0x01
    32f0:	fa 81       	ldd	r31, Y+2	; 0x02
    32f2:	81 89       	ldd	r24, Z+17	; 0x11
    32f4:	88 23       	and	r24, r24
    32f6:	59 f0       	breq	.+22     	; 0x330e <xQueueCRSend+0xa8>
                {
                    /* In this instance the co-routine could be placed directly
                     * into the ready list as we are within a critical section.
                     * Instead the same pending ready list mechanism is used as if
                     * the event were caused from within an interrupt. */
                    if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    32f8:	89 81       	ldd	r24, Y+1	; 0x01
    32fa:	9a 81       	ldd	r25, Y+2	; 0x02
    32fc:	41 96       	adiw	r24, 0x11	; 17
    32fe:	0e 94 12 0d 	call	0x1a24	; 0x1a24 <xCoRoutineRemoveFromEventList>
    3302:	88 23       	and	r24, r24
    3304:	21 f0       	breq	.+8      	; 0x330e <xQueueCRSend+0xa8>
                    {
                        /* The co-routine waiting has a higher priority so record
                         * that a yield might be appropriate. */
                        xReturn = errQUEUE_YIELD;
    3306:	8b ef       	ldi	r24, 0xFB	; 251
    3308:	8b 83       	std	Y+3, r24	; 0x03
    330a:	01 c0       	rjmp	.+2      	; 0x330e <xQueueCRSend+0xa8>
                    mtCOVERAGE_TEST_MARKER();
                }
            }
            else
            {
                xReturn = errQUEUE_FULL;
    330c:	1b 82       	std	Y+3, r1	; 0x03
            }
        }
        portENABLE_INTERRUPTS();
    330e:	78 94       	sei

        return xReturn;
    3310:	8b 81       	ldd	r24, Y+3	; 0x03
    3312:	8a 87       	std	Y+10, r24	; 0x0a
    3314:	8a 85       	ldd	r24, Y+10	; 0x0a
    }
    3316:	2a 96       	adiw	r28, 0x0a	; 10
    3318:	0f b6       	in	r0, 0x3f	; 63
    331a:	f8 94       	cli
    331c:	de bf       	out	0x3e, r29	; 62
    331e:	0f be       	out	0x3f, r0	; 63
    3320:	cd bf       	out	0x3d, r28	; 61
    3322:	cf 91       	pop	r28
    3324:	df 91       	pop	r29
    3326:	08 95       	ret

00003328 <xQueueCRReceive>:
#if ( configUSE_CO_ROUTINES == 1 )

    BaseType_t xQueueCRReceive( QueueHandle_t xQueue,
                                void * pvBuffer,
                                TickType_t xTicksToWait )
    {
    3328:	df 93       	push	r29
    332a:	cf 93       	push	r28
    332c:	cd b7       	in	r28, 0x3d	; 61
    332e:	de b7       	in	r29, 0x3e	; 62
    3330:	2a 97       	sbiw	r28, 0x0a	; 10
    3332:	0f b6       	in	r0, 0x3f	; 63
    3334:	f8 94       	cli
    3336:	de bf       	out	0x3e, r29	; 62
    3338:	0f be       	out	0x3f, r0	; 63
    333a:	cd bf       	out	0x3d, r28	; 61
    333c:	9d 83       	std	Y+5, r25	; 0x05
    333e:	8c 83       	std	Y+4, r24	; 0x04
    3340:	7f 83       	std	Y+7, r23	; 0x07
    3342:	6e 83       	std	Y+6, r22	; 0x06
    3344:	59 87       	std	Y+9, r21	; 0x09
    3346:	48 87       	std	Y+8, r20	; 0x08
        BaseType_t xReturn;
        Queue_t * const pxQueue = xQueue;
    3348:	8c 81       	ldd	r24, Y+4	; 0x04
    334a:	9d 81       	ldd	r25, Y+5	; 0x05
    334c:	9a 83       	std	Y+2, r25	; 0x02
    334e:	89 83       	std	Y+1, r24	; 0x01

        /* If the queue is already empty we may have to block.  A critical section
         * is required to prevent an interrupt adding something to the queue
         * between the check to see if the queue is empty and blocking on the queue. */
        portDISABLE_INTERRUPTS();
    3350:	f8 94       	cli
        {
            if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    3352:	e9 81       	ldd	r30, Y+1	; 0x01
    3354:	fa 81       	ldd	r31, Y+2	; 0x02
    3356:	82 8d       	ldd	r24, Z+26	; 0x1a
    3358:	88 23       	and	r24, r24
    335a:	a9 f4       	brne	.+42     	; 0x3386 <xQueueCRReceive+0x5e>
            {
                /* There are no messages in the queue, do we want to block or just
                 * leave with nothing? */
                if( xTicksToWait > ( TickType_t ) 0 )
    335c:	88 85       	ldd	r24, Y+8	; 0x08
    335e:	99 85       	ldd	r25, Y+9	; 0x09
    3360:	00 97       	sbiw	r24, 0x00	; 0
    3362:	71 f0       	breq	.+28     	; 0x3380 <xQueueCRReceive+0x58>
                {
                    /* As this is a co-routine we cannot block directly, but return
                     * indicating that we need to block. */
                    vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToReceive ) );
    3364:	89 81       	ldd	r24, Y+1	; 0x01
    3366:	9a 81       	ldd	r25, Y+2	; 0x02
    3368:	9c 01       	movw	r18, r24
    336a:	2f 5e       	subi	r18, 0xEF	; 239
    336c:	3f 4f       	sbci	r19, 0xFF	; 255
    336e:	88 85       	ldd	r24, Y+8	; 0x08
    3370:	99 85       	ldd	r25, Y+9	; 0x09
    3372:	b9 01       	movw	r22, r18
    3374:	0e 94 ff 0a 	call	0x15fe	; 0x15fe <vCoRoutineAddToDelayedList>
                    portENABLE_INTERRUPTS();
    3378:	78 94       	sei
                    return errQUEUE_BLOCKED;
    337a:	8c ef       	ldi	r24, 0xFC	; 252
    337c:	8a 87       	std	Y+10, r24	; 0x0a
    337e:	58 c0       	rjmp	.+176    	; 0x3430 <xQueueCRReceive+0x108>
                }
                else
                {
                    portENABLE_INTERRUPTS();
    3380:	78 94       	sei
                    return errQUEUE_FULL;
    3382:	1a 86       	std	Y+10, r1	; 0x0a
    3384:	55 c0       	rjmp	.+170    	; 0x3430 <xQueueCRReceive+0x108>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        portENABLE_INTERRUPTS();
    3386:	78 94       	sei

        portDISABLE_INTERRUPTS();
    3388:	f8 94       	cli
        {
            if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    338a:	e9 81       	ldd	r30, Y+1	; 0x01
    338c:	fa 81       	ldd	r31, Y+2	; 0x02
    338e:	82 8d       	ldd	r24, Z+26	; 0x1a
    3390:	88 23       	and	r24, r24
    3392:	09 f4       	brne	.+2      	; 0x3396 <xQueueCRReceive+0x6e>
    3394:	49 c0       	rjmp	.+146    	; 0x3428 <xQueueCRReceive+0x100>
            {
                /* Data is available from the queue. */
                pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;
    3396:	e9 81       	ldd	r30, Y+1	; 0x01
    3398:	fa 81       	ldd	r31, Y+2	; 0x02
    339a:	26 81       	ldd	r18, Z+6	; 0x06
    339c:	37 81       	ldd	r19, Z+7	; 0x07
    339e:	e9 81       	ldd	r30, Y+1	; 0x01
    33a0:	fa 81       	ldd	r31, Y+2	; 0x02
    33a2:	84 8d       	ldd	r24, Z+28	; 0x1c
    33a4:	88 2f       	mov	r24, r24
    33a6:	90 e0       	ldi	r25, 0x00	; 0
    33a8:	82 0f       	add	r24, r18
    33aa:	93 1f       	adc	r25, r19
    33ac:	e9 81       	ldd	r30, Y+1	; 0x01
    33ae:	fa 81       	ldd	r31, Y+2	; 0x02
    33b0:	97 83       	std	Z+7, r25	; 0x07
    33b2:	86 83       	std	Z+6, r24	; 0x06

                if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail )
    33b4:	e9 81       	ldd	r30, Y+1	; 0x01
    33b6:	fa 81       	ldd	r31, Y+2	; 0x02
    33b8:	26 81       	ldd	r18, Z+6	; 0x06
    33ba:	37 81       	ldd	r19, Z+7	; 0x07
    33bc:	e9 81       	ldd	r30, Y+1	; 0x01
    33be:	fa 81       	ldd	r31, Y+2	; 0x02
    33c0:	84 81       	ldd	r24, Z+4	; 0x04
    33c2:	95 81       	ldd	r25, Z+5	; 0x05
    33c4:	28 17       	cp	r18, r24
    33c6:	39 07       	cpc	r19, r25
    33c8:	40 f0       	brcs	.+16     	; 0x33da <xQueueCRReceive+0xb2>
                {
                    pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
    33ca:	e9 81       	ldd	r30, Y+1	; 0x01
    33cc:	fa 81       	ldd	r31, Y+2	; 0x02
    33ce:	80 81       	ld	r24, Z
    33d0:	91 81       	ldd	r25, Z+1	; 0x01
    33d2:	e9 81       	ldd	r30, Y+1	; 0x01
    33d4:	fa 81       	ldd	r31, Y+2	; 0x02
    33d6:	97 83       	std	Z+7, r25	; 0x07
    33d8:	86 83       	std	Z+6, r24	; 0x06
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                --( pxQueue->uxMessagesWaiting );
    33da:	e9 81       	ldd	r30, Y+1	; 0x01
    33dc:	fa 81       	ldd	r31, Y+2	; 0x02
    33de:	82 8d       	ldd	r24, Z+26	; 0x1a
    33e0:	81 50       	subi	r24, 0x01	; 1
    33e2:	e9 81       	ldd	r30, Y+1	; 0x01
    33e4:	fa 81       	ldd	r31, Y+2	; 0x02
    33e6:	82 8f       	std	Z+26, r24	; 0x1a
                ( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    33e8:	e9 81       	ldd	r30, Y+1	; 0x01
    33ea:	fa 81       	ldd	r31, Y+2	; 0x02
    33ec:	46 81       	ldd	r20, Z+6	; 0x06
    33ee:	57 81       	ldd	r21, Z+7	; 0x07
    33f0:	e9 81       	ldd	r30, Y+1	; 0x01
    33f2:	fa 81       	ldd	r31, Y+2	; 0x02
    33f4:	84 8d       	ldd	r24, Z+28	; 0x1c
    33f6:	28 2f       	mov	r18, r24
    33f8:	30 e0       	ldi	r19, 0x00	; 0
    33fa:	8e 81       	ldd	r24, Y+6	; 0x06
    33fc:	9f 81       	ldd	r25, Y+7	; 0x07
    33fe:	ba 01       	movw	r22, r20
    3400:	a9 01       	movw	r20, r18
    3402:	0e 94 18 4b 	call	0x9630	; 0x9630 <memcpy>

                xReturn = pdPASS;
    3406:	81 e0       	ldi	r24, 0x01	; 1
    3408:	8b 83       	std	Y+3, r24	; 0x03

                /* Were any co-routines waiting for space to become available? */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    340a:	e9 81       	ldd	r30, Y+1	; 0x01
    340c:	fa 81       	ldd	r31, Y+2	; 0x02
    340e:	80 85       	ldd	r24, Z+8	; 0x08
    3410:	88 23       	and	r24, r24
    3412:	59 f0       	breq	.+22     	; 0x342a <xQueueCRReceive+0x102>
                {
                    /* In this instance the co-routine could be placed directly
                     * into the ready list as we are within a critical section.
                     * Instead the same pending ready list mechanism is used as if
                     * the event were caused from within an interrupt. */
                    if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    3414:	89 81       	ldd	r24, Y+1	; 0x01
    3416:	9a 81       	ldd	r25, Y+2	; 0x02
    3418:	08 96       	adiw	r24, 0x08	; 8
    341a:	0e 94 12 0d 	call	0x1a24	; 0x1a24 <xCoRoutineRemoveFromEventList>
    341e:	88 23       	and	r24, r24
    3420:	21 f0       	breq	.+8      	; 0x342a <xQueueCRReceive+0x102>
                    {
                        xReturn = errQUEUE_YIELD;
    3422:	8b ef       	ldi	r24, 0xFB	; 251
    3424:	8b 83       	std	Y+3, r24	; 0x03
    3426:	01 c0       	rjmp	.+2      	; 0x342a <xQueueCRReceive+0x102>
                    mtCOVERAGE_TEST_MARKER();
                }
            }
            else
            {
                xReturn = pdFAIL;
    3428:	1b 82       	std	Y+3, r1	; 0x03
            }
        }
        portENABLE_INTERRUPTS();
    342a:	78 94       	sei

        return xReturn;
    342c:	8b 81       	ldd	r24, Y+3	; 0x03
    342e:	8a 87       	std	Y+10, r24	; 0x0a
    3430:	8a 85       	ldd	r24, Y+10	; 0x0a
    }
    3432:	2a 96       	adiw	r28, 0x0a	; 10
    3434:	0f b6       	in	r0, 0x3f	; 63
    3436:	f8 94       	cli
    3438:	de bf       	out	0x3e, r29	; 62
    343a:	0f be       	out	0x3f, r0	; 63
    343c:	cd bf       	out	0x3d, r28	; 61
    343e:	cf 91       	pop	r28
    3440:	df 91       	pop	r29
    3442:	08 95       	ret

00003444 <xQueueCRSendFromISR>:
#if ( configUSE_CO_ROUTINES == 1 )

    BaseType_t xQueueCRSendFromISR( QueueHandle_t xQueue,
                                    const void * pvItemToQueue,
                                    BaseType_t xCoRoutinePreviouslyWoken )
    {
    3444:	df 93       	push	r29
    3446:	cf 93       	push	r28
    3448:	cd b7       	in	r28, 0x3d	; 61
    344a:	de b7       	in	r29, 0x3e	; 62
    344c:	28 97       	sbiw	r28, 0x08	; 8
    344e:	0f b6       	in	r0, 0x3f	; 63
    3450:	f8 94       	cli
    3452:	de bf       	out	0x3e, r29	; 62
    3454:	0f be       	out	0x3f, r0	; 63
    3456:	cd bf       	out	0x3d, r28	; 61
    3458:	9c 83       	std	Y+4, r25	; 0x04
    345a:	8b 83       	std	Y+3, r24	; 0x03
    345c:	7e 83       	std	Y+6, r23	; 0x06
    345e:	6d 83       	std	Y+5, r22	; 0x05
    3460:	4f 83       	std	Y+7, r20	; 0x07
        Queue_t * const pxQueue = xQueue;
    3462:	8b 81       	ldd	r24, Y+3	; 0x03
    3464:	9c 81       	ldd	r25, Y+4	; 0x04
    3466:	9a 83       	std	Y+2, r25	; 0x02
    3468:	89 83       	std	Y+1, r24	; 0x01

        /* Cannot block within an ISR so if there is no space on the queue then
         * exit without doing anything. */
        if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    346a:	e9 81       	ldd	r30, Y+1	; 0x01
    346c:	fa 81       	ldd	r31, Y+2	; 0x02
    346e:	92 8d       	ldd	r25, Z+26	; 0x1a
    3470:	e9 81       	ldd	r30, Y+1	; 0x01
    3472:	fa 81       	ldd	r31, Y+2	; 0x02
    3474:	83 8d       	ldd	r24, Z+27	; 0x1b
    3476:	98 17       	cp	r25, r24
    3478:	d0 f4       	brcc	.+52     	; 0x34ae <xQueueCRSendFromISR+0x6a>
        {
            prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
    347a:	89 81       	ldd	r24, Y+1	; 0x01
    347c:	9a 81       	ldd	r25, Y+2	; 0x02
    347e:	2d 81       	ldd	r18, Y+5	; 0x05
    3480:	3e 81       	ldd	r19, Y+6	; 0x06
    3482:	b9 01       	movw	r22, r18
    3484:	40 e0       	ldi	r20, 0x00	; 0
    3486:	0e 94 75 17 	call	0x2eea	; 0x2eea <prvCopyDataToQueue>

            /* We only want to wake one co-routine per ISR, so check that a
             * co-routine has not already been woken. */
            if( xCoRoutinePreviouslyWoken == pdFALSE )
    348a:	8f 81       	ldd	r24, Y+7	; 0x07
    348c:	88 23       	and	r24, r24
    348e:	79 f4       	brne	.+30     	; 0x34ae <xQueueCRSendFromISR+0x6a>
            {
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    3490:	e9 81       	ldd	r30, Y+1	; 0x01
    3492:	fa 81       	ldd	r31, Y+2	; 0x02
    3494:	81 89       	ldd	r24, Z+17	; 0x11
    3496:	88 23       	and	r24, r24
    3498:	51 f0       	breq	.+20     	; 0x34ae <xQueueCRSendFromISR+0x6a>
                {
                    if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    349a:	89 81       	ldd	r24, Y+1	; 0x01
    349c:	9a 81       	ldd	r25, Y+2	; 0x02
    349e:	41 96       	adiw	r24, 0x11	; 17
    34a0:	0e 94 12 0d 	call	0x1a24	; 0x1a24 <xCoRoutineRemoveFromEventList>
    34a4:	88 23       	and	r24, r24
    34a6:	19 f0       	breq	.+6      	; 0x34ae <xQueueCRSendFromISR+0x6a>
                    {
                        return pdTRUE;
    34a8:	81 e0       	ldi	r24, 0x01	; 1
    34aa:	88 87       	std	Y+8, r24	; 0x08
    34ac:	02 c0       	rjmp	.+4      	; 0x34b2 <xQueueCRSendFromISR+0x6e>
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        return xCoRoutinePreviouslyWoken;
    34ae:	8f 81       	ldd	r24, Y+7	; 0x07
    34b0:	88 87       	std	Y+8, r24	; 0x08
    34b2:	88 85       	ldd	r24, Y+8	; 0x08
    }
    34b4:	28 96       	adiw	r28, 0x08	; 8
    34b6:	0f b6       	in	r0, 0x3f	; 63
    34b8:	f8 94       	cli
    34ba:	de bf       	out	0x3e, r29	; 62
    34bc:	0f be       	out	0x3f, r0	; 63
    34be:	cd bf       	out	0x3d, r28	; 61
    34c0:	cf 91       	pop	r28
    34c2:	df 91       	pop	r29
    34c4:	08 95       	ret

000034c6 <xQueueCRReceiveFromISR>:
#if ( configUSE_CO_ROUTINES == 1 )

    BaseType_t xQueueCRReceiveFromISR( QueueHandle_t xQueue,
                                       void * pvBuffer,
                                       BaseType_t * pxCoRoutineWoken )
    {
    34c6:	df 93       	push	r29
    34c8:	cf 93       	push	r28
    34ca:	cd b7       	in	r28, 0x3d	; 61
    34cc:	de b7       	in	r29, 0x3e	; 62
    34ce:	29 97       	sbiw	r28, 0x09	; 9
    34d0:	0f b6       	in	r0, 0x3f	; 63
    34d2:	f8 94       	cli
    34d4:	de bf       	out	0x3e, r29	; 62
    34d6:	0f be       	out	0x3f, r0	; 63
    34d8:	cd bf       	out	0x3d, r28	; 61
    34da:	9d 83       	std	Y+5, r25	; 0x05
    34dc:	8c 83       	std	Y+4, r24	; 0x04
    34de:	7f 83       	std	Y+7, r23	; 0x07
    34e0:	6e 83       	std	Y+6, r22	; 0x06
    34e2:	59 87       	std	Y+9, r21	; 0x09
    34e4:	48 87       	std	Y+8, r20	; 0x08
        BaseType_t xReturn;
        Queue_t * const pxQueue = xQueue;
    34e6:	8c 81       	ldd	r24, Y+4	; 0x04
    34e8:	9d 81       	ldd	r25, Y+5	; 0x05
    34ea:	9a 83       	std	Y+2, r25	; 0x02
    34ec:	89 83       	std	Y+1, r24	; 0x01

        /* We cannot block from an ISR, so check there is data available. If
         * not then just leave without doing anything. */
        if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    34ee:	e9 81       	ldd	r30, Y+1	; 0x01
    34f0:	fa 81       	ldd	r31, Y+2	; 0x02
    34f2:	82 8d       	ldd	r24, Z+26	; 0x1a
    34f4:	88 23       	and	r24, r24
    34f6:	09 f4       	brne	.+2      	; 0x34fa <xQueueCRReceiveFromISR+0x34>
    34f8:	50 c0       	rjmp	.+160    	; 0x359a <xQueueCRReceiveFromISR+0xd4>
        {
            /* Copy the data from the queue. */
            pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;
    34fa:	e9 81       	ldd	r30, Y+1	; 0x01
    34fc:	fa 81       	ldd	r31, Y+2	; 0x02
    34fe:	26 81       	ldd	r18, Z+6	; 0x06
    3500:	37 81       	ldd	r19, Z+7	; 0x07
    3502:	e9 81       	ldd	r30, Y+1	; 0x01
    3504:	fa 81       	ldd	r31, Y+2	; 0x02
    3506:	84 8d       	ldd	r24, Z+28	; 0x1c
    3508:	88 2f       	mov	r24, r24
    350a:	90 e0       	ldi	r25, 0x00	; 0
    350c:	82 0f       	add	r24, r18
    350e:	93 1f       	adc	r25, r19
    3510:	e9 81       	ldd	r30, Y+1	; 0x01
    3512:	fa 81       	ldd	r31, Y+2	; 0x02
    3514:	97 83       	std	Z+7, r25	; 0x07
    3516:	86 83       	std	Z+6, r24	; 0x06

            if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail )
    3518:	e9 81       	ldd	r30, Y+1	; 0x01
    351a:	fa 81       	ldd	r31, Y+2	; 0x02
    351c:	26 81       	ldd	r18, Z+6	; 0x06
    351e:	37 81       	ldd	r19, Z+7	; 0x07
    3520:	e9 81       	ldd	r30, Y+1	; 0x01
    3522:	fa 81       	ldd	r31, Y+2	; 0x02
    3524:	84 81       	ldd	r24, Z+4	; 0x04
    3526:	95 81       	ldd	r25, Z+5	; 0x05
    3528:	28 17       	cp	r18, r24
    352a:	39 07       	cpc	r19, r25
    352c:	40 f0       	brcs	.+16     	; 0x353e <xQueueCRReceiveFromISR+0x78>
            {
                pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
    352e:	e9 81       	ldd	r30, Y+1	; 0x01
    3530:	fa 81       	ldd	r31, Y+2	; 0x02
    3532:	80 81       	ld	r24, Z
    3534:	91 81       	ldd	r25, Z+1	; 0x01
    3536:	e9 81       	ldd	r30, Y+1	; 0x01
    3538:	fa 81       	ldd	r31, Y+2	; 0x02
    353a:	97 83       	std	Z+7, r25	; 0x07
    353c:	86 83       	std	Z+6, r24	; 0x06
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }

            --( pxQueue->uxMessagesWaiting );
    353e:	e9 81       	ldd	r30, Y+1	; 0x01
    3540:	fa 81       	ldd	r31, Y+2	; 0x02
    3542:	82 8d       	ldd	r24, Z+26	; 0x1a
    3544:	81 50       	subi	r24, 0x01	; 1
    3546:	e9 81       	ldd	r30, Y+1	; 0x01
    3548:	fa 81       	ldd	r31, Y+2	; 0x02
    354a:	82 8f       	std	Z+26, r24	; 0x1a
            ( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    354c:	e9 81       	ldd	r30, Y+1	; 0x01
    354e:	fa 81       	ldd	r31, Y+2	; 0x02
    3550:	46 81       	ldd	r20, Z+6	; 0x06
    3552:	57 81       	ldd	r21, Z+7	; 0x07
    3554:	e9 81       	ldd	r30, Y+1	; 0x01
    3556:	fa 81       	ldd	r31, Y+2	; 0x02
    3558:	84 8d       	ldd	r24, Z+28	; 0x1c
    355a:	28 2f       	mov	r18, r24
    355c:	30 e0       	ldi	r19, 0x00	; 0
    355e:	8e 81       	ldd	r24, Y+6	; 0x06
    3560:	9f 81       	ldd	r25, Y+7	; 0x07
    3562:	ba 01       	movw	r22, r20
    3564:	a9 01       	movw	r20, r18
    3566:	0e 94 18 4b 	call	0x9630	; 0x9630 <memcpy>

            if( ( *pxCoRoutineWoken ) == pdFALSE )
    356a:	e8 85       	ldd	r30, Y+8	; 0x08
    356c:	f9 85       	ldd	r31, Y+9	; 0x09
    356e:	80 81       	ld	r24, Z
    3570:	88 23       	and	r24, r24
    3572:	81 f4       	brne	.+32     	; 0x3594 <xQueueCRReceiveFromISR+0xce>
            {
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    3574:	e9 81       	ldd	r30, Y+1	; 0x01
    3576:	fa 81       	ldd	r31, Y+2	; 0x02
    3578:	80 85       	ldd	r24, Z+8	; 0x08
    357a:	88 23       	and	r24, r24
    357c:	59 f0       	breq	.+22     	; 0x3594 <xQueueCRReceiveFromISR+0xce>
                {
                    if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    357e:	89 81       	ldd	r24, Y+1	; 0x01
    3580:	9a 81       	ldd	r25, Y+2	; 0x02
    3582:	08 96       	adiw	r24, 0x08	; 8
    3584:	0e 94 12 0d 	call	0x1a24	; 0x1a24 <xCoRoutineRemoveFromEventList>
    3588:	88 23       	and	r24, r24
    358a:	21 f0       	breq	.+8      	; 0x3594 <xQueueCRReceiveFromISR+0xce>
                    {
                        *pxCoRoutineWoken = pdTRUE;
    358c:	e8 85       	ldd	r30, Y+8	; 0x08
    358e:	f9 85       	ldd	r31, Y+9	; 0x09
    3590:	81 e0       	ldi	r24, 0x01	; 1
    3592:	80 83       	st	Z, r24
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }

            xReturn = pdPASS;
    3594:	81 e0       	ldi	r24, 0x01	; 1
    3596:	8b 83       	std	Y+3, r24	; 0x03
    3598:	01 c0       	rjmp	.+2      	; 0x359c <xQueueCRReceiveFromISR+0xd6>
        }
        else
        {
            xReturn = pdFAIL;
    359a:	1b 82       	std	Y+3, r1	; 0x03
        }

        return xReturn;
    359c:	8b 81       	ldd	r24, Y+3	; 0x03
    }
    359e:	29 96       	adiw	r28, 0x09	; 9
    35a0:	0f b6       	in	r0, 0x3f	; 63
    35a2:	f8 94       	cli
    35a4:	de bf       	out	0x3e, r29	; 62
    35a6:	0f be       	out	0x3f, r0	; 63
    35a8:	cd bf       	out	0x3d, r28	; 61
    35aa:	cf 91       	pop	r28
    35ac:	df 91       	pop	r29
    35ae:	08 95       	ret

000035b0 <vQueueWaitForMessageRestricted>:
#if ( configUSE_TIMERS == 1 )

    void vQueueWaitForMessageRestricted( QueueHandle_t xQueue,
                                         TickType_t xTicksToWait,
                                         const BaseType_t xWaitIndefinitely )
    {
    35b0:	df 93       	push	r29
    35b2:	cf 93       	push	r28
    35b4:	cd b7       	in	r28, 0x3d	; 61
    35b6:	de b7       	in	r29, 0x3e	; 62
    35b8:	27 97       	sbiw	r28, 0x07	; 7
    35ba:	0f b6       	in	r0, 0x3f	; 63
    35bc:	f8 94       	cli
    35be:	de bf       	out	0x3e, r29	; 62
    35c0:	0f be       	out	0x3f, r0	; 63
    35c2:	cd bf       	out	0x3d, r28	; 61
    35c4:	9c 83       	std	Y+4, r25	; 0x04
    35c6:	8b 83       	std	Y+3, r24	; 0x03
    35c8:	7e 83       	std	Y+6, r23	; 0x06
    35ca:	6d 83       	std	Y+5, r22	; 0x05
    35cc:	4f 83       	std	Y+7, r20	; 0x07
        Queue_t * const pxQueue = xQueue;
    35ce:	8b 81       	ldd	r24, Y+3	; 0x03
    35d0:	9c 81       	ldd	r25, Y+4	; 0x04
    35d2:	9a 83       	std	Y+2, r25	; 0x02
    35d4:	89 83       	std	Y+1, r24	; 0x01
         *  will not actually cause the task to block, just place it on a blocked
         *  list.  It will not block until the scheduler is unlocked - at which
         *  time a yield will be performed.  If an item is added to the queue while
         *  the queue is locked, and the calling task blocks on the queue, then the
         *  calling task will be immediately unblocked when the queue is unlocked. */
        prvLockQueue( pxQueue );
    35d6:	0f b6       	in	r0, 0x3f	; 63
    35d8:	f8 94       	cli
    35da:	0f 92       	push	r0
    35dc:	e9 81       	ldd	r30, Y+1	; 0x01
    35de:	fa 81       	ldd	r31, Y+2	; 0x02
    35e0:	85 8d       	ldd	r24, Z+29	; 0x1d
    35e2:	8f 3f       	cpi	r24, 0xFF	; 255
    35e4:	19 f4       	brne	.+6      	; 0x35ec <vQueueWaitForMessageRestricted+0x3c>
    35e6:	e9 81       	ldd	r30, Y+1	; 0x01
    35e8:	fa 81       	ldd	r31, Y+2	; 0x02
    35ea:	15 8e       	std	Z+29, r1	; 0x1d
    35ec:	e9 81       	ldd	r30, Y+1	; 0x01
    35ee:	fa 81       	ldd	r31, Y+2	; 0x02
    35f0:	86 8d       	ldd	r24, Z+30	; 0x1e
    35f2:	8f 3f       	cpi	r24, 0xFF	; 255
    35f4:	19 f4       	brne	.+6      	; 0x35fc <vQueueWaitForMessageRestricted+0x4c>
    35f6:	e9 81       	ldd	r30, Y+1	; 0x01
    35f8:	fa 81       	ldd	r31, Y+2	; 0x02
    35fa:	16 8e       	std	Z+30, r1	; 0x1e
    35fc:	0f 90       	pop	r0
    35fe:	0f be       	out	0x3f, r0	; 63

        if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
    3600:	e9 81       	ldd	r30, Y+1	; 0x01
    3602:	fa 81       	ldd	r31, Y+2	; 0x02
    3604:	82 8d       	ldd	r24, Z+26	; 0x1a
    3606:	88 23       	and	r24, r24
    3608:	49 f4       	brne	.+18     	; 0x361c <vQueueWaitForMessageRestricted+0x6c>
        {
            /* There is nothing in the queue, block for the specified period. */
            vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait, xWaitIndefinitely );
    360a:	89 81       	ldd	r24, Y+1	; 0x01
    360c:	9a 81       	ldd	r25, Y+2	; 0x02
    360e:	41 96       	adiw	r24, 0x11	; 17
    3610:	2d 81       	ldd	r18, Y+5	; 0x05
    3612:	3e 81       	ldd	r19, Y+6	; 0x06
    3614:	b9 01       	movw	r22, r18
    3616:	4f 81       	ldd	r20, Y+7	; 0x07
    3618:	0e 94 d0 22 	call	0x45a0	; 0x45a0 <vTaskPlaceOnEventListRestricted>
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        prvUnlockQueue( pxQueue );
    361c:	89 81       	ldd	r24, Y+1	; 0x01
    361e:	9a 81       	ldd	r25, Y+2	; 0x02
    3620:	0e 94 62 18 	call	0x30c4	; 0x30c4 <prvUnlockQueue>
    }
    3624:	27 96       	adiw	r28, 0x07	; 7
    3626:	0f b6       	in	r0, 0x3f	; 63
    3628:	f8 94       	cli
    362a:	de bf       	out	0x3e, r29	; 62
    362c:	0f be       	out	0x3f, r0	; 63
    362e:	cd bf       	out	0x3d, r28	; 61
    3630:	cf 91       	pop	r28
    3632:	df 91       	pop	r29
    3634:	08 95       	ret

00003636 <xTaskCreate>:
                            const char * const pcName, /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
                            const configSTACK_DEPTH_TYPE usStackDepth,
                            void * const pvParameters,
                            UBaseType_t uxPriority,
                            TaskHandle_t * const pxCreatedTask )
    {
    3636:	8f 92       	push	r8
    3638:	9f 92       	push	r9
    363a:	af 92       	push	r10
    363c:	bf 92       	push	r11
    363e:	cf 92       	push	r12
    3640:	df 92       	push	r13
    3642:	ef 92       	push	r14
    3644:	ff 92       	push	r15
    3646:	0f 93       	push	r16
    3648:	1f 93       	push	r17
    364a:	df 93       	push	r29
    364c:	cf 93       	push	r28
    364e:	cd b7       	in	r28, 0x3d	; 61
    3650:	de b7       	in	r29, 0x3e	; 62
    3652:	60 97       	sbiw	r28, 0x10	; 16
    3654:	0f b6       	in	r0, 0x3f	; 63
    3656:	f8 94       	cli
    3658:	de bf       	out	0x3e, r29	; 62
    365a:	0f be       	out	0x3f, r0	; 63
    365c:	cd bf       	out	0x3d, r28	; 61
    365e:	9f 83       	std	Y+7, r25	; 0x07
    3660:	8e 83       	std	Y+6, r24	; 0x06
    3662:	79 87       	std	Y+9, r23	; 0x09
    3664:	68 87       	std	Y+8, r22	; 0x08
    3666:	5b 87       	std	Y+11, r21	; 0x0b
    3668:	4a 87       	std	Y+10, r20	; 0x0a
    366a:	3d 87       	std	Y+13, r19	; 0x0d
    366c:	2c 87       	std	Y+12, r18	; 0x0c
    366e:	0e 87       	std	Y+14, r16	; 0x0e
    3670:	f8 8a       	std	Y+16, r15	; 0x10
    3672:	ef 86       	std	Y+15, r14	; 0x0f
        #else /* portSTACK_GROWTH */
            {
                StackType_t * pxStack;

                /* Allocate space for the stack used by the task being created. */
                pxStack = pvPortMallocStack( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation is the stack. */
    3674:	8a 85       	ldd	r24, Y+10	; 0x0a
    3676:	9b 85       	ldd	r25, Y+11	; 0x0b
    3678:	0e 94 17 07 	call	0xe2e	; 0xe2e <pvPortMalloc>
    367c:	9a 83       	std	Y+2, r25	; 0x02
    367e:	89 83       	std	Y+1, r24	; 0x01

                if( pxStack != NULL )
    3680:	89 81       	ldd	r24, Y+1	; 0x01
    3682:	9a 81       	ldd	r25, Y+2	; 0x02
    3684:	00 97       	sbiw	r24, 0x00	; 0
    3686:	b1 f0       	breq	.+44     	; 0x36b4 <xTaskCreate+0x7e>
                {
                    /* Allocate space for the TCB. */
                    pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of TCB_t is always a pointer to the task's stack. */
    3688:	86 e2       	ldi	r24, 0x26	; 38
    368a:	90 e0       	ldi	r25, 0x00	; 0
    368c:	0e 94 17 07 	call	0xe2e	; 0xe2e <pvPortMalloc>
    3690:	9d 83       	std	Y+5, r25	; 0x05
    3692:	8c 83       	std	Y+4, r24	; 0x04

                    if( pxNewTCB != NULL )
    3694:	8c 81       	ldd	r24, Y+4	; 0x04
    3696:	9d 81       	ldd	r25, Y+5	; 0x05
    3698:	00 97       	sbiw	r24, 0x00	; 0
    369a:	39 f0       	breq	.+14     	; 0x36aa <xTaskCreate+0x74>
                    {
                        /* Store the stack location in the TCB. */
                        pxNewTCB->pxStack = pxStack;
    369c:	ec 81       	ldd	r30, Y+4	; 0x04
    369e:	fd 81       	ldd	r31, Y+5	; 0x05
    36a0:	89 81       	ldd	r24, Y+1	; 0x01
    36a2:	9a 81       	ldd	r25, Y+2	; 0x02
    36a4:	90 8f       	std	Z+24, r25	; 0x18
    36a6:	87 8b       	std	Z+23, r24	; 0x17
    36a8:	07 c0       	rjmp	.+14     	; 0x36b8 <xTaskCreate+0x82>
                    }
                    else
                    {
                        /* The stack cannot be used as the TCB was not created.  Free
                         * it again. */
                        vPortFreeStack( pxStack );
    36aa:	89 81       	ldd	r24, Y+1	; 0x01
    36ac:	9a 81       	ldd	r25, Y+2	; 0x02
    36ae:	0e 94 71 07 	call	0xee2	; 0xee2 <vPortFree>
    36b2:	02 c0       	rjmp	.+4      	; 0x36b8 <xTaskCreate+0x82>
                    }
                }
                else
                {
                    pxNewTCB = NULL;
    36b4:	1d 82       	std	Y+5, r1	; 0x05
    36b6:	1c 82       	std	Y+4, r1	; 0x04
                }
            }
        #endif /* portSTACK_GROWTH */

        if( pxNewTCB != NULL )
    36b8:	8c 81       	ldd	r24, Y+4	; 0x04
    36ba:	9d 81       	ldd	r25, Y+5	; 0x05
    36bc:	00 97       	sbiw	r24, 0x00	; 0
    36be:	e9 f0       	breq	.+58     	; 0x36fa <xTaskCreate+0xc4>
                     * task was created dynamically in case it is later deleted. */
                    pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
                }
            #endif /* tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE */

            prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
    36c0:	8a 85       	ldd	r24, Y+10	; 0x0a
    36c2:	9b 85       	ldd	r25, Y+11	; 0x0b
    36c4:	9c 01       	movw	r18, r24
    36c6:	40 e0       	ldi	r20, 0x00	; 0
    36c8:	50 e0       	ldi	r21, 0x00	; 0
    36ca:	8e 81       	ldd	r24, Y+6	; 0x06
    36cc:	9f 81       	ldd	r25, Y+7	; 0x07
    36ce:	68 85       	ldd	r22, Y+8	; 0x08
    36d0:	79 85       	ldd	r23, Y+9	; 0x09
    36d2:	ec 85       	ldd	r30, Y+12	; 0x0c
    36d4:	fd 85       	ldd	r31, Y+13	; 0x0d
    36d6:	af 85       	ldd	r26, Y+15	; 0x0f
    36d8:	b8 89       	ldd	r27, Y+16	; 0x10
    36da:	ac 80       	ldd	r10, Y+4	; 0x04
    36dc:	bd 80       	ldd	r11, Y+5	; 0x05
    36de:	8f 01       	movw	r16, r30
    36e0:	ee 84       	ldd	r14, Y+14	; 0x0e
    36e2:	6d 01       	movw	r12, r26
    36e4:	88 24       	eor	r8, r8
    36e6:	99 24       	eor	r9, r9
    36e8:	0e 94 93 1b 	call	0x3726	; 0x3726 <prvInitialiseNewTask>
            prvAddNewTaskToReadyList( pxNewTCB );
    36ec:	8c 81       	ldd	r24, Y+4	; 0x04
    36ee:	9d 81       	ldd	r25, Y+5	; 0x05
    36f0:	0e 94 58 1c 	call	0x38b0	; 0x38b0 <prvAddNewTaskToReadyList>
            xReturn = pdPASS;
    36f4:	81 e0       	ldi	r24, 0x01	; 1
    36f6:	8b 83       	std	Y+3, r24	; 0x03
    36f8:	02 c0       	rjmp	.+4      	; 0x36fe <xTaskCreate+0xc8>
        }
        else
        {
            xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    36fa:	8f ef       	ldi	r24, 0xFF	; 255
    36fc:	8b 83       	std	Y+3, r24	; 0x03
        }

        return xReturn;
    36fe:	8b 81       	ldd	r24, Y+3	; 0x03
    }
    3700:	60 96       	adiw	r28, 0x10	; 16
    3702:	0f b6       	in	r0, 0x3f	; 63
    3704:	f8 94       	cli
    3706:	de bf       	out	0x3e, r29	; 62
    3708:	0f be       	out	0x3f, r0	; 63
    370a:	cd bf       	out	0x3d, r28	; 61
    370c:	cf 91       	pop	r28
    370e:	df 91       	pop	r29
    3710:	1f 91       	pop	r17
    3712:	0f 91       	pop	r16
    3714:	ff 90       	pop	r15
    3716:	ef 90       	pop	r14
    3718:	df 90       	pop	r13
    371a:	cf 90       	pop	r12
    371c:	bf 90       	pop	r11
    371e:	af 90       	pop	r10
    3720:	9f 90       	pop	r9
    3722:	8f 90       	pop	r8
    3724:	08 95       	ret

00003726 <prvInitialiseNewTask>:
                                  void * const pvParameters,
                                  UBaseType_t uxPriority,
                                  TaskHandle_t * const pxCreatedTask,
                                  TCB_t * pxNewTCB,
                                  const MemoryRegion_t * const xRegions )
{
    3726:	8f 92       	push	r8
    3728:	9f 92       	push	r9
    372a:	af 92       	push	r10
    372c:	bf 92       	push	r11
    372e:	cf 92       	push	r12
    3730:	df 92       	push	r13
    3732:	ef 92       	push	r14
    3734:	0f 93       	push	r16
    3736:	1f 93       	push	r17
    3738:	df 93       	push	r29
    373a:	cf 93       	push	r28
    373c:	cd b7       	in	r28, 0x3d	; 61
    373e:	de b7       	in	r29, 0x3e	; 62
    3740:	64 97       	sbiw	r28, 0x14	; 20
    3742:	0f b6       	in	r0, 0x3f	; 63
    3744:	f8 94       	cli
    3746:	de bf       	out	0x3e, r29	; 62
    3748:	0f be       	out	0x3f, r0	; 63
    374a:	cd bf       	out	0x3d, r28	; 61
    374c:	9d 83       	std	Y+5, r25	; 0x05
    374e:	8c 83       	std	Y+4, r24	; 0x04
    3750:	7f 83       	std	Y+7, r23	; 0x07
    3752:	6e 83       	std	Y+6, r22	; 0x06
    3754:	28 87       	std	Y+8, r18	; 0x08
    3756:	39 87       	std	Y+9, r19	; 0x09
    3758:	4a 87       	std	Y+10, r20	; 0x0a
    375a:	5b 87       	std	Y+11, r21	; 0x0b
    375c:	1d 87       	std	Y+13, r17	; 0x0d
    375e:	0c 87       	std	Y+12, r16	; 0x0c
    3760:	ee 86       	std	Y+14, r14	; 0x0e
    3762:	d8 8a       	std	Y+16, r13	; 0x10
    3764:	cf 86       	std	Y+15, r12	; 0x0f
    3766:	ba 8a       	std	Y+18, r11	; 0x12
    3768:	a9 8a       	std	Y+17, r10	; 0x11
    376a:	9c 8a       	std	Y+20, r9	; 0x14
    376c:	8b 8a       	std	Y+19, r8	; 0x13
     * grows from high memory to low (as per the 80x86) or vice versa.
     * portSTACK_GROWTH is used to make the result positive or negative as required
     * by the port. */
    #if ( portSTACK_GROWTH < 0 )
        {
            pxTopOfStack = &( pxNewTCB->pxStack[ ulStackDepth - ( uint32_t ) 1 ] );
    376e:	e9 89       	ldd	r30, Y+17	; 0x11
    3770:	fa 89       	ldd	r31, Y+18	; 0x12
    3772:	27 89       	ldd	r18, Z+23	; 0x17
    3774:	30 8d       	ldd	r19, Z+24	; 0x18
    3776:	88 85       	ldd	r24, Y+8	; 0x08
    3778:	99 85       	ldd	r25, Y+9	; 0x09
    377a:	01 97       	sbiw	r24, 0x01	; 1
    377c:	82 0f       	add	r24, r18
    377e:	93 1f       	adc	r25, r19
    3780:	9b 83       	std	Y+3, r25	; 0x03
    3782:	8a 83       	std	Y+2, r24	; 0x02
            pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
        }
    #endif /* portSTACK_GROWTH */

    /* Store the task name in the TCB. */
    if( pcName != NULL )
    3784:	8e 81       	ldd	r24, Y+6	; 0x06
    3786:	9f 81       	ldd	r25, Y+7	; 0x07
    3788:	00 97       	sbiw	r24, 0x00	; 0
    378a:	51 f1       	breq	.+84     	; 0x37e0 <prvInitialiseNewTask+0xba>
    {
        for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    378c:	19 82       	std	Y+1, r1	; 0x01
    378e:	21 c0       	rjmp	.+66     	; 0x37d2 <prvInitialiseNewTask+0xac>
        {
            pxNewTCB->pcTaskName[ x ] = pcName[ x ];
    3790:	89 81       	ldd	r24, Y+1	; 0x01
    3792:	48 2f       	mov	r20, r24
    3794:	50 e0       	ldi	r21, 0x00	; 0
    3796:	89 81       	ldd	r24, Y+1	; 0x01
    3798:	28 2f       	mov	r18, r24
    379a:	30 e0       	ldi	r19, 0x00	; 0
    379c:	8e 81       	ldd	r24, Y+6	; 0x06
    379e:	9f 81       	ldd	r25, Y+7	; 0x07
    37a0:	fc 01       	movw	r30, r24
    37a2:	e2 0f       	add	r30, r18
    37a4:	f3 1f       	adc	r31, r19
    37a6:	20 81       	ld	r18, Z
    37a8:	89 89       	ldd	r24, Y+17	; 0x11
    37aa:	9a 89       	ldd	r25, Y+18	; 0x12
    37ac:	84 0f       	add	r24, r20
    37ae:	95 1f       	adc	r25, r21
    37b0:	fc 01       	movw	r30, r24
    37b2:	79 96       	adiw	r30, 0x19	; 25
    37b4:	20 83       	st	Z, r18

            /* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
             * configMAX_TASK_NAME_LEN characters just in case the memory after the
             * string is not accessible (extremely unlikely). */
            if( pcName[ x ] == ( char ) 0x00 )
    37b6:	89 81       	ldd	r24, Y+1	; 0x01
    37b8:	28 2f       	mov	r18, r24
    37ba:	30 e0       	ldi	r19, 0x00	; 0
    37bc:	8e 81       	ldd	r24, Y+6	; 0x06
    37be:	9f 81       	ldd	r25, Y+7	; 0x07
    37c0:	fc 01       	movw	r30, r24
    37c2:	e2 0f       	add	r30, r18
    37c4:	f3 1f       	adc	r31, r19
    37c6:	80 81       	ld	r24, Z
    37c8:	88 23       	and	r24, r24
    37ca:	31 f0       	breq	.+12     	; 0x37d8 <prvInitialiseNewTask+0xb2>
    #endif /* portSTACK_GROWTH */

    /* Store the task name in the TCB. */
    if( pcName != NULL )
    {
        for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    37cc:	89 81       	ldd	r24, Y+1	; 0x01
    37ce:	8f 5f       	subi	r24, 0xFF	; 255
    37d0:	89 83       	std	Y+1, r24	; 0x01
    37d2:	89 81       	ldd	r24, Y+1	; 0x01
    37d4:	88 30       	cpi	r24, 0x08	; 8
    37d6:	e0 f2       	brcs	.-72     	; 0x3790 <prvInitialiseNewTask+0x6a>
            }
        }

        /* Ensure the name string is terminated in the case that the string length
         * was greater or equal to configMAX_TASK_NAME_LEN. */
        pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
    37d8:	e9 89       	ldd	r30, Y+17	; 0x11
    37da:	fa 89       	ldd	r31, Y+18	; 0x12
    37dc:	10 a2       	std	Z+32, r1	; 0x20
    37de:	03 c0       	rjmp	.+6      	; 0x37e6 <prvInitialiseNewTask+0xc0>
    }
    else
    {
        /* The task has not been given a name, so just ensure there is a NULL
         * terminator when it is read out. */
        pxNewTCB->pcTaskName[ 0 ] = 0x00;
    37e0:	e9 89       	ldd	r30, Y+17	; 0x11
    37e2:	fa 89       	ldd	r31, Y+18	; 0x12
    37e4:	11 8e       	std	Z+25, r1	; 0x19
    }

    /* This is used as an array index so must ensure it's not too large. */
    configASSERT( uxPriority < configMAX_PRIORITIES );

    if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
    37e6:	8e 85       	ldd	r24, Y+14	; 0x0e
    37e8:	84 30       	cpi	r24, 0x04	; 4
    37ea:	10 f0       	brcs	.+4      	; 0x37f0 <prvInitialiseNewTask+0xca>
    {
        uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
    37ec:	83 e0       	ldi	r24, 0x03	; 3
    37ee:	8e 87       	std	Y+14, r24	; 0x0e
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    pxNewTCB->uxPriority = uxPriority;
    37f0:	e9 89       	ldd	r30, Y+17	; 0x11
    37f2:	fa 89       	ldd	r31, Y+18	; 0x12
    37f4:	8e 85       	ldd	r24, Y+14	; 0x0e
    37f6:	86 8b       	std	Z+22, r24	; 0x16
            pxNewTCB->uxBasePriority = uxPriority;
            pxNewTCB->uxMutexesHeld = 0;
        }
    #endif /* configUSE_MUTEXES */

    vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
    37f8:	89 89       	ldd	r24, Y+17	; 0x11
    37fa:	9a 89       	ldd	r25, Y+18	; 0x12
    37fc:	02 96       	adiw	r24, 0x02	; 2
    37fe:	0e 94 b9 10 	call	0x2172	; 0x2172 <vListInitialiseItem>
    vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
    3802:	89 89       	ldd	r24, Y+17	; 0x11
    3804:	9a 89       	ldd	r25, Y+18	; 0x12
    3806:	0c 96       	adiw	r24, 0x0c	; 12
    3808:	0e 94 b9 10 	call	0x2172	; 0x2172 <vListInitialiseItem>

    /* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
     * back to  the containing TCB from a generic item in a list. */
    listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
    380c:	e9 89       	ldd	r30, Y+17	; 0x11
    380e:	fa 89       	ldd	r31, Y+18	; 0x12
    3810:	89 89       	ldd	r24, Y+17	; 0x11
    3812:	9a 89       	ldd	r25, Y+18	; 0x12
    3814:	91 87       	std	Z+9, r25	; 0x09
    3816:	80 87       	std	Z+8, r24	; 0x08

    /* Event lists are always in priority order. */
    listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    3818:	8e 85       	ldd	r24, Y+14	; 0x0e
    381a:	28 2f       	mov	r18, r24
    381c:	30 e0       	ldi	r19, 0x00	; 0
    381e:	84 e0       	ldi	r24, 0x04	; 4
    3820:	90 e0       	ldi	r25, 0x00	; 0
    3822:	82 1b       	sub	r24, r18
    3824:	93 0b       	sbc	r25, r19
    3826:	e9 89       	ldd	r30, Y+17	; 0x11
    3828:	fa 89       	ldd	r31, Y+18	; 0x12
    382a:	95 87       	std	Z+13, r25	; 0x0d
    382c:	84 87       	std	Z+12, r24	; 0x0c
    listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
    382e:	e9 89       	ldd	r30, Y+17	; 0x11
    3830:	fa 89       	ldd	r31, Y+18	; 0x12
    3832:	89 89       	ldd	r24, Y+17	; 0x11
    3834:	9a 89       	ldd	r25, Y+18	; 0x12
    3836:	93 8b       	std	Z+19, r25	; 0x13
    3838:	82 8b       	std	Z+18, r24	; 0x12
        }
    #endif

    #if ( configUSE_TASK_NOTIFICATIONS == 1 )
        {
            memset( ( void * ) &( pxNewTCB->ulNotifiedValue[ 0 ] ), 0x00, sizeof( pxNewTCB->ulNotifiedValue ) );
    383a:	89 89       	ldd	r24, Y+17	; 0x11
    383c:	9a 89       	ldd	r25, Y+18	; 0x12
    383e:	81 96       	adiw	r24, 0x21	; 33
    3840:	60 e0       	ldi	r22, 0x00	; 0
    3842:	70 e0       	ldi	r23, 0x00	; 0
    3844:	44 e0       	ldi	r20, 0x04	; 4
    3846:	50 e0       	ldi	r21, 0x00	; 0
    3848:	0e 94 21 4b 	call	0x9642	; 0x9642 <memset>
            memset( ( void * ) &( pxNewTCB->ucNotifyState[ 0 ] ), 0x00, sizeof( pxNewTCB->ucNotifyState ) );
    384c:	89 89       	ldd	r24, Y+17	; 0x11
    384e:	9a 89       	ldd	r25, Y+18	; 0x12
    3850:	85 96       	adiw	r24, 0x25	; 37
    3852:	60 e0       	ldi	r22, 0x00	; 0
    3854:	70 e0       	ldi	r23, 0x00	; 0
    3856:	41 e0       	ldi	r20, 0x01	; 1
    3858:	50 e0       	ldi	r21, 0x00	; 0
    385a:	0e 94 21 4b 	call	0x9642	; 0x9642 <memset>
                        }
                    #endif /* portSTACK_GROWTH */
                }
            #else /* portHAS_STACK_OVERFLOW_CHECKING */
                {
                    pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    385e:	8a 81       	ldd	r24, Y+2	; 0x02
    3860:	9b 81       	ldd	r25, Y+3	; 0x03
    3862:	2c 81       	ldd	r18, Y+4	; 0x04
    3864:	3d 81       	ldd	r19, Y+5	; 0x05
    3866:	4c 85       	ldd	r20, Y+12	; 0x0c
    3868:	5d 85       	ldd	r21, Y+13	; 0x0d
    386a:	b9 01       	movw	r22, r18
    386c:	0e 94 97 07 	call	0xf2e	; 0xf2e <pxPortInitialiseStack>
    3870:	e9 89       	ldd	r30, Y+17	; 0x11
    3872:	fa 89       	ldd	r31, Y+18	; 0x12
    3874:	91 83       	std	Z+1, r25	; 0x01
    3876:	80 83       	st	Z, r24
                }
            #endif /* portHAS_STACK_OVERFLOW_CHECKING */
        }
    #endif /* portUSING_MPU_WRAPPERS */

    if( pxCreatedTask != NULL )
    3878:	8f 85       	ldd	r24, Y+15	; 0x0f
    387a:	98 89       	ldd	r25, Y+16	; 0x10
    387c:	00 97       	sbiw	r24, 0x00	; 0
    387e:	31 f0       	breq	.+12     	; 0x388c <prvInitialiseNewTask+0x166>
    {
        /* Pass the handle out in an anonymous way.  The handle can be used to
         * change the created task's priority, delete the created task, etc.*/
        *pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
    3880:	ef 85       	ldd	r30, Y+15	; 0x0f
    3882:	f8 89       	ldd	r31, Y+16	; 0x10
    3884:	89 89       	ldd	r24, Y+17	; 0x11
    3886:	9a 89       	ldd	r25, Y+18	; 0x12
    3888:	91 83       	std	Z+1, r25	; 0x01
    388a:	80 83       	st	Z, r24
    }
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }
}
    388c:	64 96       	adiw	r28, 0x14	; 20
    388e:	0f b6       	in	r0, 0x3f	; 63
    3890:	f8 94       	cli
    3892:	de bf       	out	0x3e, r29	; 62
    3894:	0f be       	out	0x3f, r0	; 63
    3896:	cd bf       	out	0x3d, r28	; 61
    3898:	cf 91       	pop	r28
    389a:	df 91       	pop	r29
    389c:	1f 91       	pop	r17
    389e:	0f 91       	pop	r16
    38a0:	ef 90       	pop	r14
    38a2:	df 90       	pop	r13
    38a4:	cf 90       	pop	r12
    38a6:	bf 90       	pop	r11
    38a8:	af 90       	pop	r10
    38aa:	9f 90       	pop	r9
    38ac:	8f 90       	pop	r8
    38ae:	08 95       	ret

000038b0 <prvAddNewTaskToReadyList>:
/*-----------------------------------------------------------*/

static void prvAddNewTaskToReadyList( TCB_t * pxNewTCB )
{
    38b0:	df 93       	push	r29
    38b2:	cf 93       	push	r28
    38b4:	00 d0       	rcall	.+0      	; 0x38b6 <prvAddNewTaskToReadyList+0x6>
    38b6:	00 d0       	rcall	.+0      	; 0x38b8 <prvAddNewTaskToReadyList+0x8>
    38b8:	cd b7       	in	r28, 0x3d	; 61
    38ba:	de b7       	in	r29, 0x3e	; 62
    38bc:	9c 83       	std	Y+4, r25	; 0x04
    38be:	8b 83       	std	Y+3, r24	; 0x03
    /* Ensure interrupts don't access the task lists while the lists are being
     * updated. */
    taskENTER_CRITICAL();
    38c0:	0f b6       	in	r0, 0x3f	; 63
    38c2:	f8 94       	cli
    38c4:	0f 92       	push	r0
    {
        uxCurrentNumberOfTasks++;
    38c6:	80 91 c7 07 	lds	r24, 0x07C7
    38ca:	8f 5f       	subi	r24, 0xFF	; 255
    38cc:	80 93 c7 07 	sts	0x07C7, r24

        if( pxCurrentTCB == NULL )
    38d0:	80 91 c4 07 	lds	r24, 0x07C4
    38d4:	90 91 c5 07 	lds	r25, 0x07C5
    38d8:	00 97       	sbiw	r24, 0x00	; 0
    38da:	69 f4       	brne	.+26     	; 0x38f6 <prvAddNewTaskToReadyList+0x46>
        {
            /* There are no other tasks, or all the other tasks are in
             * the suspended state - make this the current task. */
            pxCurrentTCB = pxNewTCB;
    38dc:	8b 81       	ldd	r24, Y+3	; 0x03
    38de:	9c 81       	ldd	r25, Y+4	; 0x04
    38e0:	90 93 c5 07 	sts	0x07C5, r25
    38e4:	80 93 c4 07 	sts	0x07C4, r24

            if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
    38e8:	80 91 c7 07 	lds	r24, 0x07C7
    38ec:	81 30       	cpi	r24, 0x01	; 1
    38ee:	b9 f4       	brne	.+46     	; 0x391e <prvAddNewTaskToReadyList+0x6e>
            {
                /* This is the first task to be created so do the preliminary
                 * initialisation required.  We will not recover if this call
                 * fails, but we will report the failure. */
                prvInitialiseTaskLists();
    38f0:	0e 94 3c 26 	call	0x4c78	; 0x4c78 <prvInitialiseTaskLists>
    38f4:	14 c0       	rjmp	.+40     	; 0x391e <prvAddNewTaskToReadyList+0x6e>
        else
        {
            /* If the scheduler is not already running, make this task the
             * current task if it is the highest priority task to be created
             * so far. */
            if( xSchedulerRunning == pdFALSE )
    38f6:	80 91 cb 07 	lds	r24, 0x07CB
    38fa:	88 23       	and	r24, r24
    38fc:	81 f4       	brne	.+32     	; 0x391e <prvAddNewTaskToReadyList+0x6e>
            {
                if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
    38fe:	e0 91 c4 07 	lds	r30, 0x07C4
    3902:	f0 91 c5 07 	lds	r31, 0x07C5
    3906:	96 89       	ldd	r25, Z+22	; 0x16
    3908:	eb 81       	ldd	r30, Y+3	; 0x03
    390a:	fc 81       	ldd	r31, Y+4	; 0x04
    390c:	86 89       	ldd	r24, Z+22	; 0x16
    390e:	89 17       	cp	r24, r25
    3910:	30 f0       	brcs	.+12     	; 0x391e <prvAddNewTaskToReadyList+0x6e>
                {
                    pxCurrentTCB = pxNewTCB;
    3912:	8b 81       	ldd	r24, Y+3	; 0x03
    3914:	9c 81       	ldd	r25, Y+4	; 0x04
    3916:	90 93 c5 07 	sts	0x07C5, r25
    391a:	80 93 c4 07 	sts	0x07C4, r24
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }

        uxTaskNumber++;
    391e:	80 91 d0 07 	lds	r24, 0x07D0
    3922:	8f 5f       	subi	r24, 0xFF	; 255
    3924:	80 93 d0 07 	sts	0x07D0, r24
                pxNewTCB->uxTCBNumber = uxTaskNumber;
            }
        #endif /* configUSE_TRACE_FACILITY */
        traceTASK_CREATE( pxNewTCB );

        prvAddTaskToReadyList( pxNewTCB );
    3928:	eb 81       	ldd	r30, Y+3	; 0x03
    392a:	fc 81       	ldd	r31, Y+4	; 0x04
    392c:	96 89       	ldd	r25, Z+22	; 0x16
    392e:	80 91 ca 07 	lds	r24, 0x07CA
    3932:	89 17       	cp	r24, r25
    3934:	28 f4       	brcc	.+10     	; 0x3940 <prvAddNewTaskToReadyList+0x90>
    3936:	eb 81       	ldd	r30, Y+3	; 0x03
    3938:	fc 81       	ldd	r31, Y+4	; 0x04
    393a:	86 89       	ldd	r24, Z+22	; 0x16
    393c:	80 93 ca 07 	sts	0x07CA, r24
    3940:	eb 81       	ldd	r30, Y+3	; 0x03
    3942:	fc 81       	ldd	r31, Y+4	; 0x04
    3944:	86 89       	ldd	r24, Z+22	; 0x16
    3946:	28 2f       	mov	r18, r24
    3948:	30 e0       	ldi	r19, 0x00	; 0
    394a:	c9 01       	movw	r24, r18
    394c:	88 0f       	add	r24, r24
    394e:	99 1f       	adc	r25, r25
    3950:	88 0f       	add	r24, r24
    3952:	99 1f       	adc	r25, r25
    3954:	88 0f       	add	r24, r24
    3956:	99 1f       	adc	r25, r25
    3958:	82 0f       	add	r24, r18
    395a:	93 1f       	adc	r25, r19
    395c:	fc 01       	movw	r30, r24
    395e:	ea 52       	subi	r30, 0x2A	; 42
    3960:	f8 4f       	sbci	r31, 0xF8	; 248
    3962:	81 81       	ldd	r24, Z+1	; 0x01
    3964:	92 81       	ldd	r25, Z+2	; 0x02
    3966:	9a 83       	std	Y+2, r25	; 0x02
    3968:	89 83       	std	Y+1, r24	; 0x01
    396a:	eb 81       	ldd	r30, Y+3	; 0x03
    396c:	fc 81       	ldd	r31, Y+4	; 0x04
    396e:	89 81       	ldd	r24, Y+1	; 0x01
    3970:	9a 81       	ldd	r25, Y+2	; 0x02
    3972:	95 83       	std	Z+5, r25	; 0x05
    3974:	84 83       	std	Z+4, r24	; 0x04
    3976:	e9 81       	ldd	r30, Y+1	; 0x01
    3978:	fa 81       	ldd	r31, Y+2	; 0x02
    397a:	84 81       	ldd	r24, Z+4	; 0x04
    397c:	95 81       	ldd	r25, Z+5	; 0x05
    397e:	eb 81       	ldd	r30, Y+3	; 0x03
    3980:	fc 81       	ldd	r31, Y+4	; 0x04
    3982:	97 83       	std	Z+7, r25	; 0x07
    3984:	86 83       	std	Z+6, r24	; 0x06
    3986:	e9 81       	ldd	r30, Y+1	; 0x01
    3988:	fa 81       	ldd	r31, Y+2	; 0x02
    398a:	04 80       	ldd	r0, Z+4	; 0x04
    398c:	f5 81       	ldd	r31, Z+5	; 0x05
    398e:	e0 2d       	mov	r30, r0
    3990:	8b 81       	ldd	r24, Y+3	; 0x03
    3992:	9c 81       	ldd	r25, Y+4	; 0x04
    3994:	02 96       	adiw	r24, 0x02	; 2
    3996:	93 83       	std	Z+3, r25	; 0x03
    3998:	82 83       	std	Z+2, r24	; 0x02
    399a:	8b 81       	ldd	r24, Y+3	; 0x03
    399c:	9c 81       	ldd	r25, Y+4	; 0x04
    399e:	02 96       	adiw	r24, 0x02	; 2
    39a0:	e9 81       	ldd	r30, Y+1	; 0x01
    39a2:	fa 81       	ldd	r31, Y+2	; 0x02
    39a4:	95 83       	std	Z+5, r25	; 0x05
    39a6:	84 83       	std	Z+4, r24	; 0x04
    39a8:	eb 81       	ldd	r30, Y+3	; 0x03
    39aa:	fc 81       	ldd	r31, Y+4	; 0x04
    39ac:	86 89       	ldd	r24, Z+22	; 0x16
    39ae:	28 2f       	mov	r18, r24
    39b0:	30 e0       	ldi	r19, 0x00	; 0
    39b2:	c9 01       	movw	r24, r18
    39b4:	88 0f       	add	r24, r24
    39b6:	99 1f       	adc	r25, r25
    39b8:	88 0f       	add	r24, r24
    39ba:	99 1f       	adc	r25, r25
    39bc:	88 0f       	add	r24, r24
    39be:	99 1f       	adc	r25, r25
    39c0:	82 0f       	add	r24, r18
    39c2:	93 1f       	adc	r25, r19
    39c4:	8a 52       	subi	r24, 0x2A	; 42
    39c6:	98 4f       	sbci	r25, 0xF8	; 248
    39c8:	eb 81       	ldd	r30, Y+3	; 0x03
    39ca:	fc 81       	ldd	r31, Y+4	; 0x04
    39cc:	93 87       	std	Z+11, r25	; 0x0b
    39ce:	82 87       	std	Z+10, r24	; 0x0a
    39d0:	eb 81       	ldd	r30, Y+3	; 0x03
    39d2:	fc 81       	ldd	r31, Y+4	; 0x04
    39d4:	86 89       	ldd	r24, Z+22	; 0x16
    39d6:	28 2f       	mov	r18, r24
    39d8:	30 e0       	ldi	r19, 0x00	; 0
    39da:	c9 01       	movw	r24, r18
    39dc:	88 0f       	add	r24, r24
    39de:	99 1f       	adc	r25, r25
    39e0:	88 0f       	add	r24, r24
    39e2:	99 1f       	adc	r25, r25
    39e4:	88 0f       	add	r24, r24
    39e6:	99 1f       	adc	r25, r25
    39e8:	82 0f       	add	r24, r18
    39ea:	93 1f       	adc	r25, r19
    39ec:	fc 01       	movw	r30, r24
    39ee:	ea 52       	subi	r30, 0x2A	; 42
    39f0:	f8 4f       	sbci	r31, 0xF8	; 248
    39f2:	80 81       	ld	r24, Z
    39f4:	8f 5f       	subi	r24, 0xFF	; 255
    39f6:	80 83       	st	Z, r24

        portSETUP_TCB( pxNewTCB );
    }
    taskEXIT_CRITICAL();
    39f8:	0f 90       	pop	r0
    39fa:	0f be       	out	0x3f, r0	; 63

    if( xSchedulerRunning != pdFALSE )
    39fc:	80 91 cb 07 	lds	r24, 0x07CB
    3a00:	88 23       	and	r24, r24
    3a02:	61 f0       	breq	.+24     	; 0x3a1c <prvAddNewTaskToReadyList+0x16c>
    {
        /* If the created task is of a higher priority than the current task
         * then it should run now. */
        if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
    3a04:	e0 91 c4 07 	lds	r30, 0x07C4
    3a08:	f0 91 c5 07 	lds	r31, 0x07C5
    3a0c:	96 89       	ldd	r25, Z+22	; 0x16
    3a0e:	eb 81       	ldd	r30, Y+3	; 0x03
    3a10:	fc 81       	ldd	r31, Y+4	; 0x04
    3a12:	86 89       	ldd	r24, Z+22	; 0x16
    3a14:	98 17       	cp	r25, r24
    3a16:	10 f4       	brcc	.+4      	; 0x3a1c <prvAddNewTaskToReadyList+0x16c>
        {
            taskYIELD_IF_USING_PREEMPTION();
    3a18:	0e 94 56 09 	call	0x12ac	; 0x12ac <vPortYield>
    }
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }
}
    3a1c:	0f 90       	pop	r0
    3a1e:	0f 90       	pop	r0
    3a20:	0f 90       	pop	r0
    3a22:	0f 90       	pop	r0
    3a24:	cf 91       	pop	r28
    3a26:	df 91       	pop	r29
    3a28:	08 95       	ret

00003a2a <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

    void vTaskDelete( TaskHandle_t xTaskToDelete )
    {
    3a2a:	df 93       	push	r29
    3a2c:	cf 93       	push	r28
    3a2e:	00 d0       	rcall	.+0      	; 0x3a30 <vTaskDelete+0x6>
    3a30:	00 d0       	rcall	.+0      	; 0x3a32 <vTaskDelete+0x8>
    3a32:	00 d0       	rcall	.+0      	; 0x3a34 <vTaskDelete+0xa>
    3a34:	cd b7       	in	r28, 0x3d	; 61
    3a36:	de b7       	in	r29, 0x3e	; 62
    3a38:	9c 83       	std	Y+4, r25	; 0x04
    3a3a:	8b 83       	std	Y+3, r24	; 0x03
        TCB_t * pxTCB;

        taskENTER_CRITICAL();
    3a3c:	0f b6       	in	r0, 0x3f	; 63
    3a3e:	f8 94       	cli
    3a40:	0f 92       	push	r0
        {
            /* If null is passed in here then it is the calling task that is
             * being deleted. */
            pxTCB = prvGetTCBFromHandle( xTaskToDelete );
    3a42:	8b 81       	ldd	r24, Y+3	; 0x03
    3a44:	9c 81       	ldd	r25, Y+4	; 0x04
    3a46:	00 97       	sbiw	r24, 0x00	; 0
    3a48:	39 f4       	brne	.+14     	; 0x3a58 <vTaskDelete+0x2e>
    3a4a:	80 91 c4 07 	lds	r24, 0x07C4
    3a4e:	90 91 c5 07 	lds	r25, 0x07C5
    3a52:	9e 83       	std	Y+6, r25	; 0x06
    3a54:	8d 83       	std	Y+5, r24	; 0x05
    3a56:	04 c0       	rjmp	.+8      	; 0x3a60 <vTaskDelete+0x36>
    3a58:	8b 81       	ldd	r24, Y+3	; 0x03
    3a5a:	9c 81       	ldd	r25, Y+4	; 0x04
    3a5c:	9e 83       	std	Y+6, r25	; 0x06
    3a5e:	8d 83       	std	Y+5, r24	; 0x05
    3a60:	8d 81       	ldd	r24, Y+5	; 0x05
    3a62:	9e 81       	ldd	r25, Y+6	; 0x06
    3a64:	9a 83       	std	Y+2, r25	; 0x02
    3a66:	89 83       	std	Y+1, r24	; 0x01

            /* Remove task from the ready/delayed list. */
            if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    3a68:	89 81       	ldd	r24, Y+1	; 0x01
    3a6a:	9a 81       	ldd	r25, Y+2	; 0x02
    3a6c:	02 96       	adiw	r24, 0x02	; 2
    3a6e:	0e 94 79 11 	call	0x22f2	; 0x22f2 <uxListRemove>
            {
                mtCOVERAGE_TEST_MARKER();
            }

            /* Is the task waiting on an event also? */
            if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    3a72:	e9 81       	ldd	r30, Y+1	; 0x01
    3a74:	fa 81       	ldd	r31, Y+2	; 0x02
    3a76:	84 89       	ldd	r24, Z+20	; 0x14
    3a78:	95 89       	ldd	r25, Z+21	; 0x15
    3a7a:	00 97       	sbiw	r24, 0x00	; 0
    3a7c:	29 f0       	breq	.+10     	; 0x3a88 <vTaskDelete+0x5e>
            {
                ( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    3a7e:	89 81       	ldd	r24, Y+1	; 0x01
    3a80:	9a 81       	ldd	r25, Y+2	; 0x02
    3a82:	0c 96       	adiw	r24, 0x0c	; 12
    3a84:	0e 94 79 11 	call	0x22f2	; 0x22f2 <uxListRemove>

            /* Increment the uxTaskNumber also so kernel aware debuggers can
             * detect that the task lists need re-generating.  This is done before
             * portPRE_TASK_DELETE_HOOK() as in the Windows port that macro will
             * not return. */
            uxTaskNumber++;
    3a88:	80 91 d0 07 	lds	r24, 0x07D0
    3a8c:	8f 5f       	subi	r24, 0xFF	; 255
    3a8e:	80 93 d0 07 	sts	0x07D0, r24

            if( pxTCB == pxCurrentTCB )
    3a92:	20 91 c4 07 	lds	r18, 0x07C4
    3a96:	30 91 c5 07 	lds	r19, 0x07C5
    3a9a:	89 81       	ldd	r24, Y+1	; 0x01
    3a9c:	9a 81       	ldd	r25, Y+2	; 0x02
    3a9e:	82 17       	cp	r24, r18
    3aa0:	93 07       	cpc	r25, r19
    3aa2:	81 f4       	brne	.+32     	; 0x3ac4 <vTaskDelete+0x9a>
                /* A task is deleting itself.  This cannot complete within the
                 * task itself, as a context switch to another task is required.
                 * Place the task in the termination list.  The idle task will
                 * check the termination list and free up any memory allocated by
                 * the scheduler for the TCB and stack of the deleted task. */
                vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xStateListItem ) );
    3aa4:	89 81       	ldd	r24, Y+1	; 0x01
    3aa6:	9a 81       	ldd	r25, Y+2	; 0x02
    3aa8:	9c 01       	movw	r18, r24
    3aaa:	2e 5f       	subi	r18, 0xFE	; 254
    3aac:	3f 4f       	sbci	r19, 0xFF	; 255
    3aae:	89 e1       	ldi	r24, 0x19	; 25
    3ab0:	98 e0       	ldi	r25, 0x08	; 8
    3ab2:	b9 01       	movw	r22, r18
    3ab4:	0e 94 c9 10 	call	0x2192	; 0x2192 <vListInsertEnd>

                /* Increment the ucTasksDeleted variable so the idle task knows
                 * there is a task that has been deleted and that it should therefore
                 * check the xTasksWaitingTermination list. */
                ++uxDeletedTasksWaitingCleanUp;
    3ab8:	80 91 c6 07 	lds	r24, 0x07C6
    3abc:	8f 5f       	subi	r24, 0xFF	; 255
    3abe:	80 93 c6 07 	sts	0x07C6, r24
    3ac2:	07 c0       	rjmp	.+14     	; 0x3ad2 <vTaskDelete+0xa8>
                 * required. */
                portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
            }
            else
            {
                --uxCurrentNumberOfTasks;
    3ac4:	80 91 c7 07 	lds	r24, 0x07C7
    3ac8:	81 50       	subi	r24, 0x01	; 1
    3aca:	80 93 c7 07 	sts	0x07C7, r24
                traceTASK_DELETE( pxTCB );

                /* Reset the next expected unblock time in case it referred to
                 * the task that has just been deleted. */
                prvResetNextTaskUnblockTime();
    3ace:	0e 94 be 26 	call	0x4d7c	; 0x4d7c <prvResetNextTaskUnblockTime>
            }
        }
        taskEXIT_CRITICAL();
    3ad2:	0f 90       	pop	r0
    3ad4:	0f be       	out	0x3f, r0	; 63

        /* If the task is not deleting itself, call prvDeleteTCB from outside of
         * critical section. If a task deletes itself, prvDeleteTCB is called
         * from prvCheckTasksWaitingTermination which is called from Idle task. */
        if( pxTCB != pxCurrentTCB )
    3ad6:	20 91 c4 07 	lds	r18, 0x07C4
    3ada:	30 91 c5 07 	lds	r19, 0x07C5
    3ade:	89 81       	ldd	r24, Y+1	; 0x01
    3ae0:	9a 81       	ldd	r25, Y+2	; 0x02
    3ae2:	82 17       	cp	r24, r18
    3ae4:	93 07       	cpc	r25, r19
    3ae6:	21 f0       	breq	.+8      	; 0x3af0 <vTaskDelete+0xc6>
        {
            prvDeleteTCB( pxTCB );
    3ae8:	89 81       	ldd	r24, Y+1	; 0x01
    3aea:	9a 81       	ldd	r25, Y+2	; 0x02
    3aec:	0e 94 a8 26 	call	0x4d50	; 0x4d50 <prvDeleteTCB>
        }

        /* Force a reschedule if it is the currently running task that has just
         * been deleted. */
        if( xSchedulerRunning != pdFALSE )
    3af0:	80 91 cb 07 	lds	r24, 0x07CB
    3af4:	88 23       	and	r24, r24
    3af6:	59 f0       	breq	.+22     	; 0x3b0e <vTaskDelete+0xe4>
        {
            if( pxTCB == pxCurrentTCB )
    3af8:	20 91 c4 07 	lds	r18, 0x07C4
    3afc:	30 91 c5 07 	lds	r19, 0x07C5
    3b00:	89 81       	ldd	r24, Y+1	; 0x01
    3b02:	9a 81       	ldd	r25, Y+2	; 0x02
    3b04:	82 17       	cp	r24, r18
    3b06:	93 07       	cpc	r25, r19
    3b08:	11 f4       	brne	.+4      	; 0x3b0e <vTaskDelete+0xe4>
            {
                configASSERT( uxSchedulerSuspended == 0 );
                portYIELD_WITHIN_API();
    3b0a:	0e 94 56 09 	call	0x12ac	; 0x12ac <vPortYield>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
    }
    3b0e:	26 96       	adiw	r28, 0x06	; 6
    3b10:	0f b6       	in	r0, 0x3f	; 63
    3b12:	f8 94       	cli
    3b14:	de bf       	out	0x3e, r29	; 62
    3b16:	0f be       	out	0x3f, r0	; 63
    3b18:	cd bf       	out	0x3d, r28	; 61
    3b1a:	cf 91       	pop	r28
    3b1c:	df 91       	pop	r29
    3b1e:	08 95       	ret

00003b20 <xTaskDelayUntil>:

#if ( INCLUDE_xTaskDelayUntil == 1 )

    BaseType_t xTaskDelayUntil( TickType_t * const pxPreviousWakeTime,
                                const TickType_t xTimeIncrement )
    {
    3b20:	df 93       	push	r29
    3b22:	cf 93       	push	r28
    3b24:	cd b7       	in	r28, 0x3d	; 61
    3b26:	de b7       	in	r29, 0x3e	; 62
    3b28:	2a 97       	sbiw	r28, 0x0a	; 10
    3b2a:	0f b6       	in	r0, 0x3f	; 63
    3b2c:	f8 94       	cli
    3b2e:	de bf       	out	0x3e, r29	; 62
    3b30:	0f be       	out	0x3f, r0	; 63
    3b32:	cd bf       	out	0x3d, r28	; 61
    3b34:	98 87       	std	Y+8, r25	; 0x08
    3b36:	8f 83       	std	Y+7, r24	; 0x07
    3b38:	7a 87       	std	Y+10, r23	; 0x0a
    3b3a:	69 87       	std	Y+9, r22	; 0x09
        TickType_t xTimeToWake;
        BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
    3b3c:	1b 82       	std	Y+3, r1	; 0x03

        configASSERT( pxPreviousWakeTime );
        configASSERT( ( xTimeIncrement > 0U ) );
        configASSERT( uxSchedulerSuspended == 0 );

        vTaskSuspendAll();
    3b3e:	0e 94 6c 1e 	call	0x3cd8	; 0x3cd8 <vTaskSuspendAll>
        {
            /* Minor optimisation.  The tick count cannot change in this
             * block. */
            const TickType_t xConstTickCount = xTickCount;
    3b42:	80 91 c8 07 	lds	r24, 0x07C8
    3b46:	90 91 c9 07 	lds	r25, 0x07C9
    3b4a:	9a 83       	std	Y+2, r25	; 0x02
    3b4c:	89 83       	std	Y+1, r24	; 0x01

            /* Generate the tick time at which the task wants to wake. */
            xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    3b4e:	ef 81       	ldd	r30, Y+7	; 0x07
    3b50:	f8 85       	ldd	r31, Y+8	; 0x08
    3b52:	20 81       	ld	r18, Z
    3b54:	31 81       	ldd	r19, Z+1	; 0x01
    3b56:	89 85       	ldd	r24, Y+9	; 0x09
    3b58:	9a 85       	ldd	r25, Y+10	; 0x0a
    3b5a:	82 0f       	add	r24, r18
    3b5c:	93 1f       	adc	r25, r19
    3b5e:	9e 83       	std	Y+6, r25	; 0x06
    3b60:	8d 83       	std	Y+5, r24	; 0x05

            if( xConstTickCount < *pxPreviousWakeTime )
    3b62:	ef 81       	ldd	r30, Y+7	; 0x07
    3b64:	f8 85       	ldd	r31, Y+8	; 0x08
    3b66:	20 81       	ld	r18, Z
    3b68:	31 81       	ldd	r19, Z+1	; 0x01
    3b6a:	89 81       	ldd	r24, Y+1	; 0x01
    3b6c:	9a 81       	ldd	r25, Y+2	; 0x02
    3b6e:	82 17       	cp	r24, r18
    3b70:	93 07       	cpc	r25, r19
    3b72:	98 f4       	brcc	.+38     	; 0x3b9a <xTaskDelayUntil+0x7a>
                /* The tick count has overflowed since this function was
                 * lasted called.  In this case the only time we should ever
                 * actually delay is if the wake time has also  overflowed,
                 * and the wake time is greater than the tick time.  When this
                 * is the case it is as if neither time had overflowed. */
                if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
    3b74:	ef 81       	ldd	r30, Y+7	; 0x07
    3b76:	f8 85       	ldd	r31, Y+8	; 0x08
    3b78:	20 81       	ld	r18, Z
    3b7a:	31 81       	ldd	r19, Z+1	; 0x01
    3b7c:	8d 81       	ldd	r24, Y+5	; 0x05
    3b7e:	9e 81       	ldd	r25, Y+6	; 0x06
    3b80:	82 17       	cp	r24, r18
    3b82:	93 07       	cpc	r25, r19
    3b84:	e0 f4       	brcc	.+56     	; 0x3bbe <xTaskDelayUntil+0x9e>
    3b86:	2d 81       	ldd	r18, Y+5	; 0x05
    3b88:	3e 81       	ldd	r19, Y+6	; 0x06
    3b8a:	89 81       	ldd	r24, Y+1	; 0x01
    3b8c:	9a 81       	ldd	r25, Y+2	; 0x02
    3b8e:	82 17       	cp	r24, r18
    3b90:	93 07       	cpc	r25, r19
    3b92:	a8 f4       	brcc	.+42     	; 0x3bbe <xTaskDelayUntil+0x9e>
                {
                    xShouldDelay = pdTRUE;
    3b94:	81 e0       	ldi	r24, 0x01	; 1
    3b96:	8b 83       	std	Y+3, r24	; 0x03
    3b98:	12 c0       	rjmp	.+36     	; 0x3bbe <xTaskDelayUntil+0x9e>
            else
            {
                /* The tick time has not overflowed.  In this case we will
                 * delay if either the wake time has overflowed, and/or the
                 * tick time is less than the wake time. */
                if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
    3b9a:	ef 81       	ldd	r30, Y+7	; 0x07
    3b9c:	f8 85       	ldd	r31, Y+8	; 0x08
    3b9e:	20 81       	ld	r18, Z
    3ba0:	31 81       	ldd	r19, Z+1	; 0x01
    3ba2:	8d 81       	ldd	r24, Y+5	; 0x05
    3ba4:	9e 81       	ldd	r25, Y+6	; 0x06
    3ba6:	82 17       	cp	r24, r18
    3ba8:	93 07       	cpc	r25, r19
    3baa:	38 f0       	brcs	.+14     	; 0x3bba <xTaskDelayUntil+0x9a>
    3bac:	2d 81       	ldd	r18, Y+5	; 0x05
    3bae:	3e 81       	ldd	r19, Y+6	; 0x06
    3bb0:	89 81       	ldd	r24, Y+1	; 0x01
    3bb2:	9a 81       	ldd	r25, Y+2	; 0x02
    3bb4:	82 17       	cp	r24, r18
    3bb6:	93 07       	cpc	r25, r19
    3bb8:	10 f4       	brcc	.+4      	; 0x3bbe <xTaskDelayUntil+0x9e>
                {
                    xShouldDelay = pdTRUE;
    3bba:	81 e0       	ldi	r24, 0x01	; 1
    3bbc:	8b 83       	std	Y+3, r24	; 0x03
                    mtCOVERAGE_TEST_MARKER();
                }
            }

            /* Update the wake time ready for the next call. */
            *pxPreviousWakeTime = xTimeToWake;
    3bbe:	ef 81       	ldd	r30, Y+7	; 0x07
    3bc0:	f8 85       	ldd	r31, Y+8	; 0x08
    3bc2:	8d 81       	ldd	r24, Y+5	; 0x05
    3bc4:	9e 81       	ldd	r25, Y+6	; 0x06
    3bc6:	91 83       	std	Z+1, r25	; 0x01
    3bc8:	80 83       	st	Z, r24

            if( xShouldDelay != pdFALSE )
    3bca:	8b 81       	ldd	r24, Y+3	; 0x03
    3bcc:	88 23       	and	r24, r24
    3bce:	49 f0       	breq	.+18     	; 0x3be2 <xTaskDelayUntil+0xc2>
            {
                traceTASK_DELAY_UNTIL( xTimeToWake );

                /* prvAddCurrentTaskToDelayedList() needs the block time, not
                 * the time to wake, so subtract the current tick count. */
                prvAddCurrentTaskToDelayedList( xTimeToWake - xConstTickCount, pdFALSE );
    3bd0:	8d 81       	ldd	r24, Y+5	; 0x05
    3bd2:	9e 81       	ldd	r25, Y+6	; 0x06
    3bd4:	29 81       	ldd	r18, Y+1	; 0x01
    3bd6:	3a 81       	ldd	r19, Y+2	; 0x02
    3bd8:	82 1b       	sub	r24, r18
    3bda:	93 0b       	sbc	r25, r19
    3bdc:	60 e0       	ldi	r22, 0x00	; 0
    3bde:	0e 94 a5 2e 	call	0x5d4a	; 0x5d4a <prvAddCurrentTaskToDelayedList>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        xAlreadyYielded = xTaskResumeAll();
    3be2:	0e 94 78 1e 	call	0x3cf0	; 0x3cf0 <xTaskResumeAll>
    3be6:	8c 83       	std	Y+4, r24	; 0x04

        /* Force a reschedule if xTaskResumeAll has not already done so, we may
         * have put ourselves to sleep. */
        if( xAlreadyYielded == pdFALSE )
    3be8:	8c 81       	ldd	r24, Y+4	; 0x04
    3bea:	88 23       	and	r24, r24
    3bec:	11 f4       	brne	.+4      	; 0x3bf2 <xTaskDelayUntil+0xd2>
        {
            portYIELD_WITHIN_API();
    3bee:	0e 94 56 09 	call	0x12ac	; 0x12ac <vPortYield>
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        return xShouldDelay;
    3bf2:	8b 81       	ldd	r24, Y+3	; 0x03
    }
    3bf4:	2a 96       	adiw	r28, 0x0a	; 10
    3bf6:	0f b6       	in	r0, 0x3f	; 63
    3bf8:	f8 94       	cli
    3bfa:	de bf       	out	0x3e, r29	; 62
    3bfc:	0f be       	out	0x3f, r0	; 63
    3bfe:	cd bf       	out	0x3d, r28	; 61
    3c00:	cf 91       	pop	r28
    3c02:	df 91       	pop	r29
    3c04:	08 95       	ret

00003c06 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

    void vTaskDelay( const TickType_t xTicksToDelay )
    {
    3c06:	df 93       	push	r29
    3c08:	cf 93       	push	r28
    3c0a:	00 d0       	rcall	.+0      	; 0x3c0c <vTaskDelay+0x6>
    3c0c:	0f 92       	push	r0
    3c0e:	cd b7       	in	r28, 0x3d	; 61
    3c10:	de b7       	in	r29, 0x3e	; 62
    3c12:	9b 83       	std	Y+3, r25	; 0x03
    3c14:	8a 83       	std	Y+2, r24	; 0x02
        BaseType_t xAlreadyYielded = pdFALSE;
    3c16:	19 82       	std	Y+1, r1	; 0x01

        /* A delay time of zero just forces a reschedule. */
        if( xTicksToDelay > ( TickType_t ) 0U )
    3c18:	8a 81       	ldd	r24, Y+2	; 0x02
    3c1a:	9b 81       	ldd	r25, Y+3	; 0x03
    3c1c:	00 97       	sbiw	r24, 0x00	; 0
    3c1e:	51 f0       	breq	.+20     	; 0x3c34 <vTaskDelay+0x2e>
        {
            configASSERT( uxSchedulerSuspended == 0 );
            vTaskSuspendAll();
    3c20:	0e 94 6c 1e 	call	0x3cd8	; 0x3cd8 <vTaskSuspendAll>
                 * list or removed from the blocked list until the scheduler
                 * is resumed.
                 *
                 * This task cannot be in an event list as it is the currently
                 * executing task. */
                prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
    3c24:	8a 81       	ldd	r24, Y+2	; 0x02
    3c26:	9b 81       	ldd	r25, Y+3	; 0x03
    3c28:	60 e0       	ldi	r22, 0x00	; 0
    3c2a:	0e 94 a5 2e 	call	0x5d4a	; 0x5d4a <prvAddCurrentTaskToDelayedList>
            }
            xAlreadyYielded = xTaskResumeAll();
    3c2e:	0e 94 78 1e 	call	0x3cf0	; 0x3cf0 <xTaskResumeAll>
    3c32:	89 83       	std	Y+1, r24	; 0x01
            mtCOVERAGE_TEST_MARKER();
        }

        /* Force a reschedule if xTaskResumeAll has not already done so, we may
         * have put ourselves to sleep. */
        if( xAlreadyYielded == pdFALSE )
    3c34:	89 81       	ldd	r24, Y+1	; 0x01
    3c36:	88 23       	and	r24, r24
    3c38:	11 f4       	brne	.+4      	; 0x3c3e <vTaskDelay+0x38>
        {
            portYIELD_WITHIN_API();
    3c3a:	0e 94 56 09 	call	0x12ac	; 0x12ac <vPortYield>
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }
    3c3e:	0f 90       	pop	r0
    3c40:	0f 90       	pop	r0
    3c42:	0f 90       	pop	r0
    3c44:	cf 91       	pop	r28
    3c46:	df 91       	pop	r29
    3c48:	08 95       	ret

00003c4a <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
    3c4a:	ef 92       	push	r14
    3c4c:	ff 92       	push	r15
    3c4e:	0f 93       	push	r16
    3c50:	df 93       	push	r29
    3c52:	cf 93       	push	r28
    3c54:	00 d0       	rcall	.+0      	; 0x3c56 <vTaskStartScheduler+0xc>
    3c56:	cd b7       	in	r28, 0x3d	; 61
    3c58:	de b7       	in	r29, 0x3e	; 62
            }
        }
    #else /* if ( configSUPPORT_STATIC_ALLOCATION == 1 ) */
        {
            /* The Idle task is being created using dynamically allocated RAM. */
            xReturn = xTaskCreate( prvIdleTask,
    3c5a:	8c e2       	ldi	r24, 0x2C	; 44
    3c5c:	96 e2       	ldi	r25, 0x26	; 38
    3c5e:	20 e6       	ldi	r18, 0x60	; 96
    3c60:	30 e0       	ldi	r19, 0x00	; 0
    3c62:	e3 ed       	ldi	r30, 0xD3	; 211
    3c64:	f7 e0       	ldi	r31, 0x07	; 7
    3c66:	b9 01       	movw	r22, r18
    3c68:	45 e5       	ldi	r20, 0x55	; 85
    3c6a:	50 e0       	ldi	r21, 0x00	; 0
    3c6c:	20 e0       	ldi	r18, 0x00	; 0
    3c6e:	30 e0       	ldi	r19, 0x00	; 0
    3c70:	00 e0       	ldi	r16, 0x00	; 0
    3c72:	7f 01       	movw	r14, r30
    3c74:	0e 94 1b 1b 	call	0x3636	; 0x3636 <xTaskCreate>
    3c78:	89 83       	std	Y+1, r24	; 0x01
        }
    #endif /* configSUPPORT_STATIC_ALLOCATION */

    #if ( configUSE_TIMERS == 1 )
        {
            if( xReturn == pdPASS )
    3c7a:	89 81       	ldd	r24, Y+1	; 0x01
    3c7c:	81 30       	cpi	r24, 0x01	; 1
    3c7e:	19 f4       	brne	.+6      	; 0x3c86 <vTaskStartScheduler+0x3c>
            {
                xReturn = xTimerCreateTimerTask();
    3c80:	0e 94 0b 2f 	call	0x5e16	; 0x5e16 <xTimerCreateTimerTask>
    3c84:	89 83       	std	Y+1, r24	; 0x01
                mtCOVERAGE_TEST_MARKER();
            }
        }
    #endif /* configUSE_TIMERS */

    if( xReturn == pdPASS )
    3c86:	89 81       	ldd	r24, Y+1	; 0x01
    3c88:	81 30       	cpi	r24, 0x01	; 1
    3c8a:	81 f4       	brne	.+32     	; 0x3cac <vTaskStartScheduler+0x62>
        /* Interrupts are turned off here, to ensure a tick does not occur
         * before or during the call to xPortStartScheduler().  The stacks of
         * the created tasks contain a status word with interrupts switched on
         * so interrupts will automatically get re-enabled when the first task
         * starts to run. */
        portDISABLE_INTERRUPTS();
    3c8c:	f8 94       	cli
                 * for additional information. */
                _impure_ptr = &( pxCurrentTCB->xNewLib_reent );
            }
        #endif /* configUSE_NEWLIB_REENTRANT */

        xNextTaskUnblockTime = portMAX_DELAY;
    3c8e:	8f ef       	ldi	r24, 0xFF	; 255
    3c90:	9f ef       	ldi	r25, 0xFF	; 255
    3c92:	90 93 d2 07 	sts	0x07D2, r25
    3c96:	80 93 d1 07 	sts	0x07D1, r24
        xSchedulerRunning = pdTRUE;
    3c9a:	81 e0       	ldi	r24, 0x01	; 1
    3c9c:	80 93 cb 07 	sts	0x07CB, r24
        xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
    3ca0:	10 92 c9 07 	sts	0x07C9, r1
    3ca4:	10 92 c8 07 	sts	0x07C8, r1

        traceTASK_SWITCHED_IN();

        /* Setting up the timer tick is hardware specific and thus in the
         * portable interface. */
        if( xPortStartScheduler() != pdFALSE )
    3ca8:	0e 94 1a 09 	call	0x1234	; 0x1234 <xPortStartScheduler>
     * meaning xIdleTaskHandle is not used anywhere else. */
    ( void ) xIdleTaskHandle;

    /* OpenOCD makes use of uxTopUsedPriority for thread debugging. Prevent uxTopUsedPriority
     * from getting optimized out as it is no longer used by the kernel. */
    ( void ) uxTopUsedPriority;
    3cac:	80 91 91 01 	lds	r24, 0x0191
}
    3cb0:	0f 90       	pop	r0
    3cb2:	0f 90       	pop	r0
    3cb4:	cf 91       	pop	r28
    3cb6:	df 91       	pop	r29
    3cb8:	0f 91       	pop	r16
    3cba:	ff 90       	pop	r15
    3cbc:	ef 90       	pop	r14
    3cbe:	08 95       	ret

00003cc0 <vTaskEndScheduler>:
/*-----------------------------------------------------------*/

void vTaskEndScheduler( void )
{
    3cc0:	df 93       	push	r29
    3cc2:	cf 93       	push	r28
    3cc4:	cd b7       	in	r28, 0x3d	; 61
    3cc6:	de b7       	in	r29, 0x3e	; 62
    /* Stop the scheduler interrupts and call the portable scheduler end
     * routine so the original ISRs can be restored if necessary.  The port
     * layer must ensure interrupts enable  bit is left in the correct state. */
    portDISABLE_INTERRUPTS();
    3cc8:	f8 94       	cli
    xSchedulerRunning = pdFALSE;
    3cca:	10 92 cb 07 	sts	0x07CB, r1
    vPortEndScheduler();
    3cce:	0e 94 4f 09 	call	0x129e	; 0x129e <vPortEndScheduler>
}
    3cd2:	cf 91       	pop	r28
    3cd4:	df 91       	pop	r29
    3cd6:	08 95       	ret

00003cd8 <vTaskSuspendAll>:
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
    3cd8:	df 93       	push	r29
    3cda:	cf 93       	push	r28
    3cdc:	cd b7       	in	r28, 0x3d	; 61
    3cde:	de b7       	in	r29, 0x3e	; 62
     * do not otherwise exhibit real time behaviour. */
    portSOFTWARE_BARRIER();

    /* The scheduler is suspended if uxSchedulerSuspended is non-zero.  An increment
     * is used to allow calls to vTaskSuspendAll() to nest. */
    ++uxSchedulerSuspended;
    3ce0:	80 91 d5 07 	lds	r24, 0x07D5
    3ce4:	8f 5f       	subi	r24, 0xFF	; 255
    3ce6:	80 93 d5 07 	sts	0x07D5, r24

    /* Enforces ordering for ports and optimised compilers that may otherwise place
     * the above increment elsewhere. */
    portMEMORY_BARRIER();
}
    3cea:	cf 91       	pop	r28
    3cec:	df 91       	pop	r29
    3cee:	08 95       	ret

00003cf0 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
    3cf0:	df 93       	push	r29
    3cf2:	cf 93       	push	r28
    3cf4:	cd b7       	in	r28, 0x3d	; 61
    3cf6:	de b7       	in	r29, 0x3e	; 62
    3cf8:	2b 97       	sbiw	r28, 0x0b	; 11
    3cfa:	0f b6       	in	r0, 0x3f	; 63
    3cfc:	f8 94       	cli
    3cfe:	de bf       	out	0x3e, r29	; 62
    3d00:	0f be       	out	0x3f, r0	; 63
    3d02:	cd bf       	out	0x3d, r28	; 61
    TCB_t * pxTCB = NULL;
    3d04:	1b 86       	std	Y+11, r1	; 0x0b
    3d06:	1a 86       	std	Y+10, r1	; 0x0a
    BaseType_t xAlreadyYielded = pdFALSE;
    3d08:	19 86       	std	Y+9, r1	; 0x09
    /* It is possible that an ISR caused a task to be removed from an event
     * list while the scheduler was suspended.  If this was the case then the
     * removed task will have been added to the xPendingReadyList.  Once the
     * scheduler has been resumed it is safe to move all the pending ready
     * tasks from this list into their appropriate ready list. */
    taskENTER_CRITICAL();
    3d0a:	0f b6       	in	r0, 0x3f	; 63
    3d0c:	f8 94       	cli
    3d0e:	0f 92       	push	r0
    {
        --uxSchedulerSuspended;
    3d10:	80 91 d5 07 	lds	r24, 0x07D5
    3d14:	81 50       	subi	r24, 0x01	; 1
    3d16:	80 93 d5 07 	sts	0x07D5, r24

        if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    3d1a:	80 91 d5 07 	lds	r24, 0x07D5
    3d1e:	88 23       	and	r24, r24
    3d20:	09 f0       	breq	.+2      	; 0x3d24 <xTaskResumeAll+0x34>
    3d22:	2a c1       	rjmp	.+596    	; 0x3f78 <xTaskResumeAll+0x288>
        {
            if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
    3d24:	80 91 c7 07 	lds	r24, 0x07C7
    3d28:	88 23       	and	r24, r24
    3d2a:	09 f4       	brne	.+2      	; 0x3d2e <xTaskResumeAll+0x3e>
    3d2c:	25 c1       	rjmp	.+586    	; 0x3f78 <xTaskResumeAll+0x288>
    3d2e:	f3 c0       	rjmp	.+486    	; 0x3f16 <xTaskResumeAll+0x226>
            {
                /* Move any readied tasks from the pending list into the
                 * appropriate ready list. */
                while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
                {
                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    3d30:	e0 91 15 08 	lds	r30, 0x0815
    3d34:	f0 91 16 08 	lds	r31, 0x0816
    3d38:	86 81       	ldd	r24, Z+6	; 0x06
    3d3a:	97 81       	ldd	r25, Z+7	; 0x07
    3d3c:	9b 87       	std	Y+11, r25	; 0x0b
    3d3e:	8a 87       	std	Y+10, r24	; 0x0a
                    listREMOVE_ITEM( &( pxTCB->xEventListItem ) );
    3d40:	ea 85       	ldd	r30, Y+10	; 0x0a
    3d42:	fb 85       	ldd	r31, Y+11	; 0x0b
    3d44:	84 89       	ldd	r24, Z+20	; 0x14
    3d46:	95 89       	ldd	r25, Z+21	; 0x15
    3d48:	98 87       	std	Y+8, r25	; 0x08
    3d4a:	8f 83       	std	Y+7, r24	; 0x07
    3d4c:	ea 85       	ldd	r30, Y+10	; 0x0a
    3d4e:	fb 85       	ldd	r31, Y+11	; 0x0b
    3d50:	a6 85       	ldd	r26, Z+14	; 0x0e
    3d52:	b7 85       	ldd	r27, Z+15	; 0x0f
    3d54:	ea 85       	ldd	r30, Y+10	; 0x0a
    3d56:	fb 85       	ldd	r31, Y+11	; 0x0b
    3d58:	80 89       	ldd	r24, Z+16	; 0x10
    3d5a:	91 89       	ldd	r25, Z+17	; 0x11
    3d5c:	15 96       	adiw	r26, 0x05	; 5
    3d5e:	9c 93       	st	X, r25
    3d60:	8e 93       	st	-X, r24
    3d62:	14 97       	sbiw	r26, 0x04	; 4
    3d64:	ea 85       	ldd	r30, Y+10	; 0x0a
    3d66:	fb 85       	ldd	r31, Y+11	; 0x0b
    3d68:	a0 89       	ldd	r26, Z+16	; 0x10
    3d6a:	b1 89       	ldd	r27, Z+17	; 0x11
    3d6c:	ea 85       	ldd	r30, Y+10	; 0x0a
    3d6e:	fb 85       	ldd	r31, Y+11	; 0x0b
    3d70:	86 85       	ldd	r24, Z+14	; 0x0e
    3d72:	97 85       	ldd	r25, Z+15	; 0x0f
    3d74:	13 96       	adiw	r26, 0x03	; 3
    3d76:	9c 93       	st	X, r25
    3d78:	8e 93       	st	-X, r24
    3d7a:	12 97       	sbiw	r26, 0x02	; 2
    3d7c:	ef 81       	ldd	r30, Y+7	; 0x07
    3d7e:	f8 85       	ldd	r31, Y+8	; 0x08
    3d80:	21 81       	ldd	r18, Z+1	; 0x01
    3d82:	32 81       	ldd	r19, Z+2	; 0x02
    3d84:	8a 85       	ldd	r24, Y+10	; 0x0a
    3d86:	9b 85       	ldd	r25, Y+11	; 0x0b
    3d88:	0c 96       	adiw	r24, 0x0c	; 12
    3d8a:	28 17       	cp	r18, r24
    3d8c:	39 07       	cpc	r19, r25
    3d8e:	41 f4       	brne	.+16     	; 0x3da0 <xTaskResumeAll+0xb0>
    3d90:	ea 85       	ldd	r30, Y+10	; 0x0a
    3d92:	fb 85       	ldd	r31, Y+11	; 0x0b
    3d94:	80 89       	ldd	r24, Z+16	; 0x10
    3d96:	91 89       	ldd	r25, Z+17	; 0x11
    3d98:	ef 81       	ldd	r30, Y+7	; 0x07
    3d9a:	f8 85       	ldd	r31, Y+8	; 0x08
    3d9c:	92 83       	std	Z+2, r25	; 0x02
    3d9e:	81 83       	std	Z+1, r24	; 0x01
    3da0:	ea 85       	ldd	r30, Y+10	; 0x0a
    3da2:	fb 85       	ldd	r31, Y+11	; 0x0b
    3da4:	15 8a       	std	Z+21, r1	; 0x15
    3da6:	14 8a       	std	Z+20, r1	; 0x14
    3da8:	ef 81       	ldd	r30, Y+7	; 0x07
    3daa:	f8 85       	ldd	r31, Y+8	; 0x08
    3dac:	80 81       	ld	r24, Z
    3dae:	81 50       	subi	r24, 0x01	; 1
    3db0:	ef 81       	ldd	r30, Y+7	; 0x07
    3db2:	f8 85       	ldd	r31, Y+8	; 0x08
    3db4:	80 83       	st	Z, r24
                    portMEMORY_BARRIER();
                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
    3db6:	ea 85       	ldd	r30, Y+10	; 0x0a
    3db8:	fb 85       	ldd	r31, Y+11	; 0x0b
    3dba:	82 85       	ldd	r24, Z+10	; 0x0a
    3dbc:	93 85       	ldd	r25, Z+11	; 0x0b
    3dbe:	9e 83       	std	Y+6, r25	; 0x06
    3dc0:	8d 83       	std	Y+5, r24	; 0x05
    3dc2:	ea 85       	ldd	r30, Y+10	; 0x0a
    3dc4:	fb 85       	ldd	r31, Y+11	; 0x0b
    3dc6:	a4 81       	ldd	r26, Z+4	; 0x04
    3dc8:	b5 81       	ldd	r27, Z+5	; 0x05
    3dca:	ea 85       	ldd	r30, Y+10	; 0x0a
    3dcc:	fb 85       	ldd	r31, Y+11	; 0x0b
    3dce:	86 81       	ldd	r24, Z+6	; 0x06
    3dd0:	97 81       	ldd	r25, Z+7	; 0x07
    3dd2:	15 96       	adiw	r26, 0x05	; 5
    3dd4:	9c 93       	st	X, r25
    3dd6:	8e 93       	st	-X, r24
    3dd8:	14 97       	sbiw	r26, 0x04	; 4
    3dda:	ea 85       	ldd	r30, Y+10	; 0x0a
    3ddc:	fb 85       	ldd	r31, Y+11	; 0x0b
    3dde:	a6 81       	ldd	r26, Z+6	; 0x06
    3de0:	b7 81       	ldd	r27, Z+7	; 0x07
    3de2:	ea 85       	ldd	r30, Y+10	; 0x0a
    3de4:	fb 85       	ldd	r31, Y+11	; 0x0b
    3de6:	84 81       	ldd	r24, Z+4	; 0x04
    3de8:	95 81       	ldd	r25, Z+5	; 0x05
    3dea:	13 96       	adiw	r26, 0x03	; 3
    3dec:	9c 93       	st	X, r25
    3dee:	8e 93       	st	-X, r24
    3df0:	12 97       	sbiw	r26, 0x02	; 2
    3df2:	ed 81       	ldd	r30, Y+5	; 0x05
    3df4:	fe 81       	ldd	r31, Y+6	; 0x06
    3df6:	21 81       	ldd	r18, Z+1	; 0x01
    3df8:	32 81       	ldd	r19, Z+2	; 0x02
    3dfa:	8a 85       	ldd	r24, Y+10	; 0x0a
    3dfc:	9b 85       	ldd	r25, Y+11	; 0x0b
    3dfe:	02 96       	adiw	r24, 0x02	; 2
    3e00:	28 17       	cp	r18, r24
    3e02:	39 07       	cpc	r19, r25
    3e04:	41 f4       	brne	.+16     	; 0x3e16 <xTaskResumeAll+0x126>
    3e06:	ea 85       	ldd	r30, Y+10	; 0x0a
    3e08:	fb 85       	ldd	r31, Y+11	; 0x0b
    3e0a:	86 81       	ldd	r24, Z+6	; 0x06
    3e0c:	97 81       	ldd	r25, Z+7	; 0x07
    3e0e:	ed 81       	ldd	r30, Y+5	; 0x05
    3e10:	fe 81       	ldd	r31, Y+6	; 0x06
    3e12:	92 83       	std	Z+2, r25	; 0x02
    3e14:	81 83       	std	Z+1, r24	; 0x01
    3e16:	ea 85       	ldd	r30, Y+10	; 0x0a
    3e18:	fb 85       	ldd	r31, Y+11	; 0x0b
    3e1a:	13 86       	std	Z+11, r1	; 0x0b
    3e1c:	12 86       	std	Z+10, r1	; 0x0a
    3e1e:	ed 81       	ldd	r30, Y+5	; 0x05
    3e20:	fe 81       	ldd	r31, Y+6	; 0x06
    3e22:	80 81       	ld	r24, Z
    3e24:	81 50       	subi	r24, 0x01	; 1
    3e26:	ed 81       	ldd	r30, Y+5	; 0x05
    3e28:	fe 81       	ldd	r31, Y+6	; 0x06
    3e2a:	80 83       	st	Z, r24
                    prvAddTaskToReadyList( pxTCB );
    3e2c:	ea 85       	ldd	r30, Y+10	; 0x0a
    3e2e:	fb 85       	ldd	r31, Y+11	; 0x0b
    3e30:	96 89       	ldd	r25, Z+22	; 0x16
    3e32:	80 91 ca 07 	lds	r24, 0x07CA
    3e36:	89 17       	cp	r24, r25
    3e38:	28 f4       	brcc	.+10     	; 0x3e44 <xTaskResumeAll+0x154>
    3e3a:	ea 85       	ldd	r30, Y+10	; 0x0a
    3e3c:	fb 85       	ldd	r31, Y+11	; 0x0b
    3e3e:	86 89       	ldd	r24, Z+22	; 0x16
    3e40:	80 93 ca 07 	sts	0x07CA, r24
    3e44:	ea 85       	ldd	r30, Y+10	; 0x0a
    3e46:	fb 85       	ldd	r31, Y+11	; 0x0b
    3e48:	86 89       	ldd	r24, Z+22	; 0x16
    3e4a:	28 2f       	mov	r18, r24
    3e4c:	30 e0       	ldi	r19, 0x00	; 0
    3e4e:	c9 01       	movw	r24, r18
    3e50:	88 0f       	add	r24, r24
    3e52:	99 1f       	adc	r25, r25
    3e54:	88 0f       	add	r24, r24
    3e56:	99 1f       	adc	r25, r25
    3e58:	88 0f       	add	r24, r24
    3e5a:	99 1f       	adc	r25, r25
    3e5c:	82 0f       	add	r24, r18
    3e5e:	93 1f       	adc	r25, r19
    3e60:	fc 01       	movw	r30, r24
    3e62:	ea 52       	subi	r30, 0x2A	; 42
    3e64:	f8 4f       	sbci	r31, 0xF8	; 248
    3e66:	81 81       	ldd	r24, Z+1	; 0x01
    3e68:	92 81       	ldd	r25, Z+2	; 0x02
    3e6a:	9c 83       	std	Y+4, r25	; 0x04
    3e6c:	8b 83       	std	Y+3, r24	; 0x03
    3e6e:	ea 85       	ldd	r30, Y+10	; 0x0a
    3e70:	fb 85       	ldd	r31, Y+11	; 0x0b
    3e72:	8b 81       	ldd	r24, Y+3	; 0x03
    3e74:	9c 81       	ldd	r25, Y+4	; 0x04
    3e76:	95 83       	std	Z+5, r25	; 0x05
    3e78:	84 83       	std	Z+4, r24	; 0x04
    3e7a:	eb 81       	ldd	r30, Y+3	; 0x03
    3e7c:	fc 81       	ldd	r31, Y+4	; 0x04
    3e7e:	84 81       	ldd	r24, Z+4	; 0x04
    3e80:	95 81       	ldd	r25, Z+5	; 0x05
    3e82:	ea 85       	ldd	r30, Y+10	; 0x0a
    3e84:	fb 85       	ldd	r31, Y+11	; 0x0b
    3e86:	97 83       	std	Z+7, r25	; 0x07
    3e88:	86 83       	std	Z+6, r24	; 0x06
    3e8a:	eb 81       	ldd	r30, Y+3	; 0x03
    3e8c:	fc 81       	ldd	r31, Y+4	; 0x04
    3e8e:	04 80       	ldd	r0, Z+4	; 0x04
    3e90:	f5 81       	ldd	r31, Z+5	; 0x05
    3e92:	e0 2d       	mov	r30, r0
    3e94:	8a 85       	ldd	r24, Y+10	; 0x0a
    3e96:	9b 85       	ldd	r25, Y+11	; 0x0b
    3e98:	02 96       	adiw	r24, 0x02	; 2
    3e9a:	93 83       	std	Z+3, r25	; 0x03
    3e9c:	82 83       	std	Z+2, r24	; 0x02
    3e9e:	8a 85       	ldd	r24, Y+10	; 0x0a
    3ea0:	9b 85       	ldd	r25, Y+11	; 0x0b
    3ea2:	02 96       	adiw	r24, 0x02	; 2
    3ea4:	eb 81       	ldd	r30, Y+3	; 0x03
    3ea6:	fc 81       	ldd	r31, Y+4	; 0x04
    3ea8:	95 83       	std	Z+5, r25	; 0x05
    3eaa:	84 83       	std	Z+4, r24	; 0x04
    3eac:	ea 85       	ldd	r30, Y+10	; 0x0a
    3eae:	fb 85       	ldd	r31, Y+11	; 0x0b
    3eb0:	86 89       	ldd	r24, Z+22	; 0x16
    3eb2:	28 2f       	mov	r18, r24
    3eb4:	30 e0       	ldi	r19, 0x00	; 0
    3eb6:	c9 01       	movw	r24, r18
    3eb8:	88 0f       	add	r24, r24
    3eba:	99 1f       	adc	r25, r25
    3ebc:	88 0f       	add	r24, r24
    3ebe:	99 1f       	adc	r25, r25
    3ec0:	88 0f       	add	r24, r24
    3ec2:	99 1f       	adc	r25, r25
    3ec4:	82 0f       	add	r24, r18
    3ec6:	93 1f       	adc	r25, r19
    3ec8:	8a 52       	subi	r24, 0x2A	; 42
    3eca:	98 4f       	sbci	r25, 0xF8	; 248
    3ecc:	ea 85       	ldd	r30, Y+10	; 0x0a
    3ece:	fb 85       	ldd	r31, Y+11	; 0x0b
    3ed0:	93 87       	std	Z+11, r25	; 0x0b
    3ed2:	82 87       	std	Z+10, r24	; 0x0a
    3ed4:	ea 85       	ldd	r30, Y+10	; 0x0a
    3ed6:	fb 85       	ldd	r31, Y+11	; 0x0b
    3ed8:	86 89       	ldd	r24, Z+22	; 0x16
    3eda:	28 2f       	mov	r18, r24
    3edc:	30 e0       	ldi	r19, 0x00	; 0
    3ede:	c9 01       	movw	r24, r18
    3ee0:	88 0f       	add	r24, r24
    3ee2:	99 1f       	adc	r25, r25
    3ee4:	88 0f       	add	r24, r24
    3ee6:	99 1f       	adc	r25, r25
    3ee8:	88 0f       	add	r24, r24
    3eea:	99 1f       	adc	r25, r25
    3eec:	82 0f       	add	r24, r18
    3eee:	93 1f       	adc	r25, r19
    3ef0:	fc 01       	movw	r30, r24
    3ef2:	ea 52       	subi	r30, 0x2A	; 42
    3ef4:	f8 4f       	sbci	r31, 0xF8	; 248
    3ef6:	80 81       	ld	r24, Z
    3ef8:	8f 5f       	subi	r24, 0xFF	; 255
    3efa:	80 83       	st	Z, r24

                    /* If the moved task has a priority higher than or equal to
                     * the current task then a yield must be performed. */
                    if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    3efc:	ea 85       	ldd	r30, Y+10	; 0x0a
    3efe:	fb 85       	ldd	r31, Y+11	; 0x0b
    3f00:	96 89       	ldd	r25, Z+22	; 0x16
    3f02:	e0 91 c4 07 	lds	r30, 0x07C4
    3f06:	f0 91 c5 07 	lds	r31, 0x07C5
    3f0a:	86 89       	ldd	r24, Z+22	; 0x16
    3f0c:	98 17       	cp	r25, r24
    3f0e:	18 f0       	brcs	.+6      	; 0x3f16 <xTaskResumeAll+0x226>
                    {
                        xYieldPending = pdTRUE;
    3f10:	81 e0       	ldi	r24, 0x01	; 1
    3f12:	80 93 ce 07 	sts	0x07CE, r24
        {
            if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
            {
                /* Move any readied tasks from the pending list into the
                 * appropriate ready list. */
                while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
    3f16:	80 91 10 08 	lds	r24, 0x0810
    3f1a:	88 23       	and	r24, r24
    3f1c:	09 f0       	breq	.+2      	; 0x3f20 <xTaskResumeAll+0x230>
    3f1e:	08 cf       	rjmp	.-496    	; 0x3d30 <xTaskResumeAll+0x40>
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }
                }

                if( pxTCB != NULL )
    3f20:	8a 85       	ldd	r24, Y+10	; 0x0a
    3f22:	9b 85       	ldd	r25, Y+11	; 0x0b
    3f24:	00 97       	sbiw	r24, 0x00	; 0
    3f26:	11 f0       	breq	.+4      	; 0x3f2c <xTaskResumeAll+0x23c>
                     * which may have prevented the next unblock time from being
                     * re-calculated, in which case re-calculate it now.  Mainly
                     * important for low power tickless implementations, where
                     * this can prevent an unnecessary exit from low power
                     * state. */
                    prvResetNextTaskUnblockTime();
    3f28:	0e 94 be 26 	call	0x4d7c	; 0x4d7c <prvResetNextTaskUnblockTime>
                /* If any ticks occurred while the scheduler was suspended then
                 * they should be processed now.  This ensures the tick count does
                 * not  slip, and that any delayed tasks are resumed at the correct
                 * time. */
                {
                    TickType_t xPendedCounts = xPendedTicks; /* Non-volatile copy. */
    3f2c:	80 91 cc 07 	lds	r24, 0x07CC
    3f30:	90 91 cd 07 	lds	r25, 0x07CD
    3f34:	9a 83       	std	Y+2, r25	; 0x02
    3f36:	89 83       	std	Y+1, r24	; 0x01

                    if( xPendedCounts > ( TickType_t ) 0U )
    3f38:	89 81       	ldd	r24, Y+1	; 0x01
    3f3a:	9a 81       	ldd	r25, Y+2	; 0x02
    3f3c:	00 97       	sbiw	r24, 0x00	; 0
    3f3e:	a1 f0       	breq	.+40     	; 0x3f68 <xTaskResumeAll+0x278>
                    {
                        do
                        {
                            if( xTaskIncrementTick() != pdFALSE )
    3f40:	0e 94 45 20 	call	0x408a	; 0x408a <xTaskIncrementTick>
    3f44:	88 23       	and	r24, r24
    3f46:	19 f0       	breq	.+6      	; 0x3f4e <xTaskResumeAll+0x25e>
                            {
                                xYieldPending = pdTRUE;
    3f48:	81 e0       	ldi	r24, 0x01	; 1
    3f4a:	80 93 ce 07 	sts	0x07CE, r24
                            else
                            {
                                mtCOVERAGE_TEST_MARKER();
                            }

                            --xPendedCounts;
    3f4e:	89 81       	ldd	r24, Y+1	; 0x01
    3f50:	9a 81       	ldd	r25, Y+2	; 0x02
    3f52:	01 97       	sbiw	r24, 0x01	; 1
    3f54:	9a 83       	std	Y+2, r25	; 0x02
    3f56:	89 83       	std	Y+1, r24	; 0x01
                        } while( xPendedCounts > ( TickType_t ) 0U );
    3f58:	89 81       	ldd	r24, Y+1	; 0x01
    3f5a:	9a 81       	ldd	r25, Y+2	; 0x02
    3f5c:	00 97       	sbiw	r24, 0x00	; 0
    3f5e:	81 f7       	brne	.-32     	; 0x3f40 <xTaskResumeAll+0x250>

                        xPendedTicks = 0;
    3f60:	10 92 cd 07 	sts	0x07CD, r1
    3f64:	10 92 cc 07 	sts	0x07CC, r1
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }
                }

                if( xYieldPending != pdFALSE )
    3f68:	80 91 ce 07 	lds	r24, 0x07CE
    3f6c:	88 23       	and	r24, r24
    3f6e:	21 f0       	breq	.+8      	; 0x3f78 <xTaskResumeAll+0x288>
                {
                    #if ( configUSE_PREEMPTION != 0 )
                        {
                            xAlreadyYielded = pdTRUE;
    3f70:	81 e0       	ldi	r24, 0x01	; 1
    3f72:	89 87       	std	Y+9, r24	; 0x09
                        }
                    #endif
                    taskYIELD_IF_USING_PREEMPTION();
    3f74:	0e 94 56 09 	call	0x12ac	; 0x12ac <vPortYield>
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }
    taskEXIT_CRITICAL();
    3f78:	0f 90       	pop	r0
    3f7a:	0f be       	out	0x3f, r0	; 63

    return xAlreadyYielded;
    3f7c:	89 85       	ldd	r24, Y+9	; 0x09
}
    3f7e:	2b 96       	adiw	r28, 0x0b	; 11
    3f80:	0f b6       	in	r0, 0x3f	; 63
    3f82:	f8 94       	cli
    3f84:	de bf       	out	0x3e, r29	; 62
    3f86:	0f be       	out	0x3f, r0	; 63
    3f88:	cd bf       	out	0x3d, r28	; 61
    3f8a:	cf 91       	pop	r28
    3f8c:	df 91       	pop	r29
    3f8e:	08 95       	ret

00003f90 <xTaskGetTickCount>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCount( void )
{
    3f90:	df 93       	push	r29
    3f92:	cf 93       	push	r28
    3f94:	00 d0       	rcall	.+0      	; 0x3f96 <xTaskGetTickCount+0x6>
    3f96:	cd b7       	in	r28, 0x3d	; 61
    3f98:	de b7       	in	r29, 0x3e	; 62
    TickType_t xTicks;

    /* Critical section required if running on a 16 bit processor. */
    portTICK_TYPE_ENTER_CRITICAL();
    3f9a:	0f b6       	in	r0, 0x3f	; 63
    3f9c:	f8 94       	cli
    3f9e:	0f 92       	push	r0
    {
        xTicks = xTickCount;
    3fa0:	80 91 c8 07 	lds	r24, 0x07C8
    3fa4:	90 91 c9 07 	lds	r25, 0x07C9
    3fa8:	9a 83       	std	Y+2, r25	; 0x02
    3faa:	89 83       	std	Y+1, r24	; 0x01
    }
    portTICK_TYPE_EXIT_CRITICAL();
    3fac:	0f 90       	pop	r0
    3fae:	0f be       	out	0x3f, r0	; 63

    return xTicks;
    3fb0:	89 81       	ldd	r24, Y+1	; 0x01
    3fb2:	9a 81       	ldd	r25, Y+2	; 0x02
}
    3fb4:	0f 90       	pop	r0
    3fb6:	0f 90       	pop	r0
    3fb8:	cf 91       	pop	r28
    3fba:	df 91       	pop	r29
    3fbc:	08 95       	ret

00003fbe <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCountFromISR( void )
{
    3fbe:	df 93       	push	r29
    3fc0:	cf 93       	push	r28
    3fc2:	00 d0       	rcall	.+0      	; 0x3fc4 <xTaskGetTickCountFromISR+0x6>
    3fc4:	0f 92       	push	r0
    3fc6:	cd b7       	in	r28, 0x3d	; 61
    3fc8:	de b7       	in	r29, 0x3e	; 62
     * safe API to ensure interrupt entry is as fast and as simple as possible.
     * More information (albeit Cortex-M specific) is provided on the following
     * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

    uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
    3fca:	19 82       	std	Y+1, r1	; 0x01
    {
        xReturn = xTickCount;
    3fcc:	80 91 c8 07 	lds	r24, 0x07C8
    3fd0:	90 91 c9 07 	lds	r25, 0x07C9
    3fd4:	9b 83       	std	Y+3, r25	; 0x03
    3fd6:	8a 83       	std	Y+2, r24	; 0x02
    }
    portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
    3fd8:	8a 81       	ldd	r24, Y+2	; 0x02
    3fda:	9b 81       	ldd	r25, Y+3	; 0x03
}
    3fdc:	0f 90       	pop	r0
    3fde:	0f 90       	pop	r0
    3fe0:	0f 90       	pop	r0
    3fe2:	cf 91       	pop	r28
    3fe4:	df 91       	pop	r29
    3fe6:	08 95       	ret

00003fe8 <uxTaskGetNumberOfTasks>:
/*-----------------------------------------------------------*/

UBaseType_t uxTaskGetNumberOfTasks( void )
{
    3fe8:	df 93       	push	r29
    3fea:	cf 93       	push	r28
    3fec:	cd b7       	in	r28, 0x3d	; 61
    3fee:	de b7       	in	r29, 0x3e	; 62
    /* A critical section is not required because the variables are of type
     * BaseType_t. */
    return uxCurrentNumberOfTasks;
    3ff0:	80 91 c7 07 	lds	r24, 0x07C7
}
    3ff4:	cf 91       	pop	r28
    3ff6:	df 91       	pop	r29
    3ff8:	08 95       	ret

00003ffa <pcTaskGetName>:
/*-----------------------------------------------------------*/

char * pcTaskGetName( TaskHandle_t xTaskToQuery ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
    3ffa:	df 93       	push	r29
    3ffc:	cf 93       	push	r28
    3ffe:	00 d0       	rcall	.+0      	; 0x4000 <pcTaskGetName+0x6>
    4000:	00 d0       	rcall	.+0      	; 0x4002 <pcTaskGetName+0x8>
    4002:	00 d0       	rcall	.+0      	; 0x4004 <pcTaskGetName+0xa>
    4004:	cd b7       	in	r28, 0x3d	; 61
    4006:	de b7       	in	r29, 0x3e	; 62
    4008:	9c 83       	std	Y+4, r25	; 0x04
    400a:	8b 83       	std	Y+3, r24	; 0x03
    TCB_t * pxTCB;

    /* If null is passed in here then the name of the calling task is being
     * queried. */
    pxTCB = prvGetTCBFromHandle( xTaskToQuery );
    400c:	8b 81       	ldd	r24, Y+3	; 0x03
    400e:	9c 81       	ldd	r25, Y+4	; 0x04
    4010:	00 97       	sbiw	r24, 0x00	; 0
    4012:	39 f4       	brne	.+14     	; 0x4022 <pcTaskGetName+0x28>
    4014:	80 91 c4 07 	lds	r24, 0x07C4
    4018:	90 91 c5 07 	lds	r25, 0x07C5
    401c:	9e 83       	std	Y+6, r25	; 0x06
    401e:	8d 83       	std	Y+5, r24	; 0x05
    4020:	04 c0       	rjmp	.+8      	; 0x402a <pcTaskGetName+0x30>
    4022:	8b 81       	ldd	r24, Y+3	; 0x03
    4024:	9c 81       	ldd	r25, Y+4	; 0x04
    4026:	9e 83       	std	Y+6, r25	; 0x06
    4028:	8d 83       	std	Y+5, r24	; 0x05
    402a:	8d 81       	ldd	r24, Y+5	; 0x05
    402c:	9e 81       	ldd	r25, Y+6	; 0x06
    402e:	9a 83       	std	Y+2, r25	; 0x02
    4030:	89 83       	std	Y+1, r24	; 0x01
    configASSERT( pxTCB );
    return &( pxTCB->pcTaskName[ 0 ] );
    4032:	89 81       	ldd	r24, Y+1	; 0x01
    4034:	9a 81       	ldd	r25, Y+2	; 0x02
    4036:	49 96       	adiw	r24, 0x19	; 25
}
    4038:	26 96       	adiw	r28, 0x06	; 6
    403a:	0f b6       	in	r0, 0x3f	; 63
    403c:	f8 94       	cli
    403e:	de bf       	out	0x3e, r29	; 62
    4040:	0f be       	out	0x3f, r0	; 63
    4042:	cd bf       	out	0x3d, r28	; 61
    4044:	cf 91       	pop	r28
    4046:	df 91       	pop	r29
    4048:	08 95       	ret

0000404a <xTaskCatchUpTicks>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskCatchUpTicks( TickType_t xTicksToCatchUp )
{
    404a:	df 93       	push	r29
    404c:	cf 93       	push	r28
    404e:	00 d0       	rcall	.+0      	; 0x4050 <xTaskCatchUpTicks+0x6>
    4050:	0f 92       	push	r0
    4052:	cd b7       	in	r28, 0x3d	; 61
    4054:	de b7       	in	r29, 0x3e	; 62
    4056:	9b 83       	std	Y+3, r25	; 0x03
    4058:	8a 83       	std	Y+2, r24	; 0x02
     * relies on xPendedTicks being wound down to 0 in xTaskResumeAll(). */
    configASSERT( uxSchedulerSuspended == 0 );

    /* Use xPendedTicks to mimic xTicksToCatchUp number of ticks occurring when
     * the scheduler is suspended so the ticks are executed in xTaskResumeAll(). */
    vTaskSuspendAll();
    405a:	0e 94 6c 1e 	call	0x3cd8	; 0x3cd8 <vTaskSuspendAll>
    xPendedTicks += xTicksToCatchUp;
    405e:	20 91 cc 07 	lds	r18, 0x07CC
    4062:	30 91 cd 07 	lds	r19, 0x07CD
    4066:	8a 81       	ldd	r24, Y+2	; 0x02
    4068:	9b 81       	ldd	r25, Y+3	; 0x03
    406a:	82 0f       	add	r24, r18
    406c:	93 1f       	adc	r25, r19
    406e:	90 93 cd 07 	sts	0x07CD, r25
    4072:	80 93 cc 07 	sts	0x07CC, r24
    xYieldOccurred = xTaskResumeAll();
    4076:	0e 94 78 1e 	call	0x3cf0	; 0x3cf0 <xTaskResumeAll>
    407a:	89 83       	std	Y+1, r24	; 0x01

    return xYieldOccurred;
    407c:	89 81       	ldd	r24, Y+1	; 0x01
}
    407e:	0f 90       	pop	r0
    4080:	0f 90       	pop	r0
    4082:	0f 90       	pop	r0
    4084:	cf 91       	pop	r28
    4086:	df 91       	pop	r29
    4088:	08 95       	ret

0000408a <xTaskIncrementTick>:

#endif /* INCLUDE_xTaskAbortDelay */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
    408a:	df 93       	push	r29
    408c:	cf 93       	push	r28
    408e:	cd b7       	in	r28, 0x3d	; 61
    4090:	de b7       	in	r29, 0x3e	; 62
    4092:	2f 97       	sbiw	r28, 0x0f	; 15
    4094:	0f b6       	in	r0, 0x3f	; 63
    4096:	f8 94       	cli
    4098:	de bf       	out	0x3e, r29	; 62
    409a:	0f be       	out	0x3f, r0	; 63
    409c:	cd bf       	out	0x3d, r28	; 61
    TCB_t * pxTCB;
    TickType_t xItemValue;
    BaseType_t xSwitchRequired = pdFALSE;
    409e:	1b 86       	std	Y+11, r1	; 0x0b
    /* Called by the portable layer each time a tick interrupt occurs.
     * Increments the tick then checks to see if the new tick value will cause any
     * tasks to be unblocked. */
    traceTASK_INCREMENT_TICK( xTickCount );

    if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    40a0:	80 91 d5 07 	lds	r24, 0x07D5
    40a4:	88 23       	and	r24, r24
    40a6:	09 f0       	breq	.+2      	; 0x40aa <xTaskIncrementTick+0x20>
    40a8:	74 c1       	rjmp	.+744    	; 0x4392 <xTaskIncrementTick+0x308>
    {
        /* Minor optimisation.  The tick count cannot change in this
         * block. */
        const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
    40aa:	80 91 c8 07 	lds	r24, 0x07C8
    40ae:	90 91 c9 07 	lds	r25, 0x07C9
    40b2:	01 96       	adiw	r24, 0x01	; 1
    40b4:	9a 87       	std	Y+10, r25	; 0x0a
    40b6:	89 87       	std	Y+9, r24	; 0x09

        /* Increment the RTOS tick, switching the delayed and overflowed
         * delayed lists if it wraps to 0. */
        xTickCount = xConstTickCount;
    40b8:	89 85       	ldd	r24, Y+9	; 0x09
    40ba:	9a 85       	ldd	r25, Y+10	; 0x0a
    40bc:	90 93 c9 07 	sts	0x07C9, r25
    40c0:	80 93 c8 07 	sts	0x07C8, r24

        if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
    40c4:	89 85       	ldd	r24, Y+9	; 0x09
    40c6:	9a 85       	ldd	r25, Y+10	; 0x0a
    40c8:	00 97       	sbiw	r24, 0x00	; 0
    40ca:	d9 f4       	brne	.+54     	; 0x4102 <xTaskIncrementTick+0x78>
        {
            taskSWITCH_DELAYED_LISTS();
    40cc:	80 91 0c 08 	lds	r24, 0x080C
    40d0:	90 91 0d 08 	lds	r25, 0x080D
    40d4:	98 87       	std	Y+8, r25	; 0x08
    40d6:	8f 83       	std	Y+7, r24	; 0x07
    40d8:	80 91 0e 08 	lds	r24, 0x080E
    40dc:	90 91 0f 08 	lds	r25, 0x080F
    40e0:	90 93 0d 08 	sts	0x080D, r25
    40e4:	80 93 0c 08 	sts	0x080C, r24
    40e8:	8f 81       	ldd	r24, Y+7	; 0x07
    40ea:	98 85       	ldd	r25, Y+8	; 0x08
    40ec:	90 93 0f 08 	sts	0x080F, r25
    40f0:	80 93 0e 08 	sts	0x080E, r24
    40f4:	80 91 cf 07 	lds	r24, 0x07CF
    40f8:	8f 5f       	subi	r24, 0xFF	; 255
    40fa:	80 93 cf 07 	sts	0x07CF, r24
    40fe:	0e 94 be 26 	call	0x4d7c	; 0x4d7c <prvResetNextTaskUnblockTime>

        /* See if this tick has made a timeout expire.  Tasks are stored in
         * the  queue in the order of their wake time - meaning once one task
         * has been found whose block time has not expired there is no need to
         * look any further down the list. */
        if( xConstTickCount >= xNextTaskUnblockTime )
    4102:	20 91 d1 07 	lds	r18, 0x07D1
    4106:	30 91 d2 07 	lds	r19, 0x07D2
    410a:	89 85       	ldd	r24, Y+9	; 0x09
    410c:	9a 85       	ldd	r25, Y+10	; 0x0a
    410e:	82 17       	cp	r24, r18
    4110:	93 07       	cpc	r25, r19
    4112:	08 f4       	brcc	.+2      	; 0x4116 <xTaskIncrementTick+0x8c>
    4114:	1f c1       	rjmp	.+574    	; 0x4354 <xTaskIncrementTick+0x2ca>
        {
            for( ; ; )
            {
                if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    4116:	e0 91 0c 08 	lds	r30, 0x080C
    411a:	f0 91 0d 08 	lds	r31, 0x080D
    411e:	80 81       	ld	r24, Z
    4120:	88 23       	and	r24, r24
    4122:	39 f4       	brne	.+14     	; 0x4132 <xTaskIncrementTick+0xa8>
                    /* The delayed list is empty.  Set xNextTaskUnblockTime
                     * to the maximum possible value so it is extremely
                     * unlikely that the
                     * if( xTickCount >= xNextTaskUnblockTime ) test will pass
                     * next time through. */
                    xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    4124:	8f ef       	ldi	r24, 0xFF	; 255
    4126:	9f ef       	ldi	r25, 0xFF	; 255
    4128:	90 93 d2 07 	sts	0x07D2, r25
    412c:	80 93 d1 07 	sts	0x07D1, r24
    4130:	11 c1       	rjmp	.+546    	; 0x4354 <xTaskIncrementTick+0x2ca>
                {
                    /* The delayed list is not empty, get the value of the
                     * item at the head of the delayed list.  This is the time
                     * at which the task at the head of the delayed list must
                     * be removed from the Blocked state. */
                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    4132:	e0 91 0c 08 	lds	r30, 0x080C
    4136:	f0 91 0d 08 	lds	r31, 0x080D
    413a:	05 80       	ldd	r0, Z+5	; 0x05
    413c:	f6 81       	ldd	r31, Z+6	; 0x06
    413e:	e0 2d       	mov	r30, r0
    4140:	86 81       	ldd	r24, Z+6	; 0x06
    4142:	97 81       	ldd	r25, Z+7	; 0x07
    4144:	9f 87       	std	Y+15, r25	; 0x0f
    4146:	8e 87       	std	Y+14, r24	; 0x0e
                    xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
    4148:	ee 85       	ldd	r30, Y+14	; 0x0e
    414a:	ff 85       	ldd	r31, Y+15	; 0x0f
    414c:	82 81       	ldd	r24, Z+2	; 0x02
    414e:	93 81       	ldd	r25, Z+3	; 0x03
    4150:	9d 87       	std	Y+13, r25	; 0x0d
    4152:	8c 87       	std	Y+12, r24	; 0x0c

                    if( xConstTickCount < xItemValue )
    4154:	29 85       	ldd	r18, Y+9	; 0x09
    4156:	3a 85       	ldd	r19, Y+10	; 0x0a
    4158:	8c 85       	ldd	r24, Y+12	; 0x0c
    415a:	9d 85       	ldd	r25, Y+13	; 0x0d
    415c:	28 17       	cp	r18, r24
    415e:	39 07       	cpc	r19, r25
    4160:	38 f4       	brcc	.+14     	; 0x4170 <xTaskIncrementTick+0xe6>
                        /* It is not time to unblock this item yet, but the
                         * item value is the time at which the task at the head
                         * of the blocked list must be removed from the Blocked
                         * state -  so record the item value in
                         * xNextTaskUnblockTime. */
                        xNextTaskUnblockTime = xItemValue;
    4162:	8c 85       	ldd	r24, Y+12	; 0x0c
    4164:	9d 85       	ldd	r25, Y+13	; 0x0d
    4166:	90 93 d2 07 	sts	0x07D2, r25
    416a:	80 93 d1 07 	sts	0x07D1, r24
    416e:	f2 c0       	rjmp	.+484    	; 0x4354 <xTaskIncrementTick+0x2ca>
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }

                    /* It is time to remove the item from the Blocked state. */
                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
    4170:	ee 85       	ldd	r30, Y+14	; 0x0e
    4172:	ff 85       	ldd	r31, Y+15	; 0x0f
    4174:	82 85       	ldd	r24, Z+10	; 0x0a
    4176:	93 85       	ldd	r25, Z+11	; 0x0b
    4178:	9e 83       	std	Y+6, r25	; 0x06
    417a:	8d 83       	std	Y+5, r24	; 0x05
    417c:	ee 85       	ldd	r30, Y+14	; 0x0e
    417e:	ff 85       	ldd	r31, Y+15	; 0x0f
    4180:	a4 81       	ldd	r26, Z+4	; 0x04
    4182:	b5 81       	ldd	r27, Z+5	; 0x05
    4184:	ee 85       	ldd	r30, Y+14	; 0x0e
    4186:	ff 85       	ldd	r31, Y+15	; 0x0f
    4188:	86 81       	ldd	r24, Z+6	; 0x06
    418a:	97 81       	ldd	r25, Z+7	; 0x07
    418c:	15 96       	adiw	r26, 0x05	; 5
    418e:	9c 93       	st	X, r25
    4190:	8e 93       	st	-X, r24
    4192:	14 97       	sbiw	r26, 0x04	; 4
    4194:	ee 85       	ldd	r30, Y+14	; 0x0e
    4196:	ff 85       	ldd	r31, Y+15	; 0x0f
    4198:	a6 81       	ldd	r26, Z+6	; 0x06
    419a:	b7 81       	ldd	r27, Z+7	; 0x07
    419c:	ee 85       	ldd	r30, Y+14	; 0x0e
    419e:	ff 85       	ldd	r31, Y+15	; 0x0f
    41a0:	84 81       	ldd	r24, Z+4	; 0x04
    41a2:	95 81       	ldd	r25, Z+5	; 0x05
    41a4:	13 96       	adiw	r26, 0x03	; 3
    41a6:	9c 93       	st	X, r25
    41a8:	8e 93       	st	-X, r24
    41aa:	12 97       	sbiw	r26, 0x02	; 2
    41ac:	ed 81       	ldd	r30, Y+5	; 0x05
    41ae:	fe 81       	ldd	r31, Y+6	; 0x06
    41b0:	21 81       	ldd	r18, Z+1	; 0x01
    41b2:	32 81       	ldd	r19, Z+2	; 0x02
    41b4:	8e 85       	ldd	r24, Y+14	; 0x0e
    41b6:	9f 85       	ldd	r25, Y+15	; 0x0f
    41b8:	02 96       	adiw	r24, 0x02	; 2
    41ba:	28 17       	cp	r18, r24
    41bc:	39 07       	cpc	r19, r25
    41be:	41 f4       	brne	.+16     	; 0x41d0 <xTaskIncrementTick+0x146>
    41c0:	ee 85       	ldd	r30, Y+14	; 0x0e
    41c2:	ff 85       	ldd	r31, Y+15	; 0x0f
    41c4:	86 81       	ldd	r24, Z+6	; 0x06
    41c6:	97 81       	ldd	r25, Z+7	; 0x07
    41c8:	ed 81       	ldd	r30, Y+5	; 0x05
    41ca:	fe 81       	ldd	r31, Y+6	; 0x06
    41cc:	92 83       	std	Z+2, r25	; 0x02
    41ce:	81 83       	std	Z+1, r24	; 0x01
    41d0:	ee 85       	ldd	r30, Y+14	; 0x0e
    41d2:	ff 85       	ldd	r31, Y+15	; 0x0f
    41d4:	13 86       	std	Z+11, r1	; 0x0b
    41d6:	12 86       	std	Z+10, r1	; 0x0a
    41d8:	ed 81       	ldd	r30, Y+5	; 0x05
    41da:	fe 81       	ldd	r31, Y+6	; 0x06
    41dc:	80 81       	ld	r24, Z
    41de:	81 50       	subi	r24, 0x01	; 1
    41e0:	ed 81       	ldd	r30, Y+5	; 0x05
    41e2:	fe 81       	ldd	r31, Y+6	; 0x06
    41e4:	80 83       	st	Z, r24

                    /* Is the task waiting on an event also?  If so remove
                     * it from the event list. */
                    if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    41e6:	ee 85       	ldd	r30, Y+14	; 0x0e
    41e8:	ff 85       	ldd	r31, Y+15	; 0x0f
    41ea:	84 89       	ldd	r24, Z+20	; 0x14
    41ec:	95 89       	ldd	r25, Z+21	; 0x15
    41ee:	00 97       	sbiw	r24, 0x00	; 0
    41f0:	d9 f1       	breq	.+118    	; 0x4268 <xTaskIncrementTick+0x1de>
                    {
                        listREMOVE_ITEM( &( pxTCB->xEventListItem ) );
    41f2:	ee 85       	ldd	r30, Y+14	; 0x0e
    41f4:	ff 85       	ldd	r31, Y+15	; 0x0f
    41f6:	84 89       	ldd	r24, Z+20	; 0x14
    41f8:	95 89       	ldd	r25, Z+21	; 0x15
    41fa:	9c 83       	std	Y+4, r25	; 0x04
    41fc:	8b 83       	std	Y+3, r24	; 0x03
    41fe:	ee 85       	ldd	r30, Y+14	; 0x0e
    4200:	ff 85       	ldd	r31, Y+15	; 0x0f
    4202:	a6 85       	ldd	r26, Z+14	; 0x0e
    4204:	b7 85       	ldd	r27, Z+15	; 0x0f
    4206:	ee 85       	ldd	r30, Y+14	; 0x0e
    4208:	ff 85       	ldd	r31, Y+15	; 0x0f
    420a:	80 89       	ldd	r24, Z+16	; 0x10
    420c:	91 89       	ldd	r25, Z+17	; 0x11
    420e:	15 96       	adiw	r26, 0x05	; 5
    4210:	9c 93       	st	X, r25
    4212:	8e 93       	st	-X, r24
    4214:	14 97       	sbiw	r26, 0x04	; 4
    4216:	ee 85       	ldd	r30, Y+14	; 0x0e
    4218:	ff 85       	ldd	r31, Y+15	; 0x0f
    421a:	a0 89       	ldd	r26, Z+16	; 0x10
    421c:	b1 89       	ldd	r27, Z+17	; 0x11
    421e:	ee 85       	ldd	r30, Y+14	; 0x0e
    4220:	ff 85       	ldd	r31, Y+15	; 0x0f
    4222:	86 85       	ldd	r24, Z+14	; 0x0e
    4224:	97 85       	ldd	r25, Z+15	; 0x0f
    4226:	13 96       	adiw	r26, 0x03	; 3
    4228:	9c 93       	st	X, r25
    422a:	8e 93       	st	-X, r24
    422c:	12 97       	sbiw	r26, 0x02	; 2
    422e:	eb 81       	ldd	r30, Y+3	; 0x03
    4230:	fc 81       	ldd	r31, Y+4	; 0x04
    4232:	21 81       	ldd	r18, Z+1	; 0x01
    4234:	32 81       	ldd	r19, Z+2	; 0x02
    4236:	8e 85       	ldd	r24, Y+14	; 0x0e
    4238:	9f 85       	ldd	r25, Y+15	; 0x0f
    423a:	0c 96       	adiw	r24, 0x0c	; 12
    423c:	28 17       	cp	r18, r24
    423e:	39 07       	cpc	r19, r25
    4240:	41 f4       	brne	.+16     	; 0x4252 <xTaskIncrementTick+0x1c8>
    4242:	ee 85       	ldd	r30, Y+14	; 0x0e
    4244:	ff 85       	ldd	r31, Y+15	; 0x0f
    4246:	80 89       	ldd	r24, Z+16	; 0x10
    4248:	91 89       	ldd	r25, Z+17	; 0x11
    424a:	eb 81       	ldd	r30, Y+3	; 0x03
    424c:	fc 81       	ldd	r31, Y+4	; 0x04
    424e:	92 83       	std	Z+2, r25	; 0x02
    4250:	81 83       	std	Z+1, r24	; 0x01
    4252:	ee 85       	ldd	r30, Y+14	; 0x0e
    4254:	ff 85       	ldd	r31, Y+15	; 0x0f
    4256:	15 8a       	std	Z+21, r1	; 0x15
    4258:	14 8a       	std	Z+20, r1	; 0x14
    425a:	eb 81       	ldd	r30, Y+3	; 0x03
    425c:	fc 81       	ldd	r31, Y+4	; 0x04
    425e:	80 81       	ld	r24, Z
    4260:	81 50       	subi	r24, 0x01	; 1
    4262:	eb 81       	ldd	r30, Y+3	; 0x03
    4264:	fc 81       	ldd	r31, Y+4	; 0x04
    4266:	80 83       	st	Z, r24
                        mtCOVERAGE_TEST_MARKER();
                    }

                    /* Place the unblocked task into the appropriate ready
                     * list. */
                    prvAddTaskToReadyList( pxTCB );
    4268:	ee 85       	ldd	r30, Y+14	; 0x0e
    426a:	ff 85       	ldd	r31, Y+15	; 0x0f
    426c:	96 89       	ldd	r25, Z+22	; 0x16
    426e:	80 91 ca 07 	lds	r24, 0x07CA
    4272:	89 17       	cp	r24, r25
    4274:	28 f4       	brcc	.+10     	; 0x4280 <xTaskIncrementTick+0x1f6>
    4276:	ee 85       	ldd	r30, Y+14	; 0x0e
    4278:	ff 85       	ldd	r31, Y+15	; 0x0f
    427a:	86 89       	ldd	r24, Z+22	; 0x16
    427c:	80 93 ca 07 	sts	0x07CA, r24
    4280:	ee 85       	ldd	r30, Y+14	; 0x0e
    4282:	ff 85       	ldd	r31, Y+15	; 0x0f
    4284:	86 89       	ldd	r24, Z+22	; 0x16
    4286:	28 2f       	mov	r18, r24
    4288:	30 e0       	ldi	r19, 0x00	; 0
    428a:	c9 01       	movw	r24, r18
    428c:	88 0f       	add	r24, r24
    428e:	99 1f       	adc	r25, r25
    4290:	88 0f       	add	r24, r24
    4292:	99 1f       	adc	r25, r25
    4294:	88 0f       	add	r24, r24
    4296:	99 1f       	adc	r25, r25
    4298:	82 0f       	add	r24, r18
    429a:	93 1f       	adc	r25, r19
    429c:	fc 01       	movw	r30, r24
    429e:	ea 52       	subi	r30, 0x2A	; 42
    42a0:	f8 4f       	sbci	r31, 0xF8	; 248
    42a2:	81 81       	ldd	r24, Z+1	; 0x01
    42a4:	92 81       	ldd	r25, Z+2	; 0x02
    42a6:	9a 83       	std	Y+2, r25	; 0x02
    42a8:	89 83       	std	Y+1, r24	; 0x01
    42aa:	ee 85       	ldd	r30, Y+14	; 0x0e
    42ac:	ff 85       	ldd	r31, Y+15	; 0x0f
    42ae:	89 81       	ldd	r24, Y+1	; 0x01
    42b0:	9a 81       	ldd	r25, Y+2	; 0x02
    42b2:	95 83       	std	Z+5, r25	; 0x05
    42b4:	84 83       	std	Z+4, r24	; 0x04
    42b6:	e9 81       	ldd	r30, Y+1	; 0x01
    42b8:	fa 81       	ldd	r31, Y+2	; 0x02
    42ba:	84 81       	ldd	r24, Z+4	; 0x04
    42bc:	95 81       	ldd	r25, Z+5	; 0x05
    42be:	ee 85       	ldd	r30, Y+14	; 0x0e
    42c0:	ff 85       	ldd	r31, Y+15	; 0x0f
    42c2:	97 83       	std	Z+7, r25	; 0x07
    42c4:	86 83       	std	Z+6, r24	; 0x06
    42c6:	e9 81       	ldd	r30, Y+1	; 0x01
    42c8:	fa 81       	ldd	r31, Y+2	; 0x02
    42ca:	04 80       	ldd	r0, Z+4	; 0x04
    42cc:	f5 81       	ldd	r31, Z+5	; 0x05
    42ce:	e0 2d       	mov	r30, r0
    42d0:	8e 85       	ldd	r24, Y+14	; 0x0e
    42d2:	9f 85       	ldd	r25, Y+15	; 0x0f
    42d4:	02 96       	adiw	r24, 0x02	; 2
    42d6:	93 83       	std	Z+3, r25	; 0x03
    42d8:	82 83       	std	Z+2, r24	; 0x02
    42da:	8e 85       	ldd	r24, Y+14	; 0x0e
    42dc:	9f 85       	ldd	r25, Y+15	; 0x0f
    42de:	02 96       	adiw	r24, 0x02	; 2
    42e0:	e9 81       	ldd	r30, Y+1	; 0x01
    42e2:	fa 81       	ldd	r31, Y+2	; 0x02
    42e4:	95 83       	std	Z+5, r25	; 0x05
    42e6:	84 83       	std	Z+4, r24	; 0x04
    42e8:	ee 85       	ldd	r30, Y+14	; 0x0e
    42ea:	ff 85       	ldd	r31, Y+15	; 0x0f
    42ec:	86 89       	ldd	r24, Z+22	; 0x16
    42ee:	28 2f       	mov	r18, r24
    42f0:	30 e0       	ldi	r19, 0x00	; 0
    42f2:	c9 01       	movw	r24, r18
    42f4:	88 0f       	add	r24, r24
    42f6:	99 1f       	adc	r25, r25
    42f8:	88 0f       	add	r24, r24
    42fa:	99 1f       	adc	r25, r25
    42fc:	88 0f       	add	r24, r24
    42fe:	99 1f       	adc	r25, r25
    4300:	82 0f       	add	r24, r18
    4302:	93 1f       	adc	r25, r19
    4304:	8a 52       	subi	r24, 0x2A	; 42
    4306:	98 4f       	sbci	r25, 0xF8	; 248
    4308:	ee 85       	ldd	r30, Y+14	; 0x0e
    430a:	ff 85       	ldd	r31, Y+15	; 0x0f
    430c:	93 87       	std	Z+11, r25	; 0x0b
    430e:	82 87       	std	Z+10, r24	; 0x0a
    4310:	ee 85       	ldd	r30, Y+14	; 0x0e
    4312:	ff 85       	ldd	r31, Y+15	; 0x0f
    4314:	86 89       	ldd	r24, Z+22	; 0x16
    4316:	28 2f       	mov	r18, r24
    4318:	30 e0       	ldi	r19, 0x00	; 0
    431a:	c9 01       	movw	r24, r18
    431c:	88 0f       	add	r24, r24
    431e:	99 1f       	adc	r25, r25
    4320:	88 0f       	add	r24, r24
    4322:	99 1f       	adc	r25, r25
    4324:	88 0f       	add	r24, r24
    4326:	99 1f       	adc	r25, r25
    4328:	82 0f       	add	r24, r18
    432a:	93 1f       	adc	r25, r19
    432c:	fc 01       	movw	r30, r24
    432e:	ea 52       	subi	r30, 0x2A	; 42
    4330:	f8 4f       	sbci	r31, 0xF8	; 248
    4332:	80 81       	ld	r24, Z
    4334:	8f 5f       	subi	r24, 0xFF	; 255
    4336:	80 83       	st	Z, r24
                        {
                            /* Preemption is on, but a context switch should
                             * only be performed if the unblocked task has a
                             * priority that is equal to or higher than the
                             * currently executing task. */
                            if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    4338:	ee 85       	ldd	r30, Y+14	; 0x0e
    433a:	ff 85       	ldd	r31, Y+15	; 0x0f
    433c:	96 89       	ldd	r25, Z+22	; 0x16
    433e:	e0 91 c4 07 	lds	r30, 0x07C4
    4342:	f0 91 c5 07 	lds	r31, 0x07C5
    4346:	86 89       	ldd	r24, Z+22	; 0x16
    4348:	98 17       	cp	r25, r24
    434a:	08 f4       	brcc	.+2      	; 0x434e <xTaskIncrementTick+0x2c4>
    434c:	e4 ce       	rjmp	.-568    	; 0x4116 <xTaskIncrementTick+0x8c>
                            {
                                xSwitchRequired = pdTRUE;
    434e:	81 e0       	ldi	r24, 0x01	; 1
    4350:	8b 87       	std	Y+11, r24	; 0x0b
    4352:	e1 ce       	rjmp	.-574    	; 0x4116 <xTaskIncrementTick+0x8c>
        /* Tasks of equal priority to the currently running task will share
         * processing time (time slice) if preemption is on, and the application
         * writer has not explicitly turned time slicing off. */
        #if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
            {
                if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
    4354:	e0 91 c4 07 	lds	r30, 0x07C4
    4358:	f0 91 c5 07 	lds	r31, 0x07C5
    435c:	86 89       	ldd	r24, Z+22	; 0x16
    435e:	28 2f       	mov	r18, r24
    4360:	30 e0       	ldi	r19, 0x00	; 0
    4362:	c9 01       	movw	r24, r18
    4364:	88 0f       	add	r24, r24
    4366:	99 1f       	adc	r25, r25
    4368:	88 0f       	add	r24, r24
    436a:	99 1f       	adc	r25, r25
    436c:	88 0f       	add	r24, r24
    436e:	99 1f       	adc	r25, r25
    4370:	82 0f       	add	r24, r18
    4372:	93 1f       	adc	r25, r19
    4374:	fc 01       	movw	r30, r24
    4376:	ea 52       	subi	r30, 0x2A	; 42
    4378:	f8 4f       	sbci	r31, 0xF8	; 248
    437a:	80 81       	ld	r24, Z
    437c:	82 30       	cpi	r24, 0x02	; 2
    437e:	10 f0       	brcs	.+4      	; 0x4384 <xTaskIncrementTick+0x2fa>
                {
                    xSwitchRequired = pdTRUE;
    4380:	81 e0       	ldi	r24, 0x01	; 1
    4382:	8b 87       	std	Y+11, r24	; 0x0b
            }
        #endif /* configUSE_TICK_HOOK */

        #if ( configUSE_PREEMPTION == 1 )
            {
                if( xYieldPending != pdFALSE )
    4384:	80 91 ce 07 	lds	r24, 0x07CE
    4388:	88 23       	and	r24, r24
    438a:	61 f0       	breq	.+24     	; 0x43a4 <xTaskIncrementTick+0x31a>
                {
                    xSwitchRequired = pdTRUE;
    438c:	81 e0       	ldi	r24, 0x01	; 1
    438e:	8b 87       	std	Y+11, r24	; 0x0b
    4390:	09 c0       	rjmp	.+18     	; 0x43a4 <xTaskIncrementTick+0x31a>
            }
        #endif /* configUSE_PREEMPTION */
    }
    else
    {
        ++xPendedTicks;
    4392:	80 91 cc 07 	lds	r24, 0x07CC
    4396:	90 91 cd 07 	lds	r25, 0x07CD
    439a:	01 96       	adiw	r24, 0x01	; 1
    439c:	90 93 cd 07 	sts	0x07CD, r25
    43a0:	80 93 cc 07 	sts	0x07CC, r24
                vApplicationTickHook();
            }
        #endif
    }

    return xSwitchRequired;
    43a4:	8b 85       	ldd	r24, Y+11	; 0x0b
}
    43a6:	2f 96       	adiw	r28, 0x0f	; 15
    43a8:	0f b6       	in	r0, 0x3f	; 63
    43aa:	f8 94       	cli
    43ac:	de bf       	out	0x3e, r29	; 62
    43ae:	0f be       	out	0x3f, r0	; 63
    43b0:	cd bf       	out	0x3d, r28	; 61
    43b2:	cf 91       	pop	r28
    43b4:	df 91       	pop	r29
    43b6:	08 95       	ret

000043b8 <vTaskSwitchContext>:

#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
    43b8:	df 93       	push	r29
    43ba:	cf 93       	push	r28
    43bc:	00 d0       	rcall	.+0      	; 0x43be <vTaskSwitchContext+0x6>
    43be:	0f 92       	push	r0
    43c0:	cd b7       	in	r28, 0x3d	; 61
    43c2:	de b7       	in	r29, 0x3e	; 62
    if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
    43c4:	80 91 d5 07 	lds	r24, 0x07D5
    43c8:	88 23       	and	r24, r24
    43ca:	21 f0       	breq	.+8      	; 0x43d4 <vTaskSwitchContext+0x1c>
    {
        /* The scheduler is currently suspended - do not allow a context
         * switch. */
        xYieldPending = pdTRUE;
    43cc:	81 e0       	ldi	r24, 0x01	; 1
    43ce:	80 93 ce 07 	sts	0x07CE, r24
    43d2:	59 c0       	rjmp	.+178    	; 0x4486 <vTaskSwitchContext+0xce>
    }
    else
    {
        xYieldPending = pdFALSE;
    43d4:	10 92 ce 07 	sts	0x07CE, r1
            }
        #endif

        /* Select a new task to run using either the generic C or port
         * optimised asm code. */
        taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    43d8:	80 91 ca 07 	lds	r24, 0x07CA
    43dc:	8b 83       	std	Y+3, r24	; 0x03
    43de:	03 c0       	rjmp	.+6      	; 0x43e6 <vTaskSwitchContext+0x2e>
    43e0:	8b 81       	ldd	r24, Y+3	; 0x03
    43e2:	81 50       	subi	r24, 0x01	; 1
    43e4:	8b 83       	std	Y+3, r24	; 0x03
    43e6:	8b 81       	ldd	r24, Y+3	; 0x03
    43e8:	28 2f       	mov	r18, r24
    43ea:	30 e0       	ldi	r19, 0x00	; 0
    43ec:	c9 01       	movw	r24, r18
    43ee:	88 0f       	add	r24, r24
    43f0:	99 1f       	adc	r25, r25
    43f2:	88 0f       	add	r24, r24
    43f4:	99 1f       	adc	r25, r25
    43f6:	88 0f       	add	r24, r24
    43f8:	99 1f       	adc	r25, r25
    43fa:	82 0f       	add	r24, r18
    43fc:	93 1f       	adc	r25, r19
    43fe:	fc 01       	movw	r30, r24
    4400:	ea 52       	subi	r30, 0x2A	; 42
    4402:	f8 4f       	sbci	r31, 0xF8	; 248
    4404:	80 81       	ld	r24, Z
    4406:	88 23       	and	r24, r24
    4408:	59 f3       	breq	.-42     	; 0x43e0 <vTaskSwitchContext+0x28>
    440a:	8b 81       	ldd	r24, Y+3	; 0x03
    440c:	28 2f       	mov	r18, r24
    440e:	30 e0       	ldi	r19, 0x00	; 0
    4410:	c9 01       	movw	r24, r18
    4412:	88 0f       	add	r24, r24
    4414:	99 1f       	adc	r25, r25
    4416:	88 0f       	add	r24, r24
    4418:	99 1f       	adc	r25, r25
    441a:	88 0f       	add	r24, r24
    441c:	99 1f       	adc	r25, r25
    441e:	82 0f       	add	r24, r18
    4420:	93 1f       	adc	r25, r19
    4422:	8a 52       	subi	r24, 0x2A	; 42
    4424:	98 4f       	sbci	r25, 0xF8	; 248
    4426:	9a 83       	std	Y+2, r25	; 0x02
    4428:	89 83       	std	Y+1, r24	; 0x01
    442a:	e9 81       	ldd	r30, Y+1	; 0x01
    442c:	fa 81       	ldd	r31, Y+2	; 0x02
    442e:	01 80       	ldd	r0, Z+1	; 0x01
    4430:	f2 81       	ldd	r31, Z+2	; 0x02
    4432:	e0 2d       	mov	r30, r0
    4434:	82 81       	ldd	r24, Z+2	; 0x02
    4436:	93 81       	ldd	r25, Z+3	; 0x03
    4438:	e9 81       	ldd	r30, Y+1	; 0x01
    443a:	fa 81       	ldd	r31, Y+2	; 0x02
    443c:	92 83       	std	Z+2, r25	; 0x02
    443e:	81 83       	std	Z+1, r24	; 0x01
    4440:	e9 81       	ldd	r30, Y+1	; 0x01
    4442:	fa 81       	ldd	r31, Y+2	; 0x02
    4444:	21 81       	ldd	r18, Z+1	; 0x01
    4446:	32 81       	ldd	r19, Z+2	; 0x02
    4448:	89 81       	ldd	r24, Y+1	; 0x01
    444a:	9a 81       	ldd	r25, Y+2	; 0x02
    444c:	03 96       	adiw	r24, 0x03	; 3
    444e:	28 17       	cp	r18, r24
    4450:	39 07       	cpc	r19, r25
    4452:	59 f4       	brne	.+22     	; 0x446a <vTaskSwitchContext+0xb2>
    4454:	e9 81       	ldd	r30, Y+1	; 0x01
    4456:	fa 81       	ldd	r31, Y+2	; 0x02
    4458:	01 80       	ldd	r0, Z+1	; 0x01
    445a:	f2 81       	ldd	r31, Z+2	; 0x02
    445c:	e0 2d       	mov	r30, r0
    445e:	82 81       	ldd	r24, Z+2	; 0x02
    4460:	93 81       	ldd	r25, Z+3	; 0x03
    4462:	e9 81       	ldd	r30, Y+1	; 0x01
    4464:	fa 81       	ldd	r31, Y+2	; 0x02
    4466:	92 83       	std	Z+2, r25	; 0x02
    4468:	81 83       	std	Z+1, r24	; 0x01
    446a:	e9 81       	ldd	r30, Y+1	; 0x01
    446c:	fa 81       	ldd	r31, Y+2	; 0x02
    446e:	01 80       	ldd	r0, Z+1	; 0x01
    4470:	f2 81       	ldd	r31, Z+2	; 0x02
    4472:	e0 2d       	mov	r30, r0
    4474:	86 81       	ldd	r24, Z+6	; 0x06
    4476:	97 81       	ldd	r25, Z+7	; 0x07
    4478:	90 93 c5 07 	sts	0x07C5, r25
    447c:	80 93 c4 07 	sts	0x07C4, r24
    4480:	8b 81       	ldd	r24, Y+3	; 0x03
    4482:	80 93 ca 07 	sts	0x07CA, r24
                 * for additional information. */
                _impure_ptr = &( pxCurrentTCB->xNewLib_reent );
            }
        #endif /* configUSE_NEWLIB_REENTRANT */
    }
}
    4486:	0f 90       	pop	r0
    4488:	0f 90       	pop	r0
    448a:	0f 90       	pop	r0
    448c:	cf 91       	pop	r28
    448e:	df 91       	pop	r29
    4490:	08 95       	ret

00004492 <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList,
                            const TickType_t xTicksToWait )
{
    4492:	df 93       	push	r29
    4494:	cf 93       	push	r28
    4496:	00 d0       	rcall	.+0      	; 0x4498 <vTaskPlaceOnEventList+0x6>
    4498:	00 d0       	rcall	.+0      	; 0x449a <vTaskPlaceOnEventList+0x8>
    449a:	cd b7       	in	r28, 0x3d	; 61
    449c:	de b7       	in	r29, 0x3e	; 62
    449e:	9a 83       	std	Y+2, r25	; 0x02
    44a0:	89 83       	std	Y+1, r24	; 0x01
    44a2:	7c 83       	std	Y+4, r23	; 0x04
    44a4:	6b 83       	std	Y+3, r22	; 0x03
     *      xItemValue = ( configMAX_PRIORITIES - uxPriority )
     * Therefore, the event list is sorted in descending priority order.
     *
     * The queue that contains the event list is locked, preventing
     * simultaneous access from interrupts. */
    vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    44a6:	80 91 c4 07 	lds	r24, 0x07C4
    44aa:	90 91 c5 07 	lds	r25, 0x07C5
    44ae:	9c 01       	movw	r18, r24
    44b0:	24 5f       	subi	r18, 0xF4	; 244
    44b2:	3f 4f       	sbci	r19, 0xFF	; 255
    44b4:	89 81       	ldd	r24, Y+1	; 0x01
    44b6:	9a 81       	ldd	r25, Y+2	; 0x02
    44b8:	b9 01       	movw	r22, r18
    44ba:	0e 94 0d 11 	call	0x221a	; 0x221a <vListInsert>

    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    44be:	8b 81       	ldd	r24, Y+3	; 0x03
    44c0:	9c 81       	ldd	r25, Y+4	; 0x04
    44c2:	61 e0       	ldi	r22, 0x01	; 1
    44c4:	0e 94 a5 2e 	call	0x5d4a	; 0x5d4a <prvAddCurrentTaskToDelayedList>
}
    44c8:	0f 90       	pop	r0
    44ca:	0f 90       	pop	r0
    44cc:	0f 90       	pop	r0
    44ce:	0f 90       	pop	r0
    44d0:	cf 91       	pop	r28
    44d2:	df 91       	pop	r29
    44d4:	08 95       	ret

000044d6 <vTaskPlaceOnUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnUnorderedEventList( List_t * pxEventList,
                                     const TickType_t xItemValue,
                                     const TickType_t xTicksToWait )
{
    44d6:	df 93       	push	r29
    44d8:	cf 93       	push	r28
    44da:	cd b7       	in	r28, 0x3d	; 61
    44dc:	de b7       	in	r29, 0x3e	; 62
    44de:	28 97       	sbiw	r28, 0x08	; 8
    44e0:	0f b6       	in	r0, 0x3f	; 63
    44e2:	f8 94       	cli
    44e4:	de bf       	out	0x3e, r29	; 62
    44e6:	0f be       	out	0x3f, r0	; 63
    44e8:	cd bf       	out	0x3d, r28	; 61
    44ea:	9c 83       	std	Y+4, r25	; 0x04
    44ec:	8b 83       	std	Y+3, r24	; 0x03
    44ee:	7e 83       	std	Y+6, r23	; 0x06
    44f0:	6d 83       	std	Y+5, r22	; 0x05
    44f2:	58 87       	std	Y+8, r21	; 0x08
    44f4:	4f 83       	std	Y+7, r20	; 0x07
    configASSERT( uxSchedulerSuspended != 0 );

    /* Store the item value in the event list item.  It is safe to access the
     * event list item here as interrupts won't access the event list item of a
     * task that is not in the Blocked state. */
    listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    44f6:	e0 91 c4 07 	lds	r30, 0x07C4
    44fa:	f0 91 c5 07 	lds	r31, 0x07C5
    44fe:	8d 81       	ldd	r24, Y+5	; 0x05
    4500:	9e 81       	ldd	r25, Y+6	; 0x06
    4502:	90 68       	ori	r25, 0x80	; 128
    4504:	95 87       	std	Z+13, r25	; 0x0d
    4506:	84 87       	std	Z+12, r24	; 0x0c
    /* Place the event list item of the TCB at the end of the appropriate event
     * list.  It is safe to access the event list here because it is part of an
     * event group implementation - and interrupts don't access event groups
     * directly (instead they access them indirectly by pending function calls to
     * the task level). */
    listINSERT_END( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    4508:	eb 81       	ldd	r30, Y+3	; 0x03
    450a:	fc 81       	ldd	r31, Y+4	; 0x04
    450c:	81 81       	ldd	r24, Z+1	; 0x01
    450e:	92 81       	ldd	r25, Z+2	; 0x02
    4510:	9a 83       	std	Y+2, r25	; 0x02
    4512:	89 83       	std	Y+1, r24	; 0x01
    4514:	e0 91 c4 07 	lds	r30, 0x07C4
    4518:	f0 91 c5 07 	lds	r31, 0x07C5
    451c:	89 81       	ldd	r24, Y+1	; 0x01
    451e:	9a 81       	ldd	r25, Y+2	; 0x02
    4520:	97 87       	std	Z+15, r25	; 0x0f
    4522:	86 87       	std	Z+14, r24	; 0x0e
    4524:	a0 91 c4 07 	lds	r26, 0x07C4
    4528:	b0 91 c5 07 	lds	r27, 0x07C5
    452c:	e9 81       	ldd	r30, Y+1	; 0x01
    452e:	fa 81       	ldd	r31, Y+2	; 0x02
    4530:	84 81       	ldd	r24, Z+4	; 0x04
    4532:	95 81       	ldd	r25, Z+5	; 0x05
    4534:	51 96       	adiw	r26, 0x11	; 17
    4536:	9c 93       	st	X, r25
    4538:	8e 93       	st	-X, r24
    453a:	50 97       	sbiw	r26, 0x10	; 16
    453c:	e9 81       	ldd	r30, Y+1	; 0x01
    453e:	fa 81       	ldd	r31, Y+2	; 0x02
    4540:	04 80       	ldd	r0, Z+4	; 0x04
    4542:	f5 81       	ldd	r31, Z+5	; 0x05
    4544:	e0 2d       	mov	r30, r0
    4546:	80 91 c4 07 	lds	r24, 0x07C4
    454a:	90 91 c5 07 	lds	r25, 0x07C5
    454e:	0c 96       	adiw	r24, 0x0c	; 12
    4550:	93 83       	std	Z+3, r25	; 0x03
    4552:	82 83       	std	Z+2, r24	; 0x02
    4554:	80 91 c4 07 	lds	r24, 0x07C4
    4558:	90 91 c5 07 	lds	r25, 0x07C5
    455c:	0c 96       	adiw	r24, 0x0c	; 12
    455e:	e9 81       	ldd	r30, Y+1	; 0x01
    4560:	fa 81       	ldd	r31, Y+2	; 0x02
    4562:	95 83       	std	Z+5, r25	; 0x05
    4564:	84 83       	std	Z+4, r24	; 0x04
    4566:	e0 91 c4 07 	lds	r30, 0x07C4
    456a:	f0 91 c5 07 	lds	r31, 0x07C5
    456e:	8b 81       	ldd	r24, Y+3	; 0x03
    4570:	9c 81       	ldd	r25, Y+4	; 0x04
    4572:	95 8b       	std	Z+21, r25	; 0x15
    4574:	84 8b       	std	Z+20, r24	; 0x14
    4576:	eb 81       	ldd	r30, Y+3	; 0x03
    4578:	fc 81       	ldd	r31, Y+4	; 0x04
    457a:	80 81       	ld	r24, Z
    457c:	8f 5f       	subi	r24, 0xFF	; 255
    457e:	eb 81       	ldd	r30, Y+3	; 0x03
    4580:	fc 81       	ldd	r31, Y+4	; 0x04
    4582:	80 83       	st	Z, r24

    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    4584:	8f 81       	ldd	r24, Y+7	; 0x07
    4586:	98 85       	ldd	r25, Y+8	; 0x08
    4588:	61 e0       	ldi	r22, 0x01	; 1
    458a:	0e 94 a5 2e 	call	0x5d4a	; 0x5d4a <prvAddCurrentTaskToDelayedList>
}
    458e:	28 96       	adiw	r28, 0x08	; 8
    4590:	0f b6       	in	r0, 0x3f	; 63
    4592:	f8 94       	cli
    4594:	de bf       	out	0x3e, r29	; 62
    4596:	0f be       	out	0x3f, r0	; 63
    4598:	cd bf       	out	0x3d, r28	; 61
    459a:	cf 91       	pop	r28
    459c:	df 91       	pop	r29
    459e:	08 95       	ret

000045a0 <vTaskPlaceOnEventListRestricted>:
#if ( configUSE_TIMERS == 1 )

    void vTaskPlaceOnEventListRestricted( List_t * const pxEventList,
                                          TickType_t xTicksToWait,
                                          const BaseType_t xWaitIndefinitely )
    {
    45a0:	df 93       	push	r29
    45a2:	cf 93       	push	r28
    45a4:	cd b7       	in	r28, 0x3d	; 61
    45a6:	de b7       	in	r29, 0x3e	; 62
    45a8:	27 97       	sbiw	r28, 0x07	; 7
    45aa:	0f b6       	in	r0, 0x3f	; 63
    45ac:	f8 94       	cli
    45ae:	de bf       	out	0x3e, r29	; 62
    45b0:	0f be       	out	0x3f, r0	; 63
    45b2:	cd bf       	out	0x3d, r28	; 61
    45b4:	9c 83       	std	Y+4, r25	; 0x04
    45b6:	8b 83       	std	Y+3, r24	; 0x03
    45b8:	7e 83       	std	Y+6, r23	; 0x06
    45ba:	6d 83       	std	Y+5, r22	; 0x05
    45bc:	4f 83       	std	Y+7, r20	; 0x07

        /* Place the event list item of the TCB in the appropriate event list.
         * In this case it is assume that this is the only task that is going to
         * be waiting on this event list, so the faster vListInsertEnd() function
         * can be used in place of vListInsert. */
        listINSERT_END( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    45be:	eb 81       	ldd	r30, Y+3	; 0x03
    45c0:	fc 81       	ldd	r31, Y+4	; 0x04
    45c2:	81 81       	ldd	r24, Z+1	; 0x01
    45c4:	92 81       	ldd	r25, Z+2	; 0x02
    45c6:	9a 83       	std	Y+2, r25	; 0x02
    45c8:	89 83       	std	Y+1, r24	; 0x01
    45ca:	e0 91 c4 07 	lds	r30, 0x07C4
    45ce:	f0 91 c5 07 	lds	r31, 0x07C5
    45d2:	89 81       	ldd	r24, Y+1	; 0x01
    45d4:	9a 81       	ldd	r25, Y+2	; 0x02
    45d6:	97 87       	std	Z+15, r25	; 0x0f
    45d8:	86 87       	std	Z+14, r24	; 0x0e
    45da:	a0 91 c4 07 	lds	r26, 0x07C4
    45de:	b0 91 c5 07 	lds	r27, 0x07C5
    45e2:	e9 81       	ldd	r30, Y+1	; 0x01
    45e4:	fa 81       	ldd	r31, Y+2	; 0x02
    45e6:	84 81       	ldd	r24, Z+4	; 0x04
    45e8:	95 81       	ldd	r25, Z+5	; 0x05
    45ea:	51 96       	adiw	r26, 0x11	; 17
    45ec:	9c 93       	st	X, r25
    45ee:	8e 93       	st	-X, r24
    45f0:	50 97       	sbiw	r26, 0x10	; 16
    45f2:	e9 81       	ldd	r30, Y+1	; 0x01
    45f4:	fa 81       	ldd	r31, Y+2	; 0x02
    45f6:	04 80       	ldd	r0, Z+4	; 0x04
    45f8:	f5 81       	ldd	r31, Z+5	; 0x05
    45fa:	e0 2d       	mov	r30, r0
    45fc:	80 91 c4 07 	lds	r24, 0x07C4
    4600:	90 91 c5 07 	lds	r25, 0x07C5
    4604:	0c 96       	adiw	r24, 0x0c	; 12
    4606:	93 83       	std	Z+3, r25	; 0x03
    4608:	82 83       	std	Z+2, r24	; 0x02
    460a:	80 91 c4 07 	lds	r24, 0x07C4
    460e:	90 91 c5 07 	lds	r25, 0x07C5
    4612:	0c 96       	adiw	r24, 0x0c	; 12
    4614:	e9 81       	ldd	r30, Y+1	; 0x01
    4616:	fa 81       	ldd	r31, Y+2	; 0x02
    4618:	95 83       	std	Z+5, r25	; 0x05
    461a:	84 83       	std	Z+4, r24	; 0x04
    461c:	e0 91 c4 07 	lds	r30, 0x07C4
    4620:	f0 91 c5 07 	lds	r31, 0x07C5
    4624:	8b 81       	ldd	r24, Y+3	; 0x03
    4626:	9c 81       	ldd	r25, Y+4	; 0x04
    4628:	95 8b       	std	Z+21, r25	; 0x15
    462a:	84 8b       	std	Z+20, r24	; 0x14
    462c:	eb 81       	ldd	r30, Y+3	; 0x03
    462e:	fc 81       	ldd	r31, Y+4	; 0x04
    4630:	80 81       	ld	r24, Z
    4632:	8f 5f       	subi	r24, 0xFF	; 255
    4634:	eb 81       	ldd	r30, Y+3	; 0x03
    4636:	fc 81       	ldd	r31, Y+4	; 0x04
    4638:	80 83       	st	Z, r24

        /* If the task should block indefinitely then set the block time to a
         * value that will be recognised as an indefinite delay inside the
         * prvAddCurrentTaskToDelayedList() function. */
        if( xWaitIndefinitely != pdFALSE )
    463a:	8f 81       	ldd	r24, Y+7	; 0x07
    463c:	88 23       	and	r24, r24
    463e:	21 f0       	breq	.+8      	; 0x4648 <vTaskPlaceOnEventListRestricted+0xa8>
        {
            xTicksToWait = portMAX_DELAY;
    4640:	8f ef       	ldi	r24, 0xFF	; 255
    4642:	9f ef       	ldi	r25, 0xFF	; 255
    4644:	9e 83       	std	Y+6, r25	; 0x06
    4646:	8d 83       	std	Y+5, r24	; 0x05
        }

        traceTASK_DELAY_UNTIL( ( xTickCount + xTicksToWait ) );
        prvAddCurrentTaskToDelayedList( xTicksToWait, xWaitIndefinitely );
    4648:	8d 81       	ldd	r24, Y+5	; 0x05
    464a:	9e 81       	ldd	r25, Y+6	; 0x06
    464c:	6f 81       	ldd	r22, Y+7	; 0x07
    464e:	0e 94 a5 2e 	call	0x5d4a	; 0x5d4a <prvAddCurrentTaskToDelayedList>
    }
    4652:	27 96       	adiw	r28, 0x07	; 7
    4654:	0f b6       	in	r0, 0x3f	; 63
    4656:	f8 94       	cli
    4658:	de bf       	out	0x3e, r29	; 62
    465a:	0f be       	out	0x3f, r0	; 63
    465c:	cd bf       	out	0x3d, r28	; 61
    465e:	cf 91       	pop	r28
    4660:	df 91       	pop	r29
    4662:	08 95       	ret

00004664 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
    4664:	df 93       	push	r29
    4666:	cf 93       	push	r28
    4668:	cd b7       	in	r28, 0x3d	; 61
    466a:	de b7       	in	r29, 0x3e	; 62
    466c:	2d 97       	sbiw	r28, 0x0d	; 13
    466e:	0f b6       	in	r0, 0x3f	; 63
    4670:	f8 94       	cli
    4672:	de bf       	out	0x3e, r29	; 62
    4674:	0f be       	out	0x3f, r0	; 63
    4676:	cd bf       	out	0x3d, r28	; 61
    4678:	9d 87       	std	Y+13, r25	; 0x0d
    467a:	8c 87       	std	Y+12, r24	; 0x0c
     * get called - the lock count on the queue will get modified instead.  This
     * means exclusive access to the event list is guaranteed here.
     *
     * This function assumes that a check has already been made to ensure that
     * pxEventList is not empty. */
    pxUnblockedTCB = listGET_OWNER_OF_HEAD_ENTRY( pxEventList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    467c:	ec 85       	ldd	r30, Y+12	; 0x0c
    467e:	fd 85       	ldd	r31, Y+13	; 0x0d
    4680:	05 80       	ldd	r0, Z+5	; 0x05
    4682:	f6 81       	ldd	r31, Z+6	; 0x06
    4684:	e0 2d       	mov	r30, r0
    4686:	86 81       	ldd	r24, Z+6	; 0x06
    4688:	97 81       	ldd	r25, Z+7	; 0x07
    468a:	9b 87       	std	Y+11, r25	; 0x0b
    468c:	8a 87       	std	Y+10, r24	; 0x0a
    configASSERT( pxUnblockedTCB );
    listREMOVE_ITEM( &( pxUnblockedTCB->xEventListItem ) );
    468e:	ea 85       	ldd	r30, Y+10	; 0x0a
    4690:	fb 85       	ldd	r31, Y+11	; 0x0b
    4692:	84 89       	ldd	r24, Z+20	; 0x14
    4694:	95 89       	ldd	r25, Z+21	; 0x15
    4696:	98 87       	std	Y+8, r25	; 0x08
    4698:	8f 83       	std	Y+7, r24	; 0x07
    469a:	ea 85       	ldd	r30, Y+10	; 0x0a
    469c:	fb 85       	ldd	r31, Y+11	; 0x0b
    469e:	a6 85       	ldd	r26, Z+14	; 0x0e
    46a0:	b7 85       	ldd	r27, Z+15	; 0x0f
    46a2:	ea 85       	ldd	r30, Y+10	; 0x0a
    46a4:	fb 85       	ldd	r31, Y+11	; 0x0b
    46a6:	80 89       	ldd	r24, Z+16	; 0x10
    46a8:	91 89       	ldd	r25, Z+17	; 0x11
    46aa:	15 96       	adiw	r26, 0x05	; 5
    46ac:	9c 93       	st	X, r25
    46ae:	8e 93       	st	-X, r24
    46b0:	14 97       	sbiw	r26, 0x04	; 4
    46b2:	ea 85       	ldd	r30, Y+10	; 0x0a
    46b4:	fb 85       	ldd	r31, Y+11	; 0x0b
    46b6:	a0 89       	ldd	r26, Z+16	; 0x10
    46b8:	b1 89       	ldd	r27, Z+17	; 0x11
    46ba:	ea 85       	ldd	r30, Y+10	; 0x0a
    46bc:	fb 85       	ldd	r31, Y+11	; 0x0b
    46be:	86 85       	ldd	r24, Z+14	; 0x0e
    46c0:	97 85       	ldd	r25, Z+15	; 0x0f
    46c2:	13 96       	adiw	r26, 0x03	; 3
    46c4:	9c 93       	st	X, r25
    46c6:	8e 93       	st	-X, r24
    46c8:	12 97       	sbiw	r26, 0x02	; 2
    46ca:	ef 81       	ldd	r30, Y+7	; 0x07
    46cc:	f8 85       	ldd	r31, Y+8	; 0x08
    46ce:	21 81       	ldd	r18, Z+1	; 0x01
    46d0:	32 81       	ldd	r19, Z+2	; 0x02
    46d2:	8a 85       	ldd	r24, Y+10	; 0x0a
    46d4:	9b 85       	ldd	r25, Y+11	; 0x0b
    46d6:	0c 96       	adiw	r24, 0x0c	; 12
    46d8:	28 17       	cp	r18, r24
    46da:	39 07       	cpc	r19, r25
    46dc:	41 f4       	brne	.+16     	; 0x46ee <xTaskRemoveFromEventList+0x8a>
    46de:	ea 85       	ldd	r30, Y+10	; 0x0a
    46e0:	fb 85       	ldd	r31, Y+11	; 0x0b
    46e2:	80 89       	ldd	r24, Z+16	; 0x10
    46e4:	91 89       	ldd	r25, Z+17	; 0x11
    46e6:	ef 81       	ldd	r30, Y+7	; 0x07
    46e8:	f8 85       	ldd	r31, Y+8	; 0x08
    46ea:	92 83       	std	Z+2, r25	; 0x02
    46ec:	81 83       	std	Z+1, r24	; 0x01
    46ee:	ea 85       	ldd	r30, Y+10	; 0x0a
    46f0:	fb 85       	ldd	r31, Y+11	; 0x0b
    46f2:	15 8a       	std	Z+21, r1	; 0x15
    46f4:	14 8a       	std	Z+20, r1	; 0x14
    46f6:	ef 81       	ldd	r30, Y+7	; 0x07
    46f8:	f8 85       	ldd	r31, Y+8	; 0x08
    46fa:	80 81       	ld	r24, Z
    46fc:	81 50       	subi	r24, 0x01	; 1
    46fe:	ef 81       	ldd	r30, Y+7	; 0x07
    4700:	f8 85       	ldd	r31, Y+8	; 0x08
    4702:	80 83       	st	Z, r24

    if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    4704:	80 91 d5 07 	lds	r24, 0x07D5
    4708:	88 23       	and	r24, r24
    470a:	09 f0       	breq	.+2      	; 0x470e <xTaskRemoveFromEventList+0xaa>
    470c:	a4 c0       	rjmp	.+328    	; 0x4856 <xTaskRemoveFromEventList+0x1f2>
    {
        listREMOVE_ITEM( &( pxUnblockedTCB->xStateListItem ) );
    470e:	ea 85       	ldd	r30, Y+10	; 0x0a
    4710:	fb 85       	ldd	r31, Y+11	; 0x0b
    4712:	82 85       	ldd	r24, Z+10	; 0x0a
    4714:	93 85       	ldd	r25, Z+11	; 0x0b
    4716:	9e 83       	std	Y+6, r25	; 0x06
    4718:	8d 83       	std	Y+5, r24	; 0x05
    471a:	ea 85       	ldd	r30, Y+10	; 0x0a
    471c:	fb 85       	ldd	r31, Y+11	; 0x0b
    471e:	a4 81       	ldd	r26, Z+4	; 0x04
    4720:	b5 81       	ldd	r27, Z+5	; 0x05
    4722:	ea 85       	ldd	r30, Y+10	; 0x0a
    4724:	fb 85       	ldd	r31, Y+11	; 0x0b
    4726:	86 81       	ldd	r24, Z+6	; 0x06
    4728:	97 81       	ldd	r25, Z+7	; 0x07
    472a:	15 96       	adiw	r26, 0x05	; 5
    472c:	9c 93       	st	X, r25
    472e:	8e 93       	st	-X, r24
    4730:	14 97       	sbiw	r26, 0x04	; 4
    4732:	ea 85       	ldd	r30, Y+10	; 0x0a
    4734:	fb 85       	ldd	r31, Y+11	; 0x0b
    4736:	a6 81       	ldd	r26, Z+6	; 0x06
    4738:	b7 81       	ldd	r27, Z+7	; 0x07
    473a:	ea 85       	ldd	r30, Y+10	; 0x0a
    473c:	fb 85       	ldd	r31, Y+11	; 0x0b
    473e:	84 81       	ldd	r24, Z+4	; 0x04
    4740:	95 81       	ldd	r25, Z+5	; 0x05
    4742:	13 96       	adiw	r26, 0x03	; 3
    4744:	9c 93       	st	X, r25
    4746:	8e 93       	st	-X, r24
    4748:	12 97       	sbiw	r26, 0x02	; 2
    474a:	ed 81       	ldd	r30, Y+5	; 0x05
    474c:	fe 81       	ldd	r31, Y+6	; 0x06
    474e:	21 81       	ldd	r18, Z+1	; 0x01
    4750:	32 81       	ldd	r19, Z+2	; 0x02
    4752:	8a 85       	ldd	r24, Y+10	; 0x0a
    4754:	9b 85       	ldd	r25, Y+11	; 0x0b
    4756:	02 96       	adiw	r24, 0x02	; 2
    4758:	28 17       	cp	r18, r24
    475a:	39 07       	cpc	r19, r25
    475c:	41 f4       	brne	.+16     	; 0x476e <xTaskRemoveFromEventList+0x10a>
    475e:	ea 85       	ldd	r30, Y+10	; 0x0a
    4760:	fb 85       	ldd	r31, Y+11	; 0x0b
    4762:	86 81       	ldd	r24, Z+6	; 0x06
    4764:	97 81       	ldd	r25, Z+7	; 0x07
    4766:	ed 81       	ldd	r30, Y+5	; 0x05
    4768:	fe 81       	ldd	r31, Y+6	; 0x06
    476a:	92 83       	std	Z+2, r25	; 0x02
    476c:	81 83       	std	Z+1, r24	; 0x01
    476e:	ea 85       	ldd	r30, Y+10	; 0x0a
    4770:	fb 85       	ldd	r31, Y+11	; 0x0b
    4772:	13 86       	std	Z+11, r1	; 0x0b
    4774:	12 86       	std	Z+10, r1	; 0x0a
    4776:	ed 81       	ldd	r30, Y+5	; 0x05
    4778:	fe 81       	ldd	r31, Y+6	; 0x06
    477a:	80 81       	ld	r24, Z
    477c:	81 50       	subi	r24, 0x01	; 1
    477e:	ed 81       	ldd	r30, Y+5	; 0x05
    4780:	fe 81       	ldd	r31, Y+6	; 0x06
    4782:	80 83       	st	Z, r24
        prvAddTaskToReadyList( pxUnblockedTCB );
    4784:	ea 85       	ldd	r30, Y+10	; 0x0a
    4786:	fb 85       	ldd	r31, Y+11	; 0x0b
    4788:	96 89       	ldd	r25, Z+22	; 0x16
    478a:	80 91 ca 07 	lds	r24, 0x07CA
    478e:	89 17       	cp	r24, r25
    4790:	28 f4       	brcc	.+10     	; 0x479c <xTaskRemoveFromEventList+0x138>
    4792:	ea 85       	ldd	r30, Y+10	; 0x0a
    4794:	fb 85       	ldd	r31, Y+11	; 0x0b
    4796:	86 89       	ldd	r24, Z+22	; 0x16
    4798:	80 93 ca 07 	sts	0x07CA, r24
    479c:	ea 85       	ldd	r30, Y+10	; 0x0a
    479e:	fb 85       	ldd	r31, Y+11	; 0x0b
    47a0:	86 89       	ldd	r24, Z+22	; 0x16
    47a2:	28 2f       	mov	r18, r24
    47a4:	30 e0       	ldi	r19, 0x00	; 0
    47a6:	c9 01       	movw	r24, r18
    47a8:	88 0f       	add	r24, r24
    47aa:	99 1f       	adc	r25, r25
    47ac:	88 0f       	add	r24, r24
    47ae:	99 1f       	adc	r25, r25
    47b0:	88 0f       	add	r24, r24
    47b2:	99 1f       	adc	r25, r25
    47b4:	82 0f       	add	r24, r18
    47b6:	93 1f       	adc	r25, r19
    47b8:	fc 01       	movw	r30, r24
    47ba:	ea 52       	subi	r30, 0x2A	; 42
    47bc:	f8 4f       	sbci	r31, 0xF8	; 248
    47be:	81 81       	ldd	r24, Z+1	; 0x01
    47c0:	92 81       	ldd	r25, Z+2	; 0x02
    47c2:	9c 83       	std	Y+4, r25	; 0x04
    47c4:	8b 83       	std	Y+3, r24	; 0x03
    47c6:	ea 85       	ldd	r30, Y+10	; 0x0a
    47c8:	fb 85       	ldd	r31, Y+11	; 0x0b
    47ca:	8b 81       	ldd	r24, Y+3	; 0x03
    47cc:	9c 81       	ldd	r25, Y+4	; 0x04
    47ce:	95 83       	std	Z+5, r25	; 0x05
    47d0:	84 83       	std	Z+4, r24	; 0x04
    47d2:	eb 81       	ldd	r30, Y+3	; 0x03
    47d4:	fc 81       	ldd	r31, Y+4	; 0x04
    47d6:	84 81       	ldd	r24, Z+4	; 0x04
    47d8:	95 81       	ldd	r25, Z+5	; 0x05
    47da:	ea 85       	ldd	r30, Y+10	; 0x0a
    47dc:	fb 85       	ldd	r31, Y+11	; 0x0b
    47de:	97 83       	std	Z+7, r25	; 0x07
    47e0:	86 83       	std	Z+6, r24	; 0x06
    47e2:	eb 81       	ldd	r30, Y+3	; 0x03
    47e4:	fc 81       	ldd	r31, Y+4	; 0x04
    47e6:	04 80       	ldd	r0, Z+4	; 0x04
    47e8:	f5 81       	ldd	r31, Z+5	; 0x05
    47ea:	e0 2d       	mov	r30, r0
    47ec:	8a 85       	ldd	r24, Y+10	; 0x0a
    47ee:	9b 85       	ldd	r25, Y+11	; 0x0b
    47f0:	02 96       	adiw	r24, 0x02	; 2
    47f2:	93 83       	std	Z+3, r25	; 0x03
    47f4:	82 83       	std	Z+2, r24	; 0x02
    47f6:	8a 85       	ldd	r24, Y+10	; 0x0a
    47f8:	9b 85       	ldd	r25, Y+11	; 0x0b
    47fa:	02 96       	adiw	r24, 0x02	; 2
    47fc:	eb 81       	ldd	r30, Y+3	; 0x03
    47fe:	fc 81       	ldd	r31, Y+4	; 0x04
    4800:	95 83       	std	Z+5, r25	; 0x05
    4802:	84 83       	std	Z+4, r24	; 0x04
    4804:	ea 85       	ldd	r30, Y+10	; 0x0a
    4806:	fb 85       	ldd	r31, Y+11	; 0x0b
    4808:	86 89       	ldd	r24, Z+22	; 0x16
    480a:	28 2f       	mov	r18, r24
    480c:	30 e0       	ldi	r19, 0x00	; 0
    480e:	c9 01       	movw	r24, r18
    4810:	88 0f       	add	r24, r24
    4812:	99 1f       	adc	r25, r25
    4814:	88 0f       	add	r24, r24
    4816:	99 1f       	adc	r25, r25
    4818:	88 0f       	add	r24, r24
    481a:	99 1f       	adc	r25, r25
    481c:	82 0f       	add	r24, r18
    481e:	93 1f       	adc	r25, r19
    4820:	8a 52       	subi	r24, 0x2A	; 42
    4822:	98 4f       	sbci	r25, 0xF8	; 248
    4824:	ea 85       	ldd	r30, Y+10	; 0x0a
    4826:	fb 85       	ldd	r31, Y+11	; 0x0b
    4828:	93 87       	std	Z+11, r25	; 0x0b
    482a:	82 87       	std	Z+10, r24	; 0x0a
    482c:	ea 85       	ldd	r30, Y+10	; 0x0a
    482e:	fb 85       	ldd	r31, Y+11	; 0x0b
    4830:	86 89       	ldd	r24, Z+22	; 0x16
    4832:	28 2f       	mov	r18, r24
    4834:	30 e0       	ldi	r19, 0x00	; 0
    4836:	c9 01       	movw	r24, r18
    4838:	88 0f       	add	r24, r24
    483a:	99 1f       	adc	r25, r25
    483c:	88 0f       	add	r24, r24
    483e:	99 1f       	adc	r25, r25
    4840:	88 0f       	add	r24, r24
    4842:	99 1f       	adc	r25, r25
    4844:	82 0f       	add	r24, r18
    4846:	93 1f       	adc	r25, r19
    4848:	fc 01       	movw	r30, r24
    484a:	ea 52       	subi	r30, 0x2A	; 42
    484c:	f8 4f       	sbci	r31, 0xF8	; 248
    484e:	80 81       	ld	r24, Z
    4850:	8f 5f       	subi	r24, 0xFF	; 255
    4852:	80 83       	st	Z, r24
    4854:	30 c0       	rjmp	.+96     	; 0x48b6 <xTaskRemoveFromEventList+0x252>
    }
    else
    {
        /* The delayed and ready lists cannot be accessed, so hold this task
         * pending until the scheduler is resumed. */
        listINSERT_END( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    4856:	80 91 11 08 	lds	r24, 0x0811
    485a:	90 91 12 08 	lds	r25, 0x0812
    485e:	9a 83       	std	Y+2, r25	; 0x02
    4860:	89 83       	std	Y+1, r24	; 0x01
    4862:	ea 85       	ldd	r30, Y+10	; 0x0a
    4864:	fb 85       	ldd	r31, Y+11	; 0x0b
    4866:	89 81       	ldd	r24, Y+1	; 0x01
    4868:	9a 81       	ldd	r25, Y+2	; 0x02
    486a:	97 87       	std	Z+15, r25	; 0x0f
    486c:	86 87       	std	Z+14, r24	; 0x0e
    486e:	e9 81       	ldd	r30, Y+1	; 0x01
    4870:	fa 81       	ldd	r31, Y+2	; 0x02
    4872:	84 81       	ldd	r24, Z+4	; 0x04
    4874:	95 81       	ldd	r25, Z+5	; 0x05
    4876:	ea 85       	ldd	r30, Y+10	; 0x0a
    4878:	fb 85       	ldd	r31, Y+11	; 0x0b
    487a:	91 8b       	std	Z+17, r25	; 0x11
    487c:	80 8b       	std	Z+16, r24	; 0x10
    487e:	e9 81       	ldd	r30, Y+1	; 0x01
    4880:	fa 81       	ldd	r31, Y+2	; 0x02
    4882:	04 80       	ldd	r0, Z+4	; 0x04
    4884:	f5 81       	ldd	r31, Z+5	; 0x05
    4886:	e0 2d       	mov	r30, r0
    4888:	8a 85       	ldd	r24, Y+10	; 0x0a
    488a:	9b 85       	ldd	r25, Y+11	; 0x0b
    488c:	0c 96       	adiw	r24, 0x0c	; 12
    488e:	93 83       	std	Z+3, r25	; 0x03
    4890:	82 83       	std	Z+2, r24	; 0x02
    4892:	8a 85       	ldd	r24, Y+10	; 0x0a
    4894:	9b 85       	ldd	r25, Y+11	; 0x0b
    4896:	0c 96       	adiw	r24, 0x0c	; 12
    4898:	e9 81       	ldd	r30, Y+1	; 0x01
    489a:	fa 81       	ldd	r31, Y+2	; 0x02
    489c:	95 83       	std	Z+5, r25	; 0x05
    489e:	84 83       	std	Z+4, r24	; 0x04
    48a0:	ea 85       	ldd	r30, Y+10	; 0x0a
    48a2:	fb 85       	ldd	r31, Y+11	; 0x0b
    48a4:	80 e1       	ldi	r24, 0x10	; 16
    48a6:	98 e0       	ldi	r25, 0x08	; 8
    48a8:	95 8b       	std	Z+21, r25	; 0x15
    48aa:	84 8b       	std	Z+20, r24	; 0x14
    48ac:	80 91 10 08 	lds	r24, 0x0810
    48b0:	8f 5f       	subi	r24, 0xFF	; 255
    48b2:	80 93 10 08 	sts	0x0810, r24
    }

    if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    48b6:	ea 85       	ldd	r30, Y+10	; 0x0a
    48b8:	fb 85       	ldd	r31, Y+11	; 0x0b
    48ba:	96 89       	ldd	r25, Z+22	; 0x16
    48bc:	e0 91 c4 07 	lds	r30, 0x07C4
    48c0:	f0 91 c5 07 	lds	r31, 0x07C5
    48c4:	86 89       	ldd	r24, Z+22	; 0x16
    48c6:	89 17       	cp	r24, r25
    48c8:	30 f4       	brcc	.+12     	; 0x48d6 <xTaskRemoveFromEventList+0x272>
    {
        /* Return true if the task removed from the event list has a higher
         * priority than the calling task.  This allows the calling task to know if
         * it should force a context switch now. */
        xReturn = pdTRUE;
    48ca:	81 e0       	ldi	r24, 0x01	; 1
    48cc:	89 87       	std	Y+9, r24	; 0x09

        /* Mark that a yield is pending in case the user is not using the
         * "xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
        xYieldPending = pdTRUE;
    48ce:	81 e0       	ldi	r24, 0x01	; 1
    48d0:	80 93 ce 07 	sts	0x07CE, r24
    48d4:	01 c0       	rjmp	.+2      	; 0x48d8 <xTaskRemoveFromEventList+0x274>
    }
    else
    {
        xReturn = pdFALSE;
    48d6:	19 86       	std	Y+9, r1	; 0x09
    }

    return xReturn;
    48d8:	89 85       	ldd	r24, Y+9	; 0x09
}
    48da:	2d 96       	adiw	r28, 0x0d	; 13
    48dc:	0f b6       	in	r0, 0x3f	; 63
    48de:	f8 94       	cli
    48e0:	de bf       	out	0x3e, r29	; 62
    48e2:	0f be       	out	0x3f, r0	; 63
    48e4:	cd bf       	out	0x3d, r28	; 61
    48e6:	cf 91       	pop	r28
    48e8:	df 91       	pop	r29
    48ea:	08 95       	ret

000048ec <vTaskRemoveFromUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem,
                                        const TickType_t xItemValue )
{
    48ec:	df 93       	push	r29
    48ee:	cf 93       	push	r28
    48f0:	cd b7       	in	r28, 0x3d	; 61
    48f2:	de b7       	in	r29, 0x3e	; 62
    48f4:	2c 97       	sbiw	r28, 0x0c	; 12
    48f6:	0f b6       	in	r0, 0x3f	; 63
    48f8:	f8 94       	cli
    48fa:	de bf       	out	0x3e, r29	; 62
    48fc:	0f be       	out	0x3f, r0	; 63
    48fe:	cd bf       	out	0x3d, r28	; 61
    4900:	9a 87       	std	Y+10, r25	; 0x0a
    4902:	89 87       	std	Y+9, r24	; 0x09
    4904:	7c 87       	std	Y+12, r23	; 0x0c
    4906:	6b 87       	std	Y+11, r22	; 0x0b
    /* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
     * the event flags implementation. */
    configASSERT( uxSchedulerSuspended != pdFALSE );

    /* Store the new item value in the event list. */
    listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    4908:	8b 85       	ldd	r24, Y+11	; 0x0b
    490a:	9c 85       	ldd	r25, Y+12	; 0x0c
    490c:	90 68       	ori	r25, 0x80	; 128
    490e:	e9 85       	ldd	r30, Y+9	; 0x09
    4910:	fa 85       	ldd	r31, Y+10	; 0x0a
    4912:	91 83       	std	Z+1, r25	; 0x01
    4914:	80 83       	st	Z, r24

    /* Remove the event list form the event flag.  Interrupts do not access
     * event flags. */
    pxUnblockedTCB = listGET_LIST_ITEM_OWNER( pxEventListItem ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    4916:	e9 85       	ldd	r30, Y+9	; 0x09
    4918:	fa 85       	ldd	r31, Y+10	; 0x0a
    491a:	86 81       	ldd	r24, Z+6	; 0x06
    491c:	97 81       	ldd	r25, Z+7	; 0x07
    491e:	98 87       	std	Y+8, r25	; 0x08
    4920:	8f 83       	std	Y+7, r24	; 0x07
    configASSERT( pxUnblockedTCB );
    listREMOVE_ITEM( pxEventListItem );
    4922:	e9 85       	ldd	r30, Y+9	; 0x09
    4924:	fa 85       	ldd	r31, Y+10	; 0x0a
    4926:	80 85       	ldd	r24, Z+8	; 0x08
    4928:	91 85       	ldd	r25, Z+9	; 0x09
    492a:	9e 83       	std	Y+6, r25	; 0x06
    492c:	8d 83       	std	Y+5, r24	; 0x05
    492e:	e9 85       	ldd	r30, Y+9	; 0x09
    4930:	fa 85       	ldd	r31, Y+10	; 0x0a
    4932:	a2 81       	ldd	r26, Z+2	; 0x02
    4934:	b3 81       	ldd	r27, Z+3	; 0x03
    4936:	e9 85       	ldd	r30, Y+9	; 0x09
    4938:	fa 85       	ldd	r31, Y+10	; 0x0a
    493a:	84 81       	ldd	r24, Z+4	; 0x04
    493c:	95 81       	ldd	r25, Z+5	; 0x05
    493e:	15 96       	adiw	r26, 0x05	; 5
    4940:	9c 93       	st	X, r25
    4942:	8e 93       	st	-X, r24
    4944:	14 97       	sbiw	r26, 0x04	; 4
    4946:	e9 85       	ldd	r30, Y+9	; 0x09
    4948:	fa 85       	ldd	r31, Y+10	; 0x0a
    494a:	a4 81       	ldd	r26, Z+4	; 0x04
    494c:	b5 81       	ldd	r27, Z+5	; 0x05
    494e:	e9 85       	ldd	r30, Y+9	; 0x09
    4950:	fa 85       	ldd	r31, Y+10	; 0x0a
    4952:	82 81       	ldd	r24, Z+2	; 0x02
    4954:	93 81       	ldd	r25, Z+3	; 0x03
    4956:	13 96       	adiw	r26, 0x03	; 3
    4958:	9c 93       	st	X, r25
    495a:	8e 93       	st	-X, r24
    495c:	12 97       	sbiw	r26, 0x02	; 2
    495e:	ed 81       	ldd	r30, Y+5	; 0x05
    4960:	fe 81       	ldd	r31, Y+6	; 0x06
    4962:	21 81       	ldd	r18, Z+1	; 0x01
    4964:	32 81       	ldd	r19, Z+2	; 0x02
    4966:	89 85       	ldd	r24, Y+9	; 0x09
    4968:	9a 85       	ldd	r25, Y+10	; 0x0a
    496a:	28 17       	cp	r18, r24
    496c:	39 07       	cpc	r19, r25
    496e:	41 f4       	brne	.+16     	; 0x4980 <vTaskRemoveFromUnorderedEventList+0x94>
    4970:	e9 85       	ldd	r30, Y+9	; 0x09
    4972:	fa 85       	ldd	r31, Y+10	; 0x0a
    4974:	84 81       	ldd	r24, Z+4	; 0x04
    4976:	95 81       	ldd	r25, Z+5	; 0x05
    4978:	ed 81       	ldd	r30, Y+5	; 0x05
    497a:	fe 81       	ldd	r31, Y+6	; 0x06
    497c:	92 83       	std	Z+2, r25	; 0x02
    497e:	81 83       	std	Z+1, r24	; 0x01
    4980:	e9 85       	ldd	r30, Y+9	; 0x09
    4982:	fa 85       	ldd	r31, Y+10	; 0x0a
    4984:	11 86       	std	Z+9, r1	; 0x09
    4986:	10 86       	std	Z+8, r1	; 0x08
    4988:	ed 81       	ldd	r30, Y+5	; 0x05
    498a:	fe 81       	ldd	r31, Y+6	; 0x06
    498c:	80 81       	ld	r24, Z
    498e:	81 50       	subi	r24, 0x01	; 1
    4990:	ed 81       	ldd	r30, Y+5	; 0x05
    4992:	fe 81       	ldd	r31, Y+6	; 0x06
    4994:	80 83       	st	Z, r24
    #endif

    /* Remove the task from the delayed list and add it to the ready list.  The
     * scheduler is suspended so interrupts will not be accessing the ready
     * lists. */
    listREMOVE_ITEM( &( pxUnblockedTCB->xStateListItem ) );
    4996:	ef 81       	ldd	r30, Y+7	; 0x07
    4998:	f8 85       	ldd	r31, Y+8	; 0x08
    499a:	82 85       	ldd	r24, Z+10	; 0x0a
    499c:	93 85       	ldd	r25, Z+11	; 0x0b
    499e:	9c 83       	std	Y+4, r25	; 0x04
    49a0:	8b 83       	std	Y+3, r24	; 0x03
    49a2:	ef 81       	ldd	r30, Y+7	; 0x07
    49a4:	f8 85       	ldd	r31, Y+8	; 0x08
    49a6:	a4 81       	ldd	r26, Z+4	; 0x04
    49a8:	b5 81       	ldd	r27, Z+5	; 0x05
    49aa:	ef 81       	ldd	r30, Y+7	; 0x07
    49ac:	f8 85       	ldd	r31, Y+8	; 0x08
    49ae:	86 81       	ldd	r24, Z+6	; 0x06
    49b0:	97 81       	ldd	r25, Z+7	; 0x07
    49b2:	15 96       	adiw	r26, 0x05	; 5
    49b4:	9c 93       	st	X, r25
    49b6:	8e 93       	st	-X, r24
    49b8:	14 97       	sbiw	r26, 0x04	; 4
    49ba:	ef 81       	ldd	r30, Y+7	; 0x07
    49bc:	f8 85       	ldd	r31, Y+8	; 0x08
    49be:	a6 81       	ldd	r26, Z+6	; 0x06
    49c0:	b7 81       	ldd	r27, Z+7	; 0x07
    49c2:	ef 81       	ldd	r30, Y+7	; 0x07
    49c4:	f8 85       	ldd	r31, Y+8	; 0x08
    49c6:	84 81       	ldd	r24, Z+4	; 0x04
    49c8:	95 81       	ldd	r25, Z+5	; 0x05
    49ca:	13 96       	adiw	r26, 0x03	; 3
    49cc:	9c 93       	st	X, r25
    49ce:	8e 93       	st	-X, r24
    49d0:	12 97       	sbiw	r26, 0x02	; 2
    49d2:	eb 81       	ldd	r30, Y+3	; 0x03
    49d4:	fc 81       	ldd	r31, Y+4	; 0x04
    49d6:	21 81       	ldd	r18, Z+1	; 0x01
    49d8:	32 81       	ldd	r19, Z+2	; 0x02
    49da:	8f 81       	ldd	r24, Y+7	; 0x07
    49dc:	98 85       	ldd	r25, Y+8	; 0x08
    49de:	02 96       	adiw	r24, 0x02	; 2
    49e0:	28 17       	cp	r18, r24
    49e2:	39 07       	cpc	r19, r25
    49e4:	41 f4       	brne	.+16     	; 0x49f6 <vTaskRemoveFromUnorderedEventList+0x10a>
    49e6:	ef 81       	ldd	r30, Y+7	; 0x07
    49e8:	f8 85       	ldd	r31, Y+8	; 0x08
    49ea:	86 81       	ldd	r24, Z+6	; 0x06
    49ec:	97 81       	ldd	r25, Z+7	; 0x07
    49ee:	eb 81       	ldd	r30, Y+3	; 0x03
    49f0:	fc 81       	ldd	r31, Y+4	; 0x04
    49f2:	92 83       	std	Z+2, r25	; 0x02
    49f4:	81 83       	std	Z+1, r24	; 0x01
    49f6:	ef 81       	ldd	r30, Y+7	; 0x07
    49f8:	f8 85       	ldd	r31, Y+8	; 0x08
    49fa:	13 86       	std	Z+11, r1	; 0x0b
    49fc:	12 86       	std	Z+10, r1	; 0x0a
    49fe:	eb 81       	ldd	r30, Y+3	; 0x03
    4a00:	fc 81       	ldd	r31, Y+4	; 0x04
    4a02:	80 81       	ld	r24, Z
    4a04:	81 50       	subi	r24, 0x01	; 1
    4a06:	eb 81       	ldd	r30, Y+3	; 0x03
    4a08:	fc 81       	ldd	r31, Y+4	; 0x04
    4a0a:	80 83       	st	Z, r24
    prvAddTaskToReadyList( pxUnblockedTCB );
    4a0c:	ef 81       	ldd	r30, Y+7	; 0x07
    4a0e:	f8 85       	ldd	r31, Y+8	; 0x08
    4a10:	96 89       	ldd	r25, Z+22	; 0x16
    4a12:	80 91 ca 07 	lds	r24, 0x07CA
    4a16:	89 17       	cp	r24, r25
    4a18:	28 f4       	brcc	.+10     	; 0x4a24 <vTaskRemoveFromUnorderedEventList+0x138>
    4a1a:	ef 81       	ldd	r30, Y+7	; 0x07
    4a1c:	f8 85       	ldd	r31, Y+8	; 0x08
    4a1e:	86 89       	ldd	r24, Z+22	; 0x16
    4a20:	80 93 ca 07 	sts	0x07CA, r24
    4a24:	ef 81       	ldd	r30, Y+7	; 0x07
    4a26:	f8 85       	ldd	r31, Y+8	; 0x08
    4a28:	86 89       	ldd	r24, Z+22	; 0x16
    4a2a:	28 2f       	mov	r18, r24
    4a2c:	30 e0       	ldi	r19, 0x00	; 0
    4a2e:	c9 01       	movw	r24, r18
    4a30:	88 0f       	add	r24, r24
    4a32:	99 1f       	adc	r25, r25
    4a34:	88 0f       	add	r24, r24
    4a36:	99 1f       	adc	r25, r25
    4a38:	88 0f       	add	r24, r24
    4a3a:	99 1f       	adc	r25, r25
    4a3c:	82 0f       	add	r24, r18
    4a3e:	93 1f       	adc	r25, r19
    4a40:	fc 01       	movw	r30, r24
    4a42:	ea 52       	subi	r30, 0x2A	; 42
    4a44:	f8 4f       	sbci	r31, 0xF8	; 248
    4a46:	81 81       	ldd	r24, Z+1	; 0x01
    4a48:	92 81       	ldd	r25, Z+2	; 0x02
    4a4a:	9a 83       	std	Y+2, r25	; 0x02
    4a4c:	89 83       	std	Y+1, r24	; 0x01
    4a4e:	ef 81       	ldd	r30, Y+7	; 0x07
    4a50:	f8 85       	ldd	r31, Y+8	; 0x08
    4a52:	89 81       	ldd	r24, Y+1	; 0x01
    4a54:	9a 81       	ldd	r25, Y+2	; 0x02
    4a56:	95 83       	std	Z+5, r25	; 0x05
    4a58:	84 83       	std	Z+4, r24	; 0x04
    4a5a:	e9 81       	ldd	r30, Y+1	; 0x01
    4a5c:	fa 81       	ldd	r31, Y+2	; 0x02
    4a5e:	84 81       	ldd	r24, Z+4	; 0x04
    4a60:	95 81       	ldd	r25, Z+5	; 0x05
    4a62:	ef 81       	ldd	r30, Y+7	; 0x07
    4a64:	f8 85       	ldd	r31, Y+8	; 0x08
    4a66:	97 83       	std	Z+7, r25	; 0x07
    4a68:	86 83       	std	Z+6, r24	; 0x06
    4a6a:	e9 81       	ldd	r30, Y+1	; 0x01
    4a6c:	fa 81       	ldd	r31, Y+2	; 0x02
    4a6e:	04 80       	ldd	r0, Z+4	; 0x04
    4a70:	f5 81       	ldd	r31, Z+5	; 0x05
    4a72:	e0 2d       	mov	r30, r0
    4a74:	8f 81       	ldd	r24, Y+7	; 0x07
    4a76:	98 85       	ldd	r25, Y+8	; 0x08
    4a78:	02 96       	adiw	r24, 0x02	; 2
    4a7a:	93 83       	std	Z+3, r25	; 0x03
    4a7c:	82 83       	std	Z+2, r24	; 0x02
    4a7e:	8f 81       	ldd	r24, Y+7	; 0x07
    4a80:	98 85       	ldd	r25, Y+8	; 0x08
    4a82:	02 96       	adiw	r24, 0x02	; 2
    4a84:	e9 81       	ldd	r30, Y+1	; 0x01
    4a86:	fa 81       	ldd	r31, Y+2	; 0x02
    4a88:	95 83       	std	Z+5, r25	; 0x05
    4a8a:	84 83       	std	Z+4, r24	; 0x04
    4a8c:	ef 81       	ldd	r30, Y+7	; 0x07
    4a8e:	f8 85       	ldd	r31, Y+8	; 0x08
    4a90:	86 89       	ldd	r24, Z+22	; 0x16
    4a92:	28 2f       	mov	r18, r24
    4a94:	30 e0       	ldi	r19, 0x00	; 0
    4a96:	c9 01       	movw	r24, r18
    4a98:	88 0f       	add	r24, r24
    4a9a:	99 1f       	adc	r25, r25
    4a9c:	88 0f       	add	r24, r24
    4a9e:	99 1f       	adc	r25, r25
    4aa0:	88 0f       	add	r24, r24
    4aa2:	99 1f       	adc	r25, r25
    4aa4:	82 0f       	add	r24, r18
    4aa6:	93 1f       	adc	r25, r19
    4aa8:	8a 52       	subi	r24, 0x2A	; 42
    4aaa:	98 4f       	sbci	r25, 0xF8	; 248
    4aac:	ef 81       	ldd	r30, Y+7	; 0x07
    4aae:	f8 85       	ldd	r31, Y+8	; 0x08
    4ab0:	93 87       	std	Z+11, r25	; 0x0b
    4ab2:	82 87       	std	Z+10, r24	; 0x0a
    4ab4:	ef 81       	ldd	r30, Y+7	; 0x07
    4ab6:	f8 85       	ldd	r31, Y+8	; 0x08
    4ab8:	86 89       	ldd	r24, Z+22	; 0x16
    4aba:	28 2f       	mov	r18, r24
    4abc:	30 e0       	ldi	r19, 0x00	; 0
    4abe:	c9 01       	movw	r24, r18
    4ac0:	88 0f       	add	r24, r24
    4ac2:	99 1f       	adc	r25, r25
    4ac4:	88 0f       	add	r24, r24
    4ac6:	99 1f       	adc	r25, r25
    4ac8:	88 0f       	add	r24, r24
    4aca:	99 1f       	adc	r25, r25
    4acc:	82 0f       	add	r24, r18
    4ace:	93 1f       	adc	r25, r19
    4ad0:	fc 01       	movw	r30, r24
    4ad2:	ea 52       	subi	r30, 0x2A	; 42
    4ad4:	f8 4f       	sbci	r31, 0xF8	; 248
    4ad6:	80 81       	ld	r24, Z
    4ad8:	8f 5f       	subi	r24, 0xFF	; 255
    4ada:	80 83       	st	Z, r24

    if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    4adc:	ef 81       	ldd	r30, Y+7	; 0x07
    4ade:	f8 85       	ldd	r31, Y+8	; 0x08
    4ae0:	96 89       	ldd	r25, Z+22	; 0x16
    4ae2:	e0 91 c4 07 	lds	r30, 0x07C4
    4ae6:	f0 91 c5 07 	lds	r31, 0x07C5
    4aea:	86 89       	ldd	r24, Z+22	; 0x16
    4aec:	89 17       	cp	r24, r25
    4aee:	18 f4       	brcc	.+6      	; 0x4af6 <vTaskRemoveFromUnorderedEventList+0x20a>
    {
        /* The unblocked task has a priority above that of the calling task, so
         * a context switch is required.  This function is called with the
         * scheduler suspended so xYieldPending is set so the context switch
         * occurs immediately that the scheduler is resumed (unsuspended). */
        xYieldPending = pdTRUE;
    4af0:	81 e0       	ldi	r24, 0x01	; 1
    4af2:	80 93 ce 07 	sts	0x07CE, r24
    }
}
    4af6:	2c 96       	adiw	r28, 0x0c	; 12
    4af8:	0f b6       	in	r0, 0x3f	; 63
    4afa:	f8 94       	cli
    4afc:	de bf       	out	0x3e, r29	; 62
    4afe:	0f be       	out	0x3f, r0	; 63
    4b00:	cd bf       	out	0x3d, r28	; 61
    4b02:	cf 91       	pop	r28
    4b04:	df 91       	pop	r29
    4b06:	08 95       	ret

00004b08 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    4b08:	df 93       	push	r29
    4b0a:	cf 93       	push	r28
    4b0c:	00 d0       	rcall	.+0      	; 0x4b0e <vTaskSetTimeOutState+0x6>
    4b0e:	cd b7       	in	r28, 0x3d	; 61
    4b10:	de b7       	in	r29, 0x3e	; 62
    4b12:	9a 83       	std	Y+2, r25	; 0x02
    4b14:	89 83       	std	Y+1, r24	; 0x01
    configASSERT( pxTimeOut );
    taskENTER_CRITICAL();
    4b16:	0f b6       	in	r0, 0x3f	; 63
    4b18:	f8 94       	cli
    4b1a:	0f 92       	push	r0
    {
        pxTimeOut->xOverflowCount = xNumOfOverflows;
    4b1c:	80 91 cf 07 	lds	r24, 0x07CF
    4b20:	e9 81       	ldd	r30, Y+1	; 0x01
    4b22:	fa 81       	ldd	r31, Y+2	; 0x02
    4b24:	80 83       	st	Z, r24
        pxTimeOut->xTimeOnEntering = xTickCount;
    4b26:	80 91 c8 07 	lds	r24, 0x07C8
    4b2a:	90 91 c9 07 	lds	r25, 0x07C9
    4b2e:	e9 81       	ldd	r30, Y+1	; 0x01
    4b30:	fa 81       	ldd	r31, Y+2	; 0x02
    4b32:	92 83       	std	Z+2, r25	; 0x02
    4b34:	81 83       	std	Z+1, r24	; 0x01
    }
    taskEXIT_CRITICAL();
    4b36:	0f 90       	pop	r0
    4b38:	0f be       	out	0x3f, r0	; 63
}
    4b3a:	0f 90       	pop	r0
    4b3c:	0f 90       	pop	r0
    4b3e:	cf 91       	pop	r28
    4b40:	df 91       	pop	r29
    4b42:	08 95       	ret

00004b44 <vTaskInternalSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    4b44:	df 93       	push	r29
    4b46:	cf 93       	push	r28
    4b48:	00 d0       	rcall	.+0      	; 0x4b4a <vTaskInternalSetTimeOutState+0x6>
    4b4a:	cd b7       	in	r28, 0x3d	; 61
    4b4c:	de b7       	in	r29, 0x3e	; 62
    4b4e:	9a 83       	std	Y+2, r25	; 0x02
    4b50:	89 83       	std	Y+1, r24	; 0x01
    /* For internal use only as it does not use a critical section. */
    pxTimeOut->xOverflowCount = xNumOfOverflows;
    4b52:	80 91 cf 07 	lds	r24, 0x07CF
    4b56:	e9 81       	ldd	r30, Y+1	; 0x01
    4b58:	fa 81       	ldd	r31, Y+2	; 0x02
    4b5a:	80 83       	st	Z, r24
    pxTimeOut->xTimeOnEntering = xTickCount;
    4b5c:	80 91 c8 07 	lds	r24, 0x07C8
    4b60:	90 91 c9 07 	lds	r25, 0x07C9
    4b64:	e9 81       	ldd	r30, Y+1	; 0x01
    4b66:	fa 81       	ldd	r31, Y+2	; 0x02
    4b68:	92 83       	std	Z+2, r25	; 0x02
    4b6a:	81 83       	std	Z+1, r24	; 0x01
}
    4b6c:	0f 90       	pop	r0
    4b6e:	0f 90       	pop	r0
    4b70:	cf 91       	pop	r28
    4b72:	df 91       	pop	r29
    4b74:	08 95       	ret

00004b76 <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut,
                                 TickType_t * const pxTicksToWait )
{
    4b76:	df 93       	push	r29
    4b78:	cf 93       	push	r28
    4b7a:	cd b7       	in	r28, 0x3d	; 61
    4b7c:	de b7       	in	r29, 0x3e	; 62
    4b7e:	29 97       	sbiw	r28, 0x09	; 9
    4b80:	0f b6       	in	r0, 0x3f	; 63
    4b82:	f8 94       	cli
    4b84:	de bf       	out	0x3e, r29	; 62
    4b86:	0f be       	out	0x3f, r0	; 63
    4b88:	cd bf       	out	0x3d, r28	; 61
    4b8a:	9f 83       	std	Y+7, r25	; 0x07
    4b8c:	8e 83       	std	Y+6, r24	; 0x06
    4b8e:	79 87       	std	Y+9, r23	; 0x09
    4b90:	68 87       	std	Y+8, r22	; 0x08
    BaseType_t xReturn;

    configASSERT( pxTimeOut );
    configASSERT( pxTicksToWait );

    taskENTER_CRITICAL();
    4b92:	0f b6       	in	r0, 0x3f	; 63
    4b94:	f8 94       	cli
    4b96:	0f 92       	push	r0
    {
        /* Minor optimisation.  The tick count cannot change in this block. */
        const TickType_t xConstTickCount = xTickCount;
    4b98:	80 91 c8 07 	lds	r24, 0x07C8
    4b9c:	90 91 c9 07 	lds	r25, 0x07C9
    4ba0:	9c 83       	std	Y+4, r25	; 0x04
    4ba2:	8b 83       	std	Y+3, r24	; 0x03
        const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
    4ba4:	ee 81       	ldd	r30, Y+6	; 0x06
    4ba6:	ff 81       	ldd	r31, Y+7	; 0x07
    4ba8:	21 81       	ldd	r18, Z+1	; 0x01
    4baa:	32 81       	ldd	r19, Z+2	; 0x02
    4bac:	8b 81       	ldd	r24, Y+3	; 0x03
    4bae:	9c 81       	ldd	r25, Y+4	; 0x04
    4bb0:	82 1b       	sub	r24, r18
    4bb2:	93 0b       	sbc	r25, r19
    4bb4:	9a 83       	std	Y+2, r25	; 0x02
    4bb6:	89 83       	std	Y+1, r24	; 0x01
                xReturn = pdFALSE;
            }
            else
        #endif

        if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
    4bb8:	ee 81       	ldd	r30, Y+6	; 0x06
    4bba:	ff 81       	ldd	r31, Y+7	; 0x07
    4bbc:	90 81       	ld	r25, Z
    4bbe:	80 91 cf 07 	lds	r24, 0x07CF
    4bc2:	98 17       	cp	r25, r24
    4bc4:	81 f0       	breq	.+32     	; 0x4be6 <xTaskCheckForTimeOut+0x70>
    4bc6:	ee 81       	ldd	r30, Y+6	; 0x06
    4bc8:	ff 81       	ldd	r31, Y+7	; 0x07
    4bca:	21 81       	ldd	r18, Z+1	; 0x01
    4bcc:	32 81       	ldd	r19, Z+2	; 0x02
    4bce:	8b 81       	ldd	r24, Y+3	; 0x03
    4bd0:	9c 81       	ldd	r25, Y+4	; 0x04
    4bd2:	82 17       	cp	r24, r18
    4bd4:	93 07       	cpc	r25, r19
    4bd6:	38 f0       	brcs	.+14     	; 0x4be6 <xTaskCheckForTimeOut+0x70>
            /* The tick count is greater than the time at which
             * vTaskSetTimeout() was called, but has also overflowed since
             * vTaskSetTimeOut() was called.  It must have wrapped all the way
             * around and gone past again. This passed since vTaskSetTimeout()
             * was called. */
            xReturn = pdTRUE;
    4bd8:	81 e0       	ldi	r24, 0x01	; 1
    4bda:	8d 83       	std	Y+5, r24	; 0x05
            *pxTicksToWait = ( TickType_t ) 0;
    4bdc:	e8 85       	ldd	r30, Y+8	; 0x08
    4bde:	f9 85       	ldd	r31, Y+9	; 0x09
    4be0:	11 82       	std	Z+1, r1	; 0x01
    4be2:	10 82       	st	Z, r1
    4be4:	23 c0       	rjmp	.+70     	; 0x4c2c <xTaskCheckForTimeOut+0xb6>
        }
        else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
    4be6:	e8 85       	ldd	r30, Y+8	; 0x08
    4be8:	f9 85       	ldd	r31, Y+9	; 0x09
    4bea:	20 81       	ld	r18, Z
    4bec:	31 81       	ldd	r19, Z+1	; 0x01
    4bee:	89 81       	ldd	r24, Y+1	; 0x01
    4bf0:	9a 81       	ldd	r25, Y+2	; 0x02
    4bf2:	82 17       	cp	r24, r18
    4bf4:	93 07       	cpc	r25, r19
    4bf6:	a0 f4       	brcc	.+40     	; 0x4c20 <xTaskCheckForTimeOut+0xaa>
        {
            /* Not a genuine timeout. Adjust parameters for time remaining. */
            *pxTicksToWait -= xElapsedTime;
    4bf8:	e8 85       	ldd	r30, Y+8	; 0x08
    4bfa:	f9 85       	ldd	r31, Y+9	; 0x09
    4bfc:	20 81       	ld	r18, Z
    4bfe:	31 81       	ldd	r19, Z+1	; 0x01
    4c00:	89 81       	ldd	r24, Y+1	; 0x01
    4c02:	9a 81       	ldd	r25, Y+2	; 0x02
    4c04:	a9 01       	movw	r20, r18
    4c06:	48 1b       	sub	r20, r24
    4c08:	59 0b       	sbc	r21, r25
    4c0a:	ca 01       	movw	r24, r20
    4c0c:	e8 85       	ldd	r30, Y+8	; 0x08
    4c0e:	f9 85       	ldd	r31, Y+9	; 0x09
    4c10:	91 83       	std	Z+1, r25	; 0x01
    4c12:	80 83       	st	Z, r24
            vTaskInternalSetTimeOutState( pxTimeOut );
    4c14:	8e 81       	ldd	r24, Y+6	; 0x06
    4c16:	9f 81       	ldd	r25, Y+7	; 0x07
    4c18:	0e 94 a2 25 	call	0x4b44	; 0x4b44 <vTaskInternalSetTimeOutState>
            xReturn = pdFALSE;
    4c1c:	1d 82       	std	Y+5, r1	; 0x05
    4c1e:	06 c0       	rjmp	.+12     	; 0x4c2c <xTaskCheckForTimeOut+0xb6>
        }
        else
        {
            *pxTicksToWait = ( TickType_t ) 0;
    4c20:	e8 85       	ldd	r30, Y+8	; 0x08
    4c22:	f9 85       	ldd	r31, Y+9	; 0x09
    4c24:	11 82       	std	Z+1, r1	; 0x01
    4c26:	10 82       	st	Z, r1
            xReturn = pdTRUE;
    4c28:	81 e0       	ldi	r24, 0x01	; 1
    4c2a:	8d 83       	std	Y+5, r24	; 0x05
        }
    }
    taskEXIT_CRITICAL();
    4c2c:	0f 90       	pop	r0
    4c2e:	0f be       	out	0x3f, r0	; 63

    return xReturn;
    4c30:	8d 81       	ldd	r24, Y+5	; 0x05
}
    4c32:	29 96       	adiw	r28, 0x09	; 9
    4c34:	0f b6       	in	r0, 0x3f	; 63
    4c36:	f8 94       	cli
    4c38:	de bf       	out	0x3e, r29	; 62
    4c3a:	0f be       	out	0x3f, r0	; 63
    4c3c:	cd bf       	out	0x3d, r28	; 61
    4c3e:	cf 91       	pop	r28
    4c40:	df 91       	pop	r29
    4c42:	08 95       	ret

00004c44 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
    4c44:	df 93       	push	r29
    4c46:	cf 93       	push	r28
    4c48:	cd b7       	in	r28, 0x3d	; 61
    4c4a:	de b7       	in	r29, 0x3e	; 62
    xYieldPending = pdTRUE;
    4c4c:	81 e0       	ldi	r24, 0x01	; 1
    4c4e:	80 93 ce 07 	sts	0x07CE, r24
}
    4c52:	cf 91       	pop	r28
    4c54:	df 91       	pop	r29
    4c56:	08 95       	ret

00004c58 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
    4c58:	df 93       	push	r29
    4c5a:	cf 93       	push	r28
    4c5c:	00 d0       	rcall	.+0      	; 0x4c5e <prvIdleTask+0x6>
    4c5e:	cd b7       	in	r28, 0x3d	; 61
    4c60:	de b7       	in	r29, 0x3e	; 62
    4c62:	9a 83       	std	Y+2, r25	; 0x02
    4c64:	89 83       	std	Y+1, r24	; 0x01

    for( ; ; )
    {
        /* See if any tasks have deleted themselves - if so then the idle task
         * is responsible for freeing the deleted task's TCB and stack. */
        prvCheckTasksWaitingTermination();
    4c66:	0e 94 79 26 	call	0x4cf2	; 0x4cf2 <prvCheckTasksWaitingTermination>
                 *
                 * A critical region is not required here as we are just reading from
                 * the list, and an occasional incorrect value will not matter.  If
                 * the ready list at the idle priority contains more than one task
                 * then a task other than the idle task is ready to execute. */
                if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
    4c6a:	80 91 d6 07 	lds	r24, 0x07D6
    4c6e:	82 30       	cpi	r24, 0x02	; 2
    4c70:	d0 f3       	brcs	.-12     	; 0x4c66 <prvIdleTask+0xe>
                {
                    taskYIELD();
    4c72:	0e 94 56 09 	call	0x12ac	; 0x12ac <vPortYield>
    4c76:	f7 cf       	rjmp	.-18     	; 0x4c66 <prvIdleTask+0xe>

00004c78 <prvInitialiseTaskLists>:

#endif /* portUSING_MPU_WRAPPERS */
/*-----------------------------------------------------------*/

static void prvInitialiseTaskLists( void )
{
    4c78:	df 93       	push	r29
    4c7a:	cf 93       	push	r28
    4c7c:	0f 92       	push	r0
    4c7e:	cd b7       	in	r28, 0x3d	; 61
    4c80:	de b7       	in	r29, 0x3e	; 62
    UBaseType_t uxPriority;

    for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    4c82:	19 82       	std	Y+1, r1	; 0x01
    4c84:	13 c0       	rjmp	.+38     	; 0x4cac <prvInitialiseTaskLists+0x34>
    {
        vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
    4c86:	89 81       	ldd	r24, Y+1	; 0x01
    4c88:	28 2f       	mov	r18, r24
    4c8a:	30 e0       	ldi	r19, 0x00	; 0
    4c8c:	c9 01       	movw	r24, r18
    4c8e:	88 0f       	add	r24, r24
    4c90:	99 1f       	adc	r25, r25
    4c92:	88 0f       	add	r24, r24
    4c94:	99 1f       	adc	r25, r25
    4c96:	88 0f       	add	r24, r24
    4c98:	99 1f       	adc	r25, r25
    4c9a:	82 0f       	add	r24, r18
    4c9c:	93 1f       	adc	r25, r19
    4c9e:	8a 52       	subi	r24, 0x2A	; 42
    4ca0:	98 4f       	sbci	r25, 0xF8	; 248
    4ca2:	0e 94 8f 10 	call	0x211e	; 0x211e <vListInitialise>

static void prvInitialiseTaskLists( void )
{
    UBaseType_t uxPriority;

    for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    4ca6:	89 81       	ldd	r24, Y+1	; 0x01
    4ca8:	8f 5f       	subi	r24, 0xFF	; 255
    4caa:	89 83       	std	Y+1, r24	; 0x01
    4cac:	89 81       	ldd	r24, Y+1	; 0x01
    4cae:	84 30       	cpi	r24, 0x04	; 4
    4cb0:	50 f3       	brcs	.-44     	; 0x4c86 <prvInitialiseTaskLists+0xe>
    {
        vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
    }

    vListInitialise( &xDelayedTaskList1 );
    4cb2:	8a ef       	ldi	r24, 0xFA	; 250
    4cb4:	97 e0       	ldi	r25, 0x07	; 7
    4cb6:	0e 94 8f 10 	call	0x211e	; 0x211e <vListInitialise>
    vListInitialise( &xDelayedTaskList2 );
    4cba:	83 e0       	ldi	r24, 0x03	; 3
    4cbc:	98 e0       	ldi	r25, 0x08	; 8
    4cbe:	0e 94 8f 10 	call	0x211e	; 0x211e <vListInitialise>
    vListInitialise( &xPendingReadyList );
    4cc2:	80 e1       	ldi	r24, 0x10	; 16
    4cc4:	98 e0       	ldi	r25, 0x08	; 8
    4cc6:	0e 94 8f 10 	call	0x211e	; 0x211e <vListInitialise>

    #if ( INCLUDE_vTaskDelete == 1 )
        {
            vListInitialise( &xTasksWaitingTermination );
    4cca:	89 e1       	ldi	r24, 0x19	; 25
    4ccc:	98 e0       	ldi	r25, 0x08	; 8
    4cce:	0e 94 8f 10 	call	0x211e	; 0x211e <vListInitialise>
        }
    #endif /* INCLUDE_vTaskSuspend */

    /* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
     * using list2. */
    pxDelayedTaskList = &xDelayedTaskList1;
    4cd2:	8a ef       	ldi	r24, 0xFA	; 250
    4cd4:	97 e0       	ldi	r25, 0x07	; 7
    4cd6:	90 93 0d 08 	sts	0x080D, r25
    4cda:	80 93 0c 08 	sts	0x080C, r24
    pxOverflowDelayedTaskList = &xDelayedTaskList2;
    4cde:	83 e0       	ldi	r24, 0x03	; 3
    4ce0:	98 e0       	ldi	r25, 0x08	; 8
    4ce2:	90 93 0f 08 	sts	0x080F, r25
    4ce6:	80 93 0e 08 	sts	0x080E, r24
}
    4cea:	0f 90       	pop	r0
    4cec:	cf 91       	pop	r28
    4cee:	df 91       	pop	r29
    4cf0:	08 95       	ret

00004cf2 <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
    4cf2:	df 93       	push	r29
    4cf4:	cf 93       	push	r28
    4cf6:	00 d0       	rcall	.+0      	; 0x4cf8 <prvCheckTasksWaitingTermination+0x6>
    4cf8:	cd b7       	in	r28, 0x3d	; 61
    4cfa:	de b7       	in	r29, 0x3e	; 62
    4cfc:	20 c0       	rjmp	.+64     	; 0x4d3e <prvCheckTasksWaitingTermination+0x4c>

            /* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
             * being called too often in the idle task. */
            while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
            {
                taskENTER_CRITICAL();
    4cfe:	0f b6       	in	r0, 0x3f	; 63
    4d00:	f8 94       	cli
    4d02:	0f 92       	push	r0
                {
                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    4d04:	e0 91 1e 08 	lds	r30, 0x081E
    4d08:	f0 91 1f 08 	lds	r31, 0x081F
    4d0c:	86 81       	ldd	r24, Z+6	; 0x06
    4d0e:	97 81       	ldd	r25, Z+7	; 0x07
    4d10:	9a 83       	std	Y+2, r25	; 0x02
    4d12:	89 83       	std	Y+1, r24	; 0x01
                    ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    4d14:	89 81       	ldd	r24, Y+1	; 0x01
    4d16:	9a 81       	ldd	r25, Y+2	; 0x02
    4d18:	02 96       	adiw	r24, 0x02	; 2
    4d1a:	0e 94 79 11 	call	0x22f2	; 0x22f2 <uxListRemove>
                    --uxCurrentNumberOfTasks;
    4d1e:	80 91 c7 07 	lds	r24, 0x07C7
    4d22:	81 50       	subi	r24, 0x01	; 1
    4d24:	80 93 c7 07 	sts	0x07C7, r24
                    --uxDeletedTasksWaitingCleanUp;
    4d28:	80 91 c6 07 	lds	r24, 0x07C6
    4d2c:	81 50       	subi	r24, 0x01	; 1
    4d2e:	80 93 c6 07 	sts	0x07C6, r24
                }
                taskEXIT_CRITICAL();
    4d32:	0f 90       	pop	r0
    4d34:	0f be       	out	0x3f, r0	; 63

                prvDeleteTCB( pxTCB );
    4d36:	89 81       	ldd	r24, Y+1	; 0x01
    4d38:	9a 81       	ldd	r25, Y+2	; 0x02
    4d3a:	0e 94 a8 26 	call	0x4d50	; 0x4d50 <prvDeleteTCB>
        {
            TCB_t * pxTCB;

            /* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
             * being called too often in the idle task. */
            while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
    4d3e:	80 91 c6 07 	lds	r24, 0x07C6
    4d42:	88 23       	and	r24, r24
    4d44:	e1 f6       	brne	.-72     	; 0x4cfe <prvCheckTasksWaitingTermination+0xc>

                prvDeleteTCB( pxTCB );
            }
        }
    #endif /* INCLUDE_vTaskDelete */
}
    4d46:	0f 90       	pop	r0
    4d48:	0f 90       	pop	r0
    4d4a:	cf 91       	pop	r28
    4d4c:	df 91       	pop	r29
    4d4e:	08 95       	ret

00004d50 <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

    static void prvDeleteTCB( TCB_t * pxTCB )
    {
    4d50:	df 93       	push	r29
    4d52:	cf 93       	push	r28
    4d54:	00 d0       	rcall	.+0      	; 0x4d56 <prvDeleteTCB+0x6>
    4d56:	cd b7       	in	r28, 0x3d	; 61
    4d58:	de b7       	in	r29, 0x3e	; 62
    4d5a:	9a 83       	std	Y+2, r25	; 0x02
    4d5c:	89 83       	std	Y+1, r24	; 0x01

        #if ( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
            {
                /* The task can only have been allocated dynamically - free both
                 * the stack and TCB. */
                vPortFreeStack( pxTCB->pxStack );
    4d5e:	e9 81       	ldd	r30, Y+1	; 0x01
    4d60:	fa 81       	ldd	r31, Y+2	; 0x02
    4d62:	87 89       	ldd	r24, Z+23	; 0x17
    4d64:	90 8d       	ldd	r25, Z+24	; 0x18
    4d66:	0e 94 71 07 	call	0xee2	; 0xee2 <vPortFree>
                vPortFree( pxTCB );
    4d6a:	89 81       	ldd	r24, Y+1	; 0x01
    4d6c:	9a 81       	ldd	r25, Y+2	; 0x02
    4d6e:	0e 94 71 07 	call	0xee2	; 0xee2 <vPortFree>
                    configASSERT( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB );
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        #endif /* configSUPPORT_DYNAMIC_ALLOCATION */
    }
    4d72:	0f 90       	pop	r0
    4d74:	0f 90       	pop	r0
    4d76:	cf 91       	pop	r28
    4d78:	df 91       	pop	r29
    4d7a:	08 95       	ret

00004d7c <prvResetNextTaskUnblockTime>:

#endif /* INCLUDE_vTaskDelete */
/*-----------------------------------------------------------*/

static void prvResetNextTaskUnblockTime( void )
{
    4d7c:	df 93       	push	r29
    4d7e:	cf 93       	push	r28
    4d80:	cd b7       	in	r28, 0x3d	; 61
    4d82:	de b7       	in	r29, 0x3e	; 62
    if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    4d84:	e0 91 0c 08 	lds	r30, 0x080C
    4d88:	f0 91 0d 08 	lds	r31, 0x080D
    4d8c:	80 81       	ld	r24, Z
    4d8e:	88 23       	and	r24, r24
    4d90:	39 f4       	brne	.+14     	; 0x4da0 <prvResetNextTaskUnblockTime+0x24>
    {
        /* The new current delayed list is empty.  Set xNextTaskUnblockTime to
         * the maximum possible value so it is  extremely unlikely that the
         * if( xTickCount >= xNextTaskUnblockTime ) test will pass until
         * there is an item in the delayed list. */
        xNextTaskUnblockTime = portMAX_DELAY;
    4d92:	8f ef       	ldi	r24, 0xFF	; 255
    4d94:	9f ef       	ldi	r25, 0xFF	; 255
    4d96:	90 93 d2 07 	sts	0x07D2, r25
    4d9a:	80 93 d1 07 	sts	0x07D1, r24
    4d9e:	0d c0       	rjmp	.+26     	; 0x4dba <prvResetNextTaskUnblockTime+0x3e>
    {
        /* The new current delayed list is not empty, get the value of
         * the item at the head of the delayed list.  This is the time at
         * which the task at the head of the delayed list should be removed
         * from the Blocked state. */
        xNextTaskUnblockTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxDelayedTaskList );
    4da0:	e0 91 0c 08 	lds	r30, 0x080C
    4da4:	f0 91 0d 08 	lds	r31, 0x080D
    4da8:	05 80       	ldd	r0, Z+5	; 0x05
    4daa:	f6 81       	ldd	r31, Z+6	; 0x06
    4dac:	e0 2d       	mov	r30, r0
    4dae:	80 81       	ld	r24, Z
    4db0:	91 81       	ldd	r25, Z+1	; 0x01
    4db2:	90 93 d2 07 	sts	0x07D2, r25
    4db6:	80 93 d1 07 	sts	0x07D1, r24
    }
}
    4dba:	cf 91       	pop	r28
    4dbc:	df 91       	pop	r29
    4dbe:	08 95       	ret

00004dc0 <xTaskGetSchedulerState>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )

    BaseType_t xTaskGetSchedulerState( void )
    {
    4dc0:	df 93       	push	r29
    4dc2:	cf 93       	push	r28
    4dc4:	0f 92       	push	r0
    4dc6:	cd b7       	in	r28, 0x3d	; 61
    4dc8:	de b7       	in	r29, 0x3e	; 62
        BaseType_t xReturn;

        if( xSchedulerRunning == pdFALSE )
    4dca:	80 91 cb 07 	lds	r24, 0x07CB
    4dce:	88 23       	and	r24, r24
    4dd0:	19 f4       	brne	.+6      	; 0x4dd8 <xTaskGetSchedulerState+0x18>
        {
            xReturn = taskSCHEDULER_NOT_STARTED;
    4dd2:	81 e0       	ldi	r24, 0x01	; 1
    4dd4:	89 83       	std	Y+1, r24	; 0x01
    4dd6:	08 c0       	rjmp	.+16     	; 0x4de8 <xTaskGetSchedulerState+0x28>
        }
        else
        {
            if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    4dd8:	80 91 d5 07 	lds	r24, 0x07D5
    4ddc:	88 23       	and	r24, r24
    4dde:	19 f4       	brne	.+6      	; 0x4de6 <xTaskGetSchedulerState+0x26>
            {
                xReturn = taskSCHEDULER_RUNNING;
    4de0:	82 e0       	ldi	r24, 0x02	; 2
    4de2:	89 83       	std	Y+1, r24	; 0x01
    4de4:	01 c0       	rjmp	.+2      	; 0x4de8 <xTaskGetSchedulerState+0x28>
            }
            else
            {
                xReturn = taskSCHEDULER_SUSPENDED;
    4de6:	19 82       	std	Y+1, r1	; 0x01
            }
        }

        return xReturn;
    4de8:	89 81       	ldd	r24, Y+1	; 0x01
    }
    4dea:	0f 90       	pop	r0
    4dec:	cf 91       	pop	r28
    4dee:	df 91       	pop	r29
    4df0:	08 95       	ret

00004df2 <uxTaskResetEventItemValue>:

#endif /* ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

TickType_t uxTaskResetEventItemValue( void )
{
    4df2:	df 93       	push	r29
    4df4:	cf 93       	push	r28
    4df6:	00 d0       	rcall	.+0      	; 0x4df8 <uxTaskResetEventItemValue+0x6>
    4df8:	cd b7       	in	r28, 0x3d	; 61
    4dfa:	de b7       	in	r29, 0x3e	; 62
    TickType_t uxReturn;

    uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
    4dfc:	e0 91 c4 07 	lds	r30, 0x07C4
    4e00:	f0 91 c5 07 	lds	r31, 0x07C5
    4e04:	84 85       	ldd	r24, Z+12	; 0x0c
    4e06:	95 85       	ldd	r25, Z+13	; 0x0d
    4e08:	9a 83       	std	Y+2, r25	; 0x02
    4e0a:	89 83       	std	Y+1, r24	; 0x01

    /* Reset the event list item to its normal value - so it can be used with
     * queues and semaphores. */
    listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    4e0c:	a0 91 c4 07 	lds	r26, 0x07C4
    4e10:	b0 91 c5 07 	lds	r27, 0x07C5
    4e14:	e0 91 c4 07 	lds	r30, 0x07C4
    4e18:	f0 91 c5 07 	lds	r31, 0x07C5
    4e1c:	86 89       	ldd	r24, Z+22	; 0x16
    4e1e:	28 2f       	mov	r18, r24
    4e20:	30 e0       	ldi	r19, 0x00	; 0
    4e22:	84 e0       	ldi	r24, 0x04	; 4
    4e24:	90 e0       	ldi	r25, 0x00	; 0
    4e26:	82 1b       	sub	r24, r18
    4e28:	93 0b       	sbc	r25, r19
    4e2a:	1d 96       	adiw	r26, 0x0d	; 13
    4e2c:	9c 93       	st	X, r25
    4e2e:	8e 93       	st	-X, r24
    4e30:	1c 97       	sbiw	r26, 0x0c	; 12

    return uxReturn;
    4e32:	89 81       	ldd	r24, Y+1	; 0x01
    4e34:	9a 81       	ldd	r25, Y+2	; 0x02
}
    4e36:	0f 90       	pop	r0
    4e38:	0f 90       	pop	r0
    4e3a:	cf 91       	pop	r28
    4e3c:	df 91       	pop	r29
    4e3e:	08 95       	ret

00004e40 <ulTaskGenericNotifyTake>:
#if ( configUSE_TASK_NOTIFICATIONS == 1 )

    uint32_t ulTaskGenericNotifyTake( UBaseType_t uxIndexToWait,
                                      BaseType_t xClearCountOnExit,
                                      TickType_t xTicksToWait )
    {
    4e40:	df 93       	push	r29
    4e42:	cf 93       	push	r28
    4e44:	cd b7       	in	r28, 0x3d	; 61
    4e46:	de b7       	in	r29, 0x3e	; 62
    4e48:	28 97       	sbiw	r28, 0x08	; 8
    4e4a:	0f b6       	in	r0, 0x3f	; 63
    4e4c:	f8 94       	cli
    4e4e:	de bf       	out	0x3e, r29	; 62
    4e50:	0f be       	out	0x3f, r0	; 63
    4e52:	cd bf       	out	0x3d, r28	; 61
    4e54:	8d 83       	std	Y+5, r24	; 0x05
    4e56:	6e 83       	std	Y+6, r22	; 0x06
    4e58:	58 87       	std	Y+8, r21	; 0x08
    4e5a:	4f 83       	std	Y+7, r20	; 0x07
        uint32_t ulReturn;

        configASSERT( uxIndexToWait < configTASK_NOTIFICATION_ARRAY_ENTRIES );

        taskENTER_CRITICAL();
    4e5c:	0f b6       	in	r0, 0x3f	; 63
    4e5e:	f8 94       	cli
    4e60:	0f 92       	push	r0
        {
            /* Only block if the notification count is not already non-zero. */
            if( pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] == 0UL )
    4e62:	20 91 c4 07 	lds	r18, 0x07C4
    4e66:	30 91 c5 07 	lds	r19, 0x07C5
    4e6a:	8d 81       	ldd	r24, Y+5	; 0x05
    4e6c:	88 2f       	mov	r24, r24
    4e6e:	90 e0       	ldi	r25, 0x00	; 0
    4e70:	88 0f       	add	r24, r24
    4e72:	99 1f       	adc	r25, r25
    4e74:	88 0f       	add	r24, r24
    4e76:	99 1f       	adc	r25, r25
    4e78:	82 0f       	add	r24, r18
    4e7a:	93 1f       	adc	r25, r19
    4e7c:	fc 01       	movw	r30, r24
    4e7e:	b1 96       	adiw	r30, 0x21	; 33
    4e80:	80 81       	ld	r24, Z
    4e82:	91 81       	ldd	r25, Z+1	; 0x01
    4e84:	a2 81       	ldd	r26, Z+2	; 0x02
    4e86:	b3 81       	ldd	r27, Z+3	; 0x03
    4e88:	00 97       	sbiw	r24, 0x00	; 0
    4e8a:	a1 05       	cpc	r26, r1
    4e8c:	b1 05       	cpc	r27, r1
    4e8e:	c1 f4       	brne	.+48     	; 0x4ec0 <ulTaskGenericNotifyTake+0x80>
            {
                /* Mark this task as waiting for a notification. */
                pxCurrentTCB->ucNotifyState[ uxIndexToWait ] = taskWAITING_NOTIFICATION;
    4e90:	20 91 c4 07 	lds	r18, 0x07C4
    4e94:	30 91 c5 07 	lds	r19, 0x07C5
    4e98:	8d 81       	ldd	r24, Y+5	; 0x05
    4e9a:	88 2f       	mov	r24, r24
    4e9c:	90 e0       	ldi	r25, 0x00	; 0
    4e9e:	82 0f       	add	r24, r18
    4ea0:	93 1f       	adc	r25, r19
    4ea2:	fc 01       	movw	r30, r24
    4ea4:	b5 96       	adiw	r30, 0x25	; 37
    4ea6:	81 e0       	ldi	r24, 0x01	; 1
    4ea8:	80 83       	st	Z, r24

                if( xTicksToWait > ( TickType_t ) 0 )
    4eaa:	8f 81       	ldd	r24, Y+7	; 0x07
    4eac:	98 85       	ldd	r25, Y+8	; 0x08
    4eae:	00 97       	sbiw	r24, 0x00	; 0
    4eb0:	39 f0       	breq	.+14     	; 0x4ec0 <ulTaskGenericNotifyTake+0x80>
                {
                    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    4eb2:	8f 81       	ldd	r24, Y+7	; 0x07
    4eb4:	98 85       	ldd	r25, Y+8	; 0x08
    4eb6:	61 e0       	ldi	r22, 0x01	; 1
    4eb8:	0e 94 a5 2e 	call	0x5d4a	; 0x5d4a <prvAddCurrentTaskToDelayedList>

                    /* All ports are written to allow a yield in a critical
                     * section (some will yield immediately, others wait until the
                     * critical section exits) - but it is not something that
                     * application code should ever do. */
                    portYIELD_WITHIN_API();
    4ebc:	0e 94 56 09 	call	0x12ac	; 0x12ac <vPortYield>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        taskEXIT_CRITICAL();
    4ec0:	0f 90       	pop	r0
    4ec2:	0f be       	out	0x3f, r0	; 63

        taskENTER_CRITICAL();
    4ec4:	0f b6       	in	r0, 0x3f	; 63
    4ec6:	f8 94       	cli
    4ec8:	0f 92       	push	r0
        {
            traceTASK_NOTIFY_TAKE( uxIndexToWait );
            ulReturn = pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ];
    4eca:	20 91 c4 07 	lds	r18, 0x07C4
    4ece:	30 91 c5 07 	lds	r19, 0x07C5
    4ed2:	8d 81       	ldd	r24, Y+5	; 0x05
    4ed4:	88 2f       	mov	r24, r24
    4ed6:	90 e0       	ldi	r25, 0x00	; 0
    4ed8:	88 0f       	add	r24, r24
    4eda:	99 1f       	adc	r25, r25
    4edc:	88 0f       	add	r24, r24
    4ede:	99 1f       	adc	r25, r25
    4ee0:	82 0f       	add	r24, r18
    4ee2:	93 1f       	adc	r25, r19
    4ee4:	fc 01       	movw	r30, r24
    4ee6:	b1 96       	adiw	r30, 0x21	; 33
    4ee8:	80 81       	ld	r24, Z
    4eea:	91 81       	ldd	r25, Z+1	; 0x01
    4eec:	a2 81       	ldd	r26, Z+2	; 0x02
    4eee:	b3 81       	ldd	r27, Z+3	; 0x03
    4ef0:	89 83       	std	Y+1, r24	; 0x01
    4ef2:	9a 83       	std	Y+2, r25	; 0x02
    4ef4:	ab 83       	std	Y+3, r26	; 0x03
    4ef6:	bc 83       	std	Y+4, r27	; 0x04

            if( ulReturn != 0UL )
    4ef8:	89 81       	ldd	r24, Y+1	; 0x01
    4efa:	9a 81       	ldd	r25, Y+2	; 0x02
    4efc:	ab 81       	ldd	r26, Y+3	; 0x03
    4efe:	bc 81       	ldd	r27, Y+4	; 0x04
    4f00:	00 97       	sbiw	r24, 0x00	; 0
    4f02:	a1 05       	cpc	r26, r1
    4f04:	b1 05       	cpc	r27, r1
    4f06:	a9 f1       	breq	.+106    	; 0x4f72 <ulTaskGenericNotifyTake+0x132>
            {
                if( xClearCountOnExit != pdFALSE )
    4f08:	8e 81       	ldd	r24, Y+6	; 0x06
    4f0a:	88 23       	and	r24, r24
    4f0c:	a1 f0       	breq	.+40     	; 0x4f36 <ulTaskGenericNotifyTake+0xf6>
                {
                    pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] = 0UL;
    4f0e:	20 91 c4 07 	lds	r18, 0x07C4
    4f12:	30 91 c5 07 	lds	r19, 0x07C5
    4f16:	8d 81       	ldd	r24, Y+5	; 0x05
    4f18:	88 2f       	mov	r24, r24
    4f1a:	90 e0       	ldi	r25, 0x00	; 0
    4f1c:	88 0f       	add	r24, r24
    4f1e:	99 1f       	adc	r25, r25
    4f20:	88 0f       	add	r24, r24
    4f22:	99 1f       	adc	r25, r25
    4f24:	82 0f       	add	r24, r18
    4f26:	93 1f       	adc	r25, r19
    4f28:	fc 01       	movw	r30, r24
    4f2a:	b1 96       	adiw	r30, 0x21	; 33
    4f2c:	10 82       	st	Z, r1
    4f2e:	11 82       	std	Z+1, r1	; 0x01
    4f30:	12 82       	std	Z+2, r1	; 0x02
    4f32:	13 82       	std	Z+3, r1	; 0x03
    4f34:	1e c0       	rjmp	.+60     	; 0x4f72 <ulTaskGenericNotifyTake+0x132>
                }
                else
                {
                    pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] = ulReturn - ( uint32_t ) 1;
    4f36:	e0 91 c4 07 	lds	r30, 0x07C4
    4f3a:	f0 91 c5 07 	lds	r31, 0x07C5
    4f3e:	8d 81       	ldd	r24, Y+5	; 0x05
    4f40:	68 2f       	mov	r22, r24
    4f42:	70 e0       	ldi	r23, 0x00	; 0
    4f44:	89 81       	ldd	r24, Y+1	; 0x01
    4f46:	9a 81       	ldd	r25, Y+2	; 0x02
    4f48:	ab 81       	ldd	r26, Y+3	; 0x03
    4f4a:	bc 81       	ldd	r27, Y+4	; 0x04
    4f4c:	9c 01       	movw	r18, r24
    4f4e:	ad 01       	movw	r20, r26
    4f50:	21 50       	subi	r18, 0x01	; 1
    4f52:	30 40       	sbci	r19, 0x00	; 0
    4f54:	40 40       	sbci	r20, 0x00	; 0
    4f56:	50 40       	sbci	r21, 0x00	; 0
    4f58:	cb 01       	movw	r24, r22
    4f5a:	88 0f       	add	r24, r24
    4f5c:	99 1f       	adc	r25, r25
    4f5e:	88 0f       	add	r24, r24
    4f60:	99 1f       	adc	r25, r25
    4f62:	8e 0f       	add	r24, r30
    4f64:	9f 1f       	adc	r25, r31
    4f66:	fc 01       	movw	r30, r24
    4f68:	b1 96       	adiw	r30, 0x21	; 33
    4f6a:	20 83       	st	Z, r18
    4f6c:	31 83       	std	Z+1, r19	; 0x01
    4f6e:	42 83       	std	Z+2, r20	; 0x02
    4f70:	53 83       	std	Z+3, r21	; 0x03
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }

            pxCurrentTCB->ucNotifyState[ uxIndexToWait ] = taskNOT_WAITING_NOTIFICATION;
    4f72:	20 91 c4 07 	lds	r18, 0x07C4
    4f76:	30 91 c5 07 	lds	r19, 0x07C5
    4f7a:	8d 81       	ldd	r24, Y+5	; 0x05
    4f7c:	88 2f       	mov	r24, r24
    4f7e:	90 e0       	ldi	r25, 0x00	; 0
    4f80:	82 0f       	add	r24, r18
    4f82:	93 1f       	adc	r25, r19
    4f84:	fc 01       	movw	r30, r24
    4f86:	b5 96       	adiw	r30, 0x25	; 37
    4f88:	10 82       	st	Z, r1
        }
        taskEXIT_CRITICAL();
    4f8a:	0f 90       	pop	r0
    4f8c:	0f be       	out	0x3f, r0	; 63

        return ulReturn;
    4f8e:	89 81       	ldd	r24, Y+1	; 0x01
    4f90:	9a 81       	ldd	r25, Y+2	; 0x02
    4f92:	ab 81       	ldd	r26, Y+3	; 0x03
    4f94:	bc 81       	ldd	r27, Y+4	; 0x04
    }
    4f96:	bc 01       	movw	r22, r24
    4f98:	cd 01       	movw	r24, r26
    4f9a:	28 96       	adiw	r28, 0x08	; 8
    4f9c:	0f b6       	in	r0, 0x3f	; 63
    4f9e:	f8 94       	cli
    4fa0:	de bf       	out	0x3e, r29	; 62
    4fa2:	0f be       	out	0x3f, r0	; 63
    4fa4:	cd bf       	out	0x3d, r28	; 61
    4fa6:	cf 91       	pop	r28
    4fa8:	df 91       	pop	r29
    4faa:	08 95       	ret

00004fac <xTaskGenericNotifyWait>:
    BaseType_t xTaskGenericNotifyWait( UBaseType_t uxIndexToWait,
                                       uint32_t ulBitsToClearOnEntry,
                                       uint32_t ulBitsToClearOnExit,
                                       uint32_t * pulNotificationValue,
                                       TickType_t xTicksToWait )
    {
    4fac:	cf 92       	push	r12
    4fae:	df 92       	push	r13
    4fb0:	ef 92       	push	r14
    4fb2:	ff 92       	push	r15
    4fb4:	0f 93       	push	r16
    4fb6:	1f 93       	push	r17
    4fb8:	df 93       	push	r29
    4fba:	cf 93       	push	r28
    4fbc:	cd b7       	in	r28, 0x3d	; 61
    4fbe:	de b7       	in	r29, 0x3e	; 62
    4fc0:	2e 97       	sbiw	r28, 0x0e	; 14
    4fc2:	0f b6       	in	r0, 0x3f	; 63
    4fc4:	f8 94       	cli
    4fc6:	de bf       	out	0x3e, r29	; 62
    4fc8:	0f be       	out	0x3f, r0	; 63
    4fca:	cd bf       	out	0x3d, r28	; 61
    4fcc:	8a 83       	std	Y+2, r24	; 0x02
    4fce:	4b 83       	std	Y+3, r20	; 0x03
    4fd0:	5c 83       	std	Y+4, r21	; 0x04
    4fd2:	6d 83       	std	Y+5, r22	; 0x05
    4fd4:	7e 83       	std	Y+6, r23	; 0x06
    4fd6:	0f 83       	std	Y+7, r16	; 0x07
    4fd8:	18 87       	std	Y+8, r17	; 0x08
    4fda:	29 87       	std	Y+9, r18	; 0x09
    4fdc:	3a 87       	std	Y+10, r19	; 0x0a
    4fde:	fc 86       	std	Y+12, r15	; 0x0c
    4fe0:	eb 86       	std	Y+11, r14	; 0x0b
    4fe2:	de 86       	std	Y+14, r13	; 0x0e
    4fe4:	cd 86       	std	Y+13, r12	; 0x0d
        BaseType_t xReturn;

        configASSERT( uxIndexToWait < configTASK_NOTIFICATION_ARRAY_ENTRIES );

        taskENTER_CRITICAL();
    4fe6:	0f b6       	in	r0, 0x3f	; 63
    4fe8:	f8 94       	cli
    4fea:	0f 92       	push	r0
        {
            /* Only block if a notification is not already pending. */
            if( pxCurrentTCB->ucNotifyState[ uxIndexToWait ] != taskNOTIFICATION_RECEIVED )
    4fec:	20 91 c4 07 	lds	r18, 0x07C4
    4ff0:	30 91 c5 07 	lds	r19, 0x07C5
    4ff4:	8a 81       	ldd	r24, Y+2	; 0x02
    4ff6:	88 2f       	mov	r24, r24
    4ff8:	90 e0       	ldi	r25, 0x00	; 0
    4ffa:	82 0f       	add	r24, r18
    4ffc:	93 1f       	adc	r25, r19
    4ffe:	fc 01       	movw	r30, r24
    5000:	b5 96       	adiw	r30, 0x25	; 37
    5002:	80 81       	ld	r24, Z
    5004:	82 30       	cpi	r24, 0x02	; 2
    5006:	09 f4       	brne	.+2      	; 0x500a <xTaskGenericNotifyWait+0x5e>
    5008:	47 c0       	rjmp	.+142    	; 0x5098 <xTaskGenericNotifyWait+0xec>
            {
                /* Clear bits in the task's notification value as bits may get
                 * set  by the notifying task or interrupt.  This can be used to
                 * clear the value to zero. */
                pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] &= ~ulBitsToClearOnEntry;
    500a:	60 91 c4 07 	lds	r22, 0x07C4
    500e:	70 91 c5 07 	lds	r23, 0x07C5
    5012:	8a 81       	ldd	r24, Y+2	; 0x02
    5014:	08 2f       	mov	r16, r24
    5016:	10 e0       	ldi	r17, 0x00	; 0
    5018:	8a 81       	ldd	r24, Y+2	; 0x02
    501a:	88 2f       	mov	r24, r24
    501c:	90 e0       	ldi	r25, 0x00	; 0
    501e:	88 0f       	add	r24, r24
    5020:	99 1f       	adc	r25, r25
    5022:	88 0f       	add	r24, r24
    5024:	99 1f       	adc	r25, r25
    5026:	86 0f       	add	r24, r22
    5028:	97 1f       	adc	r25, r23
    502a:	fc 01       	movw	r30, r24
    502c:	b1 96       	adiw	r30, 0x21	; 33
    502e:	20 81       	ld	r18, Z
    5030:	31 81       	ldd	r19, Z+1	; 0x01
    5032:	42 81       	ldd	r20, Z+2	; 0x02
    5034:	53 81       	ldd	r21, Z+3	; 0x03
    5036:	8b 81       	ldd	r24, Y+3	; 0x03
    5038:	9c 81       	ldd	r25, Y+4	; 0x04
    503a:	ad 81       	ldd	r26, Y+5	; 0x05
    503c:	be 81       	ldd	r27, Y+6	; 0x06
    503e:	80 95       	com	r24
    5040:	90 95       	com	r25
    5042:	a0 95       	com	r26
    5044:	b0 95       	com	r27
    5046:	28 23       	and	r18, r24
    5048:	39 23       	and	r19, r25
    504a:	4a 23       	and	r20, r26
    504c:	5b 23       	and	r21, r27
    504e:	c8 01       	movw	r24, r16
    5050:	88 0f       	add	r24, r24
    5052:	99 1f       	adc	r25, r25
    5054:	88 0f       	add	r24, r24
    5056:	99 1f       	adc	r25, r25
    5058:	86 0f       	add	r24, r22
    505a:	97 1f       	adc	r25, r23
    505c:	fc 01       	movw	r30, r24
    505e:	b1 96       	adiw	r30, 0x21	; 33
    5060:	20 83       	st	Z, r18
    5062:	31 83       	std	Z+1, r19	; 0x01
    5064:	42 83       	std	Z+2, r20	; 0x02
    5066:	53 83       	std	Z+3, r21	; 0x03

                /* Mark this task as waiting for a notification. */
                pxCurrentTCB->ucNotifyState[ uxIndexToWait ] = taskWAITING_NOTIFICATION;
    5068:	20 91 c4 07 	lds	r18, 0x07C4
    506c:	30 91 c5 07 	lds	r19, 0x07C5
    5070:	8a 81       	ldd	r24, Y+2	; 0x02
    5072:	88 2f       	mov	r24, r24
    5074:	90 e0       	ldi	r25, 0x00	; 0
    5076:	82 0f       	add	r24, r18
    5078:	93 1f       	adc	r25, r19
    507a:	fc 01       	movw	r30, r24
    507c:	b5 96       	adiw	r30, 0x25	; 37
    507e:	81 e0       	ldi	r24, 0x01	; 1
    5080:	80 83       	st	Z, r24

                if( xTicksToWait > ( TickType_t ) 0 )
    5082:	8d 85       	ldd	r24, Y+13	; 0x0d
    5084:	9e 85       	ldd	r25, Y+14	; 0x0e
    5086:	00 97       	sbiw	r24, 0x00	; 0
    5088:	39 f0       	breq	.+14     	; 0x5098 <xTaskGenericNotifyWait+0xec>
                {
                    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    508a:	8d 85       	ldd	r24, Y+13	; 0x0d
    508c:	9e 85       	ldd	r25, Y+14	; 0x0e
    508e:	61 e0       	ldi	r22, 0x01	; 1
    5090:	0e 94 a5 2e 	call	0x5d4a	; 0x5d4a <prvAddCurrentTaskToDelayedList>

                    /* All ports are written to allow a yield in a critical
                     * section (some will yield immediately, others wait until the
                     * critical section exits) - but it is not something that
                     * application code should ever do. */
                    portYIELD_WITHIN_API();
    5094:	0e 94 56 09 	call	0x12ac	; 0x12ac <vPortYield>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        taskEXIT_CRITICAL();
    5098:	0f 90       	pop	r0
    509a:	0f be       	out	0x3f, r0	; 63

        taskENTER_CRITICAL();
    509c:	0f b6       	in	r0, 0x3f	; 63
    509e:	f8 94       	cli
    50a0:	0f 92       	push	r0
        {
            traceTASK_NOTIFY_WAIT( uxIndexToWait );

            if( pulNotificationValue != NULL )
    50a2:	8b 85       	ldd	r24, Y+11	; 0x0b
    50a4:	9c 85       	ldd	r25, Y+12	; 0x0c
    50a6:	00 97       	sbiw	r24, 0x00	; 0
    50a8:	c9 f0       	breq	.+50     	; 0x50dc <xTaskGenericNotifyWait+0x130>
            {
                /* Output the current notification value, which may or may not
                 * have changed. */
                *pulNotificationValue = pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ];
    50aa:	20 91 c4 07 	lds	r18, 0x07C4
    50ae:	30 91 c5 07 	lds	r19, 0x07C5
    50b2:	8a 81       	ldd	r24, Y+2	; 0x02
    50b4:	88 2f       	mov	r24, r24
    50b6:	90 e0       	ldi	r25, 0x00	; 0
    50b8:	88 0f       	add	r24, r24
    50ba:	99 1f       	adc	r25, r25
    50bc:	88 0f       	add	r24, r24
    50be:	99 1f       	adc	r25, r25
    50c0:	82 0f       	add	r24, r18
    50c2:	93 1f       	adc	r25, r19
    50c4:	fc 01       	movw	r30, r24
    50c6:	b1 96       	adiw	r30, 0x21	; 33
    50c8:	80 81       	ld	r24, Z
    50ca:	91 81       	ldd	r25, Z+1	; 0x01
    50cc:	a2 81       	ldd	r26, Z+2	; 0x02
    50ce:	b3 81       	ldd	r27, Z+3	; 0x03
    50d0:	eb 85       	ldd	r30, Y+11	; 0x0b
    50d2:	fc 85       	ldd	r31, Y+12	; 0x0c
    50d4:	80 83       	st	Z, r24
    50d6:	91 83       	std	Z+1, r25	; 0x01
    50d8:	a2 83       	std	Z+2, r26	; 0x02
    50da:	b3 83       	std	Z+3, r27	; 0x03

            /* If ucNotifyValue is set then either the task never entered the
             * blocked state (because a notification was already pending) or the
             * task unblocked because of a notification.  Otherwise the task
             * unblocked because of a timeout. */
            if( pxCurrentTCB->ucNotifyState[ uxIndexToWait ] != taskNOTIFICATION_RECEIVED )
    50dc:	20 91 c4 07 	lds	r18, 0x07C4
    50e0:	30 91 c5 07 	lds	r19, 0x07C5
    50e4:	8a 81       	ldd	r24, Y+2	; 0x02
    50e6:	88 2f       	mov	r24, r24
    50e8:	90 e0       	ldi	r25, 0x00	; 0
    50ea:	82 0f       	add	r24, r18
    50ec:	93 1f       	adc	r25, r19
    50ee:	fc 01       	movw	r30, r24
    50f0:	b5 96       	adiw	r30, 0x25	; 37
    50f2:	80 81       	ld	r24, Z
    50f4:	82 30       	cpi	r24, 0x02	; 2
    50f6:	11 f0       	breq	.+4      	; 0x50fc <xTaskGenericNotifyWait+0x150>
            {
                /* A notification was not received. */
                xReturn = pdFALSE;
    50f8:	19 82       	std	Y+1, r1	; 0x01
    50fa:	31 c0       	rjmp	.+98     	; 0x515e <xTaskGenericNotifyWait+0x1b2>
            }
            else
            {
                /* A notification was already pending or a notification was
                 * received while the task was waiting. */
                pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] &= ~ulBitsToClearOnExit;
    50fc:	60 91 c4 07 	lds	r22, 0x07C4
    5100:	70 91 c5 07 	lds	r23, 0x07C5
    5104:	8a 81       	ldd	r24, Y+2	; 0x02
    5106:	08 2f       	mov	r16, r24
    5108:	10 e0       	ldi	r17, 0x00	; 0
    510a:	8a 81       	ldd	r24, Y+2	; 0x02
    510c:	88 2f       	mov	r24, r24
    510e:	90 e0       	ldi	r25, 0x00	; 0
    5110:	88 0f       	add	r24, r24
    5112:	99 1f       	adc	r25, r25
    5114:	88 0f       	add	r24, r24
    5116:	99 1f       	adc	r25, r25
    5118:	86 0f       	add	r24, r22
    511a:	97 1f       	adc	r25, r23
    511c:	fc 01       	movw	r30, r24
    511e:	b1 96       	adiw	r30, 0x21	; 33
    5120:	20 81       	ld	r18, Z
    5122:	31 81       	ldd	r19, Z+1	; 0x01
    5124:	42 81       	ldd	r20, Z+2	; 0x02
    5126:	53 81       	ldd	r21, Z+3	; 0x03
    5128:	8f 81       	ldd	r24, Y+7	; 0x07
    512a:	98 85       	ldd	r25, Y+8	; 0x08
    512c:	a9 85       	ldd	r26, Y+9	; 0x09
    512e:	ba 85       	ldd	r27, Y+10	; 0x0a
    5130:	80 95       	com	r24
    5132:	90 95       	com	r25
    5134:	a0 95       	com	r26
    5136:	b0 95       	com	r27
    5138:	28 23       	and	r18, r24
    513a:	39 23       	and	r19, r25
    513c:	4a 23       	and	r20, r26
    513e:	5b 23       	and	r21, r27
    5140:	c8 01       	movw	r24, r16
    5142:	88 0f       	add	r24, r24
    5144:	99 1f       	adc	r25, r25
    5146:	88 0f       	add	r24, r24
    5148:	99 1f       	adc	r25, r25
    514a:	86 0f       	add	r24, r22
    514c:	97 1f       	adc	r25, r23
    514e:	fc 01       	movw	r30, r24
    5150:	b1 96       	adiw	r30, 0x21	; 33
    5152:	20 83       	st	Z, r18
    5154:	31 83       	std	Z+1, r19	; 0x01
    5156:	42 83       	std	Z+2, r20	; 0x02
    5158:	53 83       	std	Z+3, r21	; 0x03
                xReturn = pdTRUE;
    515a:	81 e0       	ldi	r24, 0x01	; 1
    515c:	89 83       	std	Y+1, r24	; 0x01
            }

            pxCurrentTCB->ucNotifyState[ uxIndexToWait ] = taskNOT_WAITING_NOTIFICATION;
    515e:	20 91 c4 07 	lds	r18, 0x07C4
    5162:	30 91 c5 07 	lds	r19, 0x07C5
    5166:	8a 81       	ldd	r24, Y+2	; 0x02
    5168:	88 2f       	mov	r24, r24
    516a:	90 e0       	ldi	r25, 0x00	; 0
    516c:	82 0f       	add	r24, r18
    516e:	93 1f       	adc	r25, r19
    5170:	fc 01       	movw	r30, r24
    5172:	b5 96       	adiw	r30, 0x25	; 37
    5174:	10 82       	st	Z, r1
        }
        taskEXIT_CRITICAL();
    5176:	0f 90       	pop	r0
    5178:	0f be       	out	0x3f, r0	; 63

        return xReturn;
    517a:	89 81       	ldd	r24, Y+1	; 0x01
    }
    517c:	2e 96       	adiw	r28, 0x0e	; 14
    517e:	0f b6       	in	r0, 0x3f	; 63
    5180:	f8 94       	cli
    5182:	de bf       	out	0x3e, r29	; 62
    5184:	0f be       	out	0x3f, r0	; 63
    5186:	cd bf       	out	0x3d, r28	; 61
    5188:	cf 91       	pop	r28
    518a:	df 91       	pop	r29
    518c:	1f 91       	pop	r17
    518e:	0f 91       	pop	r16
    5190:	ff 90       	pop	r15
    5192:	ef 90       	pop	r14
    5194:	df 90       	pop	r13
    5196:	cf 90       	pop	r12
    5198:	08 95       	ret

0000519a <xTaskGenericNotify>:
    BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify,
                                   UBaseType_t uxIndexToNotify,
                                   uint32_t ulValue,
                                   eNotifyAction eAction,
                                   uint32_t * pulPreviousNotificationValue )
    {
    519a:	ef 92       	push	r14
    519c:	ff 92       	push	r15
    519e:	0f 93       	push	r16
    51a0:	1f 93       	push	r17
    51a2:	df 93       	push	r29
    51a4:	cf 93       	push	r28
    51a6:	cd b7       	in	r28, 0x3d	; 61
    51a8:	de b7       	in	r29, 0x3e	; 62
    51aa:	64 97       	sbiw	r28, 0x14	; 20
    51ac:	0f b6       	in	r0, 0x3f	; 63
    51ae:	f8 94       	cli
    51b0:	de bf       	out	0x3e, r29	; 62
    51b2:	0f be       	out	0x3f, r0	; 63
    51b4:	cd bf       	out	0x3d, r28	; 61
    51b6:	9a 87       	std	Y+10, r25	; 0x0a
    51b8:	89 87       	std	Y+9, r24	; 0x09
    51ba:	6b 87       	std	Y+11, r22	; 0x0b
    51bc:	2c 87       	std	Y+12, r18	; 0x0c
    51be:	3d 87       	std	Y+13, r19	; 0x0d
    51c0:	4e 87       	std	Y+14, r20	; 0x0e
    51c2:	5f 87       	std	Y+15, r21	; 0x0f
    51c4:	08 8b       	std	Y+16, r16	; 0x10
    51c6:	fa 8a       	std	Y+18, r15	; 0x12
    51c8:	e9 8a       	std	Y+17, r14	; 0x11
        TCB_t * pxTCB;
        BaseType_t xReturn = pdPASS;
    51ca:	81 e0       	ldi	r24, 0x01	; 1
    51cc:	8e 83       	std	Y+6, r24	; 0x06
        uint8_t ucOriginalNotifyState;

        configASSERT( uxIndexToNotify < configTASK_NOTIFICATION_ARRAY_ENTRIES );
        configASSERT( xTaskToNotify );
        pxTCB = xTaskToNotify;
    51ce:	89 85       	ldd	r24, Y+9	; 0x09
    51d0:	9a 85       	ldd	r25, Y+10	; 0x0a
    51d2:	98 87       	std	Y+8, r25	; 0x08
    51d4:	8f 83       	std	Y+7, r24	; 0x07

        taskENTER_CRITICAL();
    51d6:	0f b6       	in	r0, 0x3f	; 63
    51d8:	f8 94       	cli
    51da:	0f 92       	push	r0
        {
            if( pulPreviousNotificationValue != NULL )
    51dc:	89 89       	ldd	r24, Y+17	; 0x11
    51de:	9a 89       	ldd	r25, Y+18	; 0x12
    51e0:	00 97       	sbiw	r24, 0x00	; 0
    51e2:	b9 f0       	breq	.+46     	; 0x5212 <xTaskGenericNotify+0x78>
            {
                *pulPreviousNotificationValue = pxTCB->ulNotifiedValue[ uxIndexToNotify ];
    51e4:	8b 85       	ldd	r24, Y+11	; 0x0b
    51e6:	88 2f       	mov	r24, r24
    51e8:	90 e0       	ldi	r25, 0x00	; 0
    51ea:	2f 81       	ldd	r18, Y+7	; 0x07
    51ec:	38 85       	ldd	r19, Y+8	; 0x08
    51ee:	88 0f       	add	r24, r24
    51f0:	99 1f       	adc	r25, r25
    51f2:	88 0f       	add	r24, r24
    51f4:	99 1f       	adc	r25, r25
    51f6:	82 0f       	add	r24, r18
    51f8:	93 1f       	adc	r25, r19
    51fa:	fc 01       	movw	r30, r24
    51fc:	b1 96       	adiw	r30, 0x21	; 33
    51fe:	80 81       	ld	r24, Z
    5200:	91 81       	ldd	r25, Z+1	; 0x01
    5202:	a2 81       	ldd	r26, Z+2	; 0x02
    5204:	b3 81       	ldd	r27, Z+3	; 0x03
    5206:	e9 89       	ldd	r30, Y+17	; 0x11
    5208:	fa 89       	ldd	r31, Y+18	; 0x12
    520a:	80 83       	st	Z, r24
    520c:	91 83       	std	Z+1, r25	; 0x01
    520e:	a2 83       	std	Z+2, r26	; 0x02
    5210:	b3 83       	std	Z+3, r27	; 0x03
            }

            ucOriginalNotifyState = pxTCB->ucNotifyState[ uxIndexToNotify ];
    5212:	8b 85       	ldd	r24, Y+11	; 0x0b
    5214:	28 2f       	mov	r18, r24
    5216:	30 e0       	ldi	r19, 0x00	; 0
    5218:	8f 81       	ldd	r24, Y+7	; 0x07
    521a:	98 85       	ldd	r25, Y+8	; 0x08
    521c:	82 0f       	add	r24, r18
    521e:	93 1f       	adc	r25, r19
    5220:	fc 01       	movw	r30, r24
    5222:	b5 96       	adiw	r30, 0x25	; 37
    5224:	80 81       	ld	r24, Z
    5226:	8d 83       	std	Y+5, r24	; 0x05

            pxTCB->ucNotifyState[ uxIndexToNotify ] = taskNOTIFICATION_RECEIVED;
    5228:	8b 85       	ldd	r24, Y+11	; 0x0b
    522a:	28 2f       	mov	r18, r24
    522c:	30 e0       	ldi	r19, 0x00	; 0
    522e:	8f 81       	ldd	r24, Y+7	; 0x07
    5230:	98 85       	ldd	r25, Y+8	; 0x08
    5232:	82 0f       	add	r24, r18
    5234:	93 1f       	adc	r25, r19
    5236:	fc 01       	movw	r30, r24
    5238:	b5 96       	adiw	r30, 0x25	; 37
    523a:	82 e0       	ldi	r24, 0x02	; 2
    523c:	80 83       	st	Z, r24

            switch( eAction )
    523e:	88 89       	ldd	r24, Y+16	; 0x10
    5240:	28 2f       	mov	r18, r24
    5242:	30 e0       	ldi	r19, 0x00	; 0
    5244:	3c 8b       	std	Y+20, r19	; 0x14
    5246:	2b 8b       	std	Y+19, r18	; 0x13
    5248:	8b 89       	ldd	r24, Y+19	; 0x13
    524a:	9c 89       	ldd	r25, Y+20	; 0x14
    524c:	82 30       	cpi	r24, 0x02	; 2
    524e:	91 05       	cpc	r25, r1
    5250:	09 f4       	brne	.+2      	; 0x5254 <xTaskGenericNotify+0xba>
    5252:	46 c0       	rjmp	.+140    	; 0x52e0 <xTaskGenericNotify+0x146>
    5254:	2b 89       	ldd	r18, Y+19	; 0x13
    5256:	3c 89       	ldd	r19, Y+20	; 0x14
    5258:	23 30       	cpi	r18, 0x03	; 3
    525a:	31 05       	cpc	r19, r1
    525c:	34 f4       	brge	.+12     	; 0x526a <xTaskGenericNotify+0xd0>
    525e:	8b 89       	ldd	r24, Y+19	; 0x13
    5260:	9c 89       	ldd	r25, Y+20	; 0x14
    5262:	81 30       	cpi	r24, 0x01	; 1
    5264:	91 05       	cpc	r25, r1
    5266:	71 f0       	breq	.+28     	; 0x5284 <xTaskGenericNotify+0xea>
    5268:	93 c0       	rjmp	.+294    	; 0x5390 <xTaskGenericNotify+0x1f6>
    526a:	2b 89       	ldd	r18, Y+19	; 0x13
    526c:	3c 89       	ldd	r19, Y+20	; 0x14
    526e:	23 30       	cpi	r18, 0x03	; 3
    5270:	31 05       	cpc	r19, r1
    5272:	09 f4       	brne	.+2      	; 0x5276 <xTaskGenericNotify+0xdc>
    5274:	5d c0       	rjmp	.+186    	; 0x5330 <xTaskGenericNotify+0x196>
    5276:	8b 89       	ldd	r24, Y+19	; 0x13
    5278:	9c 89       	ldd	r25, Y+20	; 0x14
    527a:	84 30       	cpi	r24, 0x04	; 4
    527c:	91 05       	cpc	r25, r1
    527e:	09 f4       	brne	.+2      	; 0x5282 <xTaskGenericNotify+0xe8>
    5280:	6d c0       	rjmp	.+218    	; 0x535c <xTaskGenericNotify+0x1c2>
    5282:	86 c0       	rjmp	.+268    	; 0x5390 <xTaskGenericNotify+0x1f6>
            {
                case eSetBits:
                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] |= ulValue;
    5284:	8b 85       	ldd	r24, Y+11	; 0x0b
    5286:	08 2f       	mov	r16, r24
    5288:	10 e0       	ldi	r17, 0x00	; 0
    528a:	8b 85       	ldd	r24, Y+11	; 0x0b
    528c:	88 2f       	mov	r24, r24
    528e:	90 e0       	ldi	r25, 0x00	; 0
    5290:	2f 81       	ldd	r18, Y+7	; 0x07
    5292:	38 85       	ldd	r19, Y+8	; 0x08
    5294:	88 0f       	add	r24, r24
    5296:	99 1f       	adc	r25, r25
    5298:	88 0f       	add	r24, r24
    529a:	99 1f       	adc	r25, r25
    529c:	82 0f       	add	r24, r18
    529e:	93 1f       	adc	r25, r19
    52a0:	fc 01       	movw	r30, r24
    52a2:	b1 96       	adiw	r30, 0x21	; 33
    52a4:	20 81       	ld	r18, Z
    52a6:	31 81       	ldd	r19, Z+1	; 0x01
    52a8:	42 81       	ldd	r20, Z+2	; 0x02
    52aa:	53 81       	ldd	r21, Z+3	; 0x03
    52ac:	8c 85       	ldd	r24, Y+12	; 0x0c
    52ae:	9d 85       	ldd	r25, Y+13	; 0x0d
    52b0:	ae 85       	ldd	r26, Y+14	; 0x0e
    52b2:	bf 85       	ldd	r27, Y+15	; 0x0f
    52b4:	ba 01       	movw	r22, r20
    52b6:	a9 01       	movw	r20, r18
    52b8:	48 2b       	or	r20, r24
    52ba:	59 2b       	or	r21, r25
    52bc:	6a 2b       	or	r22, r26
    52be:	7b 2b       	or	r23, r27
    52c0:	2f 81       	ldd	r18, Y+7	; 0x07
    52c2:	38 85       	ldd	r19, Y+8	; 0x08
    52c4:	c8 01       	movw	r24, r16
    52c6:	88 0f       	add	r24, r24
    52c8:	99 1f       	adc	r25, r25
    52ca:	88 0f       	add	r24, r24
    52cc:	99 1f       	adc	r25, r25
    52ce:	82 0f       	add	r24, r18
    52d0:	93 1f       	adc	r25, r19
    52d2:	fc 01       	movw	r30, r24
    52d4:	b1 96       	adiw	r30, 0x21	; 33
    52d6:	40 83       	st	Z, r20
    52d8:	51 83       	std	Z+1, r21	; 0x01
    52da:	62 83       	std	Z+2, r22	; 0x02
    52dc:	73 83       	std	Z+3, r23	; 0x03
    52de:	58 c0       	rjmp	.+176    	; 0x5390 <xTaskGenericNotify+0x1f6>
                    break;

                case eIncrement:
                    ( pxTCB->ulNotifiedValue[ uxIndexToNotify ] )++;
    52e0:	8b 85       	ldd	r24, Y+11	; 0x0b
    52e2:	08 2f       	mov	r16, r24
    52e4:	10 e0       	ldi	r17, 0x00	; 0
    52e6:	2f 81       	ldd	r18, Y+7	; 0x07
    52e8:	38 85       	ldd	r19, Y+8	; 0x08
    52ea:	c8 01       	movw	r24, r16
    52ec:	88 0f       	add	r24, r24
    52ee:	99 1f       	adc	r25, r25
    52f0:	88 0f       	add	r24, r24
    52f2:	99 1f       	adc	r25, r25
    52f4:	82 0f       	add	r24, r18
    52f6:	93 1f       	adc	r25, r19
    52f8:	fc 01       	movw	r30, r24
    52fa:	b1 96       	adiw	r30, 0x21	; 33
    52fc:	80 81       	ld	r24, Z
    52fe:	91 81       	ldd	r25, Z+1	; 0x01
    5300:	a2 81       	ldd	r26, Z+2	; 0x02
    5302:	b3 81       	ldd	r27, Z+3	; 0x03
    5304:	ac 01       	movw	r20, r24
    5306:	bd 01       	movw	r22, r26
    5308:	4f 5f       	subi	r20, 0xFF	; 255
    530a:	5f 4f       	sbci	r21, 0xFF	; 255
    530c:	6f 4f       	sbci	r22, 0xFF	; 255
    530e:	7f 4f       	sbci	r23, 0xFF	; 255
    5310:	2f 81       	ldd	r18, Y+7	; 0x07
    5312:	38 85       	ldd	r19, Y+8	; 0x08
    5314:	c8 01       	movw	r24, r16
    5316:	88 0f       	add	r24, r24
    5318:	99 1f       	adc	r25, r25
    531a:	88 0f       	add	r24, r24
    531c:	99 1f       	adc	r25, r25
    531e:	82 0f       	add	r24, r18
    5320:	93 1f       	adc	r25, r19
    5322:	fc 01       	movw	r30, r24
    5324:	b1 96       	adiw	r30, 0x21	; 33
    5326:	40 83       	st	Z, r20
    5328:	51 83       	std	Z+1, r21	; 0x01
    532a:	62 83       	std	Z+2, r22	; 0x02
    532c:	73 83       	std	Z+3, r23	; 0x03
    532e:	30 c0       	rjmp	.+96     	; 0x5390 <xTaskGenericNotify+0x1f6>
                    break;

                case eSetValueWithOverwrite:
                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
    5330:	8b 85       	ldd	r24, Y+11	; 0x0b
    5332:	88 2f       	mov	r24, r24
    5334:	90 e0       	ldi	r25, 0x00	; 0
    5336:	2f 81       	ldd	r18, Y+7	; 0x07
    5338:	38 85       	ldd	r19, Y+8	; 0x08
    533a:	88 0f       	add	r24, r24
    533c:	99 1f       	adc	r25, r25
    533e:	88 0f       	add	r24, r24
    5340:	99 1f       	adc	r25, r25
    5342:	82 0f       	add	r24, r18
    5344:	93 1f       	adc	r25, r19
    5346:	fc 01       	movw	r30, r24
    5348:	b1 96       	adiw	r30, 0x21	; 33
    534a:	8c 85       	ldd	r24, Y+12	; 0x0c
    534c:	9d 85       	ldd	r25, Y+13	; 0x0d
    534e:	ae 85       	ldd	r26, Y+14	; 0x0e
    5350:	bf 85       	ldd	r27, Y+15	; 0x0f
    5352:	80 83       	st	Z, r24
    5354:	91 83       	std	Z+1, r25	; 0x01
    5356:	a2 83       	std	Z+2, r26	; 0x02
    5358:	b3 83       	std	Z+3, r27	; 0x03
    535a:	1a c0       	rjmp	.+52     	; 0x5390 <xTaskGenericNotify+0x1f6>
                    break;

                case eSetValueWithoutOverwrite:

                    if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    535c:	8d 81       	ldd	r24, Y+5	; 0x05
    535e:	82 30       	cpi	r24, 0x02	; 2
    5360:	b1 f0       	breq	.+44     	; 0x538e <xTaskGenericNotify+0x1f4>
                    {
                        pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
    5362:	8b 85       	ldd	r24, Y+11	; 0x0b
    5364:	88 2f       	mov	r24, r24
    5366:	90 e0       	ldi	r25, 0x00	; 0
    5368:	2f 81       	ldd	r18, Y+7	; 0x07
    536a:	38 85       	ldd	r19, Y+8	; 0x08
    536c:	88 0f       	add	r24, r24
    536e:	99 1f       	adc	r25, r25
    5370:	88 0f       	add	r24, r24
    5372:	99 1f       	adc	r25, r25
    5374:	82 0f       	add	r24, r18
    5376:	93 1f       	adc	r25, r19
    5378:	fc 01       	movw	r30, r24
    537a:	b1 96       	adiw	r30, 0x21	; 33
    537c:	8c 85       	ldd	r24, Y+12	; 0x0c
    537e:	9d 85       	ldd	r25, Y+13	; 0x0d
    5380:	ae 85       	ldd	r26, Y+14	; 0x0e
    5382:	bf 85       	ldd	r27, Y+15	; 0x0f
    5384:	80 83       	st	Z, r24
    5386:	91 83       	std	Z+1, r25	; 0x01
    5388:	a2 83       	std	Z+2, r26	; 0x02
    538a:	b3 83       	std	Z+3, r27	; 0x03
    538c:	01 c0       	rjmp	.+2      	; 0x5390 <xTaskGenericNotify+0x1f6>
                    }
                    else
                    {
                        /* The value could not be written to the task. */
                        xReturn = pdFAIL;
    538e:	1e 82       	std	Y+6, r1	; 0x06

            traceTASK_NOTIFY( uxIndexToNotify );

            /* If the task is in the blocked state specifically to wait for a
             * notification then unblock it now. */
            if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    5390:	8d 81       	ldd	r24, Y+5	; 0x05
    5392:	81 30       	cpi	r24, 0x01	; 1
    5394:	09 f0       	breq	.+2      	; 0x5398 <xTaskGenericNotify+0x1fe>
    5396:	af c0       	rjmp	.+350    	; 0x54f6 <xTaskGenericNotify+0x35c>
            {
                listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
    5398:	ef 81       	ldd	r30, Y+7	; 0x07
    539a:	f8 85       	ldd	r31, Y+8	; 0x08
    539c:	82 85       	ldd	r24, Z+10	; 0x0a
    539e:	93 85       	ldd	r25, Z+11	; 0x0b
    53a0:	9c 83       	std	Y+4, r25	; 0x04
    53a2:	8b 83       	std	Y+3, r24	; 0x03
    53a4:	ef 81       	ldd	r30, Y+7	; 0x07
    53a6:	f8 85       	ldd	r31, Y+8	; 0x08
    53a8:	a4 81       	ldd	r26, Z+4	; 0x04
    53aa:	b5 81       	ldd	r27, Z+5	; 0x05
    53ac:	ef 81       	ldd	r30, Y+7	; 0x07
    53ae:	f8 85       	ldd	r31, Y+8	; 0x08
    53b0:	86 81       	ldd	r24, Z+6	; 0x06
    53b2:	97 81       	ldd	r25, Z+7	; 0x07
    53b4:	15 96       	adiw	r26, 0x05	; 5
    53b6:	9c 93       	st	X, r25
    53b8:	8e 93       	st	-X, r24
    53ba:	14 97       	sbiw	r26, 0x04	; 4
    53bc:	ef 81       	ldd	r30, Y+7	; 0x07
    53be:	f8 85       	ldd	r31, Y+8	; 0x08
    53c0:	a6 81       	ldd	r26, Z+6	; 0x06
    53c2:	b7 81       	ldd	r27, Z+7	; 0x07
    53c4:	ef 81       	ldd	r30, Y+7	; 0x07
    53c6:	f8 85       	ldd	r31, Y+8	; 0x08
    53c8:	84 81       	ldd	r24, Z+4	; 0x04
    53ca:	95 81       	ldd	r25, Z+5	; 0x05
    53cc:	13 96       	adiw	r26, 0x03	; 3
    53ce:	9c 93       	st	X, r25
    53d0:	8e 93       	st	-X, r24
    53d2:	12 97       	sbiw	r26, 0x02	; 2
    53d4:	eb 81       	ldd	r30, Y+3	; 0x03
    53d6:	fc 81       	ldd	r31, Y+4	; 0x04
    53d8:	21 81       	ldd	r18, Z+1	; 0x01
    53da:	32 81       	ldd	r19, Z+2	; 0x02
    53dc:	8f 81       	ldd	r24, Y+7	; 0x07
    53de:	98 85       	ldd	r25, Y+8	; 0x08
    53e0:	02 96       	adiw	r24, 0x02	; 2
    53e2:	28 17       	cp	r18, r24
    53e4:	39 07       	cpc	r19, r25
    53e6:	41 f4       	brne	.+16     	; 0x53f8 <xTaskGenericNotify+0x25e>
    53e8:	ef 81       	ldd	r30, Y+7	; 0x07
    53ea:	f8 85       	ldd	r31, Y+8	; 0x08
    53ec:	86 81       	ldd	r24, Z+6	; 0x06
    53ee:	97 81       	ldd	r25, Z+7	; 0x07
    53f0:	eb 81       	ldd	r30, Y+3	; 0x03
    53f2:	fc 81       	ldd	r31, Y+4	; 0x04
    53f4:	92 83       	std	Z+2, r25	; 0x02
    53f6:	81 83       	std	Z+1, r24	; 0x01
    53f8:	ef 81       	ldd	r30, Y+7	; 0x07
    53fa:	f8 85       	ldd	r31, Y+8	; 0x08
    53fc:	13 86       	std	Z+11, r1	; 0x0b
    53fe:	12 86       	std	Z+10, r1	; 0x0a
    5400:	eb 81       	ldd	r30, Y+3	; 0x03
    5402:	fc 81       	ldd	r31, Y+4	; 0x04
    5404:	80 81       	ld	r24, Z
    5406:	81 50       	subi	r24, 0x01	; 1
    5408:	eb 81       	ldd	r30, Y+3	; 0x03
    540a:	fc 81       	ldd	r31, Y+4	; 0x04
    540c:	80 83       	st	Z, r24
                prvAddTaskToReadyList( pxTCB );
    540e:	ef 81       	ldd	r30, Y+7	; 0x07
    5410:	f8 85       	ldd	r31, Y+8	; 0x08
    5412:	96 89       	ldd	r25, Z+22	; 0x16
    5414:	80 91 ca 07 	lds	r24, 0x07CA
    5418:	89 17       	cp	r24, r25
    541a:	28 f4       	brcc	.+10     	; 0x5426 <xTaskGenericNotify+0x28c>
    541c:	ef 81       	ldd	r30, Y+7	; 0x07
    541e:	f8 85       	ldd	r31, Y+8	; 0x08
    5420:	86 89       	ldd	r24, Z+22	; 0x16
    5422:	80 93 ca 07 	sts	0x07CA, r24
    5426:	ef 81       	ldd	r30, Y+7	; 0x07
    5428:	f8 85       	ldd	r31, Y+8	; 0x08
    542a:	86 89       	ldd	r24, Z+22	; 0x16
    542c:	28 2f       	mov	r18, r24
    542e:	30 e0       	ldi	r19, 0x00	; 0
    5430:	c9 01       	movw	r24, r18
    5432:	88 0f       	add	r24, r24
    5434:	99 1f       	adc	r25, r25
    5436:	88 0f       	add	r24, r24
    5438:	99 1f       	adc	r25, r25
    543a:	88 0f       	add	r24, r24
    543c:	99 1f       	adc	r25, r25
    543e:	82 0f       	add	r24, r18
    5440:	93 1f       	adc	r25, r19
    5442:	fc 01       	movw	r30, r24
    5444:	ea 52       	subi	r30, 0x2A	; 42
    5446:	f8 4f       	sbci	r31, 0xF8	; 248
    5448:	81 81       	ldd	r24, Z+1	; 0x01
    544a:	92 81       	ldd	r25, Z+2	; 0x02
    544c:	9a 83       	std	Y+2, r25	; 0x02
    544e:	89 83       	std	Y+1, r24	; 0x01
    5450:	ef 81       	ldd	r30, Y+7	; 0x07
    5452:	f8 85       	ldd	r31, Y+8	; 0x08
    5454:	89 81       	ldd	r24, Y+1	; 0x01
    5456:	9a 81       	ldd	r25, Y+2	; 0x02
    5458:	95 83       	std	Z+5, r25	; 0x05
    545a:	84 83       	std	Z+4, r24	; 0x04
    545c:	e9 81       	ldd	r30, Y+1	; 0x01
    545e:	fa 81       	ldd	r31, Y+2	; 0x02
    5460:	84 81       	ldd	r24, Z+4	; 0x04
    5462:	95 81       	ldd	r25, Z+5	; 0x05
    5464:	ef 81       	ldd	r30, Y+7	; 0x07
    5466:	f8 85       	ldd	r31, Y+8	; 0x08
    5468:	97 83       	std	Z+7, r25	; 0x07
    546a:	86 83       	std	Z+6, r24	; 0x06
    546c:	e9 81       	ldd	r30, Y+1	; 0x01
    546e:	fa 81       	ldd	r31, Y+2	; 0x02
    5470:	04 80       	ldd	r0, Z+4	; 0x04
    5472:	f5 81       	ldd	r31, Z+5	; 0x05
    5474:	e0 2d       	mov	r30, r0
    5476:	8f 81       	ldd	r24, Y+7	; 0x07
    5478:	98 85       	ldd	r25, Y+8	; 0x08
    547a:	02 96       	adiw	r24, 0x02	; 2
    547c:	93 83       	std	Z+3, r25	; 0x03
    547e:	82 83       	std	Z+2, r24	; 0x02
    5480:	8f 81       	ldd	r24, Y+7	; 0x07
    5482:	98 85       	ldd	r25, Y+8	; 0x08
    5484:	02 96       	adiw	r24, 0x02	; 2
    5486:	e9 81       	ldd	r30, Y+1	; 0x01
    5488:	fa 81       	ldd	r31, Y+2	; 0x02
    548a:	95 83       	std	Z+5, r25	; 0x05
    548c:	84 83       	std	Z+4, r24	; 0x04
    548e:	ef 81       	ldd	r30, Y+7	; 0x07
    5490:	f8 85       	ldd	r31, Y+8	; 0x08
    5492:	86 89       	ldd	r24, Z+22	; 0x16
    5494:	28 2f       	mov	r18, r24
    5496:	30 e0       	ldi	r19, 0x00	; 0
    5498:	c9 01       	movw	r24, r18
    549a:	88 0f       	add	r24, r24
    549c:	99 1f       	adc	r25, r25
    549e:	88 0f       	add	r24, r24
    54a0:	99 1f       	adc	r25, r25
    54a2:	88 0f       	add	r24, r24
    54a4:	99 1f       	adc	r25, r25
    54a6:	82 0f       	add	r24, r18
    54a8:	93 1f       	adc	r25, r19
    54aa:	8a 52       	subi	r24, 0x2A	; 42
    54ac:	98 4f       	sbci	r25, 0xF8	; 248
    54ae:	ef 81       	ldd	r30, Y+7	; 0x07
    54b0:	f8 85       	ldd	r31, Y+8	; 0x08
    54b2:	93 87       	std	Z+11, r25	; 0x0b
    54b4:	82 87       	std	Z+10, r24	; 0x0a
    54b6:	ef 81       	ldd	r30, Y+7	; 0x07
    54b8:	f8 85       	ldd	r31, Y+8	; 0x08
    54ba:	86 89       	ldd	r24, Z+22	; 0x16
    54bc:	28 2f       	mov	r18, r24
    54be:	30 e0       	ldi	r19, 0x00	; 0
    54c0:	c9 01       	movw	r24, r18
    54c2:	88 0f       	add	r24, r24
    54c4:	99 1f       	adc	r25, r25
    54c6:	88 0f       	add	r24, r24
    54c8:	99 1f       	adc	r25, r25
    54ca:	88 0f       	add	r24, r24
    54cc:	99 1f       	adc	r25, r25
    54ce:	82 0f       	add	r24, r18
    54d0:	93 1f       	adc	r25, r19
    54d2:	fc 01       	movw	r30, r24
    54d4:	ea 52       	subi	r30, 0x2A	; 42
    54d6:	f8 4f       	sbci	r31, 0xF8	; 248
    54d8:	80 81       	ld	r24, Z
    54da:	8f 5f       	subi	r24, 0xFF	; 255
    54dc:	80 83       	st	Z, r24
                         * earliest possible time. */
                        prvResetNextTaskUnblockTime();
                    }
                #endif

                if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    54de:	ef 81       	ldd	r30, Y+7	; 0x07
    54e0:	f8 85       	ldd	r31, Y+8	; 0x08
    54e2:	96 89       	ldd	r25, Z+22	; 0x16
    54e4:	e0 91 c4 07 	lds	r30, 0x07C4
    54e8:	f0 91 c5 07 	lds	r31, 0x07C5
    54ec:	86 89       	ldd	r24, Z+22	; 0x16
    54ee:	89 17       	cp	r24, r25
    54f0:	10 f4       	brcc	.+4      	; 0x54f6 <xTaskGenericNotify+0x35c>
                {
                    /* The notified task has a priority above the currently
                     * executing task so a yield is required. */
                    taskYIELD_IF_USING_PREEMPTION();
    54f2:	0e 94 56 09 	call	0x12ac	; 0x12ac <vPortYield>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        taskEXIT_CRITICAL();
    54f6:	0f 90       	pop	r0
    54f8:	0f be       	out	0x3f, r0	; 63

        return xReturn;
    54fa:	8e 81       	ldd	r24, Y+6	; 0x06
    }
    54fc:	64 96       	adiw	r28, 0x14	; 20
    54fe:	0f b6       	in	r0, 0x3f	; 63
    5500:	f8 94       	cli
    5502:	de bf       	out	0x3e, r29	; 62
    5504:	0f be       	out	0x3f, r0	; 63
    5506:	cd bf       	out	0x3d, r28	; 61
    5508:	cf 91       	pop	r28
    550a:	df 91       	pop	r29
    550c:	1f 91       	pop	r17
    550e:	0f 91       	pop	r16
    5510:	ff 90       	pop	r15
    5512:	ef 90       	pop	r14
    5514:	08 95       	ret

00005516 <xTaskGenericNotifyFromISR>:
                                          UBaseType_t uxIndexToNotify,
                                          uint32_t ulValue,
                                          eNotifyAction eAction,
                                          uint32_t * pulPreviousNotificationValue,
                                          BaseType_t * pxHigherPriorityTaskWoken )
    {
    5516:	cf 92       	push	r12
    5518:	df 92       	push	r13
    551a:	ef 92       	push	r14
    551c:	ff 92       	push	r15
    551e:	0f 93       	push	r16
    5520:	1f 93       	push	r17
    5522:	df 93       	push	r29
    5524:	cf 93       	push	r28
    5526:	cd b7       	in	r28, 0x3d	; 61
    5528:	de b7       	in	r29, 0x3e	; 62
    552a:	69 97       	sbiw	r28, 0x19	; 25
    552c:	0f b6       	in	r0, 0x3f	; 63
    552e:	f8 94       	cli
    5530:	de bf       	out	0x3e, r29	; 62
    5532:	0f be       	out	0x3f, r0	; 63
    5534:	cd bf       	out	0x3d, r28	; 61
    5536:	9d 87       	std	Y+13, r25	; 0x0d
    5538:	8c 87       	std	Y+12, r24	; 0x0c
    553a:	6e 87       	std	Y+14, r22	; 0x0e
    553c:	2f 87       	std	Y+15, r18	; 0x0f
    553e:	38 8b       	std	Y+16, r19	; 0x10
    5540:	49 8b       	std	Y+17, r20	; 0x11
    5542:	5a 8b       	std	Y+18, r21	; 0x12
    5544:	0b 8b       	std	Y+19, r16	; 0x13
    5546:	fd 8a       	std	Y+21, r15	; 0x15
    5548:	ec 8a       	std	Y+20, r14	; 0x14
    554a:	df 8a       	std	Y+23, r13	; 0x17
    554c:	ce 8a       	std	Y+22, r12	; 0x16
        TCB_t * pxTCB;
        uint8_t ucOriginalNotifyState;
        BaseType_t xReturn = pdPASS;
    554e:	81 e0       	ldi	r24, 0x01	; 1
    5550:	88 87       	std	Y+8, r24	; 0x08
         * simple as possible.  More information (albeit Cortex-M specific) is
         * provided on the following link:
         * https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
        portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

        pxTCB = xTaskToNotify;
    5552:	8c 85       	ldd	r24, Y+12	; 0x0c
    5554:	9d 85       	ldd	r25, Y+13	; 0x0d
    5556:	9b 87       	std	Y+11, r25	; 0x0b
    5558:	8a 87       	std	Y+10, r24	; 0x0a

        uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    555a:	1f 82       	std	Y+7, r1	; 0x07
        {
            if( pulPreviousNotificationValue != NULL )
    555c:	8c 89       	ldd	r24, Y+20	; 0x14
    555e:	9d 89       	ldd	r25, Y+21	; 0x15
    5560:	00 97       	sbiw	r24, 0x00	; 0
    5562:	b9 f0       	breq	.+46     	; 0x5592 <xTaskGenericNotifyFromISR+0x7c>
            {
                *pulPreviousNotificationValue = pxTCB->ulNotifiedValue[ uxIndexToNotify ];
    5564:	8e 85       	ldd	r24, Y+14	; 0x0e
    5566:	88 2f       	mov	r24, r24
    5568:	90 e0       	ldi	r25, 0x00	; 0
    556a:	2a 85       	ldd	r18, Y+10	; 0x0a
    556c:	3b 85       	ldd	r19, Y+11	; 0x0b
    556e:	88 0f       	add	r24, r24
    5570:	99 1f       	adc	r25, r25
    5572:	88 0f       	add	r24, r24
    5574:	99 1f       	adc	r25, r25
    5576:	82 0f       	add	r24, r18
    5578:	93 1f       	adc	r25, r19
    557a:	fc 01       	movw	r30, r24
    557c:	b1 96       	adiw	r30, 0x21	; 33
    557e:	80 81       	ld	r24, Z
    5580:	91 81       	ldd	r25, Z+1	; 0x01
    5582:	a2 81       	ldd	r26, Z+2	; 0x02
    5584:	b3 81       	ldd	r27, Z+3	; 0x03
    5586:	ec 89       	ldd	r30, Y+20	; 0x14
    5588:	fd 89       	ldd	r31, Y+21	; 0x15
    558a:	80 83       	st	Z, r24
    558c:	91 83       	std	Z+1, r25	; 0x01
    558e:	a2 83       	std	Z+2, r26	; 0x02
    5590:	b3 83       	std	Z+3, r27	; 0x03
            }

            ucOriginalNotifyState = pxTCB->ucNotifyState[ uxIndexToNotify ];
    5592:	8e 85       	ldd	r24, Y+14	; 0x0e
    5594:	28 2f       	mov	r18, r24
    5596:	30 e0       	ldi	r19, 0x00	; 0
    5598:	8a 85       	ldd	r24, Y+10	; 0x0a
    559a:	9b 85       	ldd	r25, Y+11	; 0x0b
    559c:	82 0f       	add	r24, r18
    559e:	93 1f       	adc	r25, r19
    55a0:	fc 01       	movw	r30, r24
    55a2:	b5 96       	adiw	r30, 0x25	; 37
    55a4:	80 81       	ld	r24, Z
    55a6:	89 87       	std	Y+9, r24	; 0x09
            pxTCB->ucNotifyState[ uxIndexToNotify ] = taskNOTIFICATION_RECEIVED;
    55a8:	8e 85       	ldd	r24, Y+14	; 0x0e
    55aa:	28 2f       	mov	r18, r24
    55ac:	30 e0       	ldi	r19, 0x00	; 0
    55ae:	8a 85       	ldd	r24, Y+10	; 0x0a
    55b0:	9b 85       	ldd	r25, Y+11	; 0x0b
    55b2:	82 0f       	add	r24, r18
    55b4:	93 1f       	adc	r25, r19
    55b6:	fc 01       	movw	r30, r24
    55b8:	b5 96       	adiw	r30, 0x25	; 37
    55ba:	82 e0       	ldi	r24, 0x02	; 2
    55bc:	80 83       	st	Z, r24

            switch( eAction )
    55be:	8b 89       	ldd	r24, Y+19	; 0x13
    55c0:	28 2f       	mov	r18, r24
    55c2:	30 e0       	ldi	r19, 0x00	; 0
    55c4:	39 8f       	std	Y+25, r19	; 0x19
    55c6:	28 8f       	std	Y+24, r18	; 0x18
    55c8:	88 8d       	ldd	r24, Y+24	; 0x18
    55ca:	99 8d       	ldd	r25, Y+25	; 0x19
    55cc:	82 30       	cpi	r24, 0x02	; 2
    55ce:	91 05       	cpc	r25, r1
    55d0:	09 f4       	brne	.+2      	; 0x55d4 <xTaskGenericNotifyFromISR+0xbe>
    55d2:	46 c0       	rjmp	.+140    	; 0x5660 <xTaskGenericNotifyFromISR+0x14a>
    55d4:	28 8d       	ldd	r18, Y+24	; 0x18
    55d6:	39 8d       	ldd	r19, Y+25	; 0x19
    55d8:	23 30       	cpi	r18, 0x03	; 3
    55da:	31 05       	cpc	r19, r1
    55dc:	34 f4       	brge	.+12     	; 0x55ea <xTaskGenericNotifyFromISR+0xd4>
    55de:	88 8d       	ldd	r24, Y+24	; 0x18
    55e0:	99 8d       	ldd	r25, Y+25	; 0x19
    55e2:	81 30       	cpi	r24, 0x01	; 1
    55e4:	91 05       	cpc	r25, r1
    55e6:	71 f0       	breq	.+28     	; 0x5604 <xTaskGenericNotifyFromISR+0xee>
    55e8:	93 c0       	rjmp	.+294    	; 0x5710 <xTaskGenericNotifyFromISR+0x1fa>
    55ea:	28 8d       	ldd	r18, Y+24	; 0x18
    55ec:	39 8d       	ldd	r19, Y+25	; 0x19
    55ee:	23 30       	cpi	r18, 0x03	; 3
    55f0:	31 05       	cpc	r19, r1
    55f2:	09 f4       	brne	.+2      	; 0x55f6 <xTaskGenericNotifyFromISR+0xe0>
    55f4:	5d c0       	rjmp	.+186    	; 0x56b0 <xTaskGenericNotifyFromISR+0x19a>
    55f6:	88 8d       	ldd	r24, Y+24	; 0x18
    55f8:	99 8d       	ldd	r25, Y+25	; 0x19
    55fa:	84 30       	cpi	r24, 0x04	; 4
    55fc:	91 05       	cpc	r25, r1
    55fe:	09 f4       	brne	.+2      	; 0x5602 <xTaskGenericNotifyFromISR+0xec>
    5600:	6d c0       	rjmp	.+218    	; 0x56dc <xTaskGenericNotifyFromISR+0x1c6>
    5602:	86 c0       	rjmp	.+268    	; 0x5710 <xTaskGenericNotifyFromISR+0x1fa>
            {
                case eSetBits:
                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] |= ulValue;
    5604:	8e 85       	ldd	r24, Y+14	; 0x0e
    5606:	08 2f       	mov	r16, r24
    5608:	10 e0       	ldi	r17, 0x00	; 0
    560a:	8e 85       	ldd	r24, Y+14	; 0x0e
    560c:	88 2f       	mov	r24, r24
    560e:	90 e0       	ldi	r25, 0x00	; 0
    5610:	2a 85       	ldd	r18, Y+10	; 0x0a
    5612:	3b 85       	ldd	r19, Y+11	; 0x0b
    5614:	88 0f       	add	r24, r24
    5616:	99 1f       	adc	r25, r25
    5618:	88 0f       	add	r24, r24
    561a:	99 1f       	adc	r25, r25
    561c:	82 0f       	add	r24, r18
    561e:	93 1f       	adc	r25, r19
    5620:	fc 01       	movw	r30, r24
    5622:	b1 96       	adiw	r30, 0x21	; 33
    5624:	20 81       	ld	r18, Z
    5626:	31 81       	ldd	r19, Z+1	; 0x01
    5628:	42 81       	ldd	r20, Z+2	; 0x02
    562a:	53 81       	ldd	r21, Z+3	; 0x03
    562c:	8f 85       	ldd	r24, Y+15	; 0x0f
    562e:	98 89       	ldd	r25, Y+16	; 0x10
    5630:	a9 89       	ldd	r26, Y+17	; 0x11
    5632:	ba 89       	ldd	r27, Y+18	; 0x12
    5634:	ba 01       	movw	r22, r20
    5636:	a9 01       	movw	r20, r18
    5638:	48 2b       	or	r20, r24
    563a:	59 2b       	or	r21, r25
    563c:	6a 2b       	or	r22, r26
    563e:	7b 2b       	or	r23, r27
    5640:	2a 85       	ldd	r18, Y+10	; 0x0a
    5642:	3b 85       	ldd	r19, Y+11	; 0x0b
    5644:	c8 01       	movw	r24, r16
    5646:	88 0f       	add	r24, r24
    5648:	99 1f       	adc	r25, r25
    564a:	88 0f       	add	r24, r24
    564c:	99 1f       	adc	r25, r25
    564e:	82 0f       	add	r24, r18
    5650:	93 1f       	adc	r25, r19
    5652:	fc 01       	movw	r30, r24
    5654:	b1 96       	adiw	r30, 0x21	; 33
    5656:	40 83       	st	Z, r20
    5658:	51 83       	std	Z+1, r21	; 0x01
    565a:	62 83       	std	Z+2, r22	; 0x02
    565c:	73 83       	std	Z+3, r23	; 0x03
    565e:	58 c0       	rjmp	.+176    	; 0x5710 <xTaskGenericNotifyFromISR+0x1fa>
                    break;

                case eIncrement:
                    ( pxTCB->ulNotifiedValue[ uxIndexToNotify ] )++;
    5660:	8e 85       	ldd	r24, Y+14	; 0x0e
    5662:	08 2f       	mov	r16, r24
    5664:	10 e0       	ldi	r17, 0x00	; 0
    5666:	2a 85       	ldd	r18, Y+10	; 0x0a
    5668:	3b 85       	ldd	r19, Y+11	; 0x0b
    566a:	c8 01       	movw	r24, r16
    566c:	88 0f       	add	r24, r24
    566e:	99 1f       	adc	r25, r25
    5670:	88 0f       	add	r24, r24
    5672:	99 1f       	adc	r25, r25
    5674:	82 0f       	add	r24, r18
    5676:	93 1f       	adc	r25, r19
    5678:	fc 01       	movw	r30, r24
    567a:	b1 96       	adiw	r30, 0x21	; 33
    567c:	80 81       	ld	r24, Z
    567e:	91 81       	ldd	r25, Z+1	; 0x01
    5680:	a2 81       	ldd	r26, Z+2	; 0x02
    5682:	b3 81       	ldd	r27, Z+3	; 0x03
    5684:	ac 01       	movw	r20, r24
    5686:	bd 01       	movw	r22, r26
    5688:	4f 5f       	subi	r20, 0xFF	; 255
    568a:	5f 4f       	sbci	r21, 0xFF	; 255
    568c:	6f 4f       	sbci	r22, 0xFF	; 255
    568e:	7f 4f       	sbci	r23, 0xFF	; 255
    5690:	2a 85       	ldd	r18, Y+10	; 0x0a
    5692:	3b 85       	ldd	r19, Y+11	; 0x0b
    5694:	c8 01       	movw	r24, r16
    5696:	88 0f       	add	r24, r24
    5698:	99 1f       	adc	r25, r25
    569a:	88 0f       	add	r24, r24
    569c:	99 1f       	adc	r25, r25
    569e:	82 0f       	add	r24, r18
    56a0:	93 1f       	adc	r25, r19
    56a2:	fc 01       	movw	r30, r24
    56a4:	b1 96       	adiw	r30, 0x21	; 33
    56a6:	40 83       	st	Z, r20
    56a8:	51 83       	std	Z+1, r21	; 0x01
    56aa:	62 83       	std	Z+2, r22	; 0x02
    56ac:	73 83       	std	Z+3, r23	; 0x03
    56ae:	30 c0       	rjmp	.+96     	; 0x5710 <xTaskGenericNotifyFromISR+0x1fa>
                    break;

                case eSetValueWithOverwrite:
                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
    56b0:	8e 85       	ldd	r24, Y+14	; 0x0e
    56b2:	88 2f       	mov	r24, r24
    56b4:	90 e0       	ldi	r25, 0x00	; 0
    56b6:	2a 85       	ldd	r18, Y+10	; 0x0a
    56b8:	3b 85       	ldd	r19, Y+11	; 0x0b
    56ba:	88 0f       	add	r24, r24
    56bc:	99 1f       	adc	r25, r25
    56be:	88 0f       	add	r24, r24
    56c0:	99 1f       	adc	r25, r25
    56c2:	82 0f       	add	r24, r18
    56c4:	93 1f       	adc	r25, r19
    56c6:	fc 01       	movw	r30, r24
    56c8:	b1 96       	adiw	r30, 0x21	; 33
    56ca:	8f 85       	ldd	r24, Y+15	; 0x0f
    56cc:	98 89       	ldd	r25, Y+16	; 0x10
    56ce:	a9 89       	ldd	r26, Y+17	; 0x11
    56d0:	ba 89       	ldd	r27, Y+18	; 0x12
    56d2:	80 83       	st	Z, r24
    56d4:	91 83       	std	Z+1, r25	; 0x01
    56d6:	a2 83       	std	Z+2, r26	; 0x02
    56d8:	b3 83       	std	Z+3, r27	; 0x03
    56da:	1a c0       	rjmp	.+52     	; 0x5710 <xTaskGenericNotifyFromISR+0x1fa>
                    break;

                case eSetValueWithoutOverwrite:

                    if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    56dc:	89 85       	ldd	r24, Y+9	; 0x09
    56de:	82 30       	cpi	r24, 0x02	; 2
    56e0:	b1 f0       	breq	.+44     	; 0x570e <xTaskGenericNotifyFromISR+0x1f8>
                    {
                        pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
    56e2:	8e 85       	ldd	r24, Y+14	; 0x0e
    56e4:	88 2f       	mov	r24, r24
    56e6:	90 e0       	ldi	r25, 0x00	; 0
    56e8:	2a 85       	ldd	r18, Y+10	; 0x0a
    56ea:	3b 85       	ldd	r19, Y+11	; 0x0b
    56ec:	88 0f       	add	r24, r24
    56ee:	99 1f       	adc	r25, r25
    56f0:	88 0f       	add	r24, r24
    56f2:	99 1f       	adc	r25, r25
    56f4:	82 0f       	add	r24, r18
    56f6:	93 1f       	adc	r25, r19
    56f8:	fc 01       	movw	r30, r24
    56fa:	b1 96       	adiw	r30, 0x21	; 33
    56fc:	8f 85       	ldd	r24, Y+15	; 0x0f
    56fe:	98 89       	ldd	r25, Y+16	; 0x10
    5700:	a9 89       	ldd	r26, Y+17	; 0x11
    5702:	ba 89       	ldd	r27, Y+18	; 0x12
    5704:	80 83       	st	Z, r24
    5706:	91 83       	std	Z+1, r25	; 0x01
    5708:	a2 83       	std	Z+2, r26	; 0x02
    570a:	b3 83       	std	Z+3, r27	; 0x03
    570c:	01 c0       	rjmp	.+2      	; 0x5710 <xTaskGenericNotifyFromISR+0x1fa>
                    }
                    else
                    {
                        /* The value could not be written to the task. */
                        xReturn = pdFAIL;
    570e:	18 86       	std	Y+8, r1	; 0x08

            traceTASK_NOTIFY_FROM_ISR( uxIndexToNotify );

            /* If the task is in the blocked state specifically to wait for a
             * notification then unblock it now. */
            if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    5710:	89 85       	ldd	r24, Y+9	; 0x09
    5712:	81 30       	cpi	r24, 0x01	; 1
    5714:	09 f0       	breq	.+2      	; 0x5718 <xTaskGenericNotifyFromISR+0x202>
    5716:	ee c0       	rjmp	.+476    	; 0x58f4 <xTaskGenericNotifyFromISR+0x3de>
            {
                /* The task should not have been on an event list. */
                configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

                if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    5718:	80 91 d5 07 	lds	r24, 0x07D5
    571c:	88 23       	and	r24, r24
    571e:	09 f0       	breq	.+2      	; 0x5722 <xTaskGenericNotifyFromISR+0x20c>
    5720:	a4 c0       	rjmp	.+328    	; 0x586a <xTaskGenericNotifyFromISR+0x354>
                {
                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
    5722:	ea 85       	ldd	r30, Y+10	; 0x0a
    5724:	fb 85       	ldd	r31, Y+11	; 0x0b
    5726:	82 85       	ldd	r24, Z+10	; 0x0a
    5728:	93 85       	ldd	r25, Z+11	; 0x0b
    572a:	9e 83       	std	Y+6, r25	; 0x06
    572c:	8d 83       	std	Y+5, r24	; 0x05
    572e:	ea 85       	ldd	r30, Y+10	; 0x0a
    5730:	fb 85       	ldd	r31, Y+11	; 0x0b
    5732:	a4 81       	ldd	r26, Z+4	; 0x04
    5734:	b5 81       	ldd	r27, Z+5	; 0x05
    5736:	ea 85       	ldd	r30, Y+10	; 0x0a
    5738:	fb 85       	ldd	r31, Y+11	; 0x0b
    573a:	86 81       	ldd	r24, Z+6	; 0x06
    573c:	97 81       	ldd	r25, Z+7	; 0x07
    573e:	15 96       	adiw	r26, 0x05	; 5
    5740:	9c 93       	st	X, r25
    5742:	8e 93       	st	-X, r24
    5744:	14 97       	sbiw	r26, 0x04	; 4
    5746:	ea 85       	ldd	r30, Y+10	; 0x0a
    5748:	fb 85       	ldd	r31, Y+11	; 0x0b
    574a:	a6 81       	ldd	r26, Z+6	; 0x06
    574c:	b7 81       	ldd	r27, Z+7	; 0x07
    574e:	ea 85       	ldd	r30, Y+10	; 0x0a
    5750:	fb 85       	ldd	r31, Y+11	; 0x0b
    5752:	84 81       	ldd	r24, Z+4	; 0x04
    5754:	95 81       	ldd	r25, Z+5	; 0x05
    5756:	13 96       	adiw	r26, 0x03	; 3
    5758:	9c 93       	st	X, r25
    575a:	8e 93       	st	-X, r24
    575c:	12 97       	sbiw	r26, 0x02	; 2
    575e:	ed 81       	ldd	r30, Y+5	; 0x05
    5760:	fe 81       	ldd	r31, Y+6	; 0x06
    5762:	21 81       	ldd	r18, Z+1	; 0x01
    5764:	32 81       	ldd	r19, Z+2	; 0x02
    5766:	8a 85       	ldd	r24, Y+10	; 0x0a
    5768:	9b 85       	ldd	r25, Y+11	; 0x0b
    576a:	02 96       	adiw	r24, 0x02	; 2
    576c:	28 17       	cp	r18, r24
    576e:	39 07       	cpc	r19, r25
    5770:	41 f4       	brne	.+16     	; 0x5782 <xTaskGenericNotifyFromISR+0x26c>
    5772:	ea 85       	ldd	r30, Y+10	; 0x0a
    5774:	fb 85       	ldd	r31, Y+11	; 0x0b
    5776:	86 81       	ldd	r24, Z+6	; 0x06
    5778:	97 81       	ldd	r25, Z+7	; 0x07
    577a:	ed 81       	ldd	r30, Y+5	; 0x05
    577c:	fe 81       	ldd	r31, Y+6	; 0x06
    577e:	92 83       	std	Z+2, r25	; 0x02
    5780:	81 83       	std	Z+1, r24	; 0x01
    5782:	ea 85       	ldd	r30, Y+10	; 0x0a
    5784:	fb 85       	ldd	r31, Y+11	; 0x0b
    5786:	13 86       	std	Z+11, r1	; 0x0b
    5788:	12 86       	std	Z+10, r1	; 0x0a
    578a:	ed 81       	ldd	r30, Y+5	; 0x05
    578c:	fe 81       	ldd	r31, Y+6	; 0x06
    578e:	80 81       	ld	r24, Z
    5790:	81 50       	subi	r24, 0x01	; 1
    5792:	ed 81       	ldd	r30, Y+5	; 0x05
    5794:	fe 81       	ldd	r31, Y+6	; 0x06
    5796:	80 83       	st	Z, r24
                    prvAddTaskToReadyList( pxTCB );
    5798:	ea 85       	ldd	r30, Y+10	; 0x0a
    579a:	fb 85       	ldd	r31, Y+11	; 0x0b
    579c:	96 89       	ldd	r25, Z+22	; 0x16
    579e:	80 91 ca 07 	lds	r24, 0x07CA
    57a2:	89 17       	cp	r24, r25
    57a4:	28 f4       	brcc	.+10     	; 0x57b0 <xTaskGenericNotifyFromISR+0x29a>
    57a6:	ea 85       	ldd	r30, Y+10	; 0x0a
    57a8:	fb 85       	ldd	r31, Y+11	; 0x0b
    57aa:	86 89       	ldd	r24, Z+22	; 0x16
    57ac:	80 93 ca 07 	sts	0x07CA, r24
    57b0:	ea 85       	ldd	r30, Y+10	; 0x0a
    57b2:	fb 85       	ldd	r31, Y+11	; 0x0b
    57b4:	86 89       	ldd	r24, Z+22	; 0x16
    57b6:	28 2f       	mov	r18, r24
    57b8:	30 e0       	ldi	r19, 0x00	; 0
    57ba:	c9 01       	movw	r24, r18
    57bc:	88 0f       	add	r24, r24
    57be:	99 1f       	adc	r25, r25
    57c0:	88 0f       	add	r24, r24
    57c2:	99 1f       	adc	r25, r25
    57c4:	88 0f       	add	r24, r24
    57c6:	99 1f       	adc	r25, r25
    57c8:	82 0f       	add	r24, r18
    57ca:	93 1f       	adc	r25, r19
    57cc:	fc 01       	movw	r30, r24
    57ce:	ea 52       	subi	r30, 0x2A	; 42
    57d0:	f8 4f       	sbci	r31, 0xF8	; 248
    57d2:	81 81       	ldd	r24, Z+1	; 0x01
    57d4:	92 81       	ldd	r25, Z+2	; 0x02
    57d6:	9c 83       	std	Y+4, r25	; 0x04
    57d8:	8b 83       	std	Y+3, r24	; 0x03
    57da:	ea 85       	ldd	r30, Y+10	; 0x0a
    57dc:	fb 85       	ldd	r31, Y+11	; 0x0b
    57de:	8b 81       	ldd	r24, Y+3	; 0x03
    57e0:	9c 81       	ldd	r25, Y+4	; 0x04
    57e2:	95 83       	std	Z+5, r25	; 0x05
    57e4:	84 83       	std	Z+4, r24	; 0x04
    57e6:	eb 81       	ldd	r30, Y+3	; 0x03
    57e8:	fc 81       	ldd	r31, Y+4	; 0x04
    57ea:	84 81       	ldd	r24, Z+4	; 0x04
    57ec:	95 81       	ldd	r25, Z+5	; 0x05
    57ee:	ea 85       	ldd	r30, Y+10	; 0x0a
    57f0:	fb 85       	ldd	r31, Y+11	; 0x0b
    57f2:	97 83       	std	Z+7, r25	; 0x07
    57f4:	86 83       	std	Z+6, r24	; 0x06
    57f6:	eb 81       	ldd	r30, Y+3	; 0x03
    57f8:	fc 81       	ldd	r31, Y+4	; 0x04
    57fa:	04 80       	ldd	r0, Z+4	; 0x04
    57fc:	f5 81       	ldd	r31, Z+5	; 0x05
    57fe:	e0 2d       	mov	r30, r0
    5800:	8a 85       	ldd	r24, Y+10	; 0x0a
    5802:	9b 85       	ldd	r25, Y+11	; 0x0b
    5804:	02 96       	adiw	r24, 0x02	; 2
    5806:	93 83       	std	Z+3, r25	; 0x03
    5808:	82 83       	std	Z+2, r24	; 0x02
    580a:	8a 85       	ldd	r24, Y+10	; 0x0a
    580c:	9b 85       	ldd	r25, Y+11	; 0x0b
    580e:	02 96       	adiw	r24, 0x02	; 2
    5810:	eb 81       	ldd	r30, Y+3	; 0x03
    5812:	fc 81       	ldd	r31, Y+4	; 0x04
    5814:	95 83       	std	Z+5, r25	; 0x05
    5816:	84 83       	std	Z+4, r24	; 0x04
    5818:	ea 85       	ldd	r30, Y+10	; 0x0a
    581a:	fb 85       	ldd	r31, Y+11	; 0x0b
    581c:	86 89       	ldd	r24, Z+22	; 0x16
    581e:	28 2f       	mov	r18, r24
    5820:	30 e0       	ldi	r19, 0x00	; 0
    5822:	c9 01       	movw	r24, r18
    5824:	88 0f       	add	r24, r24
    5826:	99 1f       	adc	r25, r25
    5828:	88 0f       	add	r24, r24
    582a:	99 1f       	adc	r25, r25
    582c:	88 0f       	add	r24, r24
    582e:	99 1f       	adc	r25, r25
    5830:	82 0f       	add	r24, r18
    5832:	93 1f       	adc	r25, r19
    5834:	8a 52       	subi	r24, 0x2A	; 42
    5836:	98 4f       	sbci	r25, 0xF8	; 248
    5838:	ea 85       	ldd	r30, Y+10	; 0x0a
    583a:	fb 85       	ldd	r31, Y+11	; 0x0b
    583c:	93 87       	std	Z+11, r25	; 0x0b
    583e:	82 87       	std	Z+10, r24	; 0x0a
    5840:	ea 85       	ldd	r30, Y+10	; 0x0a
    5842:	fb 85       	ldd	r31, Y+11	; 0x0b
    5844:	86 89       	ldd	r24, Z+22	; 0x16
    5846:	28 2f       	mov	r18, r24
    5848:	30 e0       	ldi	r19, 0x00	; 0
    584a:	c9 01       	movw	r24, r18
    584c:	88 0f       	add	r24, r24
    584e:	99 1f       	adc	r25, r25
    5850:	88 0f       	add	r24, r24
    5852:	99 1f       	adc	r25, r25
    5854:	88 0f       	add	r24, r24
    5856:	99 1f       	adc	r25, r25
    5858:	82 0f       	add	r24, r18
    585a:	93 1f       	adc	r25, r19
    585c:	fc 01       	movw	r30, r24
    585e:	ea 52       	subi	r30, 0x2A	; 42
    5860:	f8 4f       	sbci	r31, 0xF8	; 248
    5862:	80 81       	ld	r24, Z
    5864:	8f 5f       	subi	r24, 0xFF	; 255
    5866:	80 83       	st	Z, r24
    5868:	30 c0       	rjmp	.+96     	; 0x58ca <xTaskGenericNotifyFromISR+0x3b4>
                }
                else
                {
                    /* The delayed and ready lists cannot be accessed, so hold
                     * this task pending until the scheduler is resumed. */
                    listINSERT_END( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    586a:	80 91 11 08 	lds	r24, 0x0811
    586e:	90 91 12 08 	lds	r25, 0x0812
    5872:	9a 83       	std	Y+2, r25	; 0x02
    5874:	89 83       	std	Y+1, r24	; 0x01
    5876:	ea 85       	ldd	r30, Y+10	; 0x0a
    5878:	fb 85       	ldd	r31, Y+11	; 0x0b
    587a:	89 81       	ldd	r24, Y+1	; 0x01
    587c:	9a 81       	ldd	r25, Y+2	; 0x02
    587e:	97 87       	std	Z+15, r25	; 0x0f
    5880:	86 87       	std	Z+14, r24	; 0x0e
    5882:	e9 81       	ldd	r30, Y+1	; 0x01
    5884:	fa 81       	ldd	r31, Y+2	; 0x02
    5886:	84 81       	ldd	r24, Z+4	; 0x04
    5888:	95 81       	ldd	r25, Z+5	; 0x05
    588a:	ea 85       	ldd	r30, Y+10	; 0x0a
    588c:	fb 85       	ldd	r31, Y+11	; 0x0b
    588e:	91 8b       	std	Z+17, r25	; 0x11
    5890:	80 8b       	std	Z+16, r24	; 0x10
    5892:	e9 81       	ldd	r30, Y+1	; 0x01
    5894:	fa 81       	ldd	r31, Y+2	; 0x02
    5896:	04 80       	ldd	r0, Z+4	; 0x04
    5898:	f5 81       	ldd	r31, Z+5	; 0x05
    589a:	e0 2d       	mov	r30, r0
    589c:	8a 85       	ldd	r24, Y+10	; 0x0a
    589e:	9b 85       	ldd	r25, Y+11	; 0x0b
    58a0:	0c 96       	adiw	r24, 0x0c	; 12
    58a2:	93 83       	std	Z+3, r25	; 0x03
    58a4:	82 83       	std	Z+2, r24	; 0x02
    58a6:	8a 85       	ldd	r24, Y+10	; 0x0a
    58a8:	9b 85       	ldd	r25, Y+11	; 0x0b
    58aa:	0c 96       	adiw	r24, 0x0c	; 12
    58ac:	e9 81       	ldd	r30, Y+1	; 0x01
    58ae:	fa 81       	ldd	r31, Y+2	; 0x02
    58b0:	95 83       	std	Z+5, r25	; 0x05
    58b2:	84 83       	std	Z+4, r24	; 0x04
    58b4:	ea 85       	ldd	r30, Y+10	; 0x0a
    58b6:	fb 85       	ldd	r31, Y+11	; 0x0b
    58b8:	80 e1       	ldi	r24, 0x10	; 16
    58ba:	98 e0       	ldi	r25, 0x08	; 8
    58bc:	95 8b       	std	Z+21, r25	; 0x15
    58be:	84 8b       	std	Z+20, r24	; 0x14
    58c0:	80 91 10 08 	lds	r24, 0x0810
    58c4:	8f 5f       	subi	r24, 0xFF	; 255
    58c6:	80 93 10 08 	sts	0x0810, r24
                }

                if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    58ca:	ea 85       	ldd	r30, Y+10	; 0x0a
    58cc:	fb 85       	ldd	r31, Y+11	; 0x0b
    58ce:	96 89       	ldd	r25, Z+22	; 0x16
    58d0:	e0 91 c4 07 	lds	r30, 0x07C4
    58d4:	f0 91 c5 07 	lds	r31, 0x07C5
    58d8:	86 89       	ldd	r24, Z+22	; 0x16
    58da:	89 17       	cp	r24, r25
    58dc:	58 f4       	brcc	.+22     	; 0x58f4 <xTaskGenericNotifyFromISR+0x3de>
                {
                    /* The notified task has a priority above the currently
                     * executing task so a yield is required. */
                    if( pxHigherPriorityTaskWoken != NULL )
    58de:	8e 89       	ldd	r24, Y+22	; 0x16
    58e0:	9f 89       	ldd	r25, Y+23	; 0x17
    58e2:	00 97       	sbiw	r24, 0x00	; 0
    58e4:	21 f0       	breq	.+8      	; 0x58ee <xTaskGenericNotifyFromISR+0x3d8>
                    {
                        *pxHigherPriorityTaskWoken = pdTRUE;
    58e6:	ee 89       	ldd	r30, Y+22	; 0x16
    58e8:	ff 89       	ldd	r31, Y+23	; 0x17
    58ea:	81 e0       	ldi	r24, 0x01	; 1
    58ec:	80 83       	st	Z, r24
                    }

                    /* Mark that a yield is pending in case the user is not
                     * using the "xHigherPriorityTaskWoken" parameter to an ISR
                     * safe FreeRTOS function. */
                    xYieldPending = pdTRUE;
    58ee:	81 e0       	ldi	r24, 0x01	; 1
    58f0:	80 93 ce 07 	sts	0x07CE, r24
                }
            }
        }
        portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

        return xReturn;
    58f4:	88 85       	ldd	r24, Y+8	; 0x08
    }
    58f6:	69 96       	adiw	r28, 0x19	; 25
    58f8:	0f b6       	in	r0, 0x3f	; 63
    58fa:	f8 94       	cli
    58fc:	de bf       	out	0x3e, r29	; 62
    58fe:	0f be       	out	0x3f, r0	; 63
    5900:	cd bf       	out	0x3d, r28	; 61
    5902:	cf 91       	pop	r28
    5904:	df 91       	pop	r29
    5906:	1f 91       	pop	r17
    5908:	0f 91       	pop	r16
    590a:	ff 90       	pop	r15
    590c:	ef 90       	pop	r14
    590e:	df 90       	pop	r13
    5910:	cf 90       	pop	r12
    5912:	08 95       	ret

00005914 <vTaskGenericNotifyGiveFromISR>:
#if ( configUSE_TASK_NOTIFICATIONS == 1 )

    void vTaskGenericNotifyGiveFromISR( TaskHandle_t xTaskToNotify,
                                        UBaseType_t uxIndexToNotify,
                                        BaseType_t * pxHigherPriorityTaskWoken )
    {
    5914:	0f 93       	push	r16
    5916:	1f 93       	push	r17
    5918:	df 93       	push	r29
    591a:	cf 93       	push	r28
    591c:	cd b7       	in	r28, 0x3d	; 61
    591e:	de b7       	in	r29, 0x3e	; 62
    5920:	2f 97       	sbiw	r28, 0x0f	; 15
    5922:	0f b6       	in	r0, 0x3f	; 63
    5924:	f8 94       	cli
    5926:	de bf       	out	0x3e, r29	; 62
    5928:	0f be       	out	0x3f, r0	; 63
    592a:	cd bf       	out	0x3d, r28	; 61
    592c:	9c 87       	std	Y+12, r25	; 0x0c
    592e:	8b 87       	std	Y+11, r24	; 0x0b
    5930:	6d 87       	std	Y+13, r22	; 0x0d
    5932:	5f 87       	std	Y+15, r21	; 0x0f
    5934:	4e 87       	std	Y+14, r20	; 0x0e
         * simple as possible.  More information (albeit Cortex-M specific) is
         * provided on the following link:
         * https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
        portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

        pxTCB = xTaskToNotify;
    5936:	8b 85       	ldd	r24, Y+11	; 0x0b
    5938:	9c 85       	ldd	r25, Y+12	; 0x0c
    593a:	9a 87       	std	Y+10, r25	; 0x0a
    593c:	89 87       	std	Y+9, r24	; 0x09

        uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    593e:	1f 82       	std	Y+7, r1	; 0x07
        {
            ucOriginalNotifyState = pxTCB->ucNotifyState[ uxIndexToNotify ];
    5940:	8d 85       	ldd	r24, Y+13	; 0x0d
    5942:	28 2f       	mov	r18, r24
    5944:	30 e0       	ldi	r19, 0x00	; 0
    5946:	89 85       	ldd	r24, Y+9	; 0x09
    5948:	9a 85       	ldd	r25, Y+10	; 0x0a
    594a:	82 0f       	add	r24, r18
    594c:	93 1f       	adc	r25, r19
    594e:	fc 01       	movw	r30, r24
    5950:	b5 96       	adiw	r30, 0x25	; 37
    5952:	80 81       	ld	r24, Z
    5954:	88 87       	std	Y+8, r24	; 0x08
            pxTCB->ucNotifyState[ uxIndexToNotify ] = taskNOTIFICATION_RECEIVED;
    5956:	8d 85       	ldd	r24, Y+13	; 0x0d
    5958:	28 2f       	mov	r18, r24
    595a:	30 e0       	ldi	r19, 0x00	; 0
    595c:	89 85       	ldd	r24, Y+9	; 0x09
    595e:	9a 85       	ldd	r25, Y+10	; 0x0a
    5960:	82 0f       	add	r24, r18
    5962:	93 1f       	adc	r25, r19
    5964:	fc 01       	movw	r30, r24
    5966:	b5 96       	adiw	r30, 0x25	; 37
    5968:	82 e0       	ldi	r24, 0x02	; 2
    596a:	80 83       	st	Z, r24

            /* 'Giving' is equivalent to incrementing a count in a counting
             * semaphore. */
            ( pxTCB->ulNotifiedValue[ uxIndexToNotify ] )++;
    596c:	8d 85       	ldd	r24, Y+13	; 0x0d
    596e:	08 2f       	mov	r16, r24
    5970:	10 e0       	ldi	r17, 0x00	; 0
    5972:	29 85       	ldd	r18, Y+9	; 0x09
    5974:	3a 85       	ldd	r19, Y+10	; 0x0a
    5976:	c8 01       	movw	r24, r16
    5978:	88 0f       	add	r24, r24
    597a:	99 1f       	adc	r25, r25
    597c:	88 0f       	add	r24, r24
    597e:	99 1f       	adc	r25, r25
    5980:	82 0f       	add	r24, r18
    5982:	93 1f       	adc	r25, r19
    5984:	fc 01       	movw	r30, r24
    5986:	b1 96       	adiw	r30, 0x21	; 33
    5988:	80 81       	ld	r24, Z
    598a:	91 81       	ldd	r25, Z+1	; 0x01
    598c:	a2 81       	ldd	r26, Z+2	; 0x02
    598e:	b3 81       	ldd	r27, Z+3	; 0x03
    5990:	ac 01       	movw	r20, r24
    5992:	bd 01       	movw	r22, r26
    5994:	4f 5f       	subi	r20, 0xFF	; 255
    5996:	5f 4f       	sbci	r21, 0xFF	; 255
    5998:	6f 4f       	sbci	r22, 0xFF	; 255
    599a:	7f 4f       	sbci	r23, 0xFF	; 255
    599c:	29 85       	ldd	r18, Y+9	; 0x09
    599e:	3a 85       	ldd	r19, Y+10	; 0x0a
    59a0:	c8 01       	movw	r24, r16
    59a2:	88 0f       	add	r24, r24
    59a4:	99 1f       	adc	r25, r25
    59a6:	88 0f       	add	r24, r24
    59a8:	99 1f       	adc	r25, r25
    59aa:	82 0f       	add	r24, r18
    59ac:	93 1f       	adc	r25, r19
    59ae:	fc 01       	movw	r30, r24
    59b0:	b1 96       	adiw	r30, 0x21	; 33
    59b2:	40 83       	st	Z, r20
    59b4:	51 83       	std	Z+1, r21	; 0x01
    59b6:	62 83       	std	Z+2, r22	; 0x02
    59b8:	73 83       	std	Z+3, r23	; 0x03

            traceTASK_NOTIFY_GIVE_FROM_ISR( uxIndexToNotify );

            /* If the task is in the blocked state specifically to wait for a
             * notification then unblock it now. */
            if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    59ba:	88 85       	ldd	r24, Y+8	; 0x08
    59bc:	81 30       	cpi	r24, 0x01	; 1
    59be:	09 f0       	breq	.+2      	; 0x59c2 <vTaskGenericNotifyGiveFromISR+0xae>
    59c0:	ee c0       	rjmp	.+476    	; 0x5b9e <vTaskGenericNotifyGiveFromISR+0x28a>
            {
                /* The task should not have been on an event list. */
                configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

                if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    59c2:	80 91 d5 07 	lds	r24, 0x07D5
    59c6:	88 23       	and	r24, r24
    59c8:	09 f0       	breq	.+2      	; 0x59cc <vTaskGenericNotifyGiveFromISR+0xb8>
    59ca:	a4 c0       	rjmp	.+328    	; 0x5b14 <vTaskGenericNotifyGiveFromISR+0x200>
                {
                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
    59cc:	e9 85       	ldd	r30, Y+9	; 0x09
    59ce:	fa 85       	ldd	r31, Y+10	; 0x0a
    59d0:	82 85       	ldd	r24, Z+10	; 0x0a
    59d2:	93 85       	ldd	r25, Z+11	; 0x0b
    59d4:	9e 83       	std	Y+6, r25	; 0x06
    59d6:	8d 83       	std	Y+5, r24	; 0x05
    59d8:	e9 85       	ldd	r30, Y+9	; 0x09
    59da:	fa 85       	ldd	r31, Y+10	; 0x0a
    59dc:	a4 81       	ldd	r26, Z+4	; 0x04
    59de:	b5 81       	ldd	r27, Z+5	; 0x05
    59e0:	e9 85       	ldd	r30, Y+9	; 0x09
    59e2:	fa 85       	ldd	r31, Y+10	; 0x0a
    59e4:	86 81       	ldd	r24, Z+6	; 0x06
    59e6:	97 81       	ldd	r25, Z+7	; 0x07
    59e8:	15 96       	adiw	r26, 0x05	; 5
    59ea:	9c 93       	st	X, r25
    59ec:	8e 93       	st	-X, r24
    59ee:	14 97       	sbiw	r26, 0x04	; 4
    59f0:	e9 85       	ldd	r30, Y+9	; 0x09
    59f2:	fa 85       	ldd	r31, Y+10	; 0x0a
    59f4:	a6 81       	ldd	r26, Z+6	; 0x06
    59f6:	b7 81       	ldd	r27, Z+7	; 0x07
    59f8:	e9 85       	ldd	r30, Y+9	; 0x09
    59fa:	fa 85       	ldd	r31, Y+10	; 0x0a
    59fc:	84 81       	ldd	r24, Z+4	; 0x04
    59fe:	95 81       	ldd	r25, Z+5	; 0x05
    5a00:	13 96       	adiw	r26, 0x03	; 3
    5a02:	9c 93       	st	X, r25
    5a04:	8e 93       	st	-X, r24
    5a06:	12 97       	sbiw	r26, 0x02	; 2
    5a08:	ed 81       	ldd	r30, Y+5	; 0x05
    5a0a:	fe 81       	ldd	r31, Y+6	; 0x06
    5a0c:	21 81       	ldd	r18, Z+1	; 0x01
    5a0e:	32 81       	ldd	r19, Z+2	; 0x02
    5a10:	89 85       	ldd	r24, Y+9	; 0x09
    5a12:	9a 85       	ldd	r25, Y+10	; 0x0a
    5a14:	02 96       	adiw	r24, 0x02	; 2
    5a16:	28 17       	cp	r18, r24
    5a18:	39 07       	cpc	r19, r25
    5a1a:	41 f4       	brne	.+16     	; 0x5a2c <vTaskGenericNotifyGiveFromISR+0x118>
    5a1c:	e9 85       	ldd	r30, Y+9	; 0x09
    5a1e:	fa 85       	ldd	r31, Y+10	; 0x0a
    5a20:	86 81       	ldd	r24, Z+6	; 0x06
    5a22:	97 81       	ldd	r25, Z+7	; 0x07
    5a24:	ed 81       	ldd	r30, Y+5	; 0x05
    5a26:	fe 81       	ldd	r31, Y+6	; 0x06
    5a28:	92 83       	std	Z+2, r25	; 0x02
    5a2a:	81 83       	std	Z+1, r24	; 0x01
    5a2c:	e9 85       	ldd	r30, Y+9	; 0x09
    5a2e:	fa 85       	ldd	r31, Y+10	; 0x0a
    5a30:	13 86       	std	Z+11, r1	; 0x0b
    5a32:	12 86       	std	Z+10, r1	; 0x0a
    5a34:	ed 81       	ldd	r30, Y+5	; 0x05
    5a36:	fe 81       	ldd	r31, Y+6	; 0x06
    5a38:	80 81       	ld	r24, Z
    5a3a:	81 50       	subi	r24, 0x01	; 1
    5a3c:	ed 81       	ldd	r30, Y+5	; 0x05
    5a3e:	fe 81       	ldd	r31, Y+6	; 0x06
    5a40:	80 83       	st	Z, r24
                    prvAddTaskToReadyList( pxTCB );
    5a42:	e9 85       	ldd	r30, Y+9	; 0x09
    5a44:	fa 85       	ldd	r31, Y+10	; 0x0a
    5a46:	96 89       	ldd	r25, Z+22	; 0x16
    5a48:	80 91 ca 07 	lds	r24, 0x07CA
    5a4c:	89 17       	cp	r24, r25
    5a4e:	28 f4       	brcc	.+10     	; 0x5a5a <vTaskGenericNotifyGiveFromISR+0x146>
    5a50:	e9 85       	ldd	r30, Y+9	; 0x09
    5a52:	fa 85       	ldd	r31, Y+10	; 0x0a
    5a54:	86 89       	ldd	r24, Z+22	; 0x16
    5a56:	80 93 ca 07 	sts	0x07CA, r24
    5a5a:	e9 85       	ldd	r30, Y+9	; 0x09
    5a5c:	fa 85       	ldd	r31, Y+10	; 0x0a
    5a5e:	86 89       	ldd	r24, Z+22	; 0x16
    5a60:	28 2f       	mov	r18, r24
    5a62:	30 e0       	ldi	r19, 0x00	; 0
    5a64:	c9 01       	movw	r24, r18
    5a66:	88 0f       	add	r24, r24
    5a68:	99 1f       	adc	r25, r25
    5a6a:	88 0f       	add	r24, r24
    5a6c:	99 1f       	adc	r25, r25
    5a6e:	88 0f       	add	r24, r24
    5a70:	99 1f       	adc	r25, r25
    5a72:	82 0f       	add	r24, r18
    5a74:	93 1f       	adc	r25, r19
    5a76:	fc 01       	movw	r30, r24
    5a78:	ea 52       	subi	r30, 0x2A	; 42
    5a7a:	f8 4f       	sbci	r31, 0xF8	; 248
    5a7c:	81 81       	ldd	r24, Z+1	; 0x01
    5a7e:	92 81       	ldd	r25, Z+2	; 0x02
    5a80:	9c 83       	std	Y+4, r25	; 0x04
    5a82:	8b 83       	std	Y+3, r24	; 0x03
    5a84:	e9 85       	ldd	r30, Y+9	; 0x09
    5a86:	fa 85       	ldd	r31, Y+10	; 0x0a
    5a88:	8b 81       	ldd	r24, Y+3	; 0x03
    5a8a:	9c 81       	ldd	r25, Y+4	; 0x04
    5a8c:	95 83       	std	Z+5, r25	; 0x05
    5a8e:	84 83       	std	Z+4, r24	; 0x04
    5a90:	eb 81       	ldd	r30, Y+3	; 0x03
    5a92:	fc 81       	ldd	r31, Y+4	; 0x04
    5a94:	84 81       	ldd	r24, Z+4	; 0x04
    5a96:	95 81       	ldd	r25, Z+5	; 0x05
    5a98:	e9 85       	ldd	r30, Y+9	; 0x09
    5a9a:	fa 85       	ldd	r31, Y+10	; 0x0a
    5a9c:	97 83       	std	Z+7, r25	; 0x07
    5a9e:	86 83       	std	Z+6, r24	; 0x06
    5aa0:	eb 81       	ldd	r30, Y+3	; 0x03
    5aa2:	fc 81       	ldd	r31, Y+4	; 0x04
    5aa4:	04 80       	ldd	r0, Z+4	; 0x04
    5aa6:	f5 81       	ldd	r31, Z+5	; 0x05
    5aa8:	e0 2d       	mov	r30, r0
    5aaa:	89 85       	ldd	r24, Y+9	; 0x09
    5aac:	9a 85       	ldd	r25, Y+10	; 0x0a
    5aae:	02 96       	adiw	r24, 0x02	; 2
    5ab0:	93 83       	std	Z+3, r25	; 0x03
    5ab2:	82 83       	std	Z+2, r24	; 0x02
    5ab4:	89 85       	ldd	r24, Y+9	; 0x09
    5ab6:	9a 85       	ldd	r25, Y+10	; 0x0a
    5ab8:	02 96       	adiw	r24, 0x02	; 2
    5aba:	eb 81       	ldd	r30, Y+3	; 0x03
    5abc:	fc 81       	ldd	r31, Y+4	; 0x04
    5abe:	95 83       	std	Z+5, r25	; 0x05
    5ac0:	84 83       	std	Z+4, r24	; 0x04
    5ac2:	e9 85       	ldd	r30, Y+9	; 0x09
    5ac4:	fa 85       	ldd	r31, Y+10	; 0x0a
    5ac6:	86 89       	ldd	r24, Z+22	; 0x16
    5ac8:	28 2f       	mov	r18, r24
    5aca:	30 e0       	ldi	r19, 0x00	; 0
    5acc:	c9 01       	movw	r24, r18
    5ace:	88 0f       	add	r24, r24
    5ad0:	99 1f       	adc	r25, r25
    5ad2:	88 0f       	add	r24, r24
    5ad4:	99 1f       	adc	r25, r25
    5ad6:	88 0f       	add	r24, r24
    5ad8:	99 1f       	adc	r25, r25
    5ada:	82 0f       	add	r24, r18
    5adc:	93 1f       	adc	r25, r19
    5ade:	8a 52       	subi	r24, 0x2A	; 42
    5ae0:	98 4f       	sbci	r25, 0xF8	; 248
    5ae2:	e9 85       	ldd	r30, Y+9	; 0x09
    5ae4:	fa 85       	ldd	r31, Y+10	; 0x0a
    5ae6:	93 87       	std	Z+11, r25	; 0x0b
    5ae8:	82 87       	std	Z+10, r24	; 0x0a
    5aea:	e9 85       	ldd	r30, Y+9	; 0x09
    5aec:	fa 85       	ldd	r31, Y+10	; 0x0a
    5aee:	86 89       	ldd	r24, Z+22	; 0x16
    5af0:	28 2f       	mov	r18, r24
    5af2:	30 e0       	ldi	r19, 0x00	; 0
    5af4:	c9 01       	movw	r24, r18
    5af6:	88 0f       	add	r24, r24
    5af8:	99 1f       	adc	r25, r25
    5afa:	88 0f       	add	r24, r24
    5afc:	99 1f       	adc	r25, r25
    5afe:	88 0f       	add	r24, r24
    5b00:	99 1f       	adc	r25, r25
    5b02:	82 0f       	add	r24, r18
    5b04:	93 1f       	adc	r25, r19
    5b06:	fc 01       	movw	r30, r24
    5b08:	ea 52       	subi	r30, 0x2A	; 42
    5b0a:	f8 4f       	sbci	r31, 0xF8	; 248
    5b0c:	80 81       	ld	r24, Z
    5b0e:	8f 5f       	subi	r24, 0xFF	; 255
    5b10:	80 83       	st	Z, r24
    5b12:	30 c0       	rjmp	.+96     	; 0x5b74 <vTaskGenericNotifyGiveFromISR+0x260>
                }
                else
                {
                    /* The delayed and ready lists cannot be accessed, so hold
                     * this task pending until the scheduler is resumed. */
                    listINSERT_END( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    5b14:	80 91 11 08 	lds	r24, 0x0811
    5b18:	90 91 12 08 	lds	r25, 0x0812
    5b1c:	9a 83       	std	Y+2, r25	; 0x02
    5b1e:	89 83       	std	Y+1, r24	; 0x01
    5b20:	e9 85       	ldd	r30, Y+9	; 0x09
    5b22:	fa 85       	ldd	r31, Y+10	; 0x0a
    5b24:	89 81       	ldd	r24, Y+1	; 0x01
    5b26:	9a 81       	ldd	r25, Y+2	; 0x02
    5b28:	97 87       	std	Z+15, r25	; 0x0f
    5b2a:	86 87       	std	Z+14, r24	; 0x0e
    5b2c:	e9 81       	ldd	r30, Y+1	; 0x01
    5b2e:	fa 81       	ldd	r31, Y+2	; 0x02
    5b30:	84 81       	ldd	r24, Z+4	; 0x04
    5b32:	95 81       	ldd	r25, Z+5	; 0x05
    5b34:	e9 85       	ldd	r30, Y+9	; 0x09
    5b36:	fa 85       	ldd	r31, Y+10	; 0x0a
    5b38:	91 8b       	std	Z+17, r25	; 0x11
    5b3a:	80 8b       	std	Z+16, r24	; 0x10
    5b3c:	e9 81       	ldd	r30, Y+1	; 0x01
    5b3e:	fa 81       	ldd	r31, Y+2	; 0x02
    5b40:	04 80       	ldd	r0, Z+4	; 0x04
    5b42:	f5 81       	ldd	r31, Z+5	; 0x05
    5b44:	e0 2d       	mov	r30, r0
    5b46:	89 85       	ldd	r24, Y+9	; 0x09
    5b48:	9a 85       	ldd	r25, Y+10	; 0x0a
    5b4a:	0c 96       	adiw	r24, 0x0c	; 12
    5b4c:	93 83       	std	Z+3, r25	; 0x03
    5b4e:	82 83       	std	Z+2, r24	; 0x02
    5b50:	89 85       	ldd	r24, Y+9	; 0x09
    5b52:	9a 85       	ldd	r25, Y+10	; 0x0a
    5b54:	0c 96       	adiw	r24, 0x0c	; 12
    5b56:	e9 81       	ldd	r30, Y+1	; 0x01
    5b58:	fa 81       	ldd	r31, Y+2	; 0x02
    5b5a:	95 83       	std	Z+5, r25	; 0x05
    5b5c:	84 83       	std	Z+4, r24	; 0x04
    5b5e:	e9 85       	ldd	r30, Y+9	; 0x09
    5b60:	fa 85       	ldd	r31, Y+10	; 0x0a
    5b62:	80 e1       	ldi	r24, 0x10	; 16
    5b64:	98 e0       	ldi	r25, 0x08	; 8
    5b66:	95 8b       	std	Z+21, r25	; 0x15
    5b68:	84 8b       	std	Z+20, r24	; 0x14
    5b6a:	80 91 10 08 	lds	r24, 0x0810
    5b6e:	8f 5f       	subi	r24, 0xFF	; 255
    5b70:	80 93 10 08 	sts	0x0810, r24
                }

                if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    5b74:	e9 85       	ldd	r30, Y+9	; 0x09
    5b76:	fa 85       	ldd	r31, Y+10	; 0x0a
    5b78:	96 89       	ldd	r25, Z+22	; 0x16
    5b7a:	e0 91 c4 07 	lds	r30, 0x07C4
    5b7e:	f0 91 c5 07 	lds	r31, 0x07C5
    5b82:	86 89       	ldd	r24, Z+22	; 0x16
    5b84:	89 17       	cp	r24, r25
    5b86:	58 f4       	brcc	.+22     	; 0x5b9e <vTaskGenericNotifyGiveFromISR+0x28a>
                {
                    /* The notified task has a priority above the currently
                     * executing task so a yield is required. */
                    if( pxHigherPriorityTaskWoken != NULL )
    5b88:	8e 85       	ldd	r24, Y+14	; 0x0e
    5b8a:	9f 85       	ldd	r25, Y+15	; 0x0f
    5b8c:	00 97       	sbiw	r24, 0x00	; 0
    5b8e:	21 f0       	breq	.+8      	; 0x5b98 <vTaskGenericNotifyGiveFromISR+0x284>
                    {
                        *pxHigherPriorityTaskWoken = pdTRUE;
    5b90:	ee 85       	ldd	r30, Y+14	; 0x0e
    5b92:	ff 85       	ldd	r31, Y+15	; 0x0f
    5b94:	81 e0       	ldi	r24, 0x01	; 1
    5b96:	80 83       	st	Z, r24
                    }

                    /* Mark that a yield is pending in case the user is not
                     * using the "xHigherPriorityTaskWoken" parameter in an ISR
                     * safe FreeRTOS function. */
                    xYieldPending = pdTRUE;
    5b98:	81 e0       	ldi	r24, 0x01	; 1
    5b9a:	80 93 ce 07 	sts	0x07CE, r24
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
    }
    5b9e:	2f 96       	adiw	r28, 0x0f	; 15
    5ba0:	0f b6       	in	r0, 0x3f	; 63
    5ba2:	f8 94       	cli
    5ba4:	de bf       	out	0x3e, r29	; 62
    5ba6:	0f be       	out	0x3f, r0	; 63
    5ba8:	cd bf       	out	0x3d, r28	; 61
    5baa:	cf 91       	pop	r28
    5bac:	df 91       	pop	r29
    5bae:	1f 91       	pop	r17
    5bb0:	0f 91       	pop	r16
    5bb2:	08 95       	ret

00005bb4 <xTaskGenericNotifyStateClear>:

#if ( configUSE_TASK_NOTIFICATIONS == 1 )

    BaseType_t xTaskGenericNotifyStateClear( TaskHandle_t xTask,
                                             UBaseType_t uxIndexToClear )
    {
    5bb4:	df 93       	push	r29
    5bb6:	cf 93       	push	r28
    5bb8:	cd b7       	in	r28, 0x3d	; 61
    5bba:	de b7       	in	r29, 0x3e	; 62
    5bbc:	28 97       	sbiw	r28, 0x08	; 8
    5bbe:	0f b6       	in	r0, 0x3f	; 63
    5bc0:	f8 94       	cli
    5bc2:	de bf       	out	0x3e, r29	; 62
    5bc4:	0f be       	out	0x3f, r0	; 63
    5bc6:	cd bf       	out	0x3d, r28	; 61
    5bc8:	9d 83       	std	Y+5, r25	; 0x05
    5bca:	8c 83       	std	Y+4, r24	; 0x04
    5bcc:	6e 83       	std	Y+6, r22	; 0x06

        configASSERT( uxIndexToClear < configTASK_NOTIFICATION_ARRAY_ENTRIES );

        /* If null is passed in here then it is the calling task that is having
         * its notification state cleared. */
        pxTCB = prvGetTCBFromHandle( xTask );
    5bce:	8c 81       	ldd	r24, Y+4	; 0x04
    5bd0:	9d 81       	ldd	r25, Y+5	; 0x05
    5bd2:	00 97       	sbiw	r24, 0x00	; 0
    5bd4:	39 f4       	brne	.+14     	; 0x5be4 <xTaskGenericNotifyStateClear+0x30>
    5bd6:	80 91 c4 07 	lds	r24, 0x07C4
    5bda:	90 91 c5 07 	lds	r25, 0x07C5
    5bde:	98 87       	std	Y+8, r25	; 0x08
    5be0:	8f 83       	std	Y+7, r24	; 0x07
    5be2:	04 c0       	rjmp	.+8      	; 0x5bec <xTaskGenericNotifyStateClear+0x38>
    5be4:	8c 81       	ldd	r24, Y+4	; 0x04
    5be6:	9d 81       	ldd	r25, Y+5	; 0x05
    5be8:	98 87       	std	Y+8, r25	; 0x08
    5bea:	8f 83       	std	Y+7, r24	; 0x07
    5bec:	8f 81       	ldd	r24, Y+7	; 0x07
    5bee:	98 85       	ldd	r25, Y+8	; 0x08
    5bf0:	9b 83       	std	Y+3, r25	; 0x03
    5bf2:	8a 83       	std	Y+2, r24	; 0x02

        taskENTER_CRITICAL();
    5bf4:	0f b6       	in	r0, 0x3f	; 63
    5bf6:	f8 94       	cli
    5bf8:	0f 92       	push	r0
        {
            if( pxTCB->ucNotifyState[ uxIndexToClear ] == taskNOTIFICATION_RECEIVED )
    5bfa:	8e 81       	ldd	r24, Y+6	; 0x06
    5bfc:	28 2f       	mov	r18, r24
    5bfe:	30 e0       	ldi	r19, 0x00	; 0
    5c00:	8a 81       	ldd	r24, Y+2	; 0x02
    5c02:	9b 81       	ldd	r25, Y+3	; 0x03
    5c04:	82 0f       	add	r24, r18
    5c06:	93 1f       	adc	r25, r19
    5c08:	fc 01       	movw	r30, r24
    5c0a:	b5 96       	adiw	r30, 0x25	; 37
    5c0c:	80 81       	ld	r24, Z
    5c0e:	82 30       	cpi	r24, 0x02	; 2
    5c10:	69 f4       	brne	.+26     	; 0x5c2c <xTaskGenericNotifyStateClear+0x78>
            {
                pxTCB->ucNotifyState[ uxIndexToClear ] = taskNOT_WAITING_NOTIFICATION;
    5c12:	8e 81       	ldd	r24, Y+6	; 0x06
    5c14:	28 2f       	mov	r18, r24
    5c16:	30 e0       	ldi	r19, 0x00	; 0
    5c18:	8a 81       	ldd	r24, Y+2	; 0x02
    5c1a:	9b 81       	ldd	r25, Y+3	; 0x03
    5c1c:	82 0f       	add	r24, r18
    5c1e:	93 1f       	adc	r25, r19
    5c20:	fc 01       	movw	r30, r24
    5c22:	b5 96       	adiw	r30, 0x25	; 37
    5c24:	10 82       	st	Z, r1
                xReturn = pdPASS;
    5c26:	81 e0       	ldi	r24, 0x01	; 1
    5c28:	89 83       	std	Y+1, r24	; 0x01
    5c2a:	01 c0       	rjmp	.+2      	; 0x5c2e <xTaskGenericNotifyStateClear+0x7a>
            }
            else
            {
                xReturn = pdFAIL;
    5c2c:	19 82       	std	Y+1, r1	; 0x01
            }
        }
        taskEXIT_CRITICAL();
    5c2e:	0f 90       	pop	r0
    5c30:	0f be       	out	0x3f, r0	; 63

        return xReturn;
    5c32:	89 81       	ldd	r24, Y+1	; 0x01
    }
    5c34:	28 96       	adiw	r28, 0x08	; 8
    5c36:	0f b6       	in	r0, 0x3f	; 63
    5c38:	f8 94       	cli
    5c3a:	de bf       	out	0x3e, r29	; 62
    5c3c:	0f be       	out	0x3f, r0	; 63
    5c3e:	cd bf       	out	0x3d, r28	; 61
    5c40:	cf 91       	pop	r28
    5c42:	df 91       	pop	r29
    5c44:	08 95       	ret

00005c46 <ulTaskGenericNotifyValueClear>:
#if ( configUSE_TASK_NOTIFICATIONS == 1 )

    uint32_t ulTaskGenericNotifyValueClear( TaskHandle_t xTask,
                                            UBaseType_t uxIndexToClear,
                                            uint32_t ulBitsToClear )
    {
    5c46:	0f 93       	push	r16
    5c48:	1f 93       	push	r17
    5c4a:	df 93       	push	r29
    5c4c:	cf 93       	push	r28
    5c4e:	cd b7       	in	r28, 0x3d	; 61
    5c50:	de b7       	in	r29, 0x3e	; 62
    5c52:	2f 97       	sbiw	r28, 0x0f	; 15
    5c54:	0f b6       	in	r0, 0x3f	; 63
    5c56:	f8 94       	cli
    5c58:	de bf       	out	0x3e, r29	; 62
    5c5a:	0f be       	out	0x3f, r0	; 63
    5c5c:	cd bf       	out	0x3d, r28	; 61
    5c5e:	98 87       	std	Y+8, r25	; 0x08
    5c60:	8f 83       	std	Y+7, r24	; 0x07
    5c62:	69 87       	std	Y+9, r22	; 0x09
    5c64:	2a 87       	std	Y+10, r18	; 0x0a
    5c66:	3b 87       	std	Y+11, r19	; 0x0b
    5c68:	4c 87       	std	Y+12, r20	; 0x0c
    5c6a:	5d 87       	std	Y+13, r21	; 0x0d
        TCB_t * pxTCB;
        uint32_t ulReturn;

        /* If null is passed in here then it is the calling task that is having
         * its notification state cleared. */
        pxTCB = prvGetTCBFromHandle( xTask );
    5c6c:	8f 81       	ldd	r24, Y+7	; 0x07
    5c6e:	98 85       	ldd	r25, Y+8	; 0x08
    5c70:	00 97       	sbiw	r24, 0x00	; 0
    5c72:	39 f4       	brne	.+14     	; 0x5c82 <ulTaskGenericNotifyValueClear+0x3c>
    5c74:	80 91 c4 07 	lds	r24, 0x07C4
    5c78:	90 91 c5 07 	lds	r25, 0x07C5
    5c7c:	9f 87       	std	Y+15, r25	; 0x0f
    5c7e:	8e 87       	std	Y+14, r24	; 0x0e
    5c80:	04 c0       	rjmp	.+8      	; 0x5c8a <ulTaskGenericNotifyValueClear+0x44>
    5c82:	8f 81       	ldd	r24, Y+7	; 0x07
    5c84:	98 85       	ldd	r25, Y+8	; 0x08
    5c86:	9f 87       	std	Y+15, r25	; 0x0f
    5c88:	8e 87       	std	Y+14, r24	; 0x0e
    5c8a:	8e 85       	ldd	r24, Y+14	; 0x0e
    5c8c:	9f 85       	ldd	r25, Y+15	; 0x0f
    5c8e:	9e 83       	std	Y+6, r25	; 0x06
    5c90:	8d 83       	std	Y+5, r24	; 0x05

        taskENTER_CRITICAL();
    5c92:	0f b6       	in	r0, 0x3f	; 63
    5c94:	f8 94       	cli
    5c96:	0f 92       	push	r0
        {
            /* Return the notification as it was before the bits were cleared,
             * then clear the bit mask. */
            ulReturn = pxTCB->ulNotifiedValue[ uxIndexToClear ];
    5c98:	89 85       	ldd	r24, Y+9	; 0x09
    5c9a:	88 2f       	mov	r24, r24
    5c9c:	90 e0       	ldi	r25, 0x00	; 0
    5c9e:	2d 81       	ldd	r18, Y+5	; 0x05
    5ca0:	3e 81       	ldd	r19, Y+6	; 0x06
    5ca2:	88 0f       	add	r24, r24
    5ca4:	99 1f       	adc	r25, r25
    5ca6:	88 0f       	add	r24, r24
    5ca8:	99 1f       	adc	r25, r25
    5caa:	82 0f       	add	r24, r18
    5cac:	93 1f       	adc	r25, r19
    5cae:	fc 01       	movw	r30, r24
    5cb0:	b1 96       	adiw	r30, 0x21	; 33
    5cb2:	80 81       	ld	r24, Z
    5cb4:	91 81       	ldd	r25, Z+1	; 0x01
    5cb6:	a2 81       	ldd	r26, Z+2	; 0x02
    5cb8:	b3 81       	ldd	r27, Z+3	; 0x03
    5cba:	89 83       	std	Y+1, r24	; 0x01
    5cbc:	9a 83       	std	Y+2, r25	; 0x02
    5cbe:	ab 83       	std	Y+3, r26	; 0x03
    5cc0:	bc 83       	std	Y+4, r27	; 0x04
            pxTCB->ulNotifiedValue[ uxIndexToClear ] &= ~ulBitsToClear;
    5cc2:	89 85       	ldd	r24, Y+9	; 0x09
    5cc4:	08 2f       	mov	r16, r24
    5cc6:	10 e0       	ldi	r17, 0x00	; 0
    5cc8:	89 85       	ldd	r24, Y+9	; 0x09
    5cca:	88 2f       	mov	r24, r24
    5ccc:	90 e0       	ldi	r25, 0x00	; 0
    5cce:	2d 81       	ldd	r18, Y+5	; 0x05
    5cd0:	3e 81       	ldd	r19, Y+6	; 0x06
    5cd2:	88 0f       	add	r24, r24
    5cd4:	99 1f       	adc	r25, r25
    5cd6:	88 0f       	add	r24, r24
    5cd8:	99 1f       	adc	r25, r25
    5cda:	82 0f       	add	r24, r18
    5cdc:	93 1f       	adc	r25, r19
    5cde:	fc 01       	movw	r30, r24
    5ce0:	b1 96       	adiw	r30, 0x21	; 33
    5ce2:	20 81       	ld	r18, Z
    5ce4:	31 81       	ldd	r19, Z+1	; 0x01
    5ce6:	42 81       	ldd	r20, Z+2	; 0x02
    5ce8:	53 81       	ldd	r21, Z+3	; 0x03
    5cea:	8a 85       	ldd	r24, Y+10	; 0x0a
    5cec:	9b 85       	ldd	r25, Y+11	; 0x0b
    5cee:	ac 85       	ldd	r26, Y+12	; 0x0c
    5cf0:	bd 85       	ldd	r27, Y+13	; 0x0d
    5cf2:	80 95       	com	r24
    5cf4:	90 95       	com	r25
    5cf6:	a0 95       	com	r26
    5cf8:	b0 95       	com	r27
    5cfa:	ba 01       	movw	r22, r20
    5cfc:	a9 01       	movw	r20, r18
    5cfe:	48 23       	and	r20, r24
    5d00:	59 23       	and	r21, r25
    5d02:	6a 23       	and	r22, r26
    5d04:	7b 23       	and	r23, r27
    5d06:	2d 81       	ldd	r18, Y+5	; 0x05
    5d08:	3e 81       	ldd	r19, Y+6	; 0x06
    5d0a:	c8 01       	movw	r24, r16
    5d0c:	88 0f       	add	r24, r24
    5d0e:	99 1f       	adc	r25, r25
    5d10:	88 0f       	add	r24, r24
    5d12:	99 1f       	adc	r25, r25
    5d14:	82 0f       	add	r24, r18
    5d16:	93 1f       	adc	r25, r19
    5d18:	fc 01       	movw	r30, r24
    5d1a:	b1 96       	adiw	r30, 0x21	; 33
    5d1c:	40 83       	st	Z, r20
    5d1e:	51 83       	std	Z+1, r21	; 0x01
    5d20:	62 83       	std	Z+2, r22	; 0x02
    5d22:	73 83       	std	Z+3, r23	; 0x03
        }
        taskEXIT_CRITICAL();
    5d24:	0f 90       	pop	r0
    5d26:	0f be       	out	0x3f, r0	; 63

        return ulReturn;
    5d28:	89 81       	ldd	r24, Y+1	; 0x01
    5d2a:	9a 81       	ldd	r25, Y+2	; 0x02
    5d2c:	ab 81       	ldd	r26, Y+3	; 0x03
    5d2e:	bc 81       	ldd	r27, Y+4	; 0x04
    }
    5d30:	bc 01       	movw	r22, r24
    5d32:	cd 01       	movw	r24, r26
    5d34:	2f 96       	adiw	r28, 0x0f	; 15
    5d36:	0f b6       	in	r0, 0x3f	; 63
    5d38:	f8 94       	cli
    5d3a:	de bf       	out	0x3e, r29	; 62
    5d3c:	0f be       	out	0x3f, r0	; 63
    5d3e:	cd bf       	out	0x3d, r28	; 61
    5d40:	cf 91       	pop	r28
    5d42:	df 91       	pop	r29
    5d44:	1f 91       	pop	r17
    5d46:	0f 91       	pop	r16
    5d48:	08 95       	ret

00005d4a <prvAddCurrentTaskToDelayedList>:
#endif /* if ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( INCLUDE_xTaskGetIdleTaskHandle == 1 ) ) */
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait,
                                            const BaseType_t xCanBlockIndefinitely )
{
    5d4a:	df 93       	push	r29
    5d4c:	cf 93       	push	r28
    5d4e:	cd b7       	in	r28, 0x3d	; 61
    5d50:	de b7       	in	r29, 0x3e	; 62
    5d52:	27 97       	sbiw	r28, 0x07	; 7
    5d54:	0f b6       	in	r0, 0x3f	; 63
    5d56:	f8 94       	cli
    5d58:	de bf       	out	0x3e, r29	; 62
    5d5a:	0f be       	out	0x3f, r0	; 63
    5d5c:	cd bf       	out	0x3d, r28	; 61
    5d5e:	9e 83       	std	Y+6, r25	; 0x06
    5d60:	8d 83       	std	Y+5, r24	; 0x05
    5d62:	6f 83       	std	Y+7, r22	; 0x07
    TickType_t xTimeToWake;
    const TickType_t xConstTickCount = xTickCount;
    5d64:	80 91 c8 07 	lds	r24, 0x07C8
    5d68:	90 91 c9 07 	lds	r25, 0x07C9
    5d6c:	9a 83       	std	Y+2, r25	; 0x02
    5d6e:	89 83       	std	Y+1, r24	; 0x01
        }
    #endif

    /* Remove the task from the ready list before adding it to the blocked list
     * as the same list item is used for both lists. */
    if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    5d70:	80 91 c4 07 	lds	r24, 0x07C4
    5d74:	90 91 c5 07 	lds	r25, 0x07C5
    5d78:	02 96       	adiw	r24, 0x02	; 2
    5d7a:	0e 94 79 11 	call	0x22f2	; 0x22f2 <uxListRemove>
    #else /* INCLUDE_vTaskSuspend */
        {
            /* Calculate the time at which the task should be woken if the event
             * does not occur.  This may overflow but this doesn't matter, the kernel
             * will manage it correctly. */
            xTimeToWake = xConstTickCount + xTicksToWait;
    5d7e:	29 81       	ldd	r18, Y+1	; 0x01
    5d80:	3a 81       	ldd	r19, Y+2	; 0x02
    5d82:	8d 81       	ldd	r24, Y+5	; 0x05
    5d84:	9e 81       	ldd	r25, Y+6	; 0x06
    5d86:	82 0f       	add	r24, r18
    5d88:	93 1f       	adc	r25, r19
    5d8a:	9c 83       	std	Y+4, r25	; 0x04
    5d8c:	8b 83       	std	Y+3, r24	; 0x03

            /* The list item will be inserted in wake time order. */
            listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
    5d8e:	e0 91 c4 07 	lds	r30, 0x07C4
    5d92:	f0 91 c5 07 	lds	r31, 0x07C5
    5d96:	8b 81       	ldd	r24, Y+3	; 0x03
    5d98:	9c 81       	ldd	r25, Y+4	; 0x04
    5d9a:	93 83       	std	Z+3, r25	; 0x03
    5d9c:	82 83       	std	Z+2, r24	; 0x02

            if( xTimeToWake < xConstTickCount )
    5d9e:	2b 81       	ldd	r18, Y+3	; 0x03
    5da0:	3c 81       	ldd	r19, Y+4	; 0x04
    5da2:	89 81       	ldd	r24, Y+1	; 0x01
    5da4:	9a 81       	ldd	r25, Y+2	; 0x02
    5da6:	28 17       	cp	r18, r24
    5da8:	39 07       	cpc	r19, r25
    5daa:	70 f4       	brcc	.+28     	; 0x5dc8 <prvAddCurrentTaskToDelayedList+0x7e>
            {
                /* Wake time has overflowed.  Place this item in the overflow list. */
                vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    5dac:	80 91 0e 08 	lds	r24, 0x080E
    5db0:	90 91 0f 08 	lds	r25, 0x080F
    5db4:	20 91 c4 07 	lds	r18, 0x07C4
    5db8:	30 91 c5 07 	lds	r19, 0x07C5
    5dbc:	2e 5f       	subi	r18, 0xFE	; 254
    5dbe:	3f 4f       	sbci	r19, 0xFF	; 255
    5dc0:	b9 01       	movw	r22, r18
    5dc2:	0e 94 0d 11 	call	0x221a	; 0x221a <vListInsert>
    5dc6:	1e c0       	rjmp	.+60     	; 0x5e04 <prvAddCurrentTaskToDelayedList+0xba>
            }
            else
            {
                /* The wake time has not overflowed, so the current block list is used. */
                vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    5dc8:	40 91 0c 08 	lds	r20, 0x080C
    5dcc:	50 91 0d 08 	lds	r21, 0x080D
    5dd0:	80 91 c4 07 	lds	r24, 0x07C4
    5dd4:	90 91 c5 07 	lds	r25, 0x07C5
    5dd8:	9c 01       	movw	r18, r24
    5dda:	2e 5f       	subi	r18, 0xFE	; 254
    5ddc:	3f 4f       	sbci	r19, 0xFF	; 255
    5dde:	ca 01       	movw	r24, r20
    5de0:	b9 01       	movw	r22, r18
    5de2:	0e 94 0d 11 	call	0x221a	; 0x221a <vListInsert>

                /* If the task entering the blocked state was placed at the head of the
                 * list of blocked tasks then xNextTaskUnblockTime needs to be updated
                 * too. */
                if( xTimeToWake < xNextTaskUnblockTime )
    5de6:	20 91 d1 07 	lds	r18, 0x07D1
    5dea:	30 91 d2 07 	lds	r19, 0x07D2
    5dee:	8b 81       	ldd	r24, Y+3	; 0x03
    5df0:	9c 81       	ldd	r25, Y+4	; 0x04
    5df2:	82 17       	cp	r24, r18
    5df4:	93 07       	cpc	r25, r19
    5df6:	30 f4       	brcc	.+12     	; 0x5e04 <prvAddCurrentTaskToDelayedList+0xba>
                {
                    xNextTaskUnblockTime = xTimeToWake;
    5df8:	8b 81       	ldd	r24, Y+3	; 0x03
    5dfa:	9c 81       	ldd	r25, Y+4	; 0x04
    5dfc:	90 93 d2 07 	sts	0x07D2, r25
    5e00:	80 93 d1 07 	sts	0x07D1, r24

            /* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
            ( void ) xCanBlockIndefinitely;
        }
    #endif /* INCLUDE_vTaskSuspend */
}
    5e04:	27 96       	adiw	r28, 0x07	; 7
    5e06:	0f b6       	in	r0, 0x3f	; 63
    5e08:	f8 94       	cli
    5e0a:	de bf       	out	0x3e, r29	; 62
    5e0c:	0f be       	out	0x3f, r0	; 63
    5e0e:	cd bf       	out	0x3d, r28	; 61
    5e10:	cf 91       	pop	r28
    5e12:	df 91       	pop	r29
    5e14:	08 95       	ret

00005e16 <xTimerCreateTimerTask>:
                                       TimerCallbackFunction_t pxCallbackFunction,
                                       Timer_t * pxNewTimer ) PRIVILEGED_FUNCTION;
/*-----------------------------------------------------------*/

    BaseType_t xTimerCreateTimerTask( void )
    {
    5e16:	ef 92       	push	r14
    5e18:	ff 92       	push	r15
    5e1a:	0f 93       	push	r16
    5e1c:	df 93       	push	r29
    5e1e:	cf 93       	push	r28
    5e20:	0f 92       	push	r0
    5e22:	cd b7       	in	r28, 0x3d	; 61
    5e24:	de b7       	in	r29, 0x3e	; 62
        BaseType_t xReturn = pdFAIL;
    5e26:	19 82       	std	Y+1, r1	; 0x01

        /* This function is called when the scheduler is started if
         * configUSE_TIMERS is set to 1.  Check that the infrastructure used by the
         * timer service task has been created/initialised.  If timers have already
         * been created then the initialisation will already have been performed. */
        prvCheckForValidListAndQueue();
    5e28:	0e 94 ca 33 	call	0x6794	; 0x6794 <prvCheckForValidListAndQueue>

        if( xTimerQueue != NULL )
    5e2c:	80 91 22 08 	lds	r24, 0x0822
    5e30:	90 91 23 08 	lds	r25, 0x0823
    5e34:	00 97       	sbiw	r24, 0x00	; 0
    5e36:	81 f0       	breq	.+32     	; 0x5e58 <xTimerCreateTimerTask+0x42>
                        xReturn = pdPASS;
                    }
                }
            #else /* if ( configSUPPORT_STATIC_ALLOCATION == 1 ) */
                {
                    xReturn = xTaskCreate( prvTimerTask,
    5e38:	8c e5       	ldi	r24, 0x5C	; 92
    5e3a:	91 e3       	ldi	r25, 0x31	; 49
    5e3c:	25 e6       	ldi	r18, 0x65	; 101
    5e3e:	30 e0       	ldi	r19, 0x00	; 0
    5e40:	e4 e2       	ldi	r30, 0x24	; 36
    5e42:	f8 e0       	ldi	r31, 0x08	; 8
    5e44:	b9 01       	movw	r22, r18
    5e46:	45 e5       	ldi	r20, 0x55	; 85
    5e48:	50 e0       	ldi	r21, 0x00	; 0
    5e4a:	20 e0       	ldi	r18, 0x00	; 0
    5e4c:	30 e0       	ldi	r19, 0x00	; 0
    5e4e:	03 e0       	ldi	r16, 0x03	; 3
    5e50:	7f 01       	movw	r14, r30
    5e52:	0e 94 1b 1b 	call	0x3636	; 0x3636 <xTaskCreate>
    5e56:	89 83       	std	Y+1, r24	; 0x01
        {
            mtCOVERAGE_TEST_MARKER();
        }

        configASSERT( xReturn );
        return xReturn;
    5e58:	89 81       	ldd	r24, Y+1	; 0x01
    }
    5e5a:	0f 90       	pop	r0
    5e5c:	cf 91       	pop	r28
    5e5e:	df 91       	pop	r29
    5e60:	0f 91       	pop	r16
    5e62:	ff 90       	pop	r15
    5e64:	ef 90       	pop	r14
    5e66:	08 95       	ret

00005e68 <xTimerCreate>:
        TimerHandle_t xTimerCreate( const char * const pcTimerName, /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
                                    const TickType_t xTimerPeriodInTicks,
                                    const UBaseType_t uxAutoReload,
                                    void * const pvTimerID,
                                    TimerCallbackFunction_t pxCallbackFunction )
        {
    5e68:	ef 92       	push	r14
    5e6a:	ff 92       	push	r15
    5e6c:	0f 93       	push	r16
    5e6e:	1f 93       	push	r17
    5e70:	df 93       	push	r29
    5e72:	cf 93       	push	r28
    5e74:	cd b7       	in	r28, 0x3d	; 61
    5e76:	de b7       	in	r29, 0x3e	; 62
    5e78:	2b 97       	sbiw	r28, 0x0b	; 11
    5e7a:	0f b6       	in	r0, 0x3f	; 63
    5e7c:	f8 94       	cli
    5e7e:	de bf       	out	0x3e, r29	; 62
    5e80:	0f be       	out	0x3f, r0	; 63
    5e82:	cd bf       	out	0x3d, r28	; 61
    5e84:	9c 83       	std	Y+4, r25	; 0x04
    5e86:	8b 83       	std	Y+3, r24	; 0x03
    5e88:	7e 83       	std	Y+6, r23	; 0x06
    5e8a:	6d 83       	std	Y+5, r22	; 0x05
    5e8c:	4f 83       	std	Y+7, r20	; 0x07
    5e8e:	39 87       	std	Y+9, r19	; 0x09
    5e90:	28 87       	std	Y+8, r18	; 0x08
    5e92:	1b 87       	std	Y+11, r17	; 0x0b
    5e94:	0a 87       	std	Y+10, r16	; 0x0a
            Timer_t * pxNewTimer;

            pxNewTimer = ( Timer_t * ) pvPortMalloc( sizeof( Timer_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of Timer_t is always a pointer to the timer's mame. */
    5e96:	83 e1       	ldi	r24, 0x13	; 19
    5e98:	90 e0       	ldi	r25, 0x00	; 0
    5e9a:	0e 94 17 07 	call	0xe2e	; 0xe2e <pvPortMalloc>
    5e9e:	9a 83       	std	Y+2, r25	; 0x02
    5ea0:	89 83       	std	Y+1, r24	; 0x01

            if( pxNewTimer != NULL )
    5ea2:	89 81       	ldd	r24, Y+1	; 0x01
    5ea4:	9a 81       	ldd	r25, Y+2	; 0x02
    5ea6:	00 97       	sbiw	r24, 0x00	; 0
    5ea8:	99 f0       	breq	.+38     	; 0x5ed0 <xTimerCreate+0x68>
            {
                /* Status is thus far zero as the timer is not created statically
                 * and has not been started.  The auto-reload bit may get set in
                 * prvInitialiseNewTimer. */
                pxNewTimer->ucStatus = 0x00;
    5eaa:	e9 81       	ldd	r30, Y+1	; 0x01
    5eac:	fa 81       	ldd	r31, Y+2	; 0x02
    5eae:	12 8a       	std	Z+18, r1	; 0x12
                prvInitialiseNewTimer( pcTimerName, xTimerPeriodInTicks, uxAutoReload, pvTimerID, pxCallbackFunction, pxNewTimer );
    5eb0:	8b 81       	ldd	r24, Y+3	; 0x03
    5eb2:	9c 81       	ldd	r25, Y+4	; 0x04
    5eb4:	2d 81       	ldd	r18, Y+5	; 0x05
    5eb6:	3e 81       	ldd	r19, Y+6	; 0x06
    5eb8:	e8 85       	ldd	r30, Y+8	; 0x08
    5eba:	f9 85       	ldd	r31, Y+9	; 0x09
    5ebc:	aa 85       	ldd	r26, Y+10	; 0x0a
    5ebe:	bb 85       	ldd	r27, Y+11	; 0x0b
    5ec0:	e9 80       	ldd	r14, Y+1	; 0x01
    5ec2:	fa 80       	ldd	r15, Y+2	; 0x02
    5ec4:	b9 01       	movw	r22, r18
    5ec6:	4f 81       	ldd	r20, Y+7	; 0x07
    5ec8:	9f 01       	movw	r18, r30
    5eca:	8d 01       	movw	r16, r26
    5ecc:	0e 94 77 2f 	call	0x5eee	; 0x5eee <prvInitialiseNewTimer>
            }

            return pxNewTimer;
    5ed0:	89 81       	ldd	r24, Y+1	; 0x01
    5ed2:	9a 81       	ldd	r25, Y+2	; 0x02
        }
    5ed4:	2b 96       	adiw	r28, 0x0b	; 11
    5ed6:	0f b6       	in	r0, 0x3f	; 63
    5ed8:	f8 94       	cli
    5eda:	de bf       	out	0x3e, r29	; 62
    5edc:	0f be       	out	0x3f, r0	; 63
    5ede:	cd bf       	out	0x3d, r28	; 61
    5ee0:	cf 91       	pop	r28
    5ee2:	df 91       	pop	r29
    5ee4:	1f 91       	pop	r17
    5ee6:	0f 91       	pop	r16
    5ee8:	ff 90       	pop	r15
    5eea:	ef 90       	pop	r14
    5eec:	08 95       	ret

00005eee <prvInitialiseNewTimer>:
                                       const TickType_t xTimerPeriodInTicks,
                                       const UBaseType_t uxAutoReload,
                                       void * const pvTimerID,
                                       TimerCallbackFunction_t pxCallbackFunction,
                                       Timer_t * pxNewTimer )
    {
    5eee:	ef 92       	push	r14
    5ef0:	ff 92       	push	r15
    5ef2:	0f 93       	push	r16
    5ef4:	1f 93       	push	r17
    5ef6:	df 93       	push	r29
    5ef8:	cf 93       	push	r28
    5efa:	cd b7       	in	r28, 0x3d	; 61
    5efc:	de b7       	in	r29, 0x3e	; 62
    5efe:	2b 97       	sbiw	r28, 0x0b	; 11
    5f00:	0f b6       	in	r0, 0x3f	; 63
    5f02:	f8 94       	cli
    5f04:	de bf       	out	0x3e, r29	; 62
    5f06:	0f be       	out	0x3f, r0	; 63
    5f08:	cd bf       	out	0x3d, r28	; 61
    5f0a:	9a 83       	std	Y+2, r25	; 0x02
    5f0c:	89 83       	std	Y+1, r24	; 0x01
    5f0e:	7c 83       	std	Y+4, r23	; 0x04
    5f10:	6b 83       	std	Y+3, r22	; 0x03
    5f12:	4d 83       	std	Y+5, r20	; 0x05
    5f14:	3f 83       	std	Y+7, r19	; 0x07
    5f16:	2e 83       	std	Y+6, r18	; 0x06
    5f18:	19 87       	std	Y+9, r17	; 0x09
    5f1a:	08 87       	std	Y+8, r16	; 0x08
    5f1c:	fb 86       	std	Y+11, r15	; 0x0b
    5f1e:	ea 86       	std	Y+10, r14	; 0x0a
        /* 0 is not a valid value for xTimerPeriodInTicks. */
        configASSERT( ( xTimerPeriodInTicks > 0 ) );

        /* Ensure the infrastructure used by the timer service task has been
         * created/initialised. */
        prvCheckForValidListAndQueue();
    5f20:	0e 94 ca 33 	call	0x6794	; 0x6794 <prvCheckForValidListAndQueue>

        /* Initialise the timer structure members using the function
         * parameters. */
        pxNewTimer->pcTimerName = pcTimerName;
    5f24:	ea 85       	ldd	r30, Y+10	; 0x0a
    5f26:	fb 85       	ldd	r31, Y+11	; 0x0b
    5f28:	89 81       	ldd	r24, Y+1	; 0x01
    5f2a:	9a 81       	ldd	r25, Y+2	; 0x02
    5f2c:	91 83       	std	Z+1, r25	; 0x01
    5f2e:	80 83       	st	Z, r24
        pxNewTimer->xTimerPeriodInTicks = xTimerPeriodInTicks;
    5f30:	ea 85       	ldd	r30, Y+10	; 0x0a
    5f32:	fb 85       	ldd	r31, Y+11	; 0x0b
    5f34:	8b 81       	ldd	r24, Y+3	; 0x03
    5f36:	9c 81       	ldd	r25, Y+4	; 0x04
    5f38:	95 87       	std	Z+13, r25	; 0x0d
    5f3a:	84 87       	std	Z+12, r24	; 0x0c
        pxNewTimer->pvTimerID = pvTimerID;
    5f3c:	ea 85       	ldd	r30, Y+10	; 0x0a
    5f3e:	fb 85       	ldd	r31, Y+11	; 0x0b
    5f40:	8e 81       	ldd	r24, Y+6	; 0x06
    5f42:	9f 81       	ldd	r25, Y+7	; 0x07
    5f44:	97 87       	std	Z+15, r25	; 0x0f
    5f46:	86 87       	std	Z+14, r24	; 0x0e
        pxNewTimer->pxCallbackFunction = pxCallbackFunction;
    5f48:	ea 85       	ldd	r30, Y+10	; 0x0a
    5f4a:	fb 85       	ldd	r31, Y+11	; 0x0b
    5f4c:	88 85       	ldd	r24, Y+8	; 0x08
    5f4e:	99 85       	ldd	r25, Y+9	; 0x09
    5f50:	91 8b       	std	Z+17, r25	; 0x11
    5f52:	80 8b       	std	Z+16, r24	; 0x10
        vListInitialiseItem( &( pxNewTimer->xTimerListItem ) );
    5f54:	8a 85       	ldd	r24, Y+10	; 0x0a
    5f56:	9b 85       	ldd	r25, Y+11	; 0x0b
    5f58:	02 96       	adiw	r24, 0x02	; 2
    5f5a:	0e 94 b9 10 	call	0x2172	; 0x2172 <vListInitialiseItem>

        if( uxAutoReload != pdFALSE )
    5f5e:	8d 81       	ldd	r24, Y+5	; 0x05
    5f60:	88 23       	and	r24, r24
    5f62:	39 f0       	breq	.+14     	; 0x5f72 <prvInitialiseNewTimer+0x84>
        {
            pxNewTimer->ucStatus |= tmrSTATUS_IS_AUTORELOAD;
    5f64:	ea 85       	ldd	r30, Y+10	; 0x0a
    5f66:	fb 85       	ldd	r31, Y+11	; 0x0b
    5f68:	82 89       	ldd	r24, Z+18	; 0x12
    5f6a:	84 60       	ori	r24, 0x04	; 4
    5f6c:	ea 85       	ldd	r30, Y+10	; 0x0a
    5f6e:	fb 85       	ldd	r31, Y+11	; 0x0b
    5f70:	82 8b       	std	Z+18, r24	; 0x12
        }

        traceTIMER_CREATE( pxNewTimer );
    }
    5f72:	2b 96       	adiw	r28, 0x0b	; 11
    5f74:	0f b6       	in	r0, 0x3f	; 63
    5f76:	f8 94       	cli
    5f78:	de bf       	out	0x3e, r29	; 62
    5f7a:	0f be       	out	0x3f, r0	; 63
    5f7c:	cd bf       	out	0x3d, r28	; 61
    5f7e:	cf 91       	pop	r28
    5f80:	df 91       	pop	r29
    5f82:	1f 91       	pop	r17
    5f84:	0f 91       	pop	r16
    5f86:	ff 90       	pop	r15
    5f88:	ef 90       	pop	r14
    5f8a:	08 95       	ret

00005f8c <xTimerGenericCommand>:
    BaseType_t xTimerGenericCommand( TimerHandle_t xTimer,
                                     const BaseType_t xCommandID,
                                     const TickType_t xOptionalValue,
                                     BaseType_t * const pxHigherPriorityTaskWoken,
                                     const TickType_t xTicksToWait )
    {
    5f8c:	0f 93       	push	r16
    5f8e:	1f 93       	push	r17
    5f90:	df 93       	push	r29
    5f92:	cf 93       	push	r28
    5f94:	cd b7       	in	r28, 0x3d	; 61
    5f96:	de b7       	in	r29, 0x3e	; 62
    5f98:	2f 97       	sbiw	r28, 0x0f	; 15
    5f9a:	0f b6       	in	r0, 0x3f	; 63
    5f9c:	f8 94       	cli
    5f9e:	de bf       	out	0x3e, r29	; 62
    5fa0:	0f be       	out	0x3f, r0	; 63
    5fa2:	cd bf       	out	0x3d, r28	; 61
    5fa4:	98 87       	std	Y+8, r25	; 0x08
    5fa6:	8f 83       	std	Y+7, r24	; 0x07
    5fa8:	69 87       	std	Y+9, r22	; 0x09
    5faa:	5b 87       	std	Y+11, r21	; 0x0b
    5fac:	4a 87       	std	Y+10, r20	; 0x0a
    5fae:	3d 87       	std	Y+13, r19	; 0x0d
    5fb0:	2c 87       	std	Y+12, r18	; 0x0c
    5fb2:	1f 87       	std	Y+15, r17	; 0x0f
    5fb4:	0e 87       	std	Y+14, r16	; 0x0e
        BaseType_t xReturn = pdFAIL;
    5fb6:	19 82       	std	Y+1, r1	; 0x01

        configASSERT( xTimer );

        /* Send a message to the timer service task to perform a particular action
         * on a particular timer definition. */
        if( xTimerQueue != NULL )
    5fb8:	80 91 22 08 	lds	r24, 0x0822
    5fbc:	90 91 23 08 	lds	r25, 0x0823
    5fc0:	00 97       	sbiw	r24, 0x00	; 0
    5fc2:	e9 f1       	breq	.+122    	; 0x603e <xTimerGenericCommand+0xb2>
        {
            /* Send a command to the timer service task to start the xTimer timer. */
            xMessage.xMessageID = xCommandID;
    5fc4:	89 85       	ldd	r24, Y+9	; 0x09
    5fc6:	8a 83       	std	Y+2, r24	; 0x02
            xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
    5fc8:	8a 85       	ldd	r24, Y+10	; 0x0a
    5fca:	9b 85       	ldd	r25, Y+11	; 0x0b
    5fcc:	9c 83       	std	Y+4, r25	; 0x04
    5fce:	8b 83       	std	Y+3, r24	; 0x03
            xMessage.u.xTimerParameters.pxTimer = xTimer;
    5fd0:	8f 81       	ldd	r24, Y+7	; 0x07
    5fd2:	98 85       	ldd	r25, Y+8	; 0x08
    5fd4:	9e 83       	std	Y+6, r25	; 0x06
    5fd6:	8d 83       	std	Y+5, r24	; 0x05

            if( xCommandID < tmrFIRST_FROM_ISR_COMMAND )
    5fd8:	89 85       	ldd	r24, Y+9	; 0x09
    5fda:	86 30       	cpi	r24, 0x06	; 6
    5fdc:	14 f5       	brge	.+68     	; 0x6022 <xTimerGenericCommand+0x96>
            {
                if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
    5fde:	0e 94 e0 26 	call	0x4dc0	; 0x4dc0 <xTaskGetSchedulerState>
    5fe2:	82 30       	cpi	r24, 0x02	; 2
    5fe4:	79 f4       	brne	.+30     	; 0x6004 <xTimerGenericCommand+0x78>
                {
                    xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
    5fe6:	80 91 22 08 	lds	r24, 0x0822
    5fea:	90 91 23 08 	lds	r25, 0x0823
    5fee:	9e 01       	movw	r18, r28
    5ff0:	2e 5f       	subi	r18, 0xFE	; 254
    5ff2:	3f 4f       	sbci	r19, 0xFF	; 255
    5ff4:	4e 85       	ldd	r20, Y+14	; 0x0e
    5ff6:	5f 85       	ldd	r21, Y+15	; 0x0f
    5ff8:	b9 01       	movw	r22, r18
    5ffa:	20 e0       	ldi	r18, 0x00	; 0
    5ffc:	0e 94 1f 13 	call	0x263e	; 0x263e <xQueueGenericSend>
    6000:	89 83       	std	Y+1, r24	; 0x01
    6002:	1d c0       	rjmp	.+58     	; 0x603e <xTimerGenericCommand+0xb2>
                }
                else
                {
                    xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
    6004:	80 91 22 08 	lds	r24, 0x0822
    6008:	90 91 23 08 	lds	r25, 0x0823
    600c:	9e 01       	movw	r18, r28
    600e:	2e 5f       	subi	r18, 0xFE	; 254
    6010:	3f 4f       	sbci	r19, 0xFF	; 255
    6012:	b9 01       	movw	r22, r18
    6014:	40 e0       	ldi	r20, 0x00	; 0
    6016:	50 e0       	ldi	r21, 0x00	; 0
    6018:	20 e0       	ldi	r18, 0x00	; 0
    601a:	0e 94 1f 13 	call	0x263e	; 0x263e <xQueueGenericSend>
    601e:	89 83       	std	Y+1, r24	; 0x01
    6020:	0e c0       	rjmp	.+28     	; 0x603e <xTimerGenericCommand+0xb2>
                }
            }
            else
            {
                xReturn = xQueueSendToBackFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
    6022:	80 91 22 08 	lds	r24, 0x0822
    6026:	90 91 23 08 	lds	r25, 0x0823
    602a:	9e 01       	movw	r18, r28
    602c:	2e 5f       	subi	r18, 0xFE	; 254
    602e:	3f 4f       	sbci	r19, 0xFF	; 255
    6030:	4c 85       	ldd	r20, Y+12	; 0x0c
    6032:	5d 85       	ldd	r21, Y+13	; 0x0d
    6034:	b9 01       	movw	r22, r18
    6036:	20 e0       	ldi	r18, 0x00	; 0
    6038:	0e 94 cb 13 	call	0x2796	; 0x2796 <xQueueGenericSendFromISR>
    603c:	89 83       	std	Y+1, r24	; 0x01
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        return xReturn;
    603e:	89 81       	ldd	r24, Y+1	; 0x01
    }
    6040:	2f 96       	adiw	r28, 0x0f	; 15
    6042:	0f b6       	in	r0, 0x3f	; 63
    6044:	f8 94       	cli
    6046:	de bf       	out	0x3e, r29	; 62
    6048:	0f be       	out	0x3f, r0	; 63
    604a:	cd bf       	out	0x3d, r28	; 61
    604c:	cf 91       	pop	r28
    604e:	df 91       	pop	r29
    6050:	1f 91       	pop	r17
    6052:	0f 91       	pop	r16
    6054:	08 95       	ret

00006056 <xTimerGetTimerDaemonTaskHandle>:
/*-----------------------------------------------------------*/

    TaskHandle_t xTimerGetTimerDaemonTaskHandle( void )
    {
    6056:	df 93       	push	r29
    6058:	cf 93       	push	r28
    605a:	cd b7       	in	r28, 0x3d	; 61
    605c:	de b7       	in	r29, 0x3e	; 62
        /* If xTimerGetTimerDaemonTaskHandle() is called before the scheduler has been
         * started, then xTimerTaskHandle will be NULL. */
        configASSERT( ( xTimerTaskHandle != NULL ) );
        return xTimerTaskHandle;
    605e:	80 91 24 08 	lds	r24, 0x0824
    6062:	90 91 25 08 	lds	r25, 0x0825
    }
    6066:	cf 91       	pop	r28
    6068:	df 91       	pop	r29
    606a:	08 95       	ret

0000606c <xTimerGetPeriod>:
/*-----------------------------------------------------------*/

    TickType_t xTimerGetPeriod( TimerHandle_t xTimer )
    {
    606c:	df 93       	push	r29
    606e:	cf 93       	push	r28
    6070:	00 d0       	rcall	.+0      	; 0x6072 <xTimerGetPeriod+0x6>
    6072:	00 d0       	rcall	.+0      	; 0x6074 <xTimerGetPeriod+0x8>
    6074:	cd b7       	in	r28, 0x3d	; 61
    6076:	de b7       	in	r29, 0x3e	; 62
    6078:	9c 83       	std	Y+4, r25	; 0x04
    607a:	8b 83       	std	Y+3, r24	; 0x03
        Timer_t * pxTimer = xTimer;
    607c:	8b 81       	ldd	r24, Y+3	; 0x03
    607e:	9c 81       	ldd	r25, Y+4	; 0x04
    6080:	9a 83       	std	Y+2, r25	; 0x02
    6082:	89 83       	std	Y+1, r24	; 0x01

        configASSERT( xTimer );
        return pxTimer->xTimerPeriodInTicks;
    6084:	e9 81       	ldd	r30, Y+1	; 0x01
    6086:	fa 81       	ldd	r31, Y+2	; 0x02
    6088:	84 85       	ldd	r24, Z+12	; 0x0c
    608a:	95 85       	ldd	r25, Z+13	; 0x0d
    }
    608c:	0f 90       	pop	r0
    608e:	0f 90       	pop	r0
    6090:	0f 90       	pop	r0
    6092:	0f 90       	pop	r0
    6094:	cf 91       	pop	r28
    6096:	df 91       	pop	r29
    6098:	08 95       	ret

0000609a <vTimerSetReloadMode>:
/*-----------------------------------------------------------*/

    void vTimerSetReloadMode( TimerHandle_t xTimer,
                              const UBaseType_t uxAutoReload )
    {
    609a:	df 93       	push	r29
    609c:	cf 93       	push	r28
    609e:	00 d0       	rcall	.+0      	; 0x60a0 <vTimerSetReloadMode+0x6>
    60a0:	00 d0       	rcall	.+0      	; 0x60a2 <vTimerSetReloadMode+0x8>
    60a2:	0f 92       	push	r0
    60a4:	cd b7       	in	r28, 0x3d	; 61
    60a6:	de b7       	in	r29, 0x3e	; 62
    60a8:	9c 83       	std	Y+4, r25	; 0x04
    60aa:	8b 83       	std	Y+3, r24	; 0x03
    60ac:	6d 83       	std	Y+5, r22	; 0x05
        Timer_t * pxTimer = xTimer;
    60ae:	8b 81       	ldd	r24, Y+3	; 0x03
    60b0:	9c 81       	ldd	r25, Y+4	; 0x04
    60b2:	9a 83       	std	Y+2, r25	; 0x02
    60b4:	89 83       	std	Y+1, r24	; 0x01

        configASSERT( xTimer );
        taskENTER_CRITICAL();
    60b6:	0f b6       	in	r0, 0x3f	; 63
    60b8:	f8 94       	cli
    60ba:	0f 92       	push	r0
        {
            if( uxAutoReload != pdFALSE )
    60bc:	8d 81       	ldd	r24, Y+5	; 0x05
    60be:	88 23       	and	r24, r24
    60c0:	41 f0       	breq	.+16     	; 0x60d2 <vTimerSetReloadMode+0x38>
            {
                pxTimer->ucStatus |= tmrSTATUS_IS_AUTORELOAD;
    60c2:	e9 81       	ldd	r30, Y+1	; 0x01
    60c4:	fa 81       	ldd	r31, Y+2	; 0x02
    60c6:	82 89       	ldd	r24, Z+18	; 0x12
    60c8:	84 60       	ori	r24, 0x04	; 4
    60ca:	e9 81       	ldd	r30, Y+1	; 0x01
    60cc:	fa 81       	ldd	r31, Y+2	; 0x02
    60ce:	82 8b       	std	Z+18, r24	; 0x12
    60d0:	07 c0       	rjmp	.+14     	; 0x60e0 <vTimerSetReloadMode+0x46>
            }
            else
            {
                pxTimer->ucStatus &= ( ( uint8_t ) ~tmrSTATUS_IS_AUTORELOAD );
    60d2:	e9 81       	ldd	r30, Y+1	; 0x01
    60d4:	fa 81       	ldd	r31, Y+2	; 0x02
    60d6:	82 89       	ldd	r24, Z+18	; 0x12
    60d8:	8b 7f       	andi	r24, 0xFB	; 251
    60da:	e9 81       	ldd	r30, Y+1	; 0x01
    60dc:	fa 81       	ldd	r31, Y+2	; 0x02
    60de:	82 8b       	std	Z+18, r24	; 0x12
            }
        }
        taskEXIT_CRITICAL();
    60e0:	0f 90       	pop	r0
    60e2:	0f be       	out	0x3f, r0	; 63
    }
    60e4:	0f 90       	pop	r0
    60e6:	0f 90       	pop	r0
    60e8:	0f 90       	pop	r0
    60ea:	0f 90       	pop	r0
    60ec:	0f 90       	pop	r0
    60ee:	cf 91       	pop	r28
    60f0:	df 91       	pop	r29
    60f2:	08 95       	ret

000060f4 <uxTimerGetReloadMode>:
/*-----------------------------------------------------------*/

    UBaseType_t uxTimerGetReloadMode( TimerHandle_t xTimer )
    {
    60f4:	df 93       	push	r29
    60f6:	cf 93       	push	r28
    60f8:	00 d0       	rcall	.+0      	; 0x60fa <uxTimerGetReloadMode+0x6>
    60fa:	00 d0       	rcall	.+0      	; 0x60fc <uxTimerGetReloadMode+0x8>
    60fc:	0f 92       	push	r0
    60fe:	cd b7       	in	r28, 0x3d	; 61
    6100:	de b7       	in	r29, 0x3e	; 62
    6102:	9d 83       	std	Y+5, r25	; 0x05
    6104:	8c 83       	std	Y+4, r24	; 0x04
        Timer_t * pxTimer = xTimer;
    6106:	8c 81       	ldd	r24, Y+4	; 0x04
    6108:	9d 81       	ldd	r25, Y+5	; 0x05
    610a:	9b 83       	std	Y+3, r25	; 0x03
    610c:	8a 83       	std	Y+2, r24	; 0x02
        UBaseType_t uxReturn;

        configASSERT( xTimer );
        taskENTER_CRITICAL();
    610e:	0f b6       	in	r0, 0x3f	; 63
    6110:	f8 94       	cli
    6112:	0f 92       	push	r0
        {
            if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) == 0 )
    6114:	ea 81       	ldd	r30, Y+2	; 0x02
    6116:	fb 81       	ldd	r31, Y+3	; 0x03
    6118:	82 89       	ldd	r24, Z+18	; 0x12
    611a:	88 2f       	mov	r24, r24
    611c:	90 e0       	ldi	r25, 0x00	; 0
    611e:	84 70       	andi	r24, 0x04	; 4
    6120:	90 70       	andi	r25, 0x00	; 0
    6122:	00 97       	sbiw	r24, 0x00	; 0
    6124:	11 f4       	brne	.+4      	; 0x612a <uxTimerGetReloadMode+0x36>
            {
                /* Not an auto-reload timer. */
                uxReturn = ( UBaseType_t ) pdFALSE;
    6126:	19 82       	std	Y+1, r1	; 0x01
    6128:	02 c0       	rjmp	.+4      	; 0x612e <uxTimerGetReloadMode+0x3a>
            }
            else
            {
                /* Is an auto-reload timer. */
                uxReturn = ( UBaseType_t ) pdTRUE;
    612a:	81 e0       	ldi	r24, 0x01	; 1
    612c:	89 83       	std	Y+1, r24	; 0x01
            }
        }
        taskEXIT_CRITICAL();
    612e:	0f 90       	pop	r0
    6130:	0f be       	out	0x3f, r0	; 63

        return uxReturn;
    6132:	89 81       	ldd	r24, Y+1	; 0x01
    }
    6134:	0f 90       	pop	r0
    6136:	0f 90       	pop	r0
    6138:	0f 90       	pop	r0
    613a:	0f 90       	pop	r0
    613c:	0f 90       	pop	r0
    613e:	cf 91       	pop	r28
    6140:	df 91       	pop	r29
    6142:	08 95       	ret

00006144 <xTimerGetExpiryTime>:
/*-----------------------------------------------------------*/

    TickType_t xTimerGetExpiryTime( TimerHandle_t xTimer )
    {
    6144:	df 93       	push	r29
    6146:	cf 93       	push	r28
    6148:	00 d0       	rcall	.+0      	; 0x614a <xTimerGetExpiryTime+0x6>
    614a:	00 d0       	rcall	.+0      	; 0x614c <xTimerGetExpiryTime+0x8>
    614c:	00 d0       	rcall	.+0      	; 0x614e <xTimerGetExpiryTime+0xa>
    614e:	cd b7       	in	r28, 0x3d	; 61
    6150:	de b7       	in	r29, 0x3e	; 62
    6152:	9e 83       	std	Y+6, r25	; 0x06
    6154:	8d 83       	std	Y+5, r24	; 0x05
        Timer_t * pxTimer = xTimer;
    6156:	8d 81       	ldd	r24, Y+5	; 0x05
    6158:	9e 81       	ldd	r25, Y+6	; 0x06
    615a:	9c 83       	std	Y+4, r25	; 0x04
    615c:	8b 83       	std	Y+3, r24	; 0x03
        TickType_t xReturn;

        configASSERT( xTimer );
        xReturn = listGET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ) );
    615e:	eb 81       	ldd	r30, Y+3	; 0x03
    6160:	fc 81       	ldd	r31, Y+4	; 0x04
    6162:	82 81       	ldd	r24, Z+2	; 0x02
    6164:	93 81       	ldd	r25, Z+3	; 0x03
    6166:	9a 83       	std	Y+2, r25	; 0x02
    6168:	89 83       	std	Y+1, r24	; 0x01
        return xReturn;
    616a:	89 81       	ldd	r24, Y+1	; 0x01
    616c:	9a 81       	ldd	r25, Y+2	; 0x02
    }
    616e:	26 96       	adiw	r28, 0x06	; 6
    6170:	0f b6       	in	r0, 0x3f	; 63
    6172:	f8 94       	cli
    6174:	de bf       	out	0x3e, r29	; 62
    6176:	0f be       	out	0x3f, r0	; 63
    6178:	cd bf       	out	0x3d, r28	; 61
    617a:	cf 91       	pop	r28
    617c:	df 91       	pop	r29
    617e:	08 95       	ret

00006180 <pcTimerGetName>:
/*-----------------------------------------------------------*/

    const char * pcTimerGetName( TimerHandle_t xTimer ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
    {
    6180:	df 93       	push	r29
    6182:	cf 93       	push	r28
    6184:	00 d0       	rcall	.+0      	; 0x6186 <pcTimerGetName+0x6>
    6186:	00 d0       	rcall	.+0      	; 0x6188 <pcTimerGetName+0x8>
    6188:	cd b7       	in	r28, 0x3d	; 61
    618a:	de b7       	in	r29, 0x3e	; 62
    618c:	9c 83       	std	Y+4, r25	; 0x04
    618e:	8b 83       	std	Y+3, r24	; 0x03
        Timer_t * pxTimer = xTimer;
    6190:	8b 81       	ldd	r24, Y+3	; 0x03
    6192:	9c 81       	ldd	r25, Y+4	; 0x04
    6194:	9a 83       	std	Y+2, r25	; 0x02
    6196:	89 83       	std	Y+1, r24	; 0x01

        configASSERT( xTimer );
        return pxTimer->pcTimerName;
    6198:	e9 81       	ldd	r30, Y+1	; 0x01
    619a:	fa 81       	ldd	r31, Y+2	; 0x02
    619c:	80 81       	ld	r24, Z
    619e:	91 81       	ldd	r25, Z+1	; 0x01
    }
    61a0:	0f 90       	pop	r0
    61a2:	0f 90       	pop	r0
    61a4:	0f 90       	pop	r0
    61a6:	0f 90       	pop	r0
    61a8:	cf 91       	pop	r28
    61aa:	df 91       	pop	r29
    61ac:	08 95       	ret

000061ae <prvReloadTimer>:
/*-----------------------------------------------------------*/

    static void prvReloadTimer( Timer_t * const pxTimer,
                                TickType_t xExpiredTime,
                                const TickType_t xTimeNow )
    {
    61ae:	df 93       	push	r29
    61b0:	cf 93       	push	r28
    61b2:	00 d0       	rcall	.+0      	; 0x61b4 <prvReloadTimer+0x6>
    61b4:	00 d0       	rcall	.+0      	; 0x61b6 <prvReloadTimer+0x8>
    61b6:	00 d0       	rcall	.+0      	; 0x61b8 <prvReloadTimer+0xa>
    61b8:	cd b7       	in	r28, 0x3d	; 61
    61ba:	de b7       	in	r29, 0x3e	; 62
    61bc:	9a 83       	std	Y+2, r25	; 0x02
    61be:	89 83       	std	Y+1, r24	; 0x01
    61c0:	7c 83       	std	Y+4, r23	; 0x04
    61c2:	6b 83       	std	Y+3, r22	; 0x03
    61c4:	5e 83       	std	Y+6, r21	; 0x06
    61c6:	4d 83       	std	Y+5, r20	; 0x05
    61c8:	12 c0       	rjmp	.+36     	; 0x61ee <prvReloadTimer+0x40>
         * If the next expiry time has already passed, advance the expiry time,
         * call the callback function, and try again. */
        while( prvInsertTimerInActiveList( pxTimer, ( xExpiredTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xExpiredTime ) != pdFALSE )
        {
            /* Advance the expiry time. */
            xExpiredTime += pxTimer->xTimerPeriodInTicks;
    61ca:	e9 81       	ldd	r30, Y+1	; 0x01
    61cc:	fa 81       	ldd	r31, Y+2	; 0x02
    61ce:	24 85       	ldd	r18, Z+12	; 0x0c
    61d0:	35 85       	ldd	r19, Z+13	; 0x0d
    61d2:	8b 81       	ldd	r24, Y+3	; 0x03
    61d4:	9c 81       	ldd	r25, Y+4	; 0x04
    61d6:	82 0f       	add	r24, r18
    61d8:	93 1f       	adc	r25, r19
    61da:	9c 83       	std	Y+4, r25	; 0x04
    61dc:	8b 83       	std	Y+3, r24	; 0x03

            /* Call the timer callback. */
            traceTIMER_EXPIRED( pxTimer );
            pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    61de:	e9 81       	ldd	r30, Y+1	; 0x01
    61e0:	fa 81       	ldd	r31, Y+2	; 0x02
    61e2:	00 88       	ldd	r0, Z+16	; 0x10
    61e4:	f1 89       	ldd	r31, Z+17	; 0x11
    61e6:	e0 2d       	mov	r30, r0
    61e8:	89 81       	ldd	r24, Y+1	; 0x01
    61ea:	9a 81       	ldd	r25, Y+2	; 0x02
    61ec:	09 95       	icall
                                const TickType_t xTimeNow )
    {
        /* Insert the timer into the appropriate list for the next expiry time.
         * If the next expiry time has already passed, advance the expiry time,
         * call the callback function, and try again. */
        while( prvInsertTimerInActiveList( pxTimer, ( xExpiredTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xExpiredTime ) != pdFALSE )
    61ee:	e9 81       	ldd	r30, Y+1	; 0x01
    61f0:	fa 81       	ldd	r31, Y+2	; 0x02
    61f2:	24 85       	ldd	r18, Z+12	; 0x0c
    61f4:	35 85       	ldd	r19, Z+13	; 0x0d
    61f6:	8b 81       	ldd	r24, Y+3	; 0x03
    61f8:	9c 81       	ldd	r25, Y+4	; 0x04
    61fa:	a9 01       	movw	r20, r18
    61fc:	48 0f       	add	r20, r24
    61fe:	59 1f       	adc	r21, r25
    6200:	89 81       	ldd	r24, Y+1	; 0x01
    6202:	9a 81       	ldd	r25, Y+2	; 0x02
    6204:	2d 81       	ldd	r18, Y+5	; 0x05
    6206:	3e 81       	ldd	r19, Y+6	; 0x06
    6208:	eb 81       	ldd	r30, Y+3	; 0x03
    620a:	fc 81       	ldd	r31, Y+4	; 0x04
    620c:	ba 01       	movw	r22, r20
    620e:	a9 01       	movw	r20, r18
    6210:	9f 01       	movw	r18, r30
    6212:	0e 94 2d 32 	call	0x645a	; 0x645a <prvInsertTimerInActiveList>
    6216:	88 23       	and	r24, r24
    6218:	c1 f6       	brne	.-80     	; 0x61ca <prvReloadTimer+0x1c>

            /* Call the timer callback. */
            traceTIMER_EXPIRED( pxTimer );
            pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
        }
    }
    621a:	26 96       	adiw	r28, 0x06	; 6
    621c:	0f b6       	in	r0, 0x3f	; 63
    621e:	f8 94       	cli
    6220:	de bf       	out	0x3e, r29	; 62
    6222:	0f be       	out	0x3f, r0	; 63
    6224:	cd bf       	out	0x3d, r28	; 61
    6226:	cf 91       	pop	r28
    6228:	df 91       	pop	r29
    622a:	08 95       	ret

0000622c <prvProcessExpiredTimer>:
/*-----------------------------------------------------------*/

    static void prvProcessExpiredTimer( const TickType_t xNextExpireTime,
                                        const TickType_t xTimeNow )
    {
    622c:	df 93       	push	r29
    622e:	cf 93       	push	r28
    6230:	00 d0       	rcall	.+0      	; 0x6232 <prvProcessExpiredTimer+0x6>
    6232:	00 d0       	rcall	.+0      	; 0x6234 <prvProcessExpiredTimer+0x8>
    6234:	00 d0       	rcall	.+0      	; 0x6236 <prvProcessExpiredTimer+0xa>
    6236:	cd b7       	in	r28, 0x3d	; 61
    6238:	de b7       	in	r29, 0x3e	; 62
    623a:	9c 83       	std	Y+4, r25	; 0x04
    623c:	8b 83       	std	Y+3, r24	; 0x03
    623e:	7e 83       	std	Y+6, r23	; 0x06
    6240:	6d 83       	std	Y+5, r22	; 0x05
        Timer_t * const pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); /*lint !e9087 !e9079 void * is used as this macro is used with tasks and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    6242:	e0 91 3a 08 	lds	r30, 0x083A
    6246:	f0 91 3b 08 	lds	r31, 0x083B
    624a:	05 80       	ldd	r0, Z+5	; 0x05
    624c:	f6 81       	ldd	r31, Z+6	; 0x06
    624e:	e0 2d       	mov	r30, r0
    6250:	86 81       	ldd	r24, Z+6	; 0x06
    6252:	97 81       	ldd	r25, Z+7	; 0x07
    6254:	9a 83       	std	Y+2, r25	; 0x02
    6256:	89 83       	std	Y+1, r24	; 0x01

        /* Remove the timer from the list of active timers.  A check has already
         * been performed to ensure the list is not empty. */

        ( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    6258:	89 81       	ldd	r24, Y+1	; 0x01
    625a:	9a 81       	ldd	r25, Y+2	; 0x02
    625c:	02 96       	adiw	r24, 0x02	; 2
    625e:	0e 94 79 11 	call	0x22f2	; 0x22f2 <uxListRemove>

        /* If the timer is an auto-reload timer then calculate the next
         * expiry time and re-insert the timer in the list of active timers. */
        if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
    6262:	e9 81       	ldd	r30, Y+1	; 0x01
    6264:	fa 81       	ldd	r31, Y+2	; 0x02
    6266:	82 89       	ldd	r24, Z+18	; 0x12
    6268:	88 2f       	mov	r24, r24
    626a:	90 e0       	ldi	r25, 0x00	; 0
    626c:	84 70       	andi	r24, 0x04	; 4
    626e:	90 70       	andi	r25, 0x00	; 0
    6270:	00 97       	sbiw	r24, 0x00	; 0
    6272:	51 f0       	breq	.+20     	; 0x6288 <prvProcessExpiredTimer+0x5c>
        {
            prvReloadTimer( pxTimer, xNextExpireTime, xTimeNow );
    6274:	89 81       	ldd	r24, Y+1	; 0x01
    6276:	9a 81       	ldd	r25, Y+2	; 0x02
    6278:	2b 81       	ldd	r18, Y+3	; 0x03
    627a:	3c 81       	ldd	r19, Y+4	; 0x04
    627c:	4d 81       	ldd	r20, Y+5	; 0x05
    627e:	5e 81       	ldd	r21, Y+6	; 0x06
    6280:	b9 01       	movw	r22, r18
    6282:	0e 94 d7 30 	call	0x61ae	; 0x61ae <prvReloadTimer>
    6286:	07 c0       	rjmp	.+14     	; 0x6296 <prvProcessExpiredTimer+0x6a>
        }
        else
        {
            pxTimer->ucStatus &= ( ( uint8_t ) ~tmrSTATUS_IS_ACTIVE );
    6288:	e9 81       	ldd	r30, Y+1	; 0x01
    628a:	fa 81       	ldd	r31, Y+2	; 0x02
    628c:	82 89       	ldd	r24, Z+18	; 0x12
    628e:	8e 7f       	andi	r24, 0xFE	; 254
    6290:	e9 81       	ldd	r30, Y+1	; 0x01
    6292:	fa 81       	ldd	r31, Y+2	; 0x02
    6294:	82 8b       	std	Z+18, r24	; 0x12
        }

        /* Call the timer callback. */
        traceTIMER_EXPIRED( pxTimer );
        pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    6296:	e9 81       	ldd	r30, Y+1	; 0x01
    6298:	fa 81       	ldd	r31, Y+2	; 0x02
    629a:	00 88       	ldd	r0, Z+16	; 0x10
    629c:	f1 89       	ldd	r31, Z+17	; 0x11
    629e:	e0 2d       	mov	r30, r0
    62a0:	89 81       	ldd	r24, Y+1	; 0x01
    62a2:	9a 81       	ldd	r25, Y+2	; 0x02
    62a4:	09 95       	icall
    }
    62a6:	26 96       	adiw	r28, 0x06	; 6
    62a8:	0f b6       	in	r0, 0x3f	; 63
    62aa:	f8 94       	cli
    62ac:	de bf       	out	0x3e, r29	; 62
    62ae:	0f be       	out	0x3f, r0	; 63
    62b0:	cd bf       	out	0x3d, r28	; 61
    62b2:	cf 91       	pop	r28
    62b4:	df 91       	pop	r29
    62b6:	08 95       	ret

000062b8 <prvTimerTask>:
/*-----------------------------------------------------------*/

    static portTASK_FUNCTION( prvTimerTask, pvParameters )
    {
    62b8:	df 93       	push	r29
    62ba:	cf 93       	push	r28
    62bc:	00 d0       	rcall	.+0      	; 0x62be <prvTimerTask+0x6>
    62be:	00 d0       	rcall	.+0      	; 0x62c0 <prvTimerTask+0x8>
    62c0:	0f 92       	push	r0
    62c2:	cd b7       	in	r28, 0x3d	; 61
    62c4:	de b7       	in	r29, 0x3e	; 62
    62c6:	9d 83       	std	Y+5, r25	; 0x05
    62c8:	8c 83       	std	Y+4, r24	; 0x04

        for( ; ; )
        {
            /* Query the timers list to see if it contains any timers, and if so,
             * obtain the time at which the next timer will expire. */
            xNextExpireTime = prvGetNextExpireTime( &xListWasEmpty );
    62ca:	ce 01       	movw	r24, r28
    62cc:	03 96       	adiw	r24, 0x03	; 3
    62ce:	0e 94 cb 31 	call	0x6396	; 0x6396 <prvGetNextExpireTime>
    62d2:	9a 83       	std	Y+2, r25	; 0x02
    62d4:	89 83       	std	Y+1, r24	; 0x01

            /* If a timer has expired, process it.  Otherwise, block this task
             * until either a timer does expire, or a command is received. */
            prvProcessTimerOrBlockTask( xNextExpireTime, xListWasEmpty );
    62d6:	2b 81       	ldd	r18, Y+3	; 0x03
    62d8:	89 81       	ldd	r24, Y+1	; 0x01
    62da:	9a 81       	ldd	r25, Y+2	; 0x02
    62dc:	62 2f       	mov	r22, r18
    62de:	0e 94 74 31 	call	0x62e8	; 0x62e8 <prvProcessTimerOrBlockTask>

            /* Empty the command queue. */
            prvProcessReceivedCommands();
    62e2:	0e 94 95 32 	call	0x652a	; 0x652a <prvProcessReceivedCommands>
    62e6:	f1 cf       	rjmp	.-30     	; 0x62ca <prvTimerTask+0x12>

000062e8 <prvProcessTimerOrBlockTask>:
    }
/*-----------------------------------------------------------*/

    static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime,
                                            BaseType_t xListWasEmpty )
    {
    62e8:	df 93       	push	r29
    62ea:	cf 93       	push	r28
    62ec:	00 d0       	rcall	.+0      	; 0x62ee <prvProcessTimerOrBlockTask+0x6>
    62ee:	00 d0       	rcall	.+0      	; 0x62f0 <prvProcessTimerOrBlockTask+0x8>
    62f0:	00 d0       	rcall	.+0      	; 0x62f2 <prvProcessTimerOrBlockTask+0xa>
    62f2:	cd b7       	in	r28, 0x3d	; 61
    62f4:	de b7       	in	r29, 0x3e	; 62
    62f6:	9d 83       	std	Y+5, r25	; 0x05
    62f8:	8c 83       	std	Y+4, r24	; 0x04
    62fa:	6e 83       	std	Y+6, r22	; 0x06
        TickType_t xTimeNow;
        BaseType_t xTimerListsWereSwitched;

        vTaskSuspendAll();
    62fc:	0e 94 6c 1e 	call	0x3cd8	; 0x3cd8 <vTaskSuspendAll>
            /* Obtain the time now to make an assessment as to whether the timer
             * has expired or not.  If obtaining the time causes the lists to switch
             * then don't process this timer as any timers that remained in the list
             * when the lists were switched will have been processed within the
             * prvSampleTimeNow() function. */
            xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    6300:	ce 01       	movw	r24, r28
    6302:	03 96       	adiw	r24, 0x03	; 3
    6304:	0e 94 ff 31 	call	0x63fe	; 0x63fe <prvSampleTimeNow>
    6308:	9a 83       	std	Y+2, r25	; 0x02
    630a:	89 83       	std	Y+1, r24	; 0x01

            if( xTimerListsWereSwitched == pdFALSE )
    630c:	8b 81       	ldd	r24, Y+3	; 0x03
    630e:	88 23       	and	r24, r24
    6310:	b9 f5       	brne	.+110    	; 0x6380 <prvProcessTimerOrBlockTask+0x98>
            {
                /* The tick count has not overflowed, has the timer expired? */
                if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
    6312:	8e 81       	ldd	r24, Y+6	; 0x06
    6314:	88 23       	and	r24, r24
    6316:	89 f4       	brne	.+34     	; 0x633a <prvProcessTimerOrBlockTask+0x52>
    6318:	2c 81       	ldd	r18, Y+4	; 0x04
    631a:	3d 81       	ldd	r19, Y+5	; 0x05
    631c:	89 81       	ldd	r24, Y+1	; 0x01
    631e:	9a 81       	ldd	r25, Y+2	; 0x02
    6320:	82 17       	cp	r24, r18
    6322:	93 07       	cpc	r25, r19
    6324:	50 f0       	brcs	.+20     	; 0x633a <prvProcessTimerOrBlockTask+0x52>
                {
                    ( void ) xTaskResumeAll();
    6326:	0e 94 78 1e 	call	0x3cf0	; 0x3cf0 <xTaskResumeAll>
                    prvProcessExpiredTimer( xNextExpireTime, xTimeNow );
    632a:	8c 81       	ldd	r24, Y+4	; 0x04
    632c:	9d 81       	ldd	r25, Y+5	; 0x05
    632e:	29 81       	ldd	r18, Y+1	; 0x01
    6330:	3a 81       	ldd	r19, Y+2	; 0x02
    6332:	b9 01       	movw	r22, r18
    6334:	0e 94 16 31 	call	0x622c	; 0x622c <prvProcessExpiredTimer>
    6338:	25 c0       	rjmp	.+74     	; 0x6384 <prvProcessTimerOrBlockTask+0x9c>
                     * time has not been reached yet.  This task should therefore
                     * block to wait for the next expire time or a command to be
                     * received - whichever comes first.  The following line cannot
                     * be reached unless xNextExpireTime > xTimeNow, except in the
                     * case when the current timer list is empty. */
                    if( xListWasEmpty != pdFALSE )
    633a:	8e 81       	ldd	r24, Y+6	; 0x06
    633c:	88 23       	and	r24, r24
    633e:	51 f0       	breq	.+20     	; 0x6354 <prvProcessTimerOrBlockTask+0x6c>
                    {
                        /* The current timer list is empty - is the overflow list
                         * also empty? */
                        xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
    6340:	e0 91 3c 08 	lds	r30, 0x083C
    6344:	f0 91 3d 08 	lds	r31, 0x083D
    6348:	80 81       	ld	r24, Z
    634a:	1e 82       	std	Y+6, r1	; 0x06
    634c:	88 23       	and	r24, r24
    634e:	11 f4       	brne	.+4      	; 0x6354 <prvProcessTimerOrBlockTask+0x6c>
    6350:	81 e0       	ldi	r24, 0x01	; 1
    6352:	8e 83       	std	Y+6, r24	; 0x06
                    }

                    vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ), xListWasEmpty );
    6354:	40 91 22 08 	lds	r20, 0x0822
    6358:	50 91 23 08 	lds	r21, 0x0823
    635c:	2c 81       	ldd	r18, Y+4	; 0x04
    635e:	3d 81       	ldd	r19, Y+5	; 0x05
    6360:	89 81       	ldd	r24, Y+1	; 0x01
    6362:	9a 81       	ldd	r25, Y+2	; 0x02
    6364:	28 1b       	sub	r18, r24
    6366:	39 0b       	sbc	r19, r25
    6368:	ca 01       	movw	r24, r20
    636a:	b9 01       	movw	r22, r18
    636c:	4e 81       	ldd	r20, Y+6	; 0x06
    636e:	0e 94 d8 1a 	call	0x35b0	; 0x35b0 <vQueueWaitForMessageRestricted>

                    if( xTaskResumeAll() == pdFALSE )
    6372:	0e 94 78 1e 	call	0x3cf0	; 0x3cf0 <xTaskResumeAll>
    6376:	88 23       	and	r24, r24
    6378:	29 f4       	brne	.+10     	; 0x6384 <prvProcessTimerOrBlockTask+0x9c>
                    {
                        /* Yield to wait for either a command to arrive, or the
                         * block time to expire.  If a command arrived between the
                         * critical section being exited and this yield then the yield
                         * will not cause the task to block. */
                        portYIELD_WITHIN_API();
    637a:	0e 94 56 09 	call	0x12ac	; 0x12ac <vPortYield>
    637e:	02 c0       	rjmp	.+4      	; 0x6384 <prvProcessTimerOrBlockTask+0x9c>
                    }
                }
            }
            else
            {
                ( void ) xTaskResumeAll();
    6380:	0e 94 78 1e 	call	0x3cf0	; 0x3cf0 <xTaskResumeAll>
            }
        }
    }
    6384:	26 96       	adiw	r28, 0x06	; 6
    6386:	0f b6       	in	r0, 0x3f	; 63
    6388:	f8 94       	cli
    638a:	de bf       	out	0x3e, r29	; 62
    638c:	0f be       	out	0x3f, r0	; 63
    638e:	cd bf       	out	0x3d, r28	; 61
    6390:	cf 91       	pop	r28
    6392:	df 91       	pop	r29
    6394:	08 95       	ret

00006396 <prvGetNextExpireTime>:
/*-----------------------------------------------------------*/

    static TickType_t prvGetNextExpireTime( BaseType_t * const pxListWasEmpty )
    {
    6396:	df 93       	push	r29
    6398:	cf 93       	push	r28
    639a:	00 d0       	rcall	.+0      	; 0x639c <prvGetNextExpireTime+0x6>
    639c:	00 d0       	rcall	.+0      	; 0x639e <prvGetNextExpireTime+0x8>
    639e:	0f 92       	push	r0
    63a0:	cd b7       	in	r28, 0x3d	; 61
    63a2:	de b7       	in	r29, 0x3e	; 62
    63a4:	9c 83       	std	Y+4, r25	; 0x04
    63a6:	8b 83       	std	Y+3, r24	; 0x03
         * the timer with the nearest expiry time will expire.  If there are no
         * active timers then just set the next expire time to 0.  That will cause
         * this task to unblock when the tick count overflows, at which point the
         * timer lists will be switched and the next expiry time can be
         * re-assessed.  */
        *pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
    63a8:	e0 91 3a 08 	lds	r30, 0x083A
    63ac:	f0 91 3b 08 	lds	r31, 0x083B
    63b0:	80 81       	ld	r24, Z
    63b2:	1d 82       	std	Y+5, r1	; 0x05
    63b4:	88 23       	and	r24, r24
    63b6:	11 f4       	brne	.+4      	; 0x63bc <prvGetNextExpireTime+0x26>
    63b8:	81 e0       	ldi	r24, 0x01	; 1
    63ba:	8d 83       	std	Y+5, r24	; 0x05
    63bc:	eb 81       	ldd	r30, Y+3	; 0x03
    63be:	fc 81       	ldd	r31, Y+4	; 0x04
    63c0:	8d 81       	ldd	r24, Y+5	; 0x05
    63c2:	80 83       	st	Z, r24

        if( *pxListWasEmpty == pdFALSE )
    63c4:	eb 81       	ldd	r30, Y+3	; 0x03
    63c6:	fc 81       	ldd	r31, Y+4	; 0x04
    63c8:	80 81       	ld	r24, Z
    63ca:	88 23       	and	r24, r24
    63cc:	61 f4       	brne	.+24     	; 0x63e6 <prvGetNextExpireTime+0x50>
        {
            xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    63ce:	e0 91 3a 08 	lds	r30, 0x083A
    63d2:	f0 91 3b 08 	lds	r31, 0x083B
    63d6:	05 80       	ldd	r0, Z+5	; 0x05
    63d8:	f6 81       	ldd	r31, Z+6	; 0x06
    63da:	e0 2d       	mov	r30, r0
    63dc:	80 81       	ld	r24, Z
    63de:	91 81       	ldd	r25, Z+1	; 0x01
    63e0:	9a 83       	std	Y+2, r25	; 0x02
    63e2:	89 83       	std	Y+1, r24	; 0x01
    63e4:	02 c0       	rjmp	.+4      	; 0x63ea <prvGetNextExpireTime+0x54>
        }
        else
        {
            /* Ensure the task unblocks when the tick count rolls over. */
            xNextExpireTime = ( TickType_t ) 0U;
    63e6:	1a 82       	std	Y+2, r1	; 0x02
    63e8:	19 82       	std	Y+1, r1	; 0x01
        }

        return xNextExpireTime;
    63ea:	89 81       	ldd	r24, Y+1	; 0x01
    63ec:	9a 81       	ldd	r25, Y+2	; 0x02
    }
    63ee:	0f 90       	pop	r0
    63f0:	0f 90       	pop	r0
    63f2:	0f 90       	pop	r0
    63f4:	0f 90       	pop	r0
    63f6:	0f 90       	pop	r0
    63f8:	cf 91       	pop	r28
    63fa:	df 91       	pop	r29
    63fc:	08 95       	ret

000063fe <prvSampleTimeNow>:
/*-----------------------------------------------------------*/

    static TickType_t prvSampleTimeNow( BaseType_t * const pxTimerListsWereSwitched )
    {
    63fe:	df 93       	push	r29
    6400:	cf 93       	push	r28
    6402:	00 d0       	rcall	.+0      	; 0x6404 <prvSampleTimeNow+0x6>
    6404:	00 d0       	rcall	.+0      	; 0x6406 <prvSampleTimeNow+0x8>
    6406:	cd b7       	in	r28, 0x3d	; 61
    6408:	de b7       	in	r29, 0x3e	; 62
    640a:	9c 83       	std	Y+4, r25	; 0x04
    640c:	8b 83       	std	Y+3, r24	; 0x03
        TickType_t xTimeNow;
        PRIVILEGED_DATA static TickType_t xLastTime = ( TickType_t ) 0U; /*lint !e956 Variable is only accessible to one task. */

        xTimeNow = xTaskGetTickCount();
    640e:	0e 94 c8 1f 	call	0x3f90	; 0x3f90 <xTaskGetTickCount>
    6412:	9a 83       	std	Y+2, r25	; 0x02
    6414:	89 83       	std	Y+1, r24	; 0x01

        if( xTimeNow < xLastTime )
    6416:	20 91 26 08 	lds	r18, 0x0826
    641a:	30 91 27 08 	lds	r19, 0x0827
    641e:	89 81       	ldd	r24, Y+1	; 0x01
    6420:	9a 81       	ldd	r25, Y+2	; 0x02
    6422:	82 17       	cp	r24, r18
    6424:	93 07       	cpc	r25, r19
    6426:	38 f4       	brcc	.+14     	; 0x6436 <prvSampleTimeNow+0x38>
        {
            prvSwitchTimerLists();
    6428:	0e 94 90 33 	call	0x6720	; 0x6720 <prvSwitchTimerLists>
            *pxTimerListsWereSwitched = pdTRUE;
    642c:	eb 81       	ldd	r30, Y+3	; 0x03
    642e:	fc 81       	ldd	r31, Y+4	; 0x04
    6430:	81 e0       	ldi	r24, 0x01	; 1
    6432:	80 83       	st	Z, r24
    6434:	03 c0       	rjmp	.+6      	; 0x643c <prvSampleTimeNow+0x3e>
        }
        else
        {
            *pxTimerListsWereSwitched = pdFALSE;
    6436:	eb 81       	ldd	r30, Y+3	; 0x03
    6438:	fc 81       	ldd	r31, Y+4	; 0x04
    643a:	10 82       	st	Z, r1
        }

        xLastTime = xTimeNow;
    643c:	89 81       	ldd	r24, Y+1	; 0x01
    643e:	9a 81       	ldd	r25, Y+2	; 0x02
    6440:	90 93 27 08 	sts	0x0827, r25
    6444:	80 93 26 08 	sts	0x0826, r24

        return xTimeNow;
    6448:	89 81       	ldd	r24, Y+1	; 0x01
    644a:	9a 81       	ldd	r25, Y+2	; 0x02
    }
    644c:	0f 90       	pop	r0
    644e:	0f 90       	pop	r0
    6450:	0f 90       	pop	r0
    6452:	0f 90       	pop	r0
    6454:	cf 91       	pop	r28
    6456:	df 91       	pop	r29
    6458:	08 95       	ret

0000645a <prvInsertTimerInActiveList>:

    static BaseType_t prvInsertTimerInActiveList( Timer_t * const pxTimer,
                                                  const TickType_t xNextExpiryTime,
                                                  const TickType_t xTimeNow,
                                                  const TickType_t xCommandTime )
    {
    645a:	df 93       	push	r29
    645c:	cf 93       	push	r28
    645e:	cd b7       	in	r28, 0x3d	; 61
    6460:	de b7       	in	r29, 0x3e	; 62
    6462:	29 97       	sbiw	r28, 0x09	; 9
    6464:	0f b6       	in	r0, 0x3f	; 63
    6466:	f8 94       	cli
    6468:	de bf       	out	0x3e, r29	; 62
    646a:	0f be       	out	0x3f, r0	; 63
    646c:	cd bf       	out	0x3d, r28	; 61
    646e:	9b 83       	std	Y+3, r25	; 0x03
    6470:	8a 83       	std	Y+2, r24	; 0x02
    6472:	7d 83       	std	Y+5, r23	; 0x05
    6474:	6c 83       	std	Y+4, r22	; 0x04
    6476:	5f 83       	std	Y+7, r21	; 0x07
    6478:	4e 83       	std	Y+6, r20	; 0x06
    647a:	39 87       	std	Y+9, r19	; 0x09
    647c:	28 87       	std	Y+8, r18	; 0x08
        BaseType_t xProcessTimerNow = pdFALSE;
    647e:	19 82       	std	Y+1, r1	; 0x01

        listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xNextExpiryTime );
    6480:	ea 81       	ldd	r30, Y+2	; 0x02
    6482:	fb 81       	ldd	r31, Y+3	; 0x03
    6484:	8c 81       	ldd	r24, Y+4	; 0x04
    6486:	9d 81       	ldd	r25, Y+5	; 0x05
    6488:	93 83       	std	Z+3, r25	; 0x03
    648a:	82 83       	std	Z+2, r24	; 0x02
        listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
    648c:	ea 81       	ldd	r30, Y+2	; 0x02
    648e:	fb 81       	ldd	r31, Y+3	; 0x03
    6490:	8a 81       	ldd	r24, Y+2	; 0x02
    6492:	9b 81       	ldd	r25, Y+3	; 0x03
    6494:	91 87       	std	Z+9, r25	; 0x09
    6496:	80 87       	std	Z+8, r24	; 0x08

        if( xNextExpiryTime <= xTimeNow )
    6498:	2c 81       	ldd	r18, Y+4	; 0x04
    649a:	3d 81       	ldd	r19, Y+5	; 0x05
    649c:	8e 81       	ldd	r24, Y+6	; 0x06
    649e:	9f 81       	ldd	r25, Y+7	; 0x07
    64a0:	82 17       	cp	r24, r18
    64a2:	93 07       	cpc	r25, r19
    64a4:	e0 f0       	brcs	.+56     	; 0x64de <prvInsertTimerInActiveList+0x84>
        {
            /* Has the expiry time elapsed between the command to start/reset a
             * timer was issued, and the time the command was processed? */
            if( ( ( TickType_t ) ( xTimeNow - xCommandTime ) ) >= pxTimer->xTimerPeriodInTicks ) /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    64a6:	2e 81       	ldd	r18, Y+6	; 0x06
    64a8:	3f 81       	ldd	r19, Y+7	; 0x07
    64aa:	88 85       	ldd	r24, Y+8	; 0x08
    64ac:	99 85       	ldd	r25, Y+9	; 0x09
    64ae:	28 1b       	sub	r18, r24
    64b0:	39 0b       	sbc	r19, r25
    64b2:	ea 81       	ldd	r30, Y+2	; 0x02
    64b4:	fb 81       	ldd	r31, Y+3	; 0x03
    64b6:	84 85       	ldd	r24, Z+12	; 0x0c
    64b8:	95 85       	ldd	r25, Z+13	; 0x0d
    64ba:	28 17       	cp	r18, r24
    64bc:	39 07       	cpc	r19, r25
    64be:	18 f0       	brcs	.+6      	; 0x64c6 <prvInsertTimerInActiveList+0x6c>
            {
                /* The time between a command being issued and the command being
                 * processed actually exceeds the timers period.  */
                xProcessTimerNow = pdTRUE;
    64c0:	81 e0       	ldi	r24, 0x01	; 1
    64c2:	89 83       	std	Y+1, r24	; 0x01
    64c4:	28 c0       	rjmp	.+80     	; 0x6516 <prvInsertTimerInActiveList+0xbc>
            }
            else
            {
                vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
    64c6:	80 91 3c 08 	lds	r24, 0x083C
    64ca:	90 91 3d 08 	lds	r25, 0x083D
    64ce:	2a 81       	ldd	r18, Y+2	; 0x02
    64d0:	3b 81       	ldd	r19, Y+3	; 0x03
    64d2:	2e 5f       	subi	r18, 0xFE	; 254
    64d4:	3f 4f       	sbci	r19, 0xFF	; 255
    64d6:	b9 01       	movw	r22, r18
    64d8:	0e 94 0d 11 	call	0x221a	; 0x221a <vListInsert>
    64dc:	1c c0       	rjmp	.+56     	; 0x6516 <prvInsertTimerInActiveList+0xbc>
            }
        }
        else
        {
            if( ( xTimeNow < xCommandTime ) && ( xNextExpiryTime >= xCommandTime ) )
    64de:	2e 81       	ldd	r18, Y+6	; 0x06
    64e0:	3f 81       	ldd	r19, Y+7	; 0x07
    64e2:	88 85       	ldd	r24, Y+8	; 0x08
    64e4:	99 85       	ldd	r25, Y+9	; 0x09
    64e6:	28 17       	cp	r18, r24
    64e8:	39 07       	cpc	r19, r25
    64ea:	50 f4       	brcc	.+20     	; 0x6500 <prvInsertTimerInActiveList+0xa6>
    64ec:	2c 81       	ldd	r18, Y+4	; 0x04
    64ee:	3d 81       	ldd	r19, Y+5	; 0x05
    64f0:	88 85       	ldd	r24, Y+8	; 0x08
    64f2:	99 85       	ldd	r25, Y+9	; 0x09
    64f4:	28 17       	cp	r18, r24
    64f6:	39 07       	cpc	r19, r25
    64f8:	18 f0       	brcs	.+6      	; 0x6500 <prvInsertTimerInActiveList+0xa6>
            {
                /* If, since the command was issued, the tick count has overflowed
                 * but the expiry time has not, then the timer must have already passed
                 * its expiry time and should be processed immediately. */
                xProcessTimerNow = pdTRUE;
    64fa:	81 e0       	ldi	r24, 0x01	; 1
    64fc:	89 83       	std	Y+1, r24	; 0x01
    64fe:	0b c0       	rjmp	.+22     	; 0x6516 <prvInsertTimerInActiveList+0xbc>
            }
            else
            {
                vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
    6500:	80 91 3a 08 	lds	r24, 0x083A
    6504:	90 91 3b 08 	lds	r25, 0x083B
    6508:	2a 81       	ldd	r18, Y+2	; 0x02
    650a:	3b 81       	ldd	r19, Y+3	; 0x03
    650c:	2e 5f       	subi	r18, 0xFE	; 254
    650e:	3f 4f       	sbci	r19, 0xFF	; 255
    6510:	b9 01       	movw	r22, r18
    6512:	0e 94 0d 11 	call	0x221a	; 0x221a <vListInsert>
            }
        }

        return xProcessTimerNow;
    6516:	89 81       	ldd	r24, Y+1	; 0x01
    }
    6518:	29 96       	adiw	r28, 0x09	; 9
    651a:	0f b6       	in	r0, 0x3f	; 63
    651c:	f8 94       	cli
    651e:	de bf       	out	0x3e, r29	; 62
    6520:	0f be       	out	0x3f, r0	; 63
    6522:	cd bf       	out	0x3d, r28	; 61
    6524:	cf 91       	pop	r28
    6526:	df 91       	pop	r29
    6528:	08 95       	ret

0000652a <prvProcessReceivedCommands>:
/*-----------------------------------------------------------*/

    static void prvProcessReceivedCommands( void )
    {
    652a:	df 93       	push	r29
    652c:	cf 93       	push	r28
    652e:	cd b7       	in	r28, 0x3d	; 61
    6530:	de b7       	in	r29, 0x3e	; 62
    6532:	2c 97       	sbiw	r28, 0x0c	; 12
    6534:	0f b6       	in	r0, 0x3f	; 63
    6536:	f8 94       	cli
    6538:	de bf       	out	0x3e, r29	; 62
    653a:	0f be       	out	0x3f, r0	; 63
    653c:	cd bf       	out	0x3d, r28	; 61
    653e:	d8 c0       	rjmp	.+432    	; 0x66f0 <prvProcessReceivedCommands+0x1c6>
                }
            #endif /* INCLUDE_xTimerPendFunctionCall */

            /* Commands that are positive are timer commands rather than pended
             * function calls. */
            if( xMessage.xMessageID >= ( BaseType_t ) 0 )
    6540:	8d 81       	ldd	r24, Y+5	; 0x05
    6542:	88 23       	and	r24, r24
    6544:	0c f4       	brge	.+2      	; 0x6548 <prvProcessReceivedCommands+0x1e>
    6546:	d4 c0       	rjmp	.+424    	; 0x66f0 <prvProcessReceivedCommands+0x1c6>
            {
                /* The messages uses the xTimerParameters member to work on a
                 * software timer. */
                pxTimer = xMessage.u.xTimerParameters.pxTimer;
    6548:	88 85       	ldd	r24, Y+8	; 0x08
    654a:	99 85       	ldd	r25, Y+9	; 0x09
    654c:	9c 83       	std	Y+4, r25	; 0x04
    654e:	8b 83       	std	Y+3, r24	; 0x03

                if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdFALSE ) /*lint !e961. The cast is only redundant when NULL is passed into the macro. */
    6550:	eb 81       	ldd	r30, Y+3	; 0x03
    6552:	fc 81       	ldd	r31, Y+4	; 0x04
    6554:	82 85       	ldd	r24, Z+10	; 0x0a
    6556:	93 85       	ldd	r25, Z+11	; 0x0b
    6558:	00 97       	sbiw	r24, 0x00	; 0
    655a:	29 f0       	breq	.+10     	; 0x6566 <prvProcessReceivedCommands+0x3c>
                {
                    /* The timer is in a list, remove it. */
                    ( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    655c:	8b 81       	ldd	r24, Y+3	; 0x03
    655e:	9c 81       	ldd	r25, Y+4	; 0x04
    6560:	02 96       	adiw	r24, 0x02	; 2
    6562:	0e 94 79 11 	call	0x22f2	; 0x22f2 <uxListRemove>
                 *  it must be present in the function call.  prvSampleTimeNow() must be
                 *  called after the message is received from xTimerQueue so there is no
                 *  possibility of a higher priority task adding a message to the message
                 *  queue with a time that is ahead of the timer daemon task (because it
                 *  pre-empted the timer daemon task after the xTimeNow value was set). */
                xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    6566:	ce 01       	movw	r24, r28
    6568:	0a 96       	adiw	r24, 0x0a	; 10
    656a:	0e 94 ff 31 	call	0x63fe	; 0x63fe <prvSampleTimeNow>
    656e:	9a 83       	std	Y+2, r25	; 0x02
    6570:	89 83       	std	Y+1, r24	; 0x01

                switch( xMessage.xMessageID )
    6572:	8d 81       	ldd	r24, Y+5	; 0x05
    6574:	28 2f       	mov	r18, r24
    6576:	33 27       	eor	r19, r19
    6578:	27 fd       	sbrc	r18, 7
    657a:	30 95       	com	r19
    657c:	3c 87       	std	Y+12, r19	; 0x0c
    657e:	2b 87       	std	Y+11, r18	; 0x0b
    6580:	8b 85       	ldd	r24, Y+11	; 0x0b
    6582:	9c 85       	ldd	r25, Y+12	; 0x0c
    6584:	85 30       	cpi	r24, 0x05	; 5
    6586:	91 05       	cpc	r25, r1
    6588:	09 f4       	brne	.+2      	; 0x658c <prvProcessReceivedCommands+0x62>
    658a:	9d c0       	rjmp	.+314    	; 0x66c6 <prvProcessReceivedCommands+0x19c>
    658c:	2b 85       	ldd	r18, Y+11	; 0x0b
    658e:	3c 85       	ldd	r19, Y+12	; 0x0c
    6590:	26 30       	cpi	r18, 0x06	; 6
    6592:	31 05       	cpc	r19, r1
    6594:	9c f4       	brge	.+38     	; 0x65bc <prvProcessReceivedCommands+0x92>
    6596:	8b 85       	ldd	r24, Y+11	; 0x0b
    6598:	9c 85       	ldd	r25, Y+12	; 0x0c
    659a:	83 30       	cpi	r24, 0x03	; 3
    659c:	91 05       	cpc	r25, r1
    659e:	09 f4       	brne	.+2      	; 0x65a2 <prvProcessReceivedCommands+0x78>
    65a0:	68 c0       	rjmp	.+208    	; 0x6672 <prvProcessReceivedCommands+0x148>
    65a2:	2b 85       	ldd	r18, Y+11	; 0x0b
    65a4:	3c 85       	ldd	r19, Y+12	; 0x0c
    65a6:	24 30       	cpi	r18, 0x04	; 4
    65a8:	31 05       	cpc	r19, r1
    65aa:	0c f0       	brlt	.+2      	; 0x65ae <prvProcessReceivedCommands+0x84>
    65ac:	6a c0       	rjmp	.+212    	; 0x6682 <prvProcessReceivedCommands+0x158>
    65ae:	8b 85       	ldd	r24, Y+11	; 0x0b
    65b0:	9c 85       	ldd	r25, Y+12	; 0x0c
    65b2:	81 30       	cpi	r24, 0x01	; 1
    65b4:	91 05       	cpc	r25, r1
    65b6:	0c f4       	brge	.+2      	; 0x65ba <prvProcessReceivedCommands+0x90>
    65b8:	9b c0       	rjmp	.+310    	; 0x66f0 <prvProcessReceivedCommands+0x1c6>
    65ba:	12 c0       	rjmp	.+36     	; 0x65e0 <prvProcessReceivedCommands+0xb6>
    65bc:	2b 85       	ldd	r18, Y+11	; 0x0b
    65be:	3c 85       	ldd	r19, Y+12	; 0x0c
    65c0:	28 30       	cpi	r18, 0x08	; 8
    65c2:	31 05       	cpc	r19, r1
    65c4:	09 f4       	brne	.+2      	; 0x65c8 <prvProcessReceivedCommands+0x9e>
    65c6:	55 c0       	rjmp	.+170    	; 0x6672 <prvProcessReceivedCommands+0x148>
    65c8:	8b 85       	ldd	r24, Y+11	; 0x0b
    65ca:	9c 85       	ldd	r25, Y+12	; 0x0c
    65cc:	88 30       	cpi	r24, 0x08	; 8
    65ce:	91 05       	cpc	r25, r1
    65d0:	3c f0       	brlt	.+14     	; 0x65e0 <prvProcessReceivedCommands+0xb6>
    65d2:	2b 85       	ldd	r18, Y+11	; 0x0b
    65d4:	3c 85       	ldd	r19, Y+12	; 0x0c
    65d6:	29 30       	cpi	r18, 0x09	; 9
    65d8:	31 05       	cpc	r19, r1
    65da:	09 f4       	brne	.+2      	; 0x65de <prvProcessReceivedCommands+0xb4>
    65dc:	52 c0       	rjmp	.+164    	; 0x6682 <prvProcessReceivedCommands+0x158>
    65de:	88 c0       	rjmp	.+272    	; 0x66f0 <prvProcessReceivedCommands+0x1c6>
                    case tmrCOMMAND_START:
                    case tmrCOMMAND_START_FROM_ISR:
                    case tmrCOMMAND_RESET:
                    case tmrCOMMAND_RESET_FROM_ISR:
                        /* Start or restart a timer. */
                        pxTimer->ucStatus |= tmrSTATUS_IS_ACTIVE;
    65e0:	eb 81       	ldd	r30, Y+3	; 0x03
    65e2:	fc 81       	ldd	r31, Y+4	; 0x04
    65e4:	82 89       	ldd	r24, Z+18	; 0x12
    65e6:	81 60       	ori	r24, 0x01	; 1
    65e8:	eb 81       	ldd	r30, Y+3	; 0x03
    65ea:	fc 81       	ldd	r31, Y+4	; 0x04
    65ec:	82 8b       	std	Z+18, r24	; 0x12

                        if( prvInsertTimerInActiveList( pxTimer, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.u.xTimerParameters.xMessageValue ) != pdFALSE )
    65ee:	2e 81       	ldd	r18, Y+6	; 0x06
    65f0:	3f 81       	ldd	r19, Y+7	; 0x07
    65f2:	eb 81       	ldd	r30, Y+3	; 0x03
    65f4:	fc 81       	ldd	r31, Y+4	; 0x04
    65f6:	84 85       	ldd	r24, Z+12	; 0x0c
    65f8:	95 85       	ldd	r25, Z+13	; 0x0d
    65fa:	a9 01       	movw	r20, r18
    65fc:	48 0f       	add	r20, r24
    65fe:	59 1f       	adc	r21, r25
    6600:	ee 81       	ldd	r30, Y+6	; 0x06
    6602:	ff 81       	ldd	r31, Y+7	; 0x07
    6604:	8b 81       	ldd	r24, Y+3	; 0x03
    6606:	9c 81       	ldd	r25, Y+4	; 0x04
    6608:	29 81       	ldd	r18, Y+1	; 0x01
    660a:	3a 81       	ldd	r19, Y+2	; 0x02
    660c:	ba 01       	movw	r22, r20
    660e:	a9 01       	movw	r20, r18
    6610:	9f 01       	movw	r18, r30
    6612:	0e 94 2d 32 	call	0x645a	; 0x645a <prvInsertTimerInActiveList>
    6616:	88 23       	and	r24, r24
    6618:	09 f4       	brne	.+2      	; 0x661c <prvProcessReceivedCommands+0xf2>
    661a:	6a c0       	rjmp	.+212    	; 0x66f0 <prvProcessReceivedCommands+0x1c6>
                        {
                            /* The timer expired before it was added to the active
                             * timer list.  Process it now. */
                            if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
    661c:	eb 81       	ldd	r30, Y+3	; 0x03
    661e:	fc 81       	ldd	r31, Y+4	; 0x04
    6620:	82 89       	ldd	r24, Z+18	; 0x12
    6622:	88 2f       	mov	r24, r24
    6624:	90 e0       	ldi	r25, 0x00	; 0
    6626:	84 70       	andi	r24, 0x04	; 4
    6628:	90 70       	andi	r25, 0x00	; 0
    662a:	00 97       	sbiw	r24, 0x00	; 0
    662c:	91 f0       	breq	.+36     	; 0x6652 <prvProcessReceivedCommands+0x128>
                            {
                                prvReloadTimer( pxTimer, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow );
    662e:	2e 81       	ldd	r18, Y+6	; 0x06
    6630:	3f 81       	ldd	r19, Y+7	; 0x07
    6632:	eb 81       	ldd	r30, Y+3	; 0x03
    6634:	fc 81       	ldd	r31, Y+4	; 0x04
    6636:	84 85       	ldd	r24, Z+12	; 0x0c
    6638:	95 85       	ldd	r25, Z+13	; 0x0d
    663a:	a9 01       	movw	r20, r18
    663c:	48 0f       	add	r20, r24
    663e:	59 1f       	adc	r21, r25
    6640:	8b 81       	ldd	r24, Y+3	; 0x03
    6642:	9c 81       	ldd	r25, Y+4	; 0x04
    6644:	29 81       	ldd	r18, Y+1	; 0x01
    6646:	3a 81       	ldd	r19, Y+2	; 0x02
    6648:	ba 01       	movw	r22, r20
    664a:	a9 01       	movw	r20, r18
    664c:	0e 94 d7 30 	call	0x61ae	; 0x61ae <prvReloadTimer>
    6650:	07 c0       	rjmp	.+14     	; 0x6660 <prvProcessReceivedCommands+0x136>
                            }
                            else
                            {
                                pxTimer->ucStatus &= ( ( uint8_t ) ~tmrSTATUS_IS_ACTIVE );
    6652:	eb 81       	ldd	r30, Y+3	; 0x03
    6654:	fc 81       	ldd	r31, Y+4	; 0x04
    6656:	82 89       	ldd	r24, Z+18	; 0x12
    6658:	8e 7f       	andi	r24, 0xFE	; 254
    665a:	eb 81       	ldd	r30, Y+3	; 0x03
    665c:	fc 81       	ldd	r31, Y+4	; 0x04
    665e:	82 8b       	std	Z+18, r24	; 0x12
                            }

                            /* Call the timer callback. */
                            traceTIMER_EXPIRED( pxTimer );
                            pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    6660:	eb 81       	ldd	r30, Y+3	; 0x03
    6662:	fc 81       	ldd	r31, Y+4	; 0x04
    6664:	00 88       	ldd	r0, Z+16	; 0x10
    6666:	f1 89       	ldd	r31, Z+17	; 0x11
    6668:	e0 2d       	mov	r30, r0
    666a:	8b 81       	ldd	r24, Y+3	; 0x03
    666c:	9c 81       	ldd	r25, Y+4	; 0x04
    666e:	09 95       	icall
    6670:	3f c0       	rjmp	.+126    	; 0x66f0 <prvProcessReceivedCommands+0x1c6>
                        break;

                    case tmrCOMMAND_STOP:
                    case tmrCOMMAND_STOP_FROM_ISR:
                        /* The timer has already been removed from the active list. */
                        pxTimer->ucStatus &= ( ( uint8_t ) ~tmrSTATUS_IS_ACTIVE );
    6672:	eb 81       	ldd	r30, Y+3	; 0x03
    6674:	fc 81       	ldd	r31, Y+4	; 0x04
    6676:	82 89       	ldd	r24, Z+18	; 0x12
    6678:	8e 7f       	andi	r24, 0xFE	; 254
    667a:	eb 81       	ldd	r30, Y+3	; 0x03
    667c:	fc 81       	ldd	r31, Y+4	; 0x04
    667e:	82 8b       	std	Z+18, r24	; 0x12
    6680:	37 c0       	rjmp	.+110    	; 0x66f0 <prvProcessReceivedCommands+0x1c6>
                        break;

                    case tmrCOMMAND_CHANGE_PERIOD:
                    case tmrCOMMAND_CHANGE_PERIOD_FROM_ISR:
                        pxTimer->ucStatus |= tmrSTATUS_IS_ACTIVE;
    6682:	eb 81       	ldd	r30, Y+3	; 0x03
    6684:	fc 81       	ldd	r31, Y+4	; 0x04
    6686:	82 89       	ldd	r24, Z+18	; 0x12
    6688:	81 60       	ori	r24, 0x01	; 1
    668a:	eb 81       	ldd	r30, Y+3	; 0x03
    668c:	fc 81       	ldd	r31, Y+4	; 0x04
    668e:	82 8b       	std	Z+18, r24	; 0x12
                        pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
    6690:	8e 81       	ldd	r24, Y+6	; 0x06
    6692:	9f 81       	ldd	r25, Y+7	; 0x07
    6694:	eb 81       	ldd	r30, Y+3	; 0x03
    6696:	fc 81       	ldd	r31, Y+4	; 0x04
    6698:	95 87       	std	Z+13, r25	; 0x0d
    669a:	84 87       	std	Z+12, r24	; 0x0c
                         * be longer or shorter than the old one.  The command time is
                         * therefore set to the current time, and as the period cannot
                         * be zero the next expiry time can only be in the future,
                         * meaning (unlike for the xTimerStart() case above) there is
                         * no fail case that needs to be handled here. */
                        ( void ) prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
    669c:	eb 81       	ldd	r30, Y+3	; 0x03
    669e:	fc 81       	ldd	r31, Y+4	; 0x04
    66a0:	24 85       	ldd	r18, Z+12	; 0x0c
    66a2:	35 85       	ldd	r19, Z+13	; 0x0d
    66a4:	89 81       	ldd	r24, Y+1	; 0x01
    66a6:	9a 81       	ldd	r25, Y+2	; 0x02
    66a8:	a9 01       	movw	r20, r18
    66aa:	48 0f       	add	r20, r24
    66ac:	59 1f       	adc	r21, r25
    66ae:	8b 81       	ldd	r24, Y+3	; 0x03
    66b0:	9c 81       	ldd	r25, Y+4	; 0x04
    66b2:	29 81       	ldd	r18, Y+1	; 0x01
    66b4:	3a 81       	ldd	r19, Y+2	; 0x02
    66b6:	e9 81       	ldd	r30, Y+1	; 0x01
    66b8:	fa 81       	ldd	r31, Y+2	; 0x02
    66ba:	ba 01       	movw	r22, r20
    66bc:	a9 01       	movw	r20, r18
    66be:	9f 01       	movw	r18, r30
    66c0:	0e 94 2d 32 	call	0x645a	; 0x645a <prvInsertTimerInActiveList>
    66c4:	15 c0       	rjmp	.+42     	; 0x66f0 <prvProcessReceivedCommands+0x1c6>
                        #if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
                            {
                                /* The timer has already been removed from the active list,
                                 * just free up the memory if the memory was dynamically
                                 * allocated. */
                                if( ( pxTimer->ucStatus & tmrSTATUS_IS_STATICALLY_ALLOCATED ) == ( uint8_t ) 0 )
    66c6:	eb 81       	ldd	r30, Y+3	; 0x03
    66c8:	fc 81       	ldd	r31, Y+4	; 0x04
    66ca:	82 89       	ldd	r24, Z+18	; 0x12
    66cc:	88 2f       	mov	r24, r24
    66ce:	90 e0       	ldi	r25, 0x00	; 0
    66d0:	82 70       	andi	r24, 0x02	; 2
    66d2:	90 70       	andi	r25, 0x00	; 0
    66d4:	00 97       	sbiw	r24, 0x00	; 0
    66d6:	29 f4       	brne	.+10     	; 0x66e2 <prvProcessReceivedCommands+0x1b8>
                                {
                                    vPortFree( pxTimer );
    66d8:	8b 81       	ldd	r24, Y+3	; 0x03
    66da:	9c 81       	ldd	r25, Y+4	; 0x04
    66dc:	0e 94 71 07 	call	0xee2	; 0xee2 <vPortFree>
    66e0:	07 c0       	rjmp	.+14     	; 0x66f0 <prvProcessReceivedCommands+0x1c6>
                                }
                                else
                                {
                                    pxTimer->ucStatus &= ( ( uint8_t ) ~tmrSTATUS_IS_ACTIVE );
    66e2:	eb 81       	ldd	r30, Y+3	; 0x03
    66e4:	fc 81       	ldd	r31, Y+4	; 0x04
    66e6:	82 89       	ldd	r24, Z+18	; 0x12
    66e8:	8e 7f       	andi	r24, 0xFE	; 254
    66ea:	eb 81       	ldd	r30, Y+3	; 0x03
    66ec:	fc 81       	ldd	r31, Y+4	; 0x04
    66ee:	82 8b       	std	Z+18, r24	; 0x12
        DaemonTaskMessage_t xMessage;
        Timer_t * pxTimer;
        BaseType_t xTimerListsWereSwitched;
        TickType_t xTimeNow;

        while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
    66f0:	80 91 22 08 	lds	r24, 0x0822
    66f4:	90 91 23 08 	lds	r25, 0x0823
    66f8:	9e 01       	movw	r18, r28
    66fa:	2b 5f       	subi	r18, 0xFB	; 251
    66fc:	3f 4f       	sbci	r19, 0xFF	; 255
    66fe:	b9 01       	movw	r22, r18
    6700:	40 e0       	ldi	r20, 0x00	; 0
    6702:	50 e0       	ldi	r21, 0x00	; 0
    6704:	0e 94 78 14 	call	0x28f0	; 0x28f0 <xQueueReceive>
    6708:	88 23       	and	r24, r24
    670a:	09 f0       	breq	.+2      	; 0x670e <prvProcessReceivedCommands+0x1e4>
    670c:	19 cf       	rjmp	.-462    	; 0x6540 <prvProcessReceivedCommands+0x16>
                        /* Don't expect to get here. */
                        break;
                }
            }
        }
    }
    670e:	2c 96       	adiw	r28, 0x0c	; 12
    6710:	0f b6       	in	r0, 0x3f	; 63
    6712:	f8 94       	cli
    6714:	de bf       	out	0x3e, r29	; 62
    6716:	0f be       	out	0x3f, r0	; 63
    6718:	cd bf       	out	0x3d, r28	; 61
    671a:	cf 91       	pop	r28
    671c:	df 91       	pop	r29
    671e:	08 95       	ret

00006720 <prvSwitchTimerLists>:
/*-----------------------------------------------------------*/

    static void prvSwitchTimerLists( void )
    {
    6720:	df 93       	push	r29
    6722:	cf 93       	push	r28
    6724:	00 d0       	rcall	.+0      	; 0x6726 <prvSwitchTimerLists+0x6>
    6726:	00 d0       	rcall	.+0      	; 0x6728 <prvSwitchTimerLists+0x8>
    6728:	cd b7       	in	r28, 0x3d	; 61
    672a:	de b7       	in	r29, 0x3e	; 62
    672c:	11 c0       	rjmp	.+34     	; 0x6750 <prvSwitchTimerLists+0x30>
         * If there are any timers still referenced from the current timer list
         * then they must have expired and should be processed before the lists
         * are switched. */
        while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
        {
            xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    672e:	e0 91 3a 08 	lds	r30, 0x083A
    6732:	f0 91 3b 08 	lds	r31, 0x083B
    6736:	05 80       	ldd	r0, Z+5	; 0x05
    6738:	f6 81       	ldd	r31, Z+6	; 0x06
    673a:	e0 2d       	mov	r30, r0
    673c:	80 81       	ld	r24, Z
    673e:	91 81       	ldd	r25, Z+1	; 0x01
    6740:	9c 83       	std	Y+4, r25	; 0x04
    6742:	8b 83       	std	Y+3, r24	; 0x03

            /* Process the expired timer.  For auto-reload timers, be careful to
             * process only expirations that occur on the current list.  Further
             * expirations must wait until after the lists are switched. */
            prvProcessExpiredTimer( xNextExpireTime, tmrMAX_TIME_BEFORE_OVERFLOW );
    6744:	8b 81       	ldd	r24, Y+3	; 0x03
    6746:	9c 81       	ldd	r25, Y+4	; 0x04
    6748:	6f ef       	ldi	r22, 0xFF	; 255
    674a:	7f ef       	ldi	r23, 0xFF	; 255
    674c:	0e 94 16 31 	call	0x622c	; 0x622c <prvProcessExpiredTimer>

        /* The tick count has overflowed.  The timer lists must be switched.
         * If there are any timers still referenced from the current timer list
         * then they must have expired and should be processed before the lists
         * are switched. */
        while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
    6750:	e0 91 3a 08 	lds	r30, 0x083A
    6754:	f0 91 3b 08 	lds	r31, 0x083B
    6758:	80 81       	ld	r24, Z
    675a:	88 23       	and	r24, r24
    675c:	41 f7       	brne	.-48     	; 0x672e <prvSwitchTimerLists+0xe>
             * process only expirations that occur on the current list.  Further
             * expirations must wait until after the lists are switched. */
            prvProcessExpiredTimer( xNextExpireTime, tmrMAX_TIME_BEFORE_OVERFLOW );
        }

        pxTemp = pxCurrentTimerList;
    675e:	80 91 3a 08 	lds	r24, 0x083A
    6762:	90 91 3b 08 	lds	r25, 0x083B
    6766:	9a 83       	std	Y+2, r25	; 0x02
    6768:	89 83       	std	Y+1, r24	; 0x01
        pxCurrentTimerList = pxOverflowTimerList;
    676a:	80 91 3c 08 	lds	r24, 0x083C
    676e:	90 91 3d 08 	lds	r25, 0x083D
    6772:	90 93 3b 08 	sts	0x083B, r25
    6776:	80 93 3a 08 	sts	0x083A, r24
        pxOverflowTimerList = pxTemp;
    677a:	89 81       	ldd	r24, Y+1	; 0x01
    677c:	9a 81       	ldd	r25, Y+2	; 0x02
    677e:	90 93 3d 08 	sts	0x083D, r25
    6782:	80 93 3c 08 	sts	0x083C, r24
    }
    6786:	0f 90       	pop	r0
    6788:	0f 90       	pop	r0
    678a:	0f 90       	pop	r0
    678c:	0f 90       	pop	r0
    678e:	cf 91       	pop	r28
    6790:	df 91       	pop	r29
    6792:	08 95       	ret

00006794 <prvCheckForValidListAndQueue>:
/*-----------------------------------------------------------*/

    static void prvCheckForValidListAndQueue( void )
    {
    6794:	df 93       	push	r29
    6796:	cf 93       	push	r28
    6798:	cd b7       	in	r28, 0x3d	; 61
    679a:	de b7       	in	r29, 0x3e	; 62
        /* Check that the list from which active timers are referenced, and the
         * queue used to communicate with the timer service, have been
         * initialised. */
        taskENTER_CRITICAL();
    679c:	0f b6       	in	r0, 0x3f	; 63
    679e:	f8 94       	cli
    67a0:	0f 92       	push	r0
        {
            if( xTimerQueue == NULL )
    67a2:	80 91 22 08 	lds	r24, 0x0822
    67a6:	90 91 23 08 	lds	r25, 0x0823
    67aa:	00 97       	sbiw	r24, 0x00	; 0
    67ac:	e9 f4       	brne	.+58     	; 0x67e8 <prvCheckForValidListAndQueue+0x54>
            {
                vListInitialise( &xActiveTimerList1 );
    67ae:	88 e2       	ldi	r24, 0x28	; 40
    67b0:	98 e0       	ldi	r25, 0x08	; 8
    67b2:	0e 94 8f 10 	call	0x211e	; 0x211e <vListInitialise>
                vListInitialise( &xActiveTimerList2 );
    67b6:	81 e3       	ldi	r24, 0x31	; 49
    67b8:	98 e0       	ldi	r25, 0x08	; 8
    67ba:	0e 94 8f 10 	call	0x211e	; 0x211e <vListInitialise>
                pxCurrentTimerList = &xActiveTimerList1;
    67be:	88 e2       	ldi	r24, 0x28	; 40
    67c0:	98 e0       	ldi	r25, 0x08	; 8
    67c2:	90 93 3b 08 	sts	0x083B, r25
    67c6:	80 93 3a 08 	sts	0x083A, r24
                pxOverflowTimerList = &xActiveTimerList2;
    67ca:	81 e3       	ldi	r24, 0x31	; 49
    67cc:	98 e0       	ldi	r25, 0x08	; 8
    67ce:	90 93 3d 08 	sts	0x083D, r25
    67d2:	80 93 3c 08 	sts	0x083C, r24

                        xTimerQueue = xQueueCreateStatic( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, ( UBaseType_t ) sizeof( DaemonTaskMessage_t ), &( ucStaticTimerQueueStorage[ 0 ] ), &xStaticTimerQueue );
                    }
                #else
                    {
                        xTimerQueue = xQueueCreate( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, sizeof( DaemonTaskMessage_t ) );
    67d6:	8a e0       	ldi	r24, 0x0A	; 10
    67d8:	65 e0       	ldi	r22, 0x05	; 5
    67da:	40 e0       	ldi	r20, 0x00	; 0
    67dc:	0e 94 70 12 	call	0x24e0	; 0x24e0 <xQueueGenericCreate>
    67e0:	90 93 23 08 	sts	0x0823, r25
    67e4:	80 93 22 08 	sts	0x0822, r24
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        taskEXIT_CRITICAL();
    67e8:	0f 90       	pop	r0
    67ea:	0f be       	out	0x3f, r0	; 63
    }
    67ec:	cf 91       	pop	r28
    67ee:	df 91       	pop	r29
    67f0:	08 95       	ret

000067f2 <xTimerIsTimerActive>:
/*-----------------------------------------------------------*/

    BaseType_t xTimerIsTimerActive( TimerHandle_t xTimer )
    {
    67f2:	df 93       	push	r29
    67f4:	cf 93       	push	r28
    67f6:	00 d0       	rcall	.+0      	; 0x67f8 <xTimerIsTimerActive+0x6>
    67f8:	00 d0       	rcall	.+0      	; 0x67fa <xTimerIsTimerActive+0x8>
    67fa:	0f 92       	push	r0
    67fc:	cd b7       	in	r28, 0x3d	; 61
    67fe:	de b7       	in	r29, 0x3e	; 62
    6800:	9d 83       	std	Y+5, r25	; 0x05
    6802:	8c 83       	std	Y+4, r24	; 0x04
        BaseType_t xReturn;
        Timer_t * pxTimer = xTimer;
    6804:	8c 81       	ldd	r24, Y+4	; 0x04
    6806:	9d 81       	ldd	r25, Y+5	; 0x05
    6808:	9a 83       	std	Y+2, r25	; 0x02
    680a:	89 83       	std	Y+1, r24	; 0x01

        configASSERT( xTimer );

        /* Is the timer in the list of active timers? */
        taskENTER_CRITICAL();
    680c:	0f b6       	in	r0, 0x3f	; 63
    680e:	f8 94       	cli
    6810:	0f 92       	push	r0
        {
            if( ( pxTimer->ucStatus & tmrSTATUS_IS_ACTIVE ) == 0 )
    6812:	e9 81       	ldd	r30, Y+1	; 0x01
    6814:	fa 81       	ldd	r31, Y+2	; 0x02
    6816:	82 89       	ldd	r24, Z+18	; 0x12
    6818:	88 2f       	mov	r24, r24
    681a:	90 e0       	ldi	r25, 0x00	; 0
    681c:	81 70       	andi	r24, 0x01	; 1
    681e:	90 70       	andi	r25, 0x00	; 0
    6820:	00 97       	sbiw	r24, 0x00	; 0
    6822:	11 f4       	brne	.+4      	; 0x6828 <xTimerIsTimerActive+0x36>
            {
                xReturn = pdFALSE;
    6824:	1b 82       	std	Y+3, r1	; 0x03
    6826:	02 c0       	rjmp	.+4      	; 0x682c <xTimerIsTimerActive+0x3a>
            }
            else
            {
                xReturn = pdTRUE;
    6828:	81 e0       	ldi	r24, 0x01	; 1
    682a:	8b 83       	std	Y+3, r24	; 0x03
            }
        }
        taskEXIT_CRITICAL();
    682c:	0f 90       	pop	r0
    682e:	0f be       	out	0x3f, r0	; 63

        return xReturn;
    6830:	8b 81       	ldd	r24, Y+3	; 0x03
    } /*lint !e818 Can't be pointer to const due to the typedef. */
    6832:	0f 90       	pop	r0
    6834:	0f 90       	pop	r0
    6836:	0f 90       	pop	r0
    6838:	0f 90       	pop	r0
    683a:	0f 90       	pop	r0
    683c:	cf 91       	pop	r28
    683e:	df 91       	pop	r29
    6840:	08 95       	ret

00006842 <pvTimerGetTimerID>:
/*-----------------------------------------------------------*/

    void * pvTimerGetTimerID( const TimerHandle_t xTimer )
    {
    6842:	df 93       	push	r29
    6844:	cf 93       	push	r28
    6846:	00 d0       	rcall	.+0      	; 0x6848 <pvTimerGetTimerID+0x6>
    6848:	00 d0       	rcall	.+0      	; 0x684a <pvTimerGetTimerID+0x8>
    684a:	00 d0       	rcall	.+0      	; 0x684c <pvTimerGetTimerID+0xa>
    684c:	cd b7       	in	r28, 0x3d	; 61
    684e:	de b7       	in	r29, 0x3e	; 62
    6850:	9e 83       	std	Y+6, r25	; 0x06
    6852:	8d 83       	std	Y+5, r24	; 0x05
        Timer_t * const pxTimer = xTimer;
    6854:	8d 81       	ldd	r24, Y+5	; 0x05
    6856:	9e 81       	ldd	r25, Y+6	; 0x06
    6858:	9c 83       	std	Y+4, r25	; 0x04
    685a:	8b 83       	std	Y+3, r24	; 0x03
        void * pvReturn;

        configASSERT( xTimer );

        taskENTER_CRITICAL();
    685c:	0f b6       	in	r0, 0x3f	; 63
    685e:	f8 94       	cli
    6860:	0f 92       	push	r0
        {
            pvReturn = pxTimer->pvTimerID;
    6862:	eb 81       	ldd	r30, Y+3	; 0x03
    6864:	fc 81       	ldd	r31, Y+4	; 0x04
    6866:	86 85       	ldd	r24, Z+14	; 0x0e
    6868:	97 85       	ldd	r25, Z+15	; 0x0f
    686a:	9a 83       	std	Y+2, r25	; 0x02
    686c:	89 83       	std	Y+1, r24	; 0x01
        }
        taskEXIT_CRITICAL();
    686e:	0f 90       	pop	r0
    6870:	0f be       	out	0x3f, r0	; 63

        return pvReturn;
    6872:	89 81       	ldd	r24, Y+1	; 0x01
    6874:	9a 81       	ldd	r25, Y+2	; 0x02
    }
    6876:	26 96       	adiw	r28, 0x06	; 6
    6878:	0f b6       	in	r0, 0x3f	; 63
    687a:	f8 94       	cli
    687c:	de bf       	out	0x3e, r29	; 62
    687e:	0f be       	out	0x3f, r0	; 63
    6880:	cd bf       	out	0x3d, r28	; 61
    6882:	cf 91       	pop	r28
    6884:	df 91       	pop	r29
    6886:	08 95       	ret

00006888 <vTimerSetTimerID>:
/*-----------------------------------------------------------*/

    void vTimerSetTimerID( TimerHandle_t xTimer,
                           void * pvNewID )
    {
    6888:	df 93       	push	r29
    688a:	cf 93       	push	r28
    688c:	00 d0       	rcall	.+0      	; 0x688e <vTimerSetTimerID+0x6>
    688e:	00 d0       	rcall	.+0      	; 0x6890 <vTimerSetTimerID+0x8>
    6890:	00 d0       	rcall	.+0      	; 0x6892 <vTimerSetTimerID+0xa>
    6892:	cd b7       	in	r28, 0x3d	; 61
    6894:	de b7       	in	r29, 0x3e	; 62
    6896:	9c 83       	std	Y+4, r25	; 0x04
    6898:	8b 83       	std	Y+3, r24	; 0x03
    689a:	7e 83       	std	Y+6, r23	; 0x06
    689c:	6d 83       	std	Y+5, r22	; 0x05
        Timer_t * const pxTimer = xTimer;
    689e:	8b 81       	ldd	r24, Y+3	; 0x03
    68a0:	9c 81       	ldd	r25, Y+4	; 0x04
    68a2:	9a 83       	std	Y+2, r25	; 0x02
    68a4:	89 83       	std	Y+1, r24	; 0x01

        configASSERT( xTimer );

        taskENTER_CRITICAL();
    68a6:	0f b6       	in	r0, 0x3f	; 63
    68a8:	f8 94       	cli
    68aa:	0f 92       	push	r0
        {
            pxTimer->pvTimerID = pvNewID;
    68ac:	e9 81       	ldd	r30, Y+1	; 0x01
    68ae:	fa 81       	ldd	r31, Y+2	; 0x02
    68b0:	8d 81       	ldd	r24, Y+5	; 0x05
    68b2:	9e 81       	ldd	r25, Y+6	; 0x06
    68b4:	97 87       	std	Z+15, r25	; 0x0f
    68b6:	86 87       	std	Z+14, r24	; 0x0e
        }
        taskEXIT_CRITICAL();
    68b8:	0f 90       	pop	r0
    68ba:	0f be       	out	0x3f, r0	; 63
    }
    68bc:	26 96       	adiw	r28, 0x06	; 6
    68be:	0f b6       	in	r0, 0x3f	; 63
    68c0:	f8 94       	cli
    68c2:	de bf       	out	0x3e, r29	; 62
    68c4:	0f be       	out	0x3f, r0	; 63
    68c6:	cd bf       	out	0x3d, r28	; 61
    68c8:	cf 91       	pop	r28
    68ca:	df 91       	pop	r29
    68cc:	08 95       	ret

000068ce <Handle_data>:
#define WAIT_TIME_PER_DUTY_CHANGE	30
//uint8_t ignitionState = LOGIC_LOW;
unsigned char state;

void Handle_data(States_GroupType *Sates_Ptr)
{
    68ce:	df 93       	push	r29
    68d0:	cf 93       	push	r28
    68d2:	00 d0       	rcall	.+0      	; 0x68d4 <Handle_data+0x6>
    68d4:	cd b7       	in	r28, 0x3d	; 61
    68d6:	de b7       	in	r29, 0x3e	; 62
    68d8:	9a 83       	std	Y+2, r25	; 0x02
    68da:	89 83       	std	Y+1, r24	; 0x01

	LCD_moveCursor(0, 0);
    68dc:	80 e0       	ldi	r24, 0x00	; 0
    68de:	60 e0       	ldi	r22, 0x00	; 0
    68e0:	0e 94 24 49 	call	0x9248	; 0x9248 <LCD_moveCursor>
	LCD_displayString("H:"); //hazard button
    68e4:	8d e6       	ldi	r24, 0x6D	; 109
    68e6:	90 e0       	ldi	r25, 0x00	; 0
    68e8:	0e 94 fb 48 	call	0x91f6	; 0x91f6 <LCD_displayString>
	LCD_intgerToString(Sates_Ptr->hazard_Btn);
    68ec:	e9 81       	ldd	r30, Y+1	; 0x01
    68ee:	fa 81       	ldd	r31, Y+2	; 0x02
    68f0:	83 81       	ldd	r24, Z+3	; 0x03
    68f2:	88 2f       	mov	r24, r24
    68f4:	90 e0       	ldi	r25, 0x00	; 0
    68f6:	0e 94 7f 49 	call	0x92fe	; 0x92fe <LCD_intgerToString>
	LCD_displayString(" L:");	//left indicator
    68fa:	80 e7       	ldi	r24, 0x70	; 112
    68fc:	90 e0       	ldi	r25, 0x00	; 0
    68fe:	0e 94 fb 48 	call	0x91f6	; 0x91f6 <LCD_displayString>
	LCD_intgerToString(Sates_Ptr->leftIndicator);
    6902:	e9 81       	ldd	r30, Y+1	; 0x01
    6904:	fa 81       	ldd	r31, Y+2	; 0x02
    6906:	82 81       	ldd	r24, Z+2	; 0x02
    6908:	88 2f       	mov	r24, r24
    690a:	90 e0       	ldi	r25, 0x00	; 0
    690c:	0e 94 7f 49 	call	0x92fe	; 0x92fe <LCD_intgerToString>
	LCD_moveCursor(1, 0);
    6910:	81 e0       	ldi	r24, 0x01	; 1
    6912:	60 e0       	ldi	r22, 0x00	; 0
    6914:	0e 94 24 49 	call	0x9248	; 0x9248 <LCD_moveCursor>
	LCD_displayString(" R:");	//right indicator
    6918:	84 e7       	ldi	r24, 0x74	; 116
    691a:	90 e0       	ldi	r25, 0x00	; 0
    691c:	0e 94 fb 48 	call	0x91f6	; 0x91f6 <LCD_displayString>
	LCD_intgerToString(Sates_Ptr->rightIndicator);
    6920:	e9 81       	ldd	r30, Y+1	; 0x01
    6922:	fa 81       	ldd	r31, Y+2	; 0x02
    6924:	81 81       	ldd	r24, Z+1	; 0x01
    6926:	88 2f       	mov	r24, r24
    6928:	90 e0       	ldi	r25, 0x00	; 0
    692a:	0e 94 7f 49 	call	0x92fe	; 0x92fe <LCD_intgerToString>
	LCD_displayString(" I:");	//ignition button
    692e:	88 e7       	ldi	r24, 0x78	; 120
    6930:	90 e0       	ldi	r25, 0x00	; 0
    6932:	0e 94 fb 48 	call	0x91f6	; 0x91f6 <LCD_displayString>
	LCD_intgerToString(Sates_Ptr->ignition_key);
    6936:	e9 81       	ldd	r30, Y+1	; 0x01
    6938:	fa 81       	ldd	r31, Y+2	; 0x02
    693a:	80 81       	ld	r24, Z
    693c:	88 2f       	mov	r24, r24
    693e:	90 e0       	ldi	r25, 0x00	; 0
    6940:	0e 94 7f 49 	call	0x92fe	; 0x92fe <LCD_intgerToString>

	if(Sates_Ptr->ignition_key==TRUE)
    6944:	e9 81       	ldd	r30, Y+1	; 0x01
    6946:	fa 81       	ldd	r31, Y+2	; 0x02
    6948:	80 81       	ld	r24, Z
    694a:	81 30       	cpi	r24, 0x01	; 1
    694c:	b1 f4       	brne	.+44     	; 0x697a <Handle_data+0xac>
	{
		if(Sates_Ptr->rightIndicator==TRUE)
    694e:	e9 81       	ldd	r30, Y+1	; 0x01
    6950:	fa 81       	ldd	r31, Y+2	; 0x02
    6952:	81 81       	ldd	r24, Z+1	; 0x01
    6954:	81 30       	cpi	r24, 0x01	; 1
    6956:	21 f4       	brne	.+8      	; 0x6960 <Handle_data+0x92>
		{
			state = RIGHT_INDICATOR;
    6958:	81 e0       	ldi	r24, 0x01	; 1
    695a:	80 93 4d 08 	sts	0x084D, r24
    695e:	10 c0       	rjmp	.+32     	; 0x6980 <Handle_data+0xb2>
		}
		else if(Sates_Ptr->leftIndicator==TRUE)
    6960:	e9 81       	ldd	r30, Y+1	; 0x01
    6962:	fa 81       	ldd	r31, Y+2	; 0x02
    6964:	82 81       	ldd	r24, Z+2	; 0x02
    6966:	81 30       	cpi	r24, 0x01	; 1
    6968:	21 f4       	brne	.+8      	; 0x6972 <Handle_data+0xa4>
		{
			state = LEFT_INDICATOR;
    696a:	82 e0       	ldi	r24, 0x02	; 2
    696c:	80 93 4d 08 	sts	0x084D, r24
    6970:	07 c0       	rjmp	.+14     	; 0x6980 <Handle_data+0xb2>
		}
		else{
			state = NO_INDICATOR;
    6972:	83 e0       	ldi	r24, 0x03	; 3
    6974:	80 93 4d 08 	sts	0x084D, r24
    6978:	03 c0       	rjmp	.+6      	; 0x6980 <Handle_data+0xb2>
		}
	}
	else{
		state = NO_INDICATOR;
    697a:	83 e0       	ldi	r24, 0x03	; 3
    697c:	80 93 4d 08 	sts	0x084D, r24
	}

	if(Sates_Ptr->hazard_Btn==TRUE)
    6980:	e9 81       	ldd	r30, Y+1	; 0x01
    6982:	fa 81       	ldd	r31, Y+2	; 0x02
    6984:	83 81       	ldd	r24, Z+3	; 0x03
    6986:	81 30       	cpi	r24, 0x01	; 1
    6988:	19 f4       	brne	.+6      	; 0x6990 <Handle_data+0xc2>
	{
		state = HAZARD_BUTTON;
    698a:	84 e0       	ldi	r24, 0x04	; 4
    698c:	80 93 4d 08 	sts	0x084D, r24
	}



	State_Handler();
    6990:	0e 94 cf 34 	call	0x699e	; 0x699e <State_Handler>
}
    6994:	0f 90       	pop	r0
    6996:	0f 90       	pop	r0
    6998:	cf 91       	pop	r28
    699a:	df 91       	pop	r29
    699c:	08 95       	ret

0000699e <State_Handler>:

void State_Handler(void)
{
    699e:	df 93       	push	r29
    69a0:	cf 93       	push	r28
    69a2:	00 d0       	rcall	.+0      	; 0x69a4 <State_Handler+0x6>
    69a4:	cd b7       	in	r28, 0x3d	; 61
    69a6:	de b7       	in	r29, 0x3e	; 62
	switch(state)
    69a8:	80 91 4d 08 	lds	r24, 0x084D
    69ac:	28 2f       	mov	r18, r24
    69ae:	30 e0       	ldi	r19, 0x00	; 0
    69b0:	3a 83       	std	Y+2, r19	; 0x02
    69b2:	29 83       	std	Y+1, r18	; 0x01
    69b4:	89 81       	ldd	r24, Y+1	; 0x01
    69b6:	9a 81       	ldd	r25, Y+2	; 0x02
    69b8:	82 30       	cpi	r24, 0x02	; 2
    69ba:	91 05       	cpc	r25, r1
    69bc:	e1 f0       	breq	.+56     	; 0x69f6 <State_Handler+0x58>
    69be:	29 81       	ldd	r18, Y+1	; 0x01
    69c0:	3a 81       	ldd	r19, Y+2	; 0x02
    69c2:	23 30       	cpi	r18, 0x03	; 3
    69c4:	31 05       	cpc	r19, r1
    69c6:	34 f4       	brge	.+12     	; 0x69d4 <State_Handler+0x36>
    69c8:	89 81       	ldd	r24, Y+1	; 0x01
    69ca:	9a 81       	ldd	r25, Y+2	; 0x02
    69cc:	81 30       	cpi	r24, 0x01	; 1
    69ce:	91 05       	cpc	r25, r1
    69d0:	79 f0       	breq	.+30     	; 0x69f0 <State_Handler+0x52>
    69d2:	16 c0       	rjmp	.+44     	; 0x6a00 <State_Handler+0x62>
    69d4:	29 81       	ldd	r18, Y+1	; 0x01
    69d6:	3a 81       	ldd	r19, Y+2	; 0x02
    69d8:	23 30       	cpi	r18, 0x03	; 3
    69da:	31 05       	cpc	r19, r1
    69dc:	31 f0       	breq	.+12     	; 0x69ea <State_Handler+0x4c>
    69de:	89 81       	ldd	r24, Y+1	; 0x01
    69e0:	9a 81       	ldd	r25, Y+2	; 0x02
    69e2:	84 30       	cpi	r24, 0x04	; 4
    69e4:	91 05       	cpc	r25, r1
    69e6:	51 f0       	breq	.+20     	; 0x69fc <State_Handler+0x5e>
    69e8:	0b c0       	rjmp	.+22     	; 0x6a00 <State_Handler+0x62>
	{
	case NO_INDICATOR:
		NoLED_Blink();
    69ea:	0e 94 98 38 	call	0x7130	; 0x7130 <NoLED_Blink>
    69ee:	08 c0       	rjmp	.+16     	; 0x6a00 <State_Handler+0x62>
		break;
	case RIGHT_INDICATOR:
		RightLED_Blink();
    69f0:	0e 94 05 35 	call	0x6a0a	; 0x6a0a <RightLED_Blink>
    69f4:	05 c0       	rjmp	.+10     	; 0x6a00 <State_Handler+0x62>
		break;
	case LEFT_INDICATOR:
		LeftLED_Blink();
    69f6:	0e 94 37 36 	call	0x6c6e	; 0x6c6e <LeftLED_Blink>
    69fa:	02 c0       	rjmp	.+4      	; 0x6a00 <State_Handler+0x62>
		break;
	case HAZARD_BUTTON:
		BothLEDS_Blink();
    69fc:	0e 94 69 37 	call	0x6ed2	; 0x6ed2 <BothLEDS_Blink>
		break;

	}

}
    6a00:	0f 90       	pop	r0
    6a02:	0f 90       	pop	r0
    6a04:	cf 91       	pop	r28
    6a06:	df 91       	pop	r29
    6a08:	08 95       	ret

00006a0a <RightLED_Blink>:


void RightLED_Blink(void)
{
    6a0a:	df 93       	push	r29
    6a0c:	cf 93       	push	r28
    6a0e:	cd b7       	in	r28, 0x3d	; 61
    6a10:	de b7       	in	r29, 0x3e	; 62
    6a12:	6e 97       	sbiw	r28, 0x1e	; 30
    6a14:	0f b6       	in	r0, 0x3f	; 63
    6a16:	f8 94       	cli
    6a18:	de bf       	out	0x3e, r29	; 62
    6a1a:	0f be       	out	0x3f, r0	; 63
    6a1c:	cd bf       	out	0x3d, r28	; 61
	int i = 0;
    6a1e:	1e 8e       	std	Y+30, r1	; 0x1e
    6a20:	1d 8e       	std	Y+29, r1	; 0x1d
	timer1_SetPWM_A(0);
    6a22:	80 e0       	ldi	r24, 0x00	; 0
    6a24:	0e 94 23 39 	call	0x7246	; 0x7246 <timer1_SetPWM_A>
	for(i = 2 ; i < 17 ; i++){
    6a28:	82 e0       	ldi	r24, 0x02	; 2
    6a2a:	90 e0       	ldi	r25, 0x00	; 0
    6a2c:	9e 8f       	std	Y+30, r25	; 0x1e
    6a2e:	8d 8f       	std	Y+29, r24	; 0x1d
    6a30:	82 c0       	rjmp	.+260    	; 0x6b36 <RightLED_Blink+0x12c>

		timer1_SetPWM_B((i*5));
    6a32:	2d 8d       	ldd	r18, Y+29	; 0x1d
    6a34:	3e 8d       	ldd	r19, Y+30	; 0x1e
    6a36:	c9 01       	movw	r24, r18
    6a38:	88 0f       	add	r24, r24
    6a3a:	99 1f       	adc	r25, r25
    6a3c:	88 0f       	add	r24, r24
    6a3e:	99 1f       	adc	r25, r25
    6a40:	82 0f       	add	r24, r18
    6a42:	93 1f       	adc	r25, r19
    6a44:	0e 94 d0 38 	call	0x71a0	; 0x71a0 <timer1_SetPWM_B>
    6a48:	80 e0       	ldi	r24, 0x00	; 0
    6a4a:	90 e0       	ldi	r25, 0x00	; 0
    6a4c:	a0 ef       	ldi	r26, 0xF0	; 240
    6a4e:	b1 e4       	ldi	r27, 0x41	; 65
    6a50:	89 8f       	std	Y+25, r24	; 0x19
    6a52:	9a 8f       	std	Y+26, r25	; 0x1a
    6a54:	ab 8f       	std	Y+27, r26	; 0x1b
    6a56:	bc 8f       	std	Y+28, r27	; 0x1c
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    6a58:	69 8d       	ldd	r22, Y+25	; 0x19
    6a5a:	7a 8d       	ldd	r23, Y+26	; 0x1a
    6a5c:	8b 8d       	ldd	r24, Y+27	; 0x1b
    6a5e:	9c 8d       	ldd	r25, Y+28	; 0x1c
    6a60:	20 e0       	ldi	r18, 0x00	; 0
    6a62:	30 e0       	ldi	r19, 0x00	; 0
    6a64:	4a e7       	ldi	r20, 0x7A	; 122
    6a66:	53 e4       	ldi	r21, 0x43	; 67
    6a68:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    6a6c:	dc 01       	movw	r26, r24
    6a6e:	cb 01       	movw	r24, r22
    6a70:	8d 8b       	std	Y+21, r24	; 0x15
    6a72:	9e 8b       	std	Y+22, r25	; 0x16
    6a74:	af 8b       	std	Y+23, r26	; 0x17
    6a76:	b8 8f       	std	Y+24, r27	; 0x18
	if (__tmp < 1.0)
    6a78:	6d 89       	ldd	r22, Y+21	; 0x15
    6a7a:	7e 89       	ldd	r23, Y+22	; 0x16
    6a7c:	8f 89       	ldd	r24, Y+23	; 0x17
    6a7e:	98 8d       	ldd	r25, Y+24	; 0x18
    6a80:	20 e0       	ldi	r18, 0x00	; 0
    6a82:	30 e0       	ldi	r19, 0x00	; 0
    6a84:	40 e8       	ldi	r20, 0x80	; 128
    6a86:	5f e3       	ldi	r21, 0x3F	; 63
    6a88:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    6a8c:	88 23       	and	r24, r24
    6a8e:	2c f4       	brge	.+10     	; 0x6a9a <RightLED_Blink+0x90>
		__ticks = 1;
    6a90:	81 e0       	ldi	r24, 0x01	; 1
    6a92:	90 e0       	ldi	r25, 0x00	; 0
    6a94:	9c 8b       	std	Y+20, r25	; 0x14
    6a96:	8b 8b       	std	Y+19, r24	; 0x13
    6a98:	3f c0       	rjmp	.+126    	; 0x6b18 <RightLED_Blink+0x10e>
	else if (__tmp > 65535)
    6a9a:	6d 89       	ldd	r22, Y+21	; 0x15
    6a9c:	7e 89       	ldd	r23, Y+22	; 0x16
    6a9e:	8f 89       	ldd	r24, Y+23	; 0x17
    6aa0:	98 8d       	ldd	r25, Y+24	; 0x18
    6aa2:	20 e0       	ldi	r18, 0x00	; 0
    6aa4:	3f ef       	ldi	r19, 0xFF	; 255
    6aa6:	4f e7       	ldi	r20, 0x7F	; 127
    6aa8:	57 e4       	ldi	r21, 0x47	; 71
    6aaa:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    6aae:	18 16       	cp	r1, r24
    6ab0:	4c f5       	brge	.+82     	; 0x6b04 <RightLED_Blink+0xfa>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    6ab2:	69 8d       	ldd	r22, Y+25	; 0x19
    6ab4:	7a 8d       	ldd	r23, Y+26	; 0x1a
    6ab6:	8b 8d       	ldd	r24, Y+27	; 0x1b
    6ab8:	9c 8d       	ldd	r25, Y+28	; 0x1c
    6aba:	20 e0       	ldi	r18, 0x00	; 0
    6abc:	30 e0       	ldi	r19, 0x00	; 0
    6abe:	40 e2       	ldi	r20, 0x20	; 32
    6ac0:	51 e4       	ldi	r21, 0x41	; 65
    6ac2:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    6ac6:	dc 01       	movw	r26, r24
    6ac8:	cb 01       	movw	r24, r22
    6aca:	bc 01       	movw	r22, r24
    6acc:	cd 01       	movw	r24, r26
    6ace:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    6ad2:	dc 01       	movw	r26, r24
    6ad4:	cb 01       	movw	r24, r22
    6ad6:	9c 8b       	std	Y+20, r25	; 0x14
    6ad8:	8b 8b       	std	Y+19, r24	; 0x13
    6ada:	0f c0       	rjmp	.+30     	; 0x6afa <RightLED_Blink+0xf0>
    6adc:	89 e1       	ldi	r24, 0x19	; 25
    6ade:	90 e0       	ldi	r25, 0x00	; 0
    6ae0:	9a 8b       	std	Y+18, r25	; 0x12
    6ae2:	89 8b       	std	Y+17, r24	; 0x11
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    6ae4:	89 89       	ldd	r24, Y+17	; 0x11
    6ae6:	9a 89       	ldd	r25, Y+18	; 0x12
    6ae8:	01 97       	sbiw	r24, 0x01	; 1
    6aea:	f1 f7       	brne	.-4      	; 0x6ae8 <RightLED_Blink+0xde>
    6aec:	9a 8b       	std	Y+18, r25	; 0x12
    6aee:	89 8b       	std	Y+17, r24	; 0x11
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    6af0:	8b 89       	ldd	r24, Y+19	; 0x13
    6af2:	9c 89       	ldd	r25, Y+20	; 0x14
    6af4:	01 97       	sbiw	r24, 0x01	; 1
    6af6:	9c 8b       	std	Y+20, r25	; 0x14
    6af8:	8b 8b       	std	Y+19, r24	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    6afa:	8b 89       	ldd	r24, Y+19	; 0x13
    6afc:	9c 89       	ldd	r25, Y+20	; 0x14
    6afe:	00 97       	sbiw	r24, 0x00	; 0
    6b00:	69 f7       	brne	.-38     	; 0x6adc <RightLED_Blink+0xd2>
    6b02:	14 c0       	rjmp	.+40     	; 0x6b2c <RightLED_Blink+0x122>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    6b04:	6d 89       	ldd	r22, Y+21	; 0x15
    6b06:	7e 89       	ldd	r23, Y+22	; 0x16
    6b08:	8f 89       	ldd	r24, Y+23	; 0x17
    6b0a:	98 8d       	ldd	r25, Y+24	; 0x18
    6b0c:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    6b10:	dc 01       	movw	r26, r24
    6b12:	cb 01       	movw	r24, r22
    6b14:	9c 8b       	std	Y+20, r25	; 0x14
    6b16:	8b 8b       	std	Y+19, r24	; 0x13
    6b18:	8b 89       	ldd	r24, Y+19	; 0x13
    6b1a:	9c 89       	ldd	r25, Y+20	; 0x14
    6b1c:	98 8b       	std	Y+16, r25	; 0x10
    6b1e:	8f 87       	std	Y+15, r24	; 0x0f
    6b20:	8f 85       	ldd	r24, Y+15	; 0x0f
    6b22:	98 89       	ldd	r25, Y+16	; 0x10
    6b24:	01 97       	sbiw	r24, 0x01	; 1
    6b26:	f1 f7       	brne	.-4      	; 0x6b24 <RightLED_Blink+0x11a>
    6b28:	98 8b       	std	Y+16, r25	; 0x10
    6b2a:	8f 87       	std	Y+15, r24	; 0x0f

void RightLED_Blink(void)
{
	int i = 0;
	timer1_SetPWM_A(0);
	for(i = 2 ; i < 17 ; i++){
    6b2c:	8d 8d       	ldd	r24, Y+29	; 0x1d
    6b2e:	9e 8d       	ldd	r25, Y+30	; 0x1e
    6b30:	01 96       	adiw	r24, 0x01	; 1
    6b32:	9e 8f       	std	Y+30, r25	; 0x1e
    6b34:	8d 8f       	std	Y+29, r24	; 0x1d
    6b36:	8d 8d       	ldd	r24, Y+29	; 0x1d
    6b38:	9e 8d       	ldd	r25, Y+30	; 0x1e
    6b3a:	81 31       	cpi	r24, 0x11	; 17
    6b3c:	91 05       	cpc	r25, r1
    6b3e:	0c f4       	brge	.+2      	; 0x6b42 <RightLED_Blink+0x138>
    6b40:	78 cf       	rjmp	.-272    	; 0x6a32 <RightLED_Blink+0x28>

		timer1_SetPWM_B((i*5));
		_delay_ms(WAIT_TIME_PER_DUTY_CHANGE);
	}
	for(i = 16 ; i > 1 ; i--){
    6b42:	80 e1       	ldi	r24, 0x10	; 16
    6b44:	90 e0       	ldi	r25, 0x00	; 0
    6b46:	9e 8f       	std	Y+30, r25	; 0x1e
    6b48:	8d 8f       	std	Y+29, r24	; 0x1d
    6b4a:	82 c0       	rjmp	.+260    	; 0x6c50 <RightLED_Blink+0x246>

		timer1_SetPWM_B((i*5));
    6b4c:	2d 8d       	ldd	r18, Y+29	; 0x1d
    6b4e:	3e 8d       	ldd	r19, Y+30	; 0x1e
    6b50:	c9 01       	movw	r24, r18
    6b52:	88 0f       	add	r24, r24
    6b54:	99 1f       	adc	r25, r25
    6b56:	88 0f       	add	r24, r24
    6b58:	99 1f       	adc	r25, r25
    6b5a:	82 0f       	add	r24, r18
    6b5c:	93 1f       	adc	r25, r19
    6b5e:	0e 94 d0 38 	call	0x71a0	; 0x71a0 <timer1_SetPWM_B>
    6b62:	80 e0       	ldi	r24, 0x00	; 0
    6b64:	90 e0       	ldi	r25, 0x00	; 0
    6b66:	a0 ef       	ldi	r26, 0xF0	; 240
    6b68:	b1 e4       	ldi	r27, 0x41	; 65
    6b6a:	8b 87       	std	Y+11, r24	; 0x0b
    6b6c:	9c 87       	std	Y+12, r25	; 0x0c
    6b6e:	ad 87       	std	Y+13, r26	; 0x0d
    6b70:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    6b72:	6b 85       	ldd	r22, Y+11	; 0x0b
    6b74:	7c 85       	ldd	r23, Y+12	; 0x0c
    6b76:	8d 85       	ldd	r24, Y+13	; 0x0d
    6b78:	9e 85       	ldd	r25, Y+14	; 0x0e
    6b7a:	20 e0       	ldi	r18, 0x00	; 0
    6b7c:	30 e0       	ldi	r19, 0x00	; 0
    6b7e:	4a e7       	ldi	r20, 0x7A	; 122
    6b80:	53 e4       	ldi	r21, 0x43	; 67
    6b82:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    6b86:	dc 01       	movw	r26, r24
    6b88:	cb 01       	movw	r24, r22
    6b8a:	8f 83       	std	Y+7, r24	; 0x07
    6b8c:	98 87       	std	Y+8, r25	; 0x08
    6b8e:	a9 87       	std	Y+9, r26	; 0x09
    6b90:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    6b92:	6f 81       	ldd	r22, Y+7	; 0x07
    6b94:	78 85       	ldd	r23, Y+8	; 0x08
    6b96:	89 85       	ldd	r24, Y+9	; 0x09
    6b98:	9a 85       	ldd	r25, Y+10	; 0x0a
    6b9a:	20 e0       	ldi	r18, 0x00	; 0
    6b9c:	30 e0       	ldi	r19, 0x00	; 0
    6b9e:	40 e8       	ldi	r20, 0x80	; 128
    6ba0:	5f e3       	ldi	r21, 0x3F	; 63
    6ba2:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    6ba6:	88 23       	and	r24, r24
    6ba8:	2c f4       	brge	.+10     	; 0x6bb4 <RightLED_Blink+0x1aa>
		__ticks = 1;
    6baa:	81 e0       	ldi	r24, 0x01	; 1
    6bac:	90 e0       	ldi	r25, 0x00	; 0
    6bae:	9e 83       	std	Y+6, r25	; 0x06
    6bb0:	8d 83       	std	Y+5, r24	; 0x05
    6bb2:	3f c0       	rjmp	.+126    	; 0x6c32 <RightLED_Blink+0x228>
	else if (__tmp > 65535)
    6bb4:	6f 81       	ldd	r22, Y+7	; 0x07
    6bb6:	78 85       	ldd	r23, Y+8	; 0x08
    6bb8:	89 85       	ldd	r24, Y+9	; 0x09
    6bba:	9a 85       	ldd	r25, Y+10	; 0x0a
    6bbc:	20 e0       	ldi	r18, 0x00	; 0
    6bbe:	3f ef       	ldi	r19, 0xFF	; 255
    6bc0:	4f e7       	ldi	r20, 0x7F	; 127
    6bc2:	57 e4       	ldi	r21, 0x47	; 71
    6bc4:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    6bc8:	18 16       	cp	r1, r24
    6bca:	4c f5       	brge	.+82     	; 0x6c1e <RightLED_Blink+0x214>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    6bcc:	6b 85       	ldd	r22, Y+11	; 0x0b
    6bce:	7c 85       	ldd	r23, Y+12	; 0x0c
    6bd0:	8d 85       	ldd	r24, Y+13	; 0x0d
    6bd2:	9e 85       	ldd	r25, Y+14	; 0x0e
    6bd4:	20 e0       	ldi	r18, 0x00	; 0
    6bd6:	30 e0       	ldi	r19, 0x00	; 0
    6bd8:	40 e2       	ldi	r20, 0x20	; 32
    6bda:	51 e4       	ldi	r21, 0x41	; 65
    6bdc:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    6be0:	dc 01       	movw	r26, r24
    6be2:	cb 01       	movw	r24, r22
    6be4:	bc 01       	movw	r22, r24
    6be6:	cd 01       	movw	r24, r26
    6be8:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    6bec:	dc 01       	movw	r26, r24
    6bee:	cb 01       	movw	r24, r22
    6bf0:	9e 83       	std	Y+6, r25	; 0x06
    6bf2:	8d 83       	std	Y+5, r24	; 0x05
    6bf4:	0f c0       	rjmp	.+30     	; 0x6c14 <RightLED_Blink+0x20a>
    6bf6:	89 e1       	ldi	r24, 0x19	; 25
    6bf8:	90 e0       	ldi	r25, 0x00	; 0
    6bfa:	9c 83       	std	Y+4, r25	; 0x04
    6bfc:	8b 83       	std	Y+3, r24	; 0x03
    6bfe:	8b 81       	ldd	r24, Y+3	; 0x03
    6c00:	9c 81       	ldd	r25, Y+4	; 0x04
    6c02:	01 97       	sbiw	r24, 0x01	; 1
    6c04:	f1 f7       	brne	.-4      	; 0x6c02 <RightLED_Blink+0x1f8>
    6c06:	9c 83       	std	Y+4, r25	; 0x04
    6c08:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    6c0a:	8d 81       	ldd	r24, Y+5	; 0x05
    6c0c:	9e 81       	ldd	r25, Y+6	; 0x06
    6c0e:	01 97       	sbiw	r24, 0x01	; 1
    6c10:	9e 83       	std	Y+6, r25	; 0x06
    6c12:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    6c14:	8d 81       	ldd	r24, Y+5	; 0x05
    6c16:	9e 81       	ldd	r25, Y+6	; 0x06
    6c18:	00 97       	sbiw	r24, 0x00	; 0
    6c1a:	69 f7       	brne	.-38     	; 0x6bf6 <RightLED_Blink+0x1ec>
    6c1c:	14 c0       	rjmp	.+40     	; 0x6c46 <RightLED_Blink+0x23c>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    6c1e:	6f 81       	ldd	r22, Y+7	; 0x07
    6c20:	78 85       	ldd	r23, Y+8	; 0x08
    6c22:	89 85       	ldd	r24, Y+9	; 0x09
    6c24:	9a 85       	ldd	r25, Y+10	; 0x0a
    6c26:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    6c2a:	dc 01       	movw	r26, r24
    6c2c:	cb 01       	movw	r24, r22
    6c2e:	9e 83       	std	Y+6, r25	; 0x06
    6c30:	8d 83       	std	Y+5, r24	; 0x05
    6c32:	8d 81       	ldd	r24, Y+5	; 0x05
    6c34:	9e 81       	ldd	r25, Y+6	; 0x06
    6c36:	9a 83       	std	Y+2, r25	; 0x02
    6c38:	89 83       	std	Y+1, r24	; 0x01
    6c3a:	89 81       	ldd	r24, Y+1	; 0x01
    6c3c:	9a 81       	ldd	r25, Y+2	; 0x02
    6c3e:	01 97       	sbiw	r24, 0x01	; 1
    6c40:	f1 f7       	brne	.-4      	; 0x6c3e <RightLED_Blink+0x234>
    6c42:	9a 83       	std	Y+2, r25	; 0x02
    6c44:	89 83       	std	Y+1, r24	; 0x01
	for(i = 2 ; i < 17 ; i++){

		timer1_SetPWM_B((i*5));
		_delay_ms(WAIT_TIME_PER_DUTY_CHANGE);
	}
	for(i = 16 ; i > 1 ; i--){
    6c46:	8d 8d       	ldd	r24, Y+29	; 0x1d
    6c48:	9e 8d       	ldd	r25, Y+30	; 0x1e
    6c4a:	01 97       	sbiw	r24, 0x01	; 1
    6c4c:	9e 8f       	std	Y+30, r25	; 0x1e
    6c4e:	8d 8f       	std	Y+29, r24	; 0x1d
    6c50:	8d 8d       	ldd	r24, Y+29	; 0x1d
    6c52:	9e 8d       	ldd	r25, Y+30	; 0x1e
    6c54:	82 30       	cpi	r24, 0x02	; 2
    6c56:	91 05       	cpc	r25, r1
    6c58:	0c f0       	brlt	.+2      	; 0x6c5c <RightLED_Blink+0x252>
    6c5a:	78 cf       	rjmp	.-272    	; 0x6b4c <RightLED_Blink+0x142>

		timer1_SetPWM_B((i*5));
		_delay_ms(WAIT_TIME_PER_DUTY_CHANGE);
	}
}
    6c5c:	6e 96       	adiw	r28, 0x1e	; 30
    6c5e:	0f b6       	in	r0, 0x3f	; 63
    6c60:	f8 94       	cli
    6c62:	de bf       	out	0x3e, r29	; 62
    6c64:	0f be       	out	0x3f, r0	; 63
    6c66:	cd bf       	out	0x3d, r28	; 61
    6c68:	cf 91       	pop	r28
    6c6a:	df 91       	pop	r29
    6c6c:	08 95       	ret

00006c6e <LeftLED_Blink>:

void LeftLED_Blink(void)
{
    6c6e:	df 93       	push	r29
    6c70:	cf 93       	push	r28
    6c72:	cd b7       	in	r28, 0x3d	; 61
    6c74:	de b7       	in	r29, 0x3e	; 62
    6c76:	6e 97       	sbiw	r28, 0x1e	; 30
    6c78:	0f b6       	in	r0, 0x3f	; 63
    6c7a:	f8 94       	cli
    6c7c:	de bf       	out	0x3e, r29	; 62
    6c7e:	0f be       	out	0x3f, r0	; 63
    6c80:	cd bf       	out	0x3d, r28	; 61
	int i = 0;
    6c82:	1e 8e       	std	Y+30, r1	; 0x1e
    6c84:	1d 8e       	std	Y+29, r1	; 0x1d
	timer1_SetPWM_B(0);
    6c86:	80 e0       	ldi	r24, 0x00	; 0
    6c88:	0e 94 d0 38 	call	0x71a0	; 0x71a0 <timer1_SetPWM_B>
	for(i = 2 ; i < 17 ; i++){
    6c8c:	82 e0       	ldi	r24, 0x02	; 2
    6c8e:	90 e0       	ldi	r25, 0x00	; 0
    6c90:	9e 8f       	std	Y+30, r25	; 0x1e
    6c92:	8d 8f       	std	Y+29, r24	; 0x1d
    6c94:	82 c0       	rjmp	.+260    	; 0x6d9a <LeftLED_Blink+0x12c>
		timer1_SetPWM_A((i*5));
    6c96:	2d 8d       	ldd	r18, Y+29	; 0x1d
    6c98:	3e 8d       	ldd	r19, Y+30	; 0x1e
    6c9a:	c9 01       	movw	r24, r18
    6c9c:	88 0f       	add	r24, r24
    6c9e:	99 1f       	adc	r25, r25
    6ca0:	88 0f       	add	r24, r24
    6ca2:	99 1f       	adc	r25, r25
    6ca4:	82 0f       	add	r24, r18
    6ca6:	93 1f       	adc	r25, r19
    6ca8:	0e 94 23 39 	call	0x7246	; 0x7246 <timer1_SetPWM_A>
    6cac:	80 e0       	ldi	r24, 0x00	; 0
    6cae:	90 e0       	ldi	r25, 0x00	; 0
    6cb0:	a0 ef       	ldi	r26, 0xF0	; 240
    6cb2:	b1 e4       	ldi	r27, 0x41	; 65
    6cb4:	89 8f       	std	Y+25, r24	; 0x19
    6cb6:	9a 8f       	std	Y+26, r25	; 0x1a
    6cb8:	ab 8f       	std	Y+27, r26	; 0x1b
    6cba:	bc 8f       	std	Y+28, r27	; 0x1c
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    6cbc:	69 8d       	ldd	r22, Y+25	; 0x19
    6cbe:	7a 8d       	ldd	r23, Y+26	; 0x1a
    6cc0:	8b 8d       	ldd	r24, Y+27	; 0x1b
    6cc2:	9c 8d       	ldd	r25, Y+28	; 0x1c
    6cc4:	20 e0       	ldi	r18, 0x00	; 0
    6cc6:	30 e0       	ldi	r19, 0x00	; 0
    6cc8:	4a e7       	ldi	r20, 0x7A	; 122
    6cca:	53 e4       	ldi	r21, 0x43	; 67
    6ccc:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    6cd0:	dc 01       	movw	r26, r24
    6cd2:	cb 01       	movw	r24, r22
    6cd4:	8d 8b       	std	Y+21, r24	; 0x15
    6cd6:	9e 8b       	std	Y+22, r25	; 0x16
    6cd8:	af 8b       	std	Y+23, r26	; 0x17
    6cda:	b8 8f       	std	Y+24, r27	; 0x18
	if (__tmp < 1.0)
    6cdc:	6d 89       	ldd	r22, Y+21	; 0x15
    6cde:	7e 89       	ldd	r23, Y+22	; 0x16
    6ce0:	8f 89       	ldd	r24, Y+23	; 0x17
    6ce2:	98 8d       	ldd	r25, Y+24	; 0x18
    6ce4:	20 e0       	ldi	r18, 0x00	; 0
    6ce6:	30 e0       	ldi	r19, 0x00	; 0
    6ce8:	40 e8       	ldi	r20, 0x80	; 128
    6cea:	5f e3       	ldi	r21, 0x3F	; 63
    6cec:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    6cf0:	88 23       	and	r24, r24
    6cf2:	2c f4       	brge	.+10     	; 0x6cfe <LeftLED_Blink+0x90>
		__ticks = 1;
    6cf4:	81 e0       	ldi	r24, 0x01	; 1
    6cf6:	90 e0       	ldi	r25, 0x00	; 0
    6cf8:	9c 8b       	std	Y+20, r25	; 0x14
    6cfa:	8b 8b       	std	Y+19, r24	; 0x13
    6cfc:	3f c0       	rjmp	.+126    	; 0x6d7c <LeftLED_Blink+0x10e>
	else if (__tmp > 65535)
    6cfe:	6d 89       	ldd	r22, Y+21	; 0x15
    6d00:	7e 89       	ldd	r23, Y+22	; 0x16
    6d02:	8f 89       	ldd	r24, Y+23	; 0x17
    6d04:	98 8d       	ldd	r25, Y+24	; 0x18
    6d06:	20 e0       	ldi	r18, 0x00	; 0
    6d08:	3f ef       	ldi	r19, 0xFF	; 255
    6d0a:	4f e7       	ldi	r20, 0x7F	; 127
    6d0c:	57 e4       	ldi	r21, 0x47	; 71
    6d0e:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    6d12:	18 16       	cp	r1, r24
    6d14:	4c f5       	brge	.+82     	; 0x6d68 <LeftLED_Blink+0xfa>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    6d16:	69 8d       	ldd	r22, Y+25	; 0x19
    6d18:	7a 8d       	ldd	r23, Y+26	; 0x1a
    6d1a:	8b 8d       	ldd	r24, Y+27	; 0x1b
    6d1c:	9c 8d       	ldd	r25, Y+28	; 0x1c
    6d1e:	20 e0       	ldi	r18, 0x00	; 0
    6d20:	30 e0       	ldi	r19, 0x00	; 0
    6d22:	40 e2       	ldi	r20, 0x20	; 32
    6d24:	51 e4       	ldi	r21, 0x41	; 65
    6d26:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    6d2a:	dc 01       	movw	r26, r24
    6d2c:	cb 01       	movw	r24, r22
    6d2e:	bc 01       	movw	r22, r24
    6d30:	cd 01       	movw	r24, r26
    6d32:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    6d36:	dc 01       	movw	r26, r24
    6d38:	cb 01       	movw	r24, r22
    6d3a:	9c 8b       	std	Y+20, r25	; 0x14
    6d3c:	8b 8b       	std	Y+19, r24	; 0x13
    6d3e:	0f c0       	rjmp	.+30     	; 0x6d5e <LeftLED_Blink+0xf0>
    6d40:	89 e1       	ldi	r24, 0x19	; 25
    6d42:	90 e0       	ldi	r25, 0x00	; 0
    6d44:	9a 8b       	std	Y+18, r25	; 0x12
    6d46:	89 8b       	std	Y+17, r24	; 0x11
    6d48:	89 89       	ldd	r24, Y+17	; 0x11
    6d4a:	9a 89       	ldd	r25, Y+18	; 0x12
    6d4c:	01 97       	sbiw	r24, 0x01	; 1
    6d4e:	f1 f7       	brne	.-4      	; 0x6d4c <LeftLED_Blink+0xde>
    6d50:	9a 8b       	std	Y+18, r25	; 0x12
    6d52:	89 8b       	std	Y+17, r24	; 0x11
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    6d54:	8b 89       	ldd	r24, Y+19	; 0x13
    6d56:	9c 89       	ldd	r25, Y+20	; 0x14
    6d58:	01 97       	sbiw	r24, 0x01	; 1
    6d5a:	9c 8b       	std	Y+20, r25	; 0x14
    6d5c:	8b 8b       	std	Y+19, r24	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    6d5e:	8b 89       	ldd	r24, Y+19	; 0x13
    6d60:	9c 89       	ldd	r25, Y+20	; 0x14
    6d62:	00 97       	sbiw	r24, 0x00	; 0
    6d64:	69 f7       	brne	.-38     	; 0x6d40 <LeftLED_Blink+0xd2>
    6d66:	14 c0       	rjmp	.+40     	; 0x6d90 <LeftLED_Blink+0x122>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    6d68:	6d 89       	ldd	r22, Y+21	; 0x15
    6d6a:	7e 89       	ldd	r23, Y+22	; 0x16
    6d6c:	8f 89       	ldd	r24, Y+23	; 0x17
    6d6e:	98 8d       	ldd	r25, Y+24	; 0x18
    6d70:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    6d74:	dc 01       	movw	r26, r24
    6d76:	cb 01       	movw	r24, r22
    6d78:	9c 8b       	std	Y+20, r25	; 0x14
    6d7a:	8b 8b       	std	Y+19, r24	; 0x13
    6d7c:	8b 89       	ldd	r24, Y+19	; 0x13
    6d7e:	9c 89       	ldd	r25, Y+20	; 0x14
    6d80:	98 8b       	std	Y+16, r25	; 0x10
    6d82:	8f 87       	std	Y+15, r24	; 0x0f
    6d84:	8f 85       	ldd	r24, Y+15	; 0x0f
    6d86:	98 89       	ldd	r25, Y+16	; 0x10
    6d88:	01 97       	sbiw	r24, 0x01	; 1
    6d8a:	f1 f7       	brne	.-4      	; 0x6d88 <LeftLED_Blink+0x11a>
    6d8c:	98 8b       	std	Y+16, r25	; 0x10
    6d8e:	8f 87       	std	Y+15, r24	; 0x0f

void LeftLED_Blink(void)
{
	int i = 0;
	timer1_SetPWM_B(0);
	for(i = 2 ; i < 17 ; i++){
    6d90:	8d 8d       	ldd	r24, Y+29	; 0x1d
    6d92:	9e 8d       	ldd	r25, Y+30	; 0x1e
    6d94:	01 96       	adiw	r24, 0x01	; 1
    6d96:	9e 8f       	std	Y+30, r25	; 0x1e
    6d98:	8d 8f       	std	Y+29, r24	; 0x1d
    6d9a:	8d 8d       	ldd	r24, Y+29	; 0x1d
    6d9c:	9e 8d       	ldd	r25, Y+30	; 0x1e
    6d9e:	81 31       	cpi	r24, 0x11	; 17
    6da0:	91 05       	cpc	r25, r1
    6da2:	0c f4       	brge	.+2      	; 0x6da6 <LeftLED_Blink+0x138>
    6da4:	78 cf       	rjmp	.-272    	; 0x6c96 <LeftLED_Blink+0x28>
		timer1_SetPWM_A((i*5));

		_delay_ms(WAIT_TIME_PER_DUTY_CHANGE);
	}
	for(i = 16 ; i > 1 ; i--){
    6da6:	80 e1       	ldi	r24, 0x10	; 16
    6da8:	90 e0       	ldi	r25, 0x00	; 0
    6daa:	9e 8f       	std	Y+30, r25	; 0x1e
    6dac:	8d 8f       	std	Y+29, r24	; 0x1d
    6dae:	82 c0       	rjmp	.+260    	; 0x6eb4 <LeftLED_Blink+0x246>
		timer1_SetPWM_A((i*5));
    6db0:	2d 8d       	ldd	r18, Y+29	; 0x1d
    6db2:	3e 8d       	ldd	r19, Y+30	; 0x1e
    6db4:	c9 01       	movw	r24, r18
    6db6:	88 0f       	add	r24, r24
    6db8:	99 1f       	adc	r25, r25
    6dba:	88 0f       	add	r24, r24
    6dbc:	99 1f       	adc	r25, r25
    6dbe:	82 0f       	add	r24, r18
    6dc0:	93 1f       	adc	r25, r19
    6dc2:	0e 94 23 39 	call	0x7246	; 0x7246 <timer1_SetPWM_A>
    6dc6:	80 e0       	ldi	r24, 0x00	; 0
    6dc8:	90 e0       	ldi	r25, 0x00	; 0
    6dca:	a0 ef       	ldi	r26, 0xF0	; 240
    6dcc:	b1 e4       	ldi	r27, 0x41	; 65
    6dce:	8b 87       	std	Y+11, r24	; 0x0b
    6dd0:	9c 87       	std	Y+12, r25	; 0x0c
    6dd2:	ad 87       	std	Y+13, r26	; 0x0d
    6dd4:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    6dd6:	6b 85       	ldd	r22, Y+11	; 0x0b
    6dd8:	7c 85       	ldd	r23, Y+12	; 0x0c
    6dda:	8d 85       	ldd	r24, Y+13	; 0x0d
    6ddc:	9e 85       	ldd	r25, Y+14	; 0x0e
    6dde:	20 e0       	ldi	r18, 0x00	; 0
    6de0:	30 e0       	ldi	r19, 0x00	; 0
    6de2:	4a e7       	ldi	r20, 0x7A	; 122
    6de4:	53 e4       	ldi	r21, 0x43	; 67
    6de6:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    6dea:	dc 01       	movw	r26, r24
    6dec:	cb 01       	movw	r24, r22
    6dee:	8f 83       	std	Y+7, r24	; 0x07
    6df0:	98 87       	std	Y+8, r25	; 0x08
    6df2:	a9 87       	std	Y+9, r26	; 0x09
    6df4:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    6df6:	6f 81       	ldd	r22, Y+7	; 0x07
    6df8:	78 85       	ldd	r23, Y+8	; 0x08
    6dfa:	89 85       	ldd	r24, Y+9	; 0x09
    6dfc:	9a 85       	ldd	r25, Y+10	; 0x0a
    6dfe:	20 e0       	ldi	r18, 0x00	; 0
    6e00:	30 e0       	ldi	r19, 0x00	; 0
    6e02:	40 e8       	ldi	r20, 0x80	; 128
    6e04:	5f e3       	ldi	r21, 0x3F	; 63
    6e06:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    6e0a:	88 23       	and	r24, r24
    6e0c:	2c f4       	brge	.+10     	; 0x6e18 <LeftLED_Blink+0x1aa>
		__ticks = 1;
    6e0e:	81 e0       	ldi	r24, 0x01	; 1
    6e10:	90 e0       	ldi	r25, 0x00	; 0
    6e12:	9e 83       	std	Y+6, r25	; 0x06
    6e14:	8d 83       	std	Y+5, r24	; 0x05
    6e16:	3f c0       	rjmp	.+126    	; 0x6e96 <LeftLED_Blink+0x228>
	else if (__tmp > 65535)
    6e18:	6f 81       	ldd	r22, Y+7	; 0x07
    6e1a:	78 85       	ldd	r23, Y+8	; 0x08
    6e1c:	89 85       	ldd	r24, Y+9	; 0x09
    6e1e:	9a 85       	ldd	r25, Y+10	; 0x0a
    6e20:	20 e0       	ldi	r18, 0x00	; 0
    6e22:	3f ef       	ldi	r19, 0xFF	; 255
    6e24:	4f e7       	ldi	r20, 0x7F	; 127
    6e26:	57 e4       	ldi	r21, 0x47	; 71
    6e28:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    6e2c:	18 16       	cp	r1, r24
    6e2e:	4c f5       	brge	.+82     	; 0x6e82 <LeftLED_Blink+0x214>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    6e30:	6b 85       	ldd	r22, Y+11	; 0x0b
    6e32:	7c 85       	ldd	r23, Y+12	; 0x0c
    6e34:	8d 85       	ldd	r24, Y+13	; 0x0d
    6e36:	9e 85       	ldd	r25, Y+14	; 0x0e
    6e38:	20 e0       	ldi	r18, 0x00	; 0
    6e3a:	30 e0       	ldi	r19, 0x00	; 0
    6e3c:	40 e2       	ldi	r20, 0x20	; 32
    6e3e:	51 e4       	ldi	r21, 0x41	; 65
    6e40:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    6e44:	dc 01       	movw	r26, r24
    6e46:	cb 01       	movw	r24, r22
    6e48:	bc 01       	movw	r22, r24
    6e4a:	cd 01       	movw	r24, r26
    6e4c:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    6e50:	dc 01       	movw	r26, r24
    6e52:	cb 01       	movw	r24, r22
    6e54:	9e 83       	std	Y+6, r25	; 0x06
    6e56:	8d 83       	std	Y+5, r24	; 0x05
    6e58:	0f c0       	rjmp	.+30     	; 0x6e78 <LeftLED_Blink+0x20a>
    6e5a:	89 e1       	ldi	r24, 0x19	; 25
    6e5c:	90 e0       	ldi	r25, 0x00	; 0
    6e5e:	9c 83       	std	Y+4, r25	; 0x04
    6e60:	8b 83       	std	Y+3, r24	; 0x03
    6e62:	8b 81       	ldd	r24, Y+3	; 0x03
    6e64:	9c 81       	ldd	r25, Y+4	; 0x04
    6e66:	01 97       	sbiw	r24, 0x01	; 1
    6e68:	f1 f7       	brne	.-4      	; 0x6e66 <LeftLED_Blink+0x1f8>
    6e6a:	9c 83       	std	Y+4, r25	; 0x04
    6e6c:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    6e6e:	8d 81       	ldd	r24, Y+5	; 0x05
    6e70:	9e 81       	ldd	r25, Y+6	; 0x06
    6e72:	01 97       	sbiw	r24, 0x01	; 1
    6e74:	9e 83       	std	Y+6, r25	; 0x06
    6e76:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    6e78:	8d 81       	ldd	r24, Y+5	; 0x05
    6e7a:	9e 81       	ldd	r25, Y+6	; 0x06
    6e7c:	00 97       	sbiw	r24, 0x00	; 0
    6e7e:	69 f7       	brne	.-38     	; 0x6e5a <LeftLED_Blink+0x1ec>
    6e80:	14 c0       	rjmp	.+40     	; 0x6eaa <LeftLED_Blink+0x23c>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    6e82:	6f 81       	ldd	r22, Y+7	; 0x07
    6e84:	78 85       	ldd	r23, Y+8	; 0x08
    6e86:	89 85       	ldd	r24, Y+9	; 0x09
    6e88:	9a 85       	ldd	r25, Y+10	; 0x0a
    6e8a:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    6e8e:	dc 01       	movw	r26, r24
    6e90:	cb 01       	movw	r24, r22
    6e92:	9e 83       	std	Y+6, r25	; 0x06
    6e94:	8d 83       	std	Y+5, r24	; 0x05
    6e96:	8d 81       	ldd	r24, Y+5	; 0x05
    6e98:	9e 81       	ldd	r25, Y+6	; 0x06
    6e9a:	9a 83       	std	Y+2, r25	; 0x02
    6e9c:	89 83       	std	Y+1, r24	; 0x01
    6e9e:	89 81       	ldd	r24, Y+1	; 0x01
    6ea0:	9a 81       	ldd	r25, Y+2	; 0x02
    6ea2:	01 97       	sbiw	r24, 0x01	; 1
    6ea4:	f1 f7       	brne	.-4      	; 0x6ea2 <LeftLED_Blink+0x234>
    6ea6:	9a 83       	std	Y+2, r25	; 0x02
    6ea8:	89 83       	std	Y+1, r24	; 0x01
	for(i = 2 ; i < 17 ; i++){
		timer1_SetPWM_A((i*5));

		_delay_ms(WAIT_TIME_PER_DUTY_CHANGE);
	}
	for(i = 16 ; i > 1 ; i--){
    6eaa:	8d 8d       	ldd	r24, Y+29	; 0x1d
    6eac:	9e 8d       	ldd	r25, Y+30	; 0x1e
    6eae:	01 97       	sbiw	r24, 0x01	; 1
    6eb0:	9e 8f       	std	Y+30, r25	; 0x1e
    6eb2:	8d 8f       	std	Y+29, r24	; 0x1d
    6eb4:	8d 8d       	ldd	r24, Y+29	; 0x1d
    6eb6:	9e 8d       	ldd	r25, Y+30	; 0x1e
    6eb8:	82 30       	cpi	r24, 0x02	; 2
    6eba:	91 05       	cpc	r25, r1
    6ebc:	0c f0       	brlt	.+2      	; 0x6ec0 <LeftLED_Blink+0x252>
    6ebe:	78 cf       	rjmp	.-272    	; 0x6db0 <LeftLED_Blink+0x142>
		timer1_SetPWM_A((i*5));

		_delay_ms(WAIT_TIME_PER_DUTY_CHANGE);
	}
}
    6ec0:	6e 96       	adiw	r28, 0x1e	; 30
    6ec2:	0f b6       	in	r0, 0x3f	; 63
    6ec4:	f8 94       	cli
    6ec6:	de bf       	out	0x3e, r29	; 62
    6ec8:	0f be       	out	0x3f, r0	; 63
    6eca:	cd bf       	out	0x3d, r28	; 61
    6ecc:	cf 91       	pop	r28
    6ece:	df 91       	pop	r29
    6ed0:	08 95       	ret

00006ed2 <BothLEDS_Blink>:

void BothLEDS_Blink(void)
{
    6ed2:	df 93       	push	r29
    6ed4:	cf 93       	push	r28
    6ed6:	cd b7       	in	r28, 0x3d	; 61
    6ed8:	de b7       	in	r29, 0x3e	; 62
    6eda:	6e 97       	sbiw	r28, 0x1e	; 30
    6edc:	0f b6       	in	r0, 0x3f	; 63
    6ede:	f8 94       	cli
    6ee0:	de bf       	out	0x3e, r29	; 62
    6ee2:	0f be       	out	0x3f, r0	; 63
    6ee4:	cd bf       	out	0x3d, r28	; 61
	int i = 0;
    6ee6:	1e 8e       	std	Y+30, r1	; 0x1e
    6ee8:	1d 8e       	std	Y+29, r1	; 0x1d
	for(i = 2 ; i < 17 ; i++){
    6eea:	82 e0       	ldi	r24, 0x02	; 2
    6eec:	90 e0       	ldi	r25, 0x00	; 0
    6eee:	9e 8f       	std	Y+30, r25	; 0x1e
    6ef0:	8d 8f       	std	Y+29, r24	; 0x1d
    6ef2:	82 c0       	rjmp	.+260    	; 0x6ff8 <BothLEDS_Blink+0x126>
		timer1_SetPWM_A_B(i*5);
    6ef4:	2d 8d       	ldd	r18, Y+29	; 0x1d
    6ef6:	3e 8d       	ldd	r19, Y+30	; 0x1e
    6ef8:	c9 01       	movw	r24, r18
    6efa:	88 0f       	add	r24, r24
    6efc:	99 1f       	adc	r25, r25
    6efe:	88 0f       	add	r24, r24
    6f00:	99 1f       	adc	r25, r25
    6f02:	82 0f       	add	r24, r18
    6f04:	93 1f       	adc	r25, r19
    6f06:	0e 94 76 39 	call	0x72ec	; 0x72ec <timer1_SetPWM_A_B>
    6f0a:	80 e0       	ldi	r24, 0x00	; 0
    6f0c:	90 e0       	ldi	r25, 0x00	; 0
    6f0e:	a0 ef       	ldi	r26, 0xF0	; 240
    6f10:	b1 e4       	ldi	r27, 0x41	; 65
    6f12:	89 8f       	std	Y+25, r24	; 0x19
    6f14:	9a 8f       	std	Y+26, r25	; 0x1a
    6f16:	ab 8f       	std	Y+27, r26	; 0x1b
    6f18:	bc 8f       	std	Y+28, r27	; 0x1c
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    6f1a:	69 8d       	ldd	r22, Y+25	; 0x19
    6f1c:	7a 8d       	ldd	r23, Y+26	; 0x1a
    6f1e:	8b 8d       	ldd	r24, Y+27	; 0x1b
    6f20:	9c 8d       	ldd	r25, Y+28	; 0x1c
    6f22:	20 e0       	ldi	r18, 0x00	; 0
    6f24:	30 e0       	ldi	r19, 0x00	; 0
    6f26:	4a e7       	ldi	r20, 0x7A	; 122
    6f28:	53 e4       	ldi	r21, 0x43	; 67
    6f2a:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    6f2e:	dc 01       	movw	r26, r24
    6f30:	cb 01       	movw	r24, r22
    6f32:	8d 8b       	std	Y+21, r24	; 0x15
    6f34:	9e 8b       	std	Y+22, r25	; 0x16
    6f36:	af 8b       	std	Y+23, r26	; 0x17
    6f38:	b8 8f       	std	Y+24, r27	; 0x18
	if (__tmp < 1.0)
    6f3a:	6d 89       	ldd	r22, Y+21	; 0x15
    6f3c:	7e 89       	ldd	r23, Y+22	; 0x16
    6f3e:	8f 89       	ldd	r24, Y+23	; 0x17
    6f40:	98 8d       	ldd	r25, Y+24	; 0x18
    6f42:	20 e0       	ldi	r18, 0x00	; 0
    6f44:	30 e0       	ldi	r19, 0x00	; 0
    6f46:	40 e8       	ldi	r20, 0x80	; 128
    6f48:	5f e3       	ldi	r21, 0x3F	; 63
    6f4a:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    6f4e:	88 23       	and	r24, r24
    6f50:	2c f4       	brge	.+10     	; 0x6f5c <BothLEDS_Blink+0x8a>
		__ticks = 1;
    6f52:	81 e0       	ldi	r24, 0x01	; 1
    6f54:	90 e0       	ldi	r25, 0x00	; 0
    6f56:	9c 8b       	std	Y+20, r25	; 0x14
    6f58:	8b 8b       	std	Y+19, r24	; 0x13
    6f5a:	3f c0       	rjmp	.+126    	; 0x6fda <BothLEDS_Blink+0x108>
	else if (__tmp > 65535)
    6f5c:	6d 89       	ldd	r22, Y+21	; 0x15
    6f5e:	7e 89       	ldd	r23, Y+22	; 0x16
    6f60:	8f 89       	ldd	r24, Y+23	; 0x17
    6f62:	98 8d       	ldd	r25, Y+24	; 0x18
    6f64:	20 e0       	ldi	r18, 0x00	; 0
    6f66:	3f ef       	ldi	r19, 0xFF	; 255
    6f68:	4f e7       	ldi	r20, 0x7F	; 127
    6f6a:	57 e4       	ldi	r21, 0x47	; 71
    6f6c:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    6f70:	18 16       	cp	r1, r24
    6f72:	4c f5       	brge	.+82     	; 0x6fc6 <BothLEDS_Blink+0xf4>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    6f74:	69 8d       	ldd	r22, Y+25	; 0x19
    6f76:	7a 8d       	ldd	r23, Y+26	; 0x1a
    6f78:	8b 8d       	ldd	r24, Y+27	; 0x1b
    6f7a:	9c 8d       	ldd	r25, Y+28	; 0x1c
    6f7c:	20 e0       	ldi	r18, 0x00	; 0
    6f7e:	30 e0       	ldi	r19, 0x00	; 0
    6f80:	40 e2       	ldi	r20, 0x20	; 32
    6f82:	51 e4       	ldi	r21, 0x41	; 65
    6f84:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    6f88:	dc 01       	movw	r26, r24
    6f8a:	cb 01       	movw	r24, r22
    6f8c:	bc 01       	movw	r22, r24
    6f8e:	cd 01       	movw	r24, r26
    6f90:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    6f94:	dc 01       	movw	r26, r24
    6f96:	cb 01       	movw	r24, r22
    6f98:	9c 8b       	std	Y+20, r25	; 0x14
    6f9a:	8b 8b       	std	Y+19, r24	; 0x13
    6f9c:	0f c0       	rjmp	.+30     	; 0x6fbc <BothLEDS_Blink+0xea>
    6f9e:	89 e1       	ldi	r24, 0x19	; 25
    6fa0:	90 e0       	ldi	r25, 0x00	; 0
    6fa2:	9a 8b       	std	Y+18, r25	; 0x12
    6fa4:	89 8b       	std	Y+17, r24	; 0x11
    6fa6:	89 89       	ldd	r24, Y+17	; 0x11
    6fa8:	9a 89       	ldd	r25, Y+18	; 0x12
    6faa:	01 97       	sbiw	r24, 0x01	; 1
    6fac:	f1 f7       	brne	.-4      	; 0x6faa <BothLEDS_Blink+0xd8>
    6fae:	9a 8b       	std	Y+18, r25	; 0x12
    6fb0:	89 8b       	std	Y+17, r24	; 0x11
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    6fb2:	8b 89       	ldd	r24, Y+19	; 0x13
    6fb4:	9c 89       	ldd	r25, Y+20	; 0x14
    6fb6:	01 97       	sbiw	r24, 0x01	; 1
    6fb8:	9c 8b       	std	Y+20, r25	; 0x14
    6fba:	8b 8b       	std	Y+19, r24	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    6fbc:	8b 89       	ldd	r24, Y+19	; 0x13
    6fbe:	9c 89       	ldd	r25, Y+20	; 0x14
    6fc0:	00 97       	sbiw	r24, 0x00	; 0
    6fc2:	69 f7       	brne	.-38     	; 0x6f9e <BothLEDS_Blink+0xcc>
    6fc4:	14 c0       	rjmp	.+40     	; 0x6fee <BothLEDS_Blink+0x11c>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    6fc6:	6d 89       	ldd	r22, Y+21	; 0x15
    6fc8:	7e 89       	ldd	r23, Y+22	; 0x16
    6fca:	8f 89       	ldd	r24, Y+23	; 0x17
    6fcc:	98 8d       	ldd	r25, Y+24	; 0x18
    6fce:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    6fd2:	dc 01       	movw	r26, r24
    6fd4:	cb 01       	movw	r24, r22
    6fd6:	9c 8b       	std	Y+20, r25	; 0x14
    6fd8:	8b 8b       	std	Y+19, r24	; 0x13
    6fda:	8b 89       	ldd	r24, Y+19	; 0x13
    6fdc:	9c 89       	ldd	r25, Y+20	; 0x14
    6fde:	98 8b       	std	Y+16, r25	; 0x10
    6fe0:	8f 87       	std	Y+15, r24	; 0x0f
    6fe2:	8f 85       	ldd	r24, Y+15	; 0x0f
    6fe4:	98 89       	ldd	r25, Y+16	; 0x10
    6fe6:	01 97       	sbiw	r24, 0x01	; 1
    6fe8:	f1 f7       	brne	.-4      	; 0x6fe6 <BothLEDS_Blink+0x114>
    6fea:	98 8b       	std	Y+16, r25	; 0x10
    6fec:	8f 87       	std	Y+15, r24	; 0x0f
}

void BothLEDS_Blink(void)
{
	int i = 0;
	for(i = 2 ; i < 17 ; i++){
    6fee:	8d 8d       	ldd	r24, Y+29	; 0x1d
    6ff0:	9e 8d       	ldd	r25, Y+30	; 0x1e
    6ff2:	01 96       	adiw	r24, 0x01	; 1
    6ff4:	9e 8f       	std	Y+30, r25	; 0x1e
    6ff6:	8d 8f       	std	Y+29, r24	; 0x1d
    6ff8:	8d 8d       	ldd	r24, Y+29	; 0x1d
    6ffa:	9e 8d       	ldd	r25, Y+30	; 0x1e
    6ffc:	81 31       	cpi	r24, 0x11	; 17
    6ffe:	91 05       	cpc	r25, r1
    7000:	0c f4       	brge	.+2      	; 0x7004 <BothLEDS_Blink+0x132>
    7002:	78 cf       	rjmp	.-272    	; 0x6ef4 <BothLEDS_Blink+0x22>
		timer1_SetPWM_A_B(i*5);
		_delay_ms(WAIT_TIME_PER_DUTY_CHANGE);
	}
	for(i = 16 ; i > 1 ; i--){
    7004:	80 e1       	ldi	r24, 0x10	; 16
    7006:	90 e0       	ldi	r25, 0x00	; 0
    7008:	9e 8f       	std	Y+30, r25	; 0x1e
    700a:	8d 8f       	std	Y+29, r24	; 0x1d
    700c:	82 c0       	rjmp	.+260    	; 0x7112 <BothLEDS_Blink+0x240>
		timer1_SetPWM_A_B(i*5);
    700e:	2d 8d       	ldd	r18, Y+29	; 0x1d
    7010:	3e 8d       	ldd	r19, Y+30	; 0x1e
    7012:	c9 01       	movw	r24, r18
    7014:	88 0f       	add	r24, r24
    7016:	99 1f       	adc	r25, r25
    7018:	88 0f       	add	r24, r24
    701a:	99 1f       	adc	r25, r25
    701c:	82 0f       	add	r24, r18
    701e:	93 1f       	adc	r25, r19
    7020:	0e 94 76 39 	call	0x72ec	; 0x72ec <timer1_SetPWM_A_B>
    7024:	80 e0       	ldi	r24, 0x00	; 0
    7026:	90 e0       	ldi	r25, 0x00	; 0
    7028:	a0 ef       	ldi	r26, 0xF0	; 240
    702a:	b1 e4       	ldi	r27, 0x41	; 65
    702c:	8b 87       	std	Y+11, r24	; 0x0b
    702e:	9c 87       	std	Y+12, r25	; 0x0c
    7030:	ad 87       	std	Y+13, r26	; 0x0d
    7032:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    7034:	6b 85       	ldd	r22, Y+11	; 0x0b
    7036:	7c 85       	ldd	r23, Y+12	; 0x0c
    7038:	8d 85       	ldd	r24, Y+13	; 0x0d
    703a:	9e 85       	ldd	r25, Y+14	; 0x0e
    703c:	20 e0       	ldi	r18, 0x00	; 0
    703e:	30 e0       	ldi	r19, 0x00	; 0
    7040:	4a e7       	ldi	r20, 0x7A	; 122
    7042:	53 e4       	ldi	r21, 0x43	; 67
    7044:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    7048:	dc 01       	movw	r26, r24
    704a:	cb 01       	movw	r24, r22
    704c:	8f 83       	std	Y+7, r24	; 0x07
    704e:	98 87       	std	Y+8, r25	; 0x08
    7050:	a9 87       	std	Y+9, r26	; 0x09
    7052:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    7054:	6f 81       	ldd	r22, Y+7	; 0x07
    7056:	78 85       	ldd	r23, Y+8	; 0x08
    7058:	89 85       	ldd	r24, Y+9	; 0x09
    705a:	9a 85       	ldd	r25, Y+10	; 0x0a
    705c:	20 e0       	ldi	r18, 0x00	; 0
    705e:	30 e0       	ldi	r19, 0x00	; 0
    7060:	40 e8       	ldi	r20, 0x80	; 128
    7062:	5f e3       	ldi	r21, 0x3F	; 63
    7064:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    7068:	88 23       	and	r24, r24
    706a:	2c f4       	brge	.+10     	; 0x7076 <BothLEDS_Blink+0x1a4>
		__ticks = 1;
    706c:	81 e0       	ldi	r24, 0x01	; 1
    706e:	90 e0       	ldi	r25, 0x00	; 0
    7070:	9e 83       	std	Y+6, r25	; 0x06
    7072:	8d 83       	std	Y+5, r24	; 0x05
    7074:	3f c0       	rjmp	.+126    	; 0x70f4 <BothLEDS_Blink+0x222>
	else if (__tmp > 65535)
    7076:	6f 81       	ldd	r22, Y+7	; 0x07
    7078:	78 85       	ldd	r23, Y+8	; 0x08
    707a:	89 85       	ldd	r24, Y+9	; 0x09
    707c:	9a 85       	ldd	r25, Y+10	; 0x0a
    707e:	20 e0       	ldi	r18, 0x00	; 0
    7080:	3f ef       	ldi	r19, 0xFF	; 255
    7082:	4f e7       	ldi	r20, 0x7F	; 127
    7084:	57 e4       	ldi	r21, 0x47	; 71
    7086:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    708a:	18 16       	cp	r1, r24
    708c:	4c f5       	brge	.+82     	; 0x70e0 <BothLEDS_Blink+0x20e>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    708e:	6b 85       	ldd	r22, Y+11	; 0x0b
    7090:	7c 85       	ldd	r23, Y+12	; 0x0c
    7092:	8d 85       	ldd	r24, Y+13	; 0x0d
    7094:	9e 85       	ldd	r25, Y+14	; 0x0e
    7096:	20 e0       	ldi	r18, 0x00	; 0
    7098:	30 e0       	ldi	r19, 0x00	; 0
    709a:	40 e2       	ldi	r20, 0x20	; 32
    709c:	51 e4       	ldi	r21, 0x41	; 65
    709e:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    70a2:	dc 01       	movw	r26, r24
    70a4:	cb 01       	movw	r24, r22
    70a6:	bc 01       	movw	r22, r24
    70a8:	cd 01       	movw	r24, r26
    70aa:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    70ae:	dc 01       	movw	r26, r24
    70b0:	cb 01       	movw	r24, r22
    70b2:	9e 83       	std	Y+6, r25	; 0x06
    70b4:	8d 83       	std	Y+5, r24	; 0x05
    70b6:	0f c0       	rjmp	.+30     	; 0x70d6 <BothLEDS_Blink+0x204>
    70b8:	89 e1       	ldi	r24, 0x19	; 25
    70ba:	90 e0       	ldi	r25, 0x00	; 0
    70bc:	9c 83       	std	Y+4, r25	; 0x04
    70be:	8b 83       	std	Y+3, r24	; 0x03
    70c0:	8b 81       	ldd	r24, Y+3	; 0x03
    70c2:	9c 81       	ldd	r25, Y+4	; 0x04
    70c4:	01 97       	sbiw	r24, 0x01	; 1
    70c6:	f1 f7       	brne	.-4      	; 0x70c4 <BothLEDS_Blink+0x1f2>
    70c8:	9c 83       	std	Y+4, r25	; 0x04
    70ca:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    70cc:	8d 81       	ldd	r24, Y+5	; 0x05
    70ce:	9e 81       	ldd	r25, Y+6	; 0x06
    70d0:	01 97       	sbiw	r24, 0x01	; 1
    70d2:	9e 83       	std	Y+6, r25	; 0x06
    70d4:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    70d6:	8d 81       	ldd	r24, Y+5	; 0x05
    70d8:	9e 81       	ldd	r25, Y+6	; 0x06
    70da:	00 97       	sbiw	r24, 0x00	; 0
    70dc:	69 f7       	brne	.-38     	; 0x70b8 <BothLEDS_Blink+0x1e6>
    70de:	14 c0       	rjmp	.+40     	; 0x7108 <BothLEDS_Blink+0x236>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    70e0:	6f 81       	ldd	r22, Y+7	; 0x07
    70e2:	78 85       	ldd	r23, Y+8	; 0x08
    70e4:	89 85       	ldd	r24, Y+9	; 0x09
    70e6:	9a 85       	ldd	r25, Y+10	; 0x0a
    70e8:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    70ec:	dc 01       	movw	r26, r24
    70ee:	cb 01       	movw	r24, r22
    70f0:	9e 83       	std	Y+6, r25	; 0x06
    70f2:	8d 83       	std	Y+5, r24	; 0x05
    70f4:	8d 81       	ldd	r24, Y+5	; 0x05
    70f6:	9e 81       	ldd	r25, Y+6	; 0x06
    70f8:	9a 83       	std	Y+2, r25	; 0x02
    70fa:	89 83       	std	Y+1, r24	; 0x01
    70fc:	89 81       	ldd	r24, Y+1	; 0x01
    70fe:	9a 81       	ldd	r25, Y+2	; 0x02
    7100:	01 97       	sbiw	r24, 0x01	; 1
    7102:	f1 f7       	brne	.-4      	; 0x7100 <BothLEDS_Blink+0x22e>
    7104:	9a 83       	std	Y+2, r25	; 0x02
    7106:	89 83       	std	Y+1, r24	; 0x01
	int i = 0;
	for(i = 2 ; i < 17 ; i++){
		timer1_SetPWM_A_B(i*5);
		_delay_ms(WAIT_TIME_PER_DUTY_CHANGE);
	}
	for(i = 16 ; i > 1 ; i--){
    7108:	8d 8d       	ldd	r24, Y+29	; 0x1d
    710a:	9e 8d       	ldd	r25, Y+30	; 0x1e
    710c:	01 97       	sbiw	r24, 0x01	; 1
    710e:	9e 8f       	std	Y+30, r25	; 0x1e
    7110:	8d 8f       	std	Y+29, r24	; 0x1d
    7112:	8d 8d       	ldd	r24, Y+29	; 0x1d
    7114:	9e 8d       	ldd	r25, Y+30	; 0x1e
    7116:	82 30       	cpi	r24, 0x02	; 2
    7118:	91 05       	cpc	r25, r1
    711a:	0c f0       	brlt	.+2      	; 0x711e <BothLEDS_Blink+0x24c>
    711c:	78 cf       	rjmp	.-272    	; 0x700e <BothLEDS_Blink+0x13c>
		timer1_SetPWM_A_B(i*5);
		_delay_ms(WAIT_TIME_PER_DUTY_CHANGE);
	}

}
    711e:	6e 96       	adiw	r28, 0x1e	; 30
    7120:	0f b6       	in	r0, 0x3f	; 63
    7122:	f8 94       	cli
    7124:	de bf       	out	0x3e, r29	; 62
    7126:	0f be       	out	0x3f, r0	; 63
    7128:	cd bf       	out	0x3d, r28	; 61
    712a:	cf 91       	pop	r28
    712c:	df 91       	pop	r29
    712e:	08 95       	ret

00007130 <NoLED_Blink>:


void NoLED_Blink(void){
    7130:	df 93       	push	r29
    7132:	cf 93       	push	r28
    7134:	cd b7       	in	r28, 0x3d	; 61
    7136:	de b7       	in	r29, 0x3e	; 62
	timer1_SetPWM_A_B(0);
    7138:	80 e0       	ldi	r24, 0x00	; 0
    713a:	0e 94 76 39 	call	0x72ec	; 0x72ec <timer1_SetPWM_A_B>
}
    713e:	cf 91       	pop	r28
    7140:	df 91       	pop	r29
    7142:	08 95       	ret

00007144 <timer1_PWM_Init>:
#include <avr/io.h>
#include "Timer1_PWM.h"

unsigned long TopValue;

void timer1_PWM_Init(void){
    7144:	df 93       	push	r29
    7146:	cf 93       	push	r28
    7148:	cd b7       	in	r28, 0x3d	; 61
    714a:	de b7       	in	r29, 0x3e	; 62
	TCCR1A = (1 << COM1A1) | (1 << COM1B1) | (1<< WGM11);
    714c:	ef e4       	ldi	r30, 0x4F	; 79
    714e:	f0 e0       	ldi	r31, 0x00	; 0
    7150:	82 ea       	ldi	r24, 0xA2	; 162
    7152:	80 83       	st	Z, r24
	TCCR1B = (1<<WGM13) | (1<<WGM12) | (1<<CS10);
    7154:	ee e4       	ldi	r30, 0x4E	; 78
    7156:	f0 e0       	ldi	r31, 0x00	; 0
    7158:	89 e1       	ldi	r24, 0x19	; 25
    715a:	80 83       	st	Z, r24
	TopValue = ((float)100/PWM_FREQUENCY_IN_KHZ)*160;
    715c:	80 ea       	ldi	r24, 0xA0	; 160
    715e:	90 e0       	ldi	r25, 0x00	; 0
    7160:	a0 e0       	ldi	r26, 0x00	; 0
    7162:	b0 e0       	ldi	r27, 0x00	; 0
    7164:	80 93 4e 08 	sts	0x084E, r24
    7168:	90 93 4f 08 	sts	0x084F, r25
    716c:	a0 93 50 08 	sts	0x0850, r26
    7170:	b0 93 51 08 	sts	0x0851, r27
	ICR1 = TopValue;
    7174:	e6 e4       	ldi	r30, 0x46	; 70
    7176:	f0 e0       	ldi	r31, 0x00	; 0
    7178:	80 91 4e 08 	lds	r24, 0x084E
    717c:	90 91 4f 08 	lds	r25, 0x084F
    7180:	a0 91 50 08 	lds	r26, 0x0850
    7184:	b0 91 51 08 	lds	r27, 0x0851
    7188:	91 83       	std	Z+1, r25	; 0x01
    718a:	80 83       	st	Z, r24
//	OCR1A = 20000;
//	OCR1B = 45500;
	DDRB |= (1<<PB5) | (1<<PB6);
    718c:	a7 e3       	ldi	r26, 0x37	; 55
    718e:	b0 e0       	ldi	r27, 0x00	; 0
    7190:	e7 e3       	ldi	r30, 0x37	; 55
    7192:	f0 e0       	ldi	r31, 0x00	; 0
    7194:	80 81       	ld	r24, Z
    7196:	80 66       	ori	r24, 0x60	; 96
    7198:	8c 93       	st	X, r24

}
    719a:	cf 91       	pop	r28
    719c:	df 91       	pop	r29
    719e:	08 95       	ret

000071a0 <timer1_SetPWM_B>:

void timer1_SetPWM_B(unsigned char dutyB){
    71a0:	ef 92       	push	r14
    71a2:	ff 92       	push	r15
    71a4:	0f 93       	push	r16
    71a6:	1f 93       	push	r17
    71a8:	df 93       	push	r29
    71aa:	cf 93       	push	r28
    71ac:	00 d0       	rcall	.+0      	; 0x71ae <timer1_SetPWM_B+0xe>
    71ae:	00 d0       	rcall	.+0      	; 0x71b0 <timer1_SetPWM_B+0x10>
    71b0:	0f 92       	push	r0
    71b2:	cd b7       	in	r28, 0x3d	; 61
    71b4:	de b7       	in	r29, 0x3e	; 62
    71b6:	8d 83       	std	Y+5, r24	; 0x05
	unsigned long actualDuty = (unsigned long)(((float)dutyB/100)*(TopValue));
    71b8:	8d 81       	ldd	r24, Y+5	; 0x05
    71ba:	88 2f       	mov	r24, r24
    71bc:	90 e0       	ldi	r25, 0x00	; 0
    71be:	a0 e0       	ldi	r26, 0x00	; 0
    71c0:	b0 e0       	ldi	r27, 0x00	; 0
    71c2:	bc 01       	movw	r22, r24
    71c4:	cd 01       	movw	r24, r26
    71c6:	0e 94 a9 04 	call	0x952	; 0x952 <__floatunsisf>
    71ca:	dc 01       	movw	r26, r24
    71cc:	cb 01       	movw	r24, r22
    71ce:	bc 01       	movw	r22, r24
    71d0:	cd 01       	movw	r24, r26
    71d2:	20 e0       	ldi	r18, 0x00	; 0
    71d4:	30 e0       	ldi	r19, 0x00	; 0
    71d6:	48 ec       	ldi	r20, 0xC8	; 200
    71d8:	52 e4       	ldi	r21, 0x42	; 66
    71da:	0e 94 19 03 	call	0x632	; 0x632 <__divsf3>
    71de:	dc 01       	movw	r26, r24
    71e0:	cb 01       	movw	r24, r22
    71e2:	7c 01       	movw	r14, r24
    71e4:	8d 01       	movw	r16, r26
    71e6:	80 91 4e 08 	lds	r24, 0x084E
    71ea:	90 91 4f 08 	lds	r25, 0x084F
    71ee:	a0 91 50 08 	lds	r26, 0x0850
    71f2:	b0 91 51 08 	lds	r27, 0x0851
    71f6:	bc 01       	movw	r22, r24
    71f8:	cd 01       	movw	r24, r26
    71fa:	0e 94 a9 04 	call	0x952	; 0x952 <__floatunsisf>
    71fe:	9b 01       	movw	r18, r22
    7200:	ac 01       	movw	r20, r24
    7202:	c8 01       	movw	r24, r16
    7204:	b7 01       	movw	r22, r14
    7206:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    720a:	dc 01       	movw	r26, r24
    720c:	cb 01       	movw	r24, r22
    720e:	bc 01       	movw	r22, r24
    7210:	cd 01       	movw	r24, r26
    7212:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    7216:	dc 01       	movw	r26, r24
    7218:	cb 01       	movw	r24, r22
    721a:	89 83       	std	Y+1, r24	; 0x01
    721c:	9a 83       	std	Y+2, r25	; 0x02
    721e:	ab 83       	std	Y+3, r26	; 0x03
    7220:	bc 83       	std	Y+4, r27	; 0x04
	OCR1B = actualDuty;
    7222:	e8 e4       	ldi	r30, 0x48	; 72
    7224:	f0 e0       	ldi	r31, 0x00	; 0
    7226:	89 81       	ldd	r24, Y+1	; 0x01
    7228:	9a 81       	ldd	r25, Y+2	; 0x02
    722a:	91 83       	std	Z+1, r25	; 0x01
    722c:	80 83       	st	Z, r24
}
    722e:	0f 90       	pop	r0
    7230:	0f 90       	pop	r0
    7232:	0f 90       	pop	r0
    7234:	0f 90       	pop	r0
    7236:	0f 90       	pop	r0
    7238:	cf 91       	pop	r28
    723a:	df 91       	pop	r29
    723c:	1f 91       	pop	r17
    723e:	0f 91       	pop	r16
    7240:	ff 90       	pop	r15
    7242:	ef 90       	pop	r14
    7244:	08 95       	ret

00007246 <timer1_SetPWM_A>:


void timer1_SetPWM_A(unsigned char dutyA){
    7246:	ef 92       	push	r14
    7248:	ff 92       	push	r15
    724a:	0f 93       	push	r16
    724c:	1f 93       	push	r17
    724e:	df 93       	push	r29
    7250:	cf 93       	push	r28
    7252:	00 d0       	rcall	.+0      	; 0x7254 <timer1_SetPWM_A+0xe>
    7254:	00 d0       	rcall	.+0      	; 0x7256 <timer1_SetPWM_A+0x10>
    7256:	0f 92       	push	r0
    7258:	cd b7       	in	r28, 0x3d	; 61
    725a:	de b7       	in	r29, 0x3e	; 62
    725c:	8d 83       	std	Y+5, r24	; 0x05
	unsigned long actualDuty = (unsigned long)(((float)dutyA/100)*(TopValue));
    725e:	8d 81       	ldd	r24, Y+5	; 0x05
    7260:	88 2f       	mov	r24, r24
    7262:	90 e0       	ldi	r25, 0x00	; 0
    7264:	a0 e0       	ldi	r26, 0x00	; 0
    7266:	b0 e0       	ldi	r27, 0x00	; 0
    7268:	bc 01       	movw	r22, r24
    726a:	cd 01       	movw	r24, r26
    726c:	0e 94 a9 04 	call	0x952	; 0x952 <__floatunsisf>
    7270:	dc 01       	movw	r26, r24
    7272:	cb 01       	movw	r24, r22
    7274:	bc 01       	movw	r22, r24
    7276:	cd 01       	movw	r24, r26
    7278:	20 e0       	ldi	r18, 0x00	; 0
    727a:	30 e0       	ldi	r19, 0x00	; 0
    727c:	48 ec       	ldi	r20, 0xC8	; 200
    727e:	52 e4       	ldi	r21, 0x42	; 66
    7280:	0e 94 19 03 	call	0x632	; 0x632 <__divsf3>
    7284:	dc 01       	movw	r26, r24
    7286:	cb 01       	movw	r24, r22
    7288:	7c 01       	movw	r14, r24
    728a:	8d 01       	movw	r16, r26
    728c:	80 91 4e 08 	lds	r24, 0x084E
    7290:	90 91 4f 08 	lds	r25, 0x084F
    7294:	a0 91 50 08 	lds	r26, 0x0850
    7298:	b0 91 51 08 	lds	r27, 0x0851
    729c:	bc 01       	movw	r22, r24
    729e:	cd 01       	movw	r24, r26
    72a0:	0e 94 a9 04 	call	0x952	; 0x952 <__floatunsisf>
    72a4:	9b 01       	movw	r18, r22
    72a6:	ac 01       	movw	r20, r24
    72a8:	c8 01       	movw	r24, r16
    72aa:	b7 01       	movw	r22, r14
    72ac:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    72b0:	dc 01       	movw	r26, r24
    72b2:	cb 01       	movw	r24, r22
    72b4:	bc 01       	movw	r22, r24
    72b6:	cd 01       	movw	r24, r26
    72b8:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    72bc:	dc 01       	movw	r26, r24
    72be:	cb 01       	movw	r24, r22
    72c0:	89 83       	std	Y+1, r24	; 0x01
    72c2:	9a 83       	std	Y+2, r25	; 0x02
    72c4:	ab 83       	std	Y+3, r26	; 0x03
    72c6:	bc 83       	std	Y+4, r27	; 0x04
	OCR1A = actualDuty;
    72c8:	ea e4       	ldi	r30, 0x4A	; 74
    72ca:	f0 e0       	ldi	r31, 0x00	; 0
    72cc:	89 81       	ldd	r24, Y+1	; 0x01
    72ce:	9a 81       	ldd	r25, Y+2	; 0x02
    72d0:	91 83       	std	Z+1, r25	; 0x01
    72d2:	80 83       	st	Z, r24
}
    72d4:	0f 90       	pop	r0
    72d6:	0f 90       	pop	r0
    72d8:	0f 90       	pop	r0
    72da:	0f 90       	pop	r0
    72dc:	0f 90       	pop	r0
    72de:	cf 91       	pop	r28
    72e0:	df 91       	pop	r29
    72e2:	1f 91       	pop	r17
    72e4:	0f 91       	pop	r16
    72e6:	ff 90       	pop	r15
    72e8:	ef 90       	pop	r14
    72ea:	08 95       	ret

000072ec <timer1_SetPWM_A_B>:


void timer1_SetPWM_A_B(unsigned char dutyA_B){
    72ec:	ef 92       	push	r14
    72ee:	ff 92       	push	r15
    72f0:	0f 93       	push	r16
    72f2:	1f 93       	push	r17
    72f4:	df 93       	push	r29
    72f6:	cf 93       	push	r28
    72f8:	00 d0       	rcall	.+0      	; 0x72fa <timer1_SetPWM_A_B+0xe>
    72fa:	00 d0       	rcall	.+0      	; 0x72fc <timer1_SetPWM_A_B+0x10>
    72fc:	0f 92       	push	r0
    72fe:	cd b7       	in	r28, 0x3d	; 61
    7300:	de b7       	in	r29, 0x3e	; 62
    7302:	8d 83       	std	Y+5, r24	; 0x05
	unsigned long actualDuty = (unsigned long)(((float)dutyA_B/100)*(TopValue));
    7304:	8d 81       	ldd	r24, Y+5	; 0x05
    7306:	88 2f       	mov	r24, r24
    7308:	90 e0       	ldi	r25, 0x00	; 0
    730a:	a0 e0       	ldi	r26, 0x00	; 0
    730c:	b0 e0       	ldi	r27, 0x00	; 0
    730e:	bc 01       	movw	r22, r24
    7310:	cd 01       	movw	r24, r26
    7312:	0e 94 a9 04 	call	0x952	; 0x952 <__floatunsisf>
    7316:	dc 01       	movw	r26, r24
    7318:	cb 01       	movw	r24, r22
    731a:	bc 01       	movw	r22, r24
    731c:	cd 01       	movw	r24, r26
    731e:	20 e0       	ldi	r18, 0x00	; 0
    7320:	30 e0       	ldi	r19, 0x00	; 0
    7322:	48 ec       	ldi	r20, 0xC8	; 200
    7324:	52 e4       	ldi	r21, 0x42	; 66
    7326:	0e 94 19 03 	call	0x632	; 0x632 <__divsf3>
    732a:	dc 01       	movw	r26, r24
    732c:	cb 01       	movw	r24, r22
    732e:	7c 01       	movw	r14, r24
    7330:	8d 01       	movw	r16, r26
    7332:	80 91 4e 08 	lds	r24, 0x084E
    7336:	90 91 4f 08 	lds	r25, 0x084F
    733a:	a0 91 50 08 	lds	r26, 0x0850
    733e:	b0 91 51 08 	lds	r27, 0x0851
    7342:	bc 01       	movw	r22, r24
    7344:	cd 01       	movw	r24, r26
    7346:	0e 94 a9 04 	call	0x952	; 0x952 <__floatunsisf>
    734a:	9b 01       	movw	r18, r22
    734c:	ac 01       	movw	r20, r24
    734e:	c8 01       	movw	r24, r16
    7350:	b7 01       	movw	r22, r14
    7352:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    7356:	dc 01       	movw	r26, r24
    7358:	cb 01       	movw	r24, r22
    735a:	bc 01       	movw	r22, r24
    735c:	cd 01       	movw	r24, r26
    735e:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    7362:	dc 01       	movw	r26, r24
    7364:	cb 01       	movw	r24, r22
    7366:	89 83       	std	Y+1, r24	; 0x01
    7368:	9a 83       	std	Y+2, r25	; 0x02
    736a:	ab 83       	std	Y+3, r26	; 0x03
    736c:	bc 83       	std	Y+4, r27	; 0x04
	OCR1A = actualDuty;
    736e:	ea e4       	ldi	r30, 0x4A	; 74
    7370:	f0 e0       	ldi	r31, 0x00	; 0
    7372:	89 81       	ldd	r24, Y+1	; 0x01
    7374:	9a 81       	ldd	r25, Y+2	; 0x02
    7376:	91 83       	std	Z+1, r25	; 0x01
    7378:	80 83       	st	Z, r24
	OCR1B = actualDuty;
    737a:	e8 e4       	ldi	r30, 0x48	; 72
    737c:	f0 e0       	ldi	r31, 0x00	; 0
    737e:	89 81       	ldd	r24, Y+1	; 0x01
    7380:	9a 81       	ldd	r25, Y+2	; 0x02
    7382:	91 83       	std	Z+1, r25	; 0x01
    7384:	80 83       	st	Z, r24
}
    7386:	0f 90       	pop	r0
    7388:	0f 90       	pop	r0
    738a:	0f 90       	pop	r0
    738c:	0f 90       	pop	r0
    738e:	0f 90       	pop	r0
    7390:	cf 91       	pop	r28
    7392:	df 91       	pop	r29
    7394:	1f 91       	pop	r17
    7396:	0f 91       	pop	r16
    7398:	ff 90       	pop	r15
    739a:	ef 90       	pop	r14
    739c:	08 95       	ret

0000739e <Timer2_Init_CTC_Mode>:
 */

#include "avr/io.h"

void Timer2_Init_CTC_Mode(unsigned char tick)
{
    739e:	df 93       	push	r29
    73a0:	cf 93       	push	r28
    73a2:	0f 92       	push	r0
    73a4:	cd b7       	in	r28, 0x3d	; 61
    73a6:	de b7       	in	r29, 0x3e	; 62
    73a8:	89 83       	std	Y+1, r24	; 0x01
	TCNT2 = 0;    // Set Timer initial value to 0
    73aa:	e4 e4       	ldi	r30, 0x44	; 68
    73ac:	f0 e0       	ldi	r31, 0x00	; 0
    73ae:	10 82       	st	Z, r1
	OCR2  = tick; // Set Compare Value
    73b0:	e3 e4       	ldi	r30, 0x43	; 67
    73b2:	f0 e0       	ldi	r31, 0x00	; 0
    73b4:	89 81       	ldd	r24, Y+1	; 0x01
    73b6:	80 83       	st	Z, r24
	TIMSK |= (1<<OCIE2); // Enable Timer2 Compare Interrupt
    73b8:	a9 e5       	ldi	r26, 0x59	; 89
    73ba:	b0 e0       	ldi	r27, 0x00	; 0
    73bc:	e9 e5       	ldi	r30, 0x59	; 89
    73be:	f0 e0       	ldi	r31, 0x00	; 0
    73c0:	80 81       	ld	r24, Z
    73c2:	80 68       	ori	r24, 0x80	; 128
    73c4:	8c 93       	st	X, r24
	 * 1. Non PWM mode FOC0=1
	 * 2. CTC Mode WGM01=1 & WGM00=0
	 * 3. No need for OC0 in this example so COM00=0 & COM01=0
	 * 4. clock = F_CPU/8 CS22=0 CS21=1 CS20=0
	 */
	TCCR2 = (1<<FOC2) | (1<<WGM21) | (1<<CS21);
    73c6:	e5 e4       	ldi	r30, 0x45	; 69
    73c8:	f0 e0       	ldi	r31, 0x00	; 0
    73ca:	8a e8       	ldi	r24, 0x8A	; 138
    73cc:	80 83       	st	Z, r24
}
    73ce:	0f 90       	pop	r0
    73d0:	cf 91       	pop	r28
    73d2:	df 91       	pop	r29
    73d4:	08 95       	ret

000073d6 <Get_Data>:
#include<util/delay.h>



States_GroupType Get_Data(void)
{
    73d6:	df 93       	push	r29
    73d8:	cf 93       	push	r28
    73da:	0f 92       	push	r0
    73dc:	cd b7       	in	r28, 0x3d	; 61
    73de:	de b7       	in	r29, 0x3e	; 62
//	SET_BIT(PORTB,6);
	static unsigned char hazardBtn_releaseFlag = TRUE;
	static States_GroupType ButtonState = {0,0,0,0};

	if(GPIO_readPin(dio_config_array[HAZARD_BUTTON_ID].port_id,dio_config_array[HAZARD_BUTTON_ID].pin_num) ){
    73e0:	80 91 97 01 	lds	r24, 0x0197
    73e4:	90 91 98 01 	lds	r25, 0x0198
    73e8:	69 2f       	mov	r22, r25
    73ea:	0e 94 8a 3c 	call	0x7914	; 0x7914 <GPIO_readPin>
    73ee:	88 23       	and	r24, r24
    73f0:	89 f0       	breq	.+34     	; 0x7414 <Get_Data+0x3e>
		if(hazardBtn_releaseFlag == TRUE){
    73f2:	80 91 92 01 	lds	r24, 0x0192
    73f6:	81 30       	cpi	r24, 0x01	; 1
    73f8:	81 f4       	brne	.+32     	; 0x741a <Get_Data+0x44>
			hazardBtn_releaseFlag = FALSE;
    73fa:	10 92 92 01 	sts	0x0192, r1
			ButtonState.hazard_Btn = !ButtonState.hazard_Btn;
    73fe:	80 91 41 08 	lds	r24, 0x0841
    7402:	19 82       	std	Y+1, r1	; 0x01
    7404:	88 23       	and	r24, r24
    7406:	11 f4       	brne	.+4      	; 0x740c <Get_Data+0x36>
    7408:	81 e0       	ldi	r24, 0x01	; 1
    740a:	89 83       	std	Y+1, r24	; 0x01
    740c:	89 81       	ldd	r24, Y+1	; 0x01
    740e:	80 93 41 08 	sts	0x0841, r24
    7412:	03 c0       	rjmp	.+6      	; 0x741a <Get_Data+0x44>
		}

	}
	else{
		hazardBtn_releaseFlag = TRUE;
    7414:	81 e0       	ldi	r24, 0x01	; 1
    7416:	80 93 92 01 	sts	0x0192, r24
	}




	if(!GPIO_readPin(dio_config_array[RIGHT_INDICATOR_BUTTON_ID].port_id,dio_config_array[RIGHT_INDICATOR_BUTTON_ID].pin_num) && !GPIO_readPin(dio_config_array[IGNITION_SWICH_ID].port_id,dio_config_array[IGNITION_SWICH_ID].pin_num)){
    741a:	80 91 9a 01 	lds	r24, 0x019A
    741e:	90 91 9b 01 	lds	r25, 0x019B
    7422:	69 2f       	mov	r22, r25
    7424:	0e 94 8a 3c 	call	0x7914	; 0x7914 <GPIO_readPin>
    7428:	88 23       	and	r24, r24
    742a:	71 f5       	brne	.+92     	; 0x7488 <Get_Data+0xb2>
    742c:	80 91 a0 01 	lds	r24, 0x01A0
    7430:	90 91 a1 01 	lds	r25, 0x01A1
    7434:	69 2f       	mov	r22, r25
    7436:	0e 94 8a 3c 	call	0x7914	; 0x7914 <GPIO_readPin>
    743a:	88 23       	and	r24, r24
    743c:	29 f5       	brne	.+74     	; 0x7488 <Get_Data+0xb2>
		vTaskDelay(pdMS_TO_TICKS( 50 ));
    743e:	82 e3       	ldi	r24, 0x32	; 50
    7440:	90 e0       	ldi	r25, 0x00	; 0
    7442:	0e 94 03 1e 	call	0x3c06	; 0x3c06 <vTaskDelay>
		if(!GPIO_readPin(dio_config_array[IGNITION_SWICH_ID].port_id,dio_config_array[IGNITION_SWICH_ID].pin_num)){
    7446:	80 91 a0 01 	lds	r24, 0x01A0
    744a:	90 91 a1 01 	lds	r25, 0x01A1
    744e:	69 2f       	mov	r22, r25
    7450:	0e 94 8a 3c 	call	0x7914	; 0x7914 <GPIO_readPin>
    7454:	88 23       	and	r24, r24
    7456:	99 f4       	brne	.+38     	; 0x747e <Get_Data+0xa8>
			ButtonState.ignition_key = 1;
    7458:	81 e0       	ldi	r24, 0x01	; 1
    745a:	80 93 3e 08 	sts	0x083E, r24
			if(!GPIO_readPin(dio_config_array[RIGHT_INDICATOR_BUTTON_ID].port_id,dio_config_array[RIGHT_INDICATOR_BUTTON_ID].pin_num)){
    745e:	80 91 9a 01 	lds	r24, 0x019A
    7462:	90 91 9b 01 	lds	r25, 0x019B
    7466:	69 2f       	mov	r22, r25
    7468:	0e 94 8a 3c 	call	0x7914	; 0x7914 <GPIO_readPin>
    746c:	88 23       	and	r24, r24
    746e:	21 f4       	brne	.+8      	; 0x7478 <Get_Data+0xa2>
				ButtonState.rightIndicator = 1;
    7470:	81 e0       	ldi	r24, 0x01	; 1
    7472:	80 93 3f 08 	sts	0x083F, r24
    7476:	6a c0       	rjmp	.+212    	; 0x754c <Get_Data+0x176>
			}
			else{
				ButtonState.rightIndicator = 0;
    7478:	10 92 3f 08 	sts	0x083F, r1
    747c:	67 c0       	rjmp	.+206    	; 0x754c <Get_Data+0x176>
			}
		}
		else{
			ButtonState.ignition_key = 0;
    747e:	10 92 3e 08 	sts	0x083E, r1
			ButtonState.rightIndicator = 0;
    7482:	10 92 3f 08 	sts	0x083F, r1
    7486:	62 c0       	rjmp	.+196    	; 0x754c <Get_Data+0x176>
		}
	}
	else if(!GPIO_readPin(dio_config_array[LEFT_INDICATOR_BUTTON_ID].port_id,dio_config_array[LEFT_INDICATOR_BUTTON_ID].pin_num) && !GPIO_readPin(dio_config_array[IGNITION_SWICH_ID].port_id,dio_config_array[IGNITION_SWICH_ID].pin_num)){
    7488:	80 91 9d 01 	lds	r24, 0x019D
    748c:	90 91 9e 01 	lds	r25, 0x019E
    7490:	69 2f       	mov	r22, r25
    7492:	0e 94 8a 3c 	call	0x7914	; 0x7914 <GPIO_readPin>
    7496:	88 23       	and	r24, r24
    7498:	71 f5       	brne	.+92     	; 0x74f6 <Get_Data+0x120>
    749a:	80 91 a0 01 	lds	r24, 0x01A0
    749e:	90 91 a1 01 	lds	r25, 0x01A1
    74a2:	69 2f       	mov	r22, r25
    74a4:	0e 94 8a 3c 	call	0x7914	; 0x7914 <GPIO_readPin>
    74a8:	88 23       	and	r24, r24
    74aa:	29 f5       	brne	.+74     	; 0x74f6 <Get_Data+0x120>
		vTaskDelay(pdMS_TO_TICKS( 50 ));
    74ac:	82 e3       	ldi	r24, 0x32	; 50
    74ae:	90 e0       	ldi	r25, 0x00	; 0
    74b0:	0e 94 03 1e 	call	0x3c06	; 0x3c06 <vTaskDelay>
		if(!GPIO_readPin(dio_config_array[IGNITION_SWICH_ID].port_id,dio_config_array[IGNITION_SWICH_ID].pin_num)){
    74b4:	80 91 a0 01 	lds	r24, 0x01A0
    74b8:	90 91 a1 01 	lds	r25, 0x01A1
    74bc:	69 2f       	mov	r22, r25
    74be:	0e 94 8a 3c 	call	0x7914	; 0x7914 <GPIO_readPin>
    74c2:	88 23       	and	r24, r24
    74c4:	99 f4       	brne	.+38     	; 0x74ec <Get_Data+0x116>
			ButtonState.ignition_key = 1;
    74c6:	81 e0       	ldi	r24, 0x01	; 1
    74c8:	80 93 3e 08 	sts	0x083E, r24
			if(!GPIO_readPin(dio_config_array[LEFT_INDICATOR_BUTTON_ID].port_id,dio_config_array[LEFT_INDICATOR_BUTTON_ID].pin_num)){
    74cc:	80 91 9d 01 	lds	r24, 0x019D
    74d0:	90 91 9e 01 	lds	r25, 0x019E
    74d4:	69 2f       	mov	r22, r25
    74d6:	0e 94 8a 3c 	call	0x7914	; 0x7914 <GPIO_readPin>
    74da:	88 23       	and	r24, r24
    74dc:	21 f4       	brne	.+8      	; 0x74e6 <Get_Data+0x110>
				ButtonState.leftIndicator = 1;
    74de:	81 e0       	ldi	r24, 0x01	; 1
    74e0:	80 93 40 08 	sts	0x0840, r24
    74e4:	33 c0       	rjmp	.+102    	; 0x754c <Get_Data+0x176>
			}
			else{
				ButtonState.leftIndicator = 0;
    74e6:	10 92 40 08 	sts	0x0840, r1
    74ea:	30 c0       	rjmp	.+96     	; 0x754c <Get_Data+0x176>
			}
		}
		else{
			ButtonState.ignition_key = 0;
    74ec:	10 92 3e 08 	sts	0x083E, r1
			ButtonState.leftIndicator = 0;
    74f0:	10 92 40 08 	sts	0x0840, r1
    74f4:	2b c0       	rjmp	.+86     	; 0x754c <Get_Data+0x176>
		}
	}
	else if(!GPIO_readPin(dio_config_array[IGNITION_SWICH_ID].port_id,dio_config_array[IGNITION_SWICH_ID].pin_num)){
    74f6:	80 91 a0 01 	lds	r24, 0x01A0
    74fa:	90 91 a1 01 	lds	r25, 0x01A1
    74fe:	69 2f       	mov	r22, r25
    7500:	0e 94 8a 3c 	call	0x7914	; 0x7914 <GPIO_readPin>
    7504:	88 23       	and	r24, r24
    7506:	e1 f4       	brne	.+56     	; 0x7540 <Get_Data+0x16a>
		vTaskDelay(pdMS_TO_TICKS( 50 ));
    7508:	82 e3       	ldi	r24, 0x32	; 50
    750a:	90 e0       	ldi	r25, 0x00	; 0
    750c:	0e 94 03 1e 	call	0x3c06	; 0x3c06 <vTaskDelay>
		if(!GPIO_readPin(dio_config_array[IGNITION_SWICH_ID].port_id,dio_config_array[IGNITION_SWICH_ID].pin_num)){
    7510:	80 91 a0 01 	lds	r24, 0x01A0
    7514:	90 91 a1 01 	lds	r25, 0x01A1
    7518:	69 2f       	mov	r22, r25
    751a:	0e 94 8a 3c 	call	0x7914	; 0x7914 <GPIO_readPin>
    751e:	88 23       	and	r24, r24
    7520:	41 f4       	brne	.+16     	; 0x7532 <Get_Data+0x15c>
			ButtonState.ignition_key = 1;
    7522:	81 e0       	ldi	r24, 0x01	; 1
    7524:	80 93 3e 08 	sts	0x083E, r24
			ButtonState.rightIndicator = 0;
    7528:	10 92 3f 08 	sts	0x083F, r1
			ButtonState.leftIndicator = 0;
    752c:	10 92 40 08 	sts	0x0840, r1
    7530:	0d c0       	rjmp	.+26     	; 0x754c <Get_Data+0x176>
		}
		else{
			ButtonState.ignition_key = 0;
    7532:	10 92 3e 08 	sts	0x083E, r1
			ButtonState.rightIndicator = 0;
    7536:	10 92 3f 08 	sts	0x083F, r1
			ButtonState.leftIndicator = 0;
    753a:	10 92 40 08 	sts	0x0840, r1
    753e:	06 c0       	rjmp	.+12     	; 0x754c <Get_Data+0x176>
		}
	}
	else{
		ButtonState.ignition_key = 0;
    7540:	10 92 3e 08 	sts	0x083E, r1
		ButtonState.rightIndicator = 0;
    7544:	10 92 3f 08 	sts	0x083F, r1
		ButtonState.leftIndicator = 0;
    7548:	10 92 40 08 	sts	0x0840, r1
	//	else{
	//		ButtonState.ignition_key = 0;
	//	}


	return ButtonState;
    754c:	80 91 3e 08 	lds	r24, 0x083E
    7550:	90 91 3f 08 	lds	r25, 0x083F
    7554:	a0 91 40 08 	lds	r26, 0x0840
    7558:	b0 91 41 08 	lds	r27, 0x0841
}
    755c:	bc 01       	movw	r22, r24
    755e:	cd 01       	movw	r24, r26
    7560:	0f 90       	pop	r0
    7562:	cf 91       	pop	r28
    7564:	df 91       	pop	r29
    7566:	08 95       	ret

00007568 <GPIO_setupPinDirection>:
 * Description :
 * Setup the direction of the required pin input/output.
 * If the input port number or pin number are not correct, The function will not handle the request.
 */
void GPIO_setupPinDirection(uint8 port_num, uint8 pin_num, GPIO_PinDirectionType direction)
{
    7568:	df 93       	push	r29
    756a:	cf 93       	push	r28
    756c:	00 d0       	rcall	.+0      	; 0x756e <GPIO_setupPinDirection+0x6>
    756e:	00 d0       	rcall	.+0      	; 0x7570 <GPIO_setupPinDirection+0x8>
    7570:	0f 92       	push	r0
    7572:	cd b7       	in	r28, 0x3d	; 61
    7574:	de b7       	in	r29, 0x3e	; 62
    7576:	89 83       	std	Y+1, r24	; 0x01
    7578:	6a 83       	std	Y+2, r22	; 0x02
    757a:	4b 83       	std	Y+3, r20	; 0x03
	/*
	 * Check if the input port number is greater than NUM_OF_PINS_PER_PORT value.
	 * Or if the input pin number is greater than NUM_OF_PINS_PER_PORT value.
	 * In this case the input is not valid port/pin number
	 */
	if((pin_num >= NUM_OF_PINS_PER_PORT) || (port_num >= NUM_OF_PORTS))
    757c:	8a 81       	ldd	r24, Y+2	; 0x02
    757e:	88 30       	cpi	r24, 0x08	; 8
    7580:	08 f0       	brcs	.+2      	; 0x7584 <GPIO_setupPinDirection+0x1c>
    7582:	d5 c0       	rjmp	.+426    	; 0x772e <GPIO_setupPinDirection+0x1c6>
    7584:	89 81       	ldd	r24, Y+1	; 0x01
    7586:	86 30       	cpi	r24, 0x06	; 6
    7588:	08 f0       	brcs	.+2      	; 0x758c <GPIO_setupPinDirection+0x24>
    758a:	d1 c0       	rjmp	.+418    	; 0x772e <GPIO_setupPinDirection+0x1c6>
		/* Do Nothing */
	}
	else
	{
		/* Setup the pin direction as required */
		switch(port_num)
    758c:	89 81       	ldd	r24, Y+1	; 0x01
    758e:	28 2f       	mov	r18, r24
    7590:	30 e0       	ldi	r19, 0x00	; 0
    7592:	3d 83       	std	Y+5, r19	; 0x05
    7594:	2c 83       	std	Y+4, r18	; 0x04
    7596:	8c 81       	ldd	r24, Y+4	; 0x04
    7598:	9d 81       	ldd	r25, Y+5	; 0x05
    759a:	81 30       	cpi	r24, 0x01	; 1
    759c:	91 05       	cpc	r25, r1
    759e:	09 f4       	brne	.+2      	; 0x75a2 <GPIO_setupPinDirection+0x3a>
    75a0:	43 c0       	rjmp	.+134    	; 0x7628 <GPIO_setupPinDirection+0xc0>
    75a2:	2c 81       	ldd	r18, Y+4	; 0x04
    75a4:	3d 81       	ldd	r19, Y+5	; 0x05
    75a6:	22 30       	cpi	r18, 0x02	; 2
    75a8:	31 05       	cpc	r19, r1
    75aa:	2c f4       	brge	.+10     	; 0x75b6 <GPIO_setupPinDirection+0x4e>
    75ac:	8c 81       	ldd	r24, Y+4	; 0x04
    75ae:	9d 81       	ldd	r25, Y+5	; 0x05
    75b0:	00 97       	sbiw	r24, 0x00	; 0
    75b2:	71 f0       	breq	.+28     	; 0x75d0 <GPIO_setupPinDirection+0x68>
    75b4:	bc c0       	rjmp	.+376    	; 0x772e <GPIO_setupPinDirection+0x1c6>
    75b6:	2c 81       	ldd	r18, Y+4	; 0x04
    75b8:	3d 81       	ldd	r19, Y+5	; 0x05
    75ba:	22 30       	cpi	r18, 0x02	; 2
    75bc:	31 05       	cpc	r19, r1
    75be:	09 f4       	brne	.+2      	; 0x75c2 <GPIO_setupPinDirection+0x5a>
    75c0:	5f c0       	rjmp	.+190    	; 0x7680 <GPIO_setupPinDirection+0x118>
    75c2:	8c 81       	ldd	r24, Y+4	; 0x04
    75c4:	9d 81       	ldd	r25, Y+5	; 0x05
    75c6:	83 30       	cpi	r24, 0x03	; 3
    75c8:	91 05       	cpc	r25, r1
    75ca:	09 f4       	brne	.+2      	; 0x75ce <GPIO_setupPinDirection+0x66>
    75cc:	85 c0       	rjmp	.+266    	; 0x76d8 <GPIO_setupPinDirection+0x170>
    75ce:	af c0       	rjmp	.+350    	; 0x772e <GPIO_setupPinDirection+0x1c6>
		{
		case PORTA_ID:
			if(direction == PIN_OUTPUT)
    75d0:	8b 81       	ldd	r24, Y+3	; 0x03
    75d2:	81 30       	cpi	r24, 0x01	; 1
    75d4:	a1 f4       	brne	.+40     	; 0x75fe <GPIO_setupPinDirection+0x96>
			{
				SET_BIT(DDRA,pin_num);
    75d6:	aa e3       	ldi	r26, 0x3A	; 58
    75d8:	b0 e0       	ldi	r27, 0x00	; 0
    75da:	ea e3       	ldi	r30, 0x3A	; 58
    75dc:	f0 e0       	ldi	r31, 0x00	; 0
    75de:	80 81       	ld	r24, Z
    75e0:	48 2f       	mov	r20, r24
    75e2:	8a 81       	ldd	r24, Y+2	; 0x02
    75e4:	28 2f       	mov	r18, r24
    75e6:	30 e0       	ldi	r19, 0x00	; 0
    75e8:	81 e0       	ldi	r24, 0x01	; 1
    75ea:	90 e0       	ldi	r25, 0x00	; 0
    75ec:	02 2e       	mov	r0, r18
    75ee:	02 c0       	rjmp	.+4      	; 0x75f4 <GPIO_setupPinDirection+0x8c>
    75f0:	88 0f       	add	r24, r24
    75f2:	99 1f       	adc	r25, r25
    75f4:	0a 94       	dec	r0
    75f6:	e2 f7       	brpl	.-8      	; 0x75f0 <GPIO_setupPinDirection+0x88>
    75f8:	84 2b       	or	r24, r20
    75fa:	8c 93       	st	X, r24
    75fc:	98 c0       	rjmp	.+304    	; 0x772e <GPIO_setupPinDirection+0x1c6>
			}
			else
			{
				CLEAR_BIT(DDRA,pin_num);
    75fe:	aa e3       	ldi	r26, 0x3A	; 58
    7600:	b0 e0       	ldi	r27, 0x00	; 0
    7602:	ea e3       	ldi	r30, 0x3A	; 58
    7604:	f0 e0       	ldi	r31, 0x00	; 0
    7606:	80 81       	ld	r24, Z
    7608:	48 2f       	mov	r20, r24
    760a:	8a 81       	ldd	r24, Y+2	; 0x02
    760c:	28 2f       	mov	r18, r24
    760e:	30 e0       	ldi	r19, 0x00	; 0
    7610:	81 e0       	ldi	r24, 0x01	; 1
    7612:	90 e0       	ldi	r25, 0x00	; 0
    7614:	02 2e       	mov	r0, r18
    7616:	02 c0       	rjmp	.+4      	; 0x761c <GPIO_setupPinDirection+0xb4>
    7618:	88 0f       	add	r24, r24
    761a:	99 1f       	adc	r25, r25
    761c:	0a 94       	dec	r0
    761e:	e2 f7       	brpl	.-8      	; 0x7618 <GPIO_setupPinDirection+0xb0>
    7620:	80 95       	com	r24
    7622:	84 23       	and	r24, r20
    7624:	8c 93       	st	X, r24
    7626:	83 c0       	rjmp	.+262    	; 0x772e <GPIO_setupPinDirection+0x1c6>
			}
			break;
		case PORTB_ID:
			if(direction == PIN_OUTPUT)
    7628:	8b 81       	ldd	r24, Y+3	; 0x03
    762a:	81 30       	cpi	r24, 0x01	; 1
    762c:	a1 f4       	brne	.+40     	; 0x7656 <GPIO_setupPinDirection+0xee>
			{
				SET_BIT(DDRB,pin_num);
    762e:	a7 e3       	ldi	r26, 0x37	; 55
    7630:	b0 e0       	ldi	r27, 0x00	; 0
    7632:	e7 e3       	ldi	r30, 0x37	; 55
    7634:	f0 e0       	ldi	r31, 0x00	; 0
    7636:	80 81       	ld	r24, Z
    7638:	48 2f       	mov	r20, r24
    763a:	8a 81       	ldd	r24, Y+2	; 0x02
    763c:	28 2f       	mov	r18, r24
    763e:	30 e0       	ldi	r19, 0x00	; 0
    7640:	81 e0       	ldi	r24, 0x01	; 1
    7642:	90 e0       	ldi	r25, 0x00	; 0
    7644:	02 2e       	mov	r0, r18
    7646:	02 c0       	rjmp	.+4      	; 0x764c <GPIO_setupPinDirection+0xe4>
    7648:	88 0f       	add	r24, r24
    764a:	99 1f       	adc	r25, r25
    764c:	0a 94       	dec	r0
    764e:	e2 f7       	brpl	.-8      	; 0x7648 <GPIO_setupPinDirection+0xe0>
    7650:	84 2b       	or	r24, r20
    7652:	8c 93       	st	X, r24
    7654:	6c c0       	rjmp	.+216    	; 0x772e <GPIO_setupPinDirection+0x1c6>
			}
			else
			{
				CLEAR_BIT(DDRB,pin_num);
    7656:	a7 e3       	ldi	r26, 0x37	; 55
    7658:	b0 e0       	ldi	r27, 0x00	; 0
    765a:	e7 e3       	ldi	r30, 0x37	; 55
    765c:	f0 e0       	ldi	r31, 0x00	; 0
    765e:	80 81       	ld	r24, Z
    7660:	48 2f       	mov	r20, r24
    7662:	8a 81       	ldd	r24, Y+2	; 0x02
    7664:	28 2f       	mov	r18, r24
    7666:	30 e0       	ldi	r19, 0x00	; 0
    7668:	81 e0       	ldi	r24, 0x01	; 1
    766a:	90 e0       	ldi	r25, 0x00	; 0
    766c:	02 2e       	mov	r0, r18
    766e:	02 c0       	rjmp	.+4      	; 0x7674 <GPIO_setupPinDirection+0x10c>
    7670:	88 0f       	add	r24, r24
    7672:	99 1f       	adc	r25, r25
    7674:	0a 94       	dec	r0
    7676:	e2 f7       	brpl	.-8      	; 0x7670 <GPIO_setupPinDirection+0x108>
    7678:	80 95       	com	r24
    767a:	84 23       	and	r24, r20
    767c:	8c 93       	st	X, r24
    767e:	57 c0       	rjmp	.+174    	; 0x772e <GPIO_setupPinDirection+0x1c6>
			}
			break;
		case PORTC_ID:
			if(direction == PIN_OUTPUT)
    7680:	8b 81       	ldd	r24, Y+3	; 0x03
    7682:	81 30       	cpi	r24, 0x01	; 1
    7684:	a1 f4       	brne	.+40     	; 0x76ae <GPIO_setupPinDirection+0x146>
			{
				SET_BIT(DDRC,pin_num);
    7686:	a4 e3       	ldi	r26, 0x34	; 52
    7688:	b0 e0       	ldi	r27, 0x00	; 0
    768a:	e4 e3       	ldi	r30, 0x34	; 52
    768c:	f0 e0       	ldi	r31, 0x00	; 0
    768e:	80 81       	ld	r24, Z
    7690:	48 2f       	mov	r20, r24
    7692:	8a 81       	ldd	r24, Y+2	; 0x02
    7694:	28 2f       	mov	r18, r24
    7696:	30 e0       	ldi	r19, 0x00	; 0
    7698:	81 e0       	ldi	r24, 0x01	; 1
    769a:	90 e0       	ldi	r25, 0x00	; 0
    769c:	02 2e       	mov	r0, r18
    769e:	02 c0       	rjmp	.+4      	; 0x76a4 <GPIO_setupPinDirection+0x13c>
    76a0:	88 0f       	add	r24, r24
    76a2:	99 1f       	adc	r25, r25
    76a4:	0a 94       	dec	r0
    76a6:	e2 f7       	brpl	.-8      	; 0x76a0 <GPIO_setupPinDirection+0x138>
    76a8:	84 2b       	or	r24, r20
    76aa:	8c 93       	st	X, r24
    76ac:	40 c0       	rjmp	.+128    	; 0x772e <GPIO_setupPinDirection+0x1c6>
			}
			else
			{
				CLEAR_BIT(DDRC,pin_num);
    76ae:	a4 e3       	ldi	r26, 0x34	; 52
    76b0:	b0 e0       	ldi	r27, 0x00	; 0
    76b2:	e4 e3       	ldi	r30, 0x34	; 52
    76b4:	f0 e0       	ldi	r31, 0x00	; 0
    76b6:	80 81       	ld	r24, Z
    76b8:	48 2f       	mov	r20, r24
    76ba:	8a 81       	ldd	r24, Y+2	; 0x02
    76bc:	28 2f       	mov	r18, r24
    76be:	30 e0       	ldi	r19, 0x00	; 0
    76c0:	81 e0       	ldi	r24, 0x01	; 1
    76c2:	90 e0       	ldi	r25, 0x00	; 0
    76c4:	02 2e       	mov	r0, r18
    76c6:	02 c0       	rjmp	.+4      	; 0x76cc <GPIO_setupPinDirection+0x164>
    76c8:	88 0f       	add	r24, r24
    76ca:	99 1f       	adc	r25, r25
    76cc:	0a 94       	dec	r0
    76ce:	e2 f7       	brpl	.-8      	; 0x76c8 <GPIO_setupPinDirection+0x160>
    76d0:	80 95       	com	r24
    76d2:	84 23       	and	r24, r20
    76d4:	8c 93       	st	X, r24
    76d6:	2b c0       	rjmp	.+86     	; 0x772e <GPIO_setupPinDirection+0x1c6>
			}
			break;
		case PORTD_ID:
			if(direction == PIN_OUTPUT)
    76d8:	8b 81       	ldd	r24, Y+3	; 0x03
    76da:	81 30       	cpi	r24, 0x01	; 1
    76dc:	a1 f4       	brne	.+40     	; 0x7706 <GPIO_setupPinDirection+0x19e>
			{
				SET_BIT(DDRD,pin_num);
    76de:	a1 e3       	ldi	r26, 0x31	; 49
    76e0:	b0 e0       	ldi	r27, 0x00	; 0
    76e2:	e1 e3       	ldi	r30, 0x31	; 49
    76e4:	f0 e0       	ldi	r31, 0x00	; 0
    76e6:	80 81       	ld	r24, Z
    76e8:	48 2f       	mov	r20, r24
    76ea:	8a 81       	ldd	r24, Y+2	; 0x02
    76ec:	28 2f       	mov	r18, r24
    76ee:	30 e0       	ldi	r19, 0x00	; 0
    76f0:	81 e0       	ldi	r24, 0x01	; 1
    76f2:	90 e0       	ldi	r25, 0x00	; 0
    76f4:	02 2e       	mov	r0, r18
    76f6:	02 c0       	rjmp	.+4      	; 0x76fc <GPIO_setupPinDirection+0x194>
    76f8:	88 0f       	add	r24, r24
    76fa:	99 1f       	adc	r25, r25
    76fc:	0a 94       	dec	r0
    76fe:	e2 f7       	brpl	.-8      	; 0x76f8 <GPIO_setupPinDirection+0x190>
    7700:	84 2b       	or	r24, r20
    7702:	8c 93       	st	X, r24
    7704:	14 c0       	rjmp	.+40     	; 0x772e <GPIO_setupPinDirection+0x1c6>
			}
			else
			{
				CLEAR_BIT(DDRD,pin_num);
    7706:	a1 e3       	ldi	r26, 0x31	; 49
    7708:	b0 e0       	ldi	r27, 0x00	; 0
    770a:	e1 e3       	ldi	r30, 0x31	; 49
    770c:	f0 e0       	ldi	r31, 0x00	; 0
    770e:	80 81       	ld	r24, Z
    7710:	48 2f       	mov	r20, r24
    7712:	8a 81       	ldd	r24, Y+2	; 0x02
    7714:	28 2f       	mov	r18, r24
    7716:	30 e0       	ldi	r19, 0x00	; 0
    7718:	81 e0       	ldi	r24, 0x01	; 1
    771a:	90 e0       	ldi	r25, 0x00	; 0
    771c:	02 2e       	mov	r0, r18
    771e:	02 c0       	rjmp	.+4      	; 0x7724 <GPIO_setupPinDirection+0x1bc>
    7720:	88 0f       	add	r24, r24
    7722:	99 1f       	adc	r25, r25
    7724:	0a 94       	dec	r0
    7726:	e2 f7       	brpl	.-8      	; 0x7720 <GPIO_setupPinDirection+0x1b8>
    7728:	80 95       	com	r24
    772a:	84 23       	and	r24, r20
    772c:	8c 93       	st	X, r24
//				CLEAR_BIT(DDRF,pin_num);
//			}
//			break;
		}
	}
}
    772e:	0f 90       	pop	r0
    7730:	0f 90       	pop	r0
    7732:	0f 90       	pop	r0
    7734:	0f 90       	pop	r0
    7736:	0f 90       	pop	r0
    7738:	cf 91       	pop	r28
    773a:	df 91       	pop	r29
    773c:	08 95       	ret

0000773e <GPIO_writePin>:
 * Write the value Logic High or Logic Low on the required pin.
 * If the input port number or pin number are not correct, The function will not handle the request.
 * If the pin is input, this function will enable/disable the internal pull-up resistor.
 */
void GPIO_writePin(uint8 port_num, uint8 pin_num, uint8 value)
{
    773e:	df 93       	push	r29
    7740:	cf 93       	push	r28
    7742:	00 d0       	rcall	.+0      	; 0x7744 <GPIO_writePin+0x6>
    7744:	00 d0       	rcall	.+0      	; 0x7746 <GPIO_writePin+0x8>
    7746:	0f 92       	push	r0
    7748:	cd b7       	in	r28, 0x3d	; 61
    774a:	de b7       	in	r29, 0x3e	; 62
    774c:	89 83       	std	Y+1, r24	; 0x01
    774e:	6a 83       	std	Y+2, r22	; 0x02
    7750:	4b 83       	std	Y+3, r20	; 0x03
	/*
	 * Check if the input port number is greater than NUM_OF_PINS_PER_PORT value.
	 * Or if the input pin number is greater than NUM_OF_PINS_PER_PORT value.
	 * In this case the input is not valid port/pin number
	 */
	if((pin_num >= NUM_OF_PINS_PER_PORT) || (port_num >= NUM_OF_PORTS))
    7752:	8a 81       	ldd	r24, Y+2	; 0x02
    7754:	88 30       	cpi	r24, 0x08	; 8
    7756:	08 f0       	brcs	.+2      	; 0x775a <GPIO_writePin+0x1c>
    7758:	d5 c0       	rjmp	.+426    	; 0x7904 <GPIO_writePin+0x1c6>
    775a:	89 81       	ldd	r24, Y+1	; 0x01
    775c:	86 30       	cpi	r24, 0x06	; 6
    775e:	08 f0       	brcs	.+2      	; 0x7762 <GPIO_writePin+0x24>
    7760:	d1 c0       	rjmp	.+418    	; 0x7904 <GPIO_writePin+0x1c6>
		/* Do Nothing */
	}
	else
	{
		/* Write the pin value as required */
		switch(port_num)
    7762:	89 81       	ldd	r24, Y+1	; 0x01
    7764:	28 2f       	mov	r18, r24
    7766:	30 e0       	ldi	r19, 0x00	; 0
    7768:	3d 83       	std	Y+5, r19	; 0x05
    776a:	2c 83       	std	Y+4, r18	; 0x04
    776c:	8c 81       	ldd	r24, Y+4	; 0x04
    776e:	9d 81       	ldd	r25, Y+5	; 0x05
    7770:	81 30       	cpi	r24, 0x01	; 1
    7772:	91 05       	cpc	r25, r1
    7774:	09 f4       	brne	.+2      	; 0x7778 <GPIO_writePin+0x3a>
    7776:	43 c0       	rjmp	.+134    	; 0x77fe <GPIO_writePin+0xc0>
    7778:	2c 81       	ldd	r18, Y+4	; 0x04
    777a:	3d 81       	ldd	r19, Y+5	; 0x05
    777c:	22 30       	cpi	r18, 0x02	; 2
    777e:	31 05       	cpc	r19, r1
    7780:	2c f4       	brge	.+10     	; 0x778c <GPIO_writePin+0x4e>
    7782:	8c 81       	ldd	r24, Y+4	; 0x04
    7784:	9d 81       	ldd	r25, Y+5	; 0x05
    7786:	00 97       	sbiw	r24, 0x00	; 0
    7788:	71 f0       	breq	.+28     	; 0x77a6 <GPIO_writePin+0x68>
    778a:	bc c0       	rjmp	.+376    	; 0x7904 <GPIO_writePin+0x1c6>
    778c:	2c 81       	ldd	r18, Y+4	; 0x04
    778e:	3d 81       	ldd	r19, Y+5	; 0x05
    7790:	22 30       	cpi	r18, 0x02	; 2
    7792:	31 05       	cpc	r19, r1
    7794:	09 f4       	brne	.+2      	; 0x7798 <GPIO_writePin+0x5a>
    7796:	5f c0       	rjmp	.+190    	; 0x7856 <GPIO_writePin+0x118>
    7798:	8c 81       	ldd	r24, Y+4	; 0x04
    779a:	9d 81       	ldd	r25, Y+5	; 0x05
    779c:	83 30       	cpi	r24, 0x03	; 3
    779e:	91 05       	cpc	r25, r1
    77a0:	09 f4       	brne	.+2      	; 0x77a4 <GPIO_writePin+0x66>
    77a2:	85 c0       	rjmp	.+266    	; 0x78ae <GPIO_writePin+0x170>
    77a4:	af c0       	rjmp	.+350    	; 0x7904 <GPIO_writePin+0x1c6>
		{
		case PORTA_ID:
			if(value == LOGIC_HIGH)
    77a6:	8b 81       	ldd	r24, Y+3	; 0x03
    77a8:	81 30       	cpi	r24, 0x01	; 1
    77aa:	a1 f4       	brne	.+40     	; 0x77d4 <GPIO_writePin+0x96>
			{
				SET_BIT(PORTA,pin_num);
    77ac:	ab e3       	ldi	r26, 0x3B	; 59
    77ae:	b0 e0       	ldi	r27, 0x00	; 0
    77b0:	eb e3       	ldi	r30, 0x3B	; 59
    77b2:	f0 e0       	ldi	r31, 0x00	; 0
    77b4:	80 81       	ld	r24, Z
    77b6:	48 2f       	mov	r20, r24
    77b8:	8a 81       	ldd	r24, Y+2	; 0x02
    77ba:	28 2f       	mov	r18, r24
    77bc:	30 e0       	ldi	r19, 0x00	; 0
    77be:	81 e0       	ldi	r24, 0x01	; 1
    77c0:	90 e0       	ldi	r25, 0x00	; 0
    77c2:	02 2e       	mov	r0, r18
    77c4:	02 c0       	rjmp	.+4      	; 0x77ca <GPIO_writePin+0x8c>
    77c6:	88 0f       	add	r24, r24
    77c8:	99 1f       	adc	r25, r25
    77ca:	0a 94       	dec	r0
    77cc:	e2 f7       	brpl	.-8      	; 0x77c6 <GPIO_writePin+0x88>
    77ce:	84 2b       	or	r24, r20
    77d0:	8c 93       	st	X, r24
    77d2:	98 c0       	rjmp	.+304    	; 0x7904 <GPIO_writePin+0x1c6>
			}
			else
			{
				CLEAR_BIT(PORTA,pin_num);
    77d4:	ab e3       	ldi	r26, 0x3B	; 59
    77d6:	b0 e0       	ldi	r27, 0x00	; 0
    77d8:	eb e3       	ldi	r30, 0x3B	; 59
    77da:	f0 e0       	ldi	r31, 0x00	; 0
    77dc:	80 81       	ld	r24, Z
    77de:	48 2f       	mov	r20, r24
    77e0:	8a 81       	ldd	r24, Y+2	; 0x02
    77e2:	28 2f       	mov	r18, r24
    77e4:	30 e0       	ldi	r19, 0x00	; 0
    77e6:	81 e0       	ldi	r24, 0x01	; 1
    77e8:	90 e0       	ldi	r25, 0x00	; 0
    77ea:	02 2e       	mov	r0, r18
    77ec:	02 c0       	rjmp	.+4      	; 0x77f2 <GPIO_writePin+0xb4>
    77ee:	88 0f       	add	r24, r24
    77f0:	99 1f       	adc	r25, r25
    77f2:	0a 94       	dec	r0
    77f4:	e2 f7       	brpl	.-8      	; 0x77ee <GPIO_writePin+0xb0>
    77f6:	80 95       	com	r24
    77f8:	84 23       	and	r24, r20
    77fa:	8c 93       	st	X, r24
    77fc:	83 c0       	rjmp	.+262    	; 0x7904 <GPIO_writePin+0x1c6>
			}
			break;
		case PORTB_ID:
			if(value == LOGIC_HIGH)
    77fe:	8b 81       	ldd	r24, Y+3	; 0x03
    7800:	81 30       	cpi	r24, 0x01	; 1
    7802:	a1 f4       	brne	.+40     	; 0x782c <GPIO_writePin+0xee>
			{
				SET_BIT(PORTB,pin_num);
    7804:	a8 e3       	ldi	r26, 0x38	; 56
    7806:	b0 e0       	ldi	r27, 0x00	; 0
    7808:	e8 e3       	ldi	r30, 0x38	; 56
    780a:	f0 e0       	ldi	r31, 0x00	; 0
    780c:	80 81       	ld	r24, Z
    780e:	48 2f       	mov	r20, r24
    7810:	8a 81       	ldd	r24, Y+2	; 0x02
    7812:	28 2f       	mov	r18, r24
    7814:	30 e0       	ldi	r19, 0x00	; 0
    7816:	81 e0       	ldi	r24, 0x01	; 1
    7818:	90 e0       	ldi	r25, 0x00	; 0
    781a:	02 2e       	mov	r0, r18
    781c:	02 c0       	rjmp	.+4      	; 0x7822 <GPIO_writePin+0xe4>
    781e:	88 0f       	add	r24, r24
    7820:	99 1f       	adc	r25, r25
    7822:	0a 94       	dec	r0
    7824:	e2 f7       	brpl	.-8      	; 0x781e <GPIO_writePin+0xe0>
    7826:	84 2b       	or	r24, r20
    7828:	8c 93       	st	X, r24
    782a:	6c c0       	rjmp	.+216    	; 0x7904 <GPIO_writePin+0x1c6>
			}
			else
			{
				CLEAR_BIT(PORTB,pin_num);
    782c:	a8 e3       	ldi	r26, 0x38	; 56
    782e:	b0 e0       	ldi	r27, 0x00	; 0
    7830:	e8 e3       	ldi	r30, 0x38	; 56
    7832:	f0 e0       	ldi	r31, 0x00	; 0
    7834:	80 81       	ld	r24, Z
    7836:	48 2f       	mov	r20, r24
    7838:	8a 81       	ldd	r24, Y+2	; 0x02
    783a:	28 2f       	mov	r18, r24
    783c:	30 e0       	ldi	r19, 0x00	; 0
    783e:	81 e0       	ldi	r24, 0x01	; 1
    7840:	90 e0       	ldi	r25, 0x00	; 0
    7842:	02 2e       	mov	r0, r18
    7844:	02 c0       	rjmp	.+4      	; 0x784a <GPIO_writePin+0x10c>
    7846:	88 0f       	add	r24, r24
    7848:	99 1f       	adc	r25, r25
    784a:	0a 94       	dec	r0
    784c:	e2 f7       	brpl	.-8      	; 0x7846 <GPIO_writePin+0x108>
    784e:	80 95       	com	r24
    7850:	84 23       	and	r24, r20
    7852:	8c 93       	st	X, r24
    7854:	57 c0       	rjmp	.+174    	; 0x7904 <GPIO_writePin+0x1c6>
			}
			break;
		case PORTC_ID:
			if(value == LOGIC_HIGH)
    7856:	8b 81       	ldd	r24, Y+3	; 0x03
    7858:	81 30       	cpi	r24, 0x01	; 1
    785a:	a1 f4       	brne	.+40     	; 0x7884 <GPIO_writePin+0x146>
			{
				SET_BIT(PORTC,pin_num);
    785c:	a5 e3       	ldi	r26, 0x35	; 53
    785e:	b0 e0       	ldi	r27, 0x00	; 0
    7860:	e5 e3       	ldi	r30, 0x35	; 53
    7862:	f0 e0       	ldi	r31, 0x00	; 0
    7864:	80 81       	ld	r24, Z
    7866:	48 2f       	mov	r20, r24
    7868:	8a 81       	ldd	r24, Y+2	; 0x02
    786a:	28 2f       	mov	r18, r24
    786c:	30 e0       	ldi	r19, 0x00	; 0
    786e:	81 e0       	ldi	r24, 0x01	; 1
    7870:	90 e0       	ldi	r25, 0x00	; 0
    7872:	02 2e       	mov	r0, r18
    7874:	02 c0       	rjmp	.+4      	; 0x787a <GPIO_writePin+0x13c>
    7876:	88 0f       	add	r24, r24
    7878:	99 1f       	adc	r25, r25
    787a:	0a 94       	dec	r0
    787c:	e2 f7       	brpl	.-8      	; 0x7876 <GPIO_writePin+0x138>
    787e:	84 2b       	or	r24, r20
    7880:	8c 93       	st	X, r24
    7882:	40 c0       	rjmp	.+128    	; 0x7904 <GPIO_writePin+0x1c6>
			}
			else
			{
				CLEAR_BIT(PORTC,pin_num);
    7884:	a5 e3       	ldi	r26, 0x35	; 53
    7886:	b0 e0       	ldi	r27, 0x00	; 0
    7888:	e5 e3       	ldi	r30, 0x35	; 53
    788a:	f0 e0       	ldi	r31, 0x00	; 0
    788c:	80 81       	ld	r24, Z
    788e:	48 2f       	mov	r20, r24
    7890:	8a 81       	ldd	r24, Y+2	; 0x02
    7892:	28 2f       	mov	r18, r24
    7894:	30 e0       	ldi	r19, 0x00	; 0
    7896:	81 e0       	ldi	r24, 0x01	; 1
    7898:	90 e0       	ldi	r25, 0x00	; 0
    789a:	02 2e       	mov	r0, r18
    789c:	02 c0       	rjmp	.+4      	; 0x78a2 <GPIO_writePin+0x164>
    789e:	88 0f       	add	r24, r24
    78a0:	99 1f       	adc	r25, r25
    78a2:	0a 94       	dec	r0
    78a4:	e2 f7       	brpl	.-8      	; 0x789e <GPIO_writePin+0x160>
    78a6:	80 95       	com	r24
    78a8:	84 23       	and	r24, r20
    78aa:	8c 93       	st	X, r24
    78ac:	2b c0       	rjmp	.+86     	; 0x7904 <GPIO_writePin+0x1c6>
			}
			break;
		case PORTD_ID:
			if(value == LOGIC_HIGH)
    78ae:	8b 81       	ldd	r24, Y+3	; 0x03
    78b0:	81 30       	cpi	r24, 0x01	; 1
    78b2:	a1 f4       	brne	.+40     	; 0x78dc <GPIO_writePin+0x19e>
			{
				SET_BIT(PORTD,pin_num);
    78b4:	a2 e3       	ldi	r26, 0x32	; 50
    78b6:	b0 e0       	ldi	r27, 0x00	; 0
    78b8:	e2 e3       	ldi	r30, 0x32	; 50
    78ba:	f0 e0       	ldi	r31, 0x00	; 0
    78bc:	80 81       	ld	r24, Z
    78be:	48 2f       	mov	r20, r24
    78c0:	8a 81       	ldd	r24, Y+2	; 0x02
    78c2:	28 2f       	mov	r18, r24
    78c4:	30 e0       	ldi	r19, 0x00	; 0
    78c6:	81 e0       	ldi	r24, 0x01	; 1
    78c8:	90 e0       	ldi	r25, 0x00	; 0
    78ca:	02 2e       	mov	r0, r18
    78cc:	02 c0       	rjmp	.+4      	; 0x78d2 <GPIO_writePin+0x194>
    78ce:	88 0f       	add	r24, r24
    78d0:	99 1f       	adc	r25, r25
    78d2:	0a 94       	dec	r0
    78d4:	e2 f7       	brpl	.-8      	; 0x78ce <GPIO_writePin+0x190>
    78d6:	84 2b       	or	r24, r20
    78d8:	8c 93       	st	X, r24
    78da:	14 c0       	rjmp	.+40     	; 0x7904 <GPIO_writePin+0x1c6>
			}
			else
			{
				CLEAR_BIT(PORTD,pin_num);
    78dc:	a2 e3       	ldi	r26, 0x32	; 50
    78de:	b0 e0       	ldi	r27, 0x00	; 0
    78e0:	e2 e3       	ldi	r30, 0x32	; 50
    78e2:	f0 e0       	ldi	r31, 0x00	; 0
    78e4:	80 81       	ld	r24, Z
    78e6:	48 2f       	mov	r20, r24
    78e8:	8a 81       	ldd	r24, Y+2	; 0x02
    78ea:	28 2f       	mov	r18, r24
    78ec:	30 e0       	ldi	r19, 0x00	; 0
    78ee:	81 e0       	ldi	r24, 0x01	; 1
    78f0:	90 e0       	ldi	r25, 0x00	; 0
    78f2:	02 2e       	mov	r0, r18
    78f4:	02 c0       	rjmp	.+4      	; 0x78fa <GPIO_writePin+0x1bc>
    78f6:	88 0f       	add	r24, r24
    78f8:	99 1f       	adc	r25, r25
    78fa:	0a 94       	dec	r0
    78fc:	e2 f7       	brpl	.-8      	; 0x78f6 <GPIO_writePin+0x1b8>
    78fe:	80 95       	com	r24
    7900:	84 23       	and	r24, r20
    7902:	8c 93       	st	X, r24
//				CLEAR_BIT(PORTF,pin_num);
//			}
//			break;
		}
	}
}
    7904:	0f 90       	pop	r0
    7906:	0f 90       	pop	r0
    7908:	0f 90       	pop	r0
    790a:	0f 90       	pop	r0
    790c:	0f 90       	pop	r0
    790e:	cf 91       	pop	r28
    7910:	df 91       	pop	r29
    7912:	08 95       	ret

00007914 <GPIO_readPin>:
 * Description :
 * Read and return the value for the required pin, it should be Logic High or Logic Low.
 * If the input port number or pin number are not correct, The function will return Logic Low.
 */
uint8 GPIO_readPin(uint8 port_num, uint8 pin_num)
{
    7914:	df 93       	push	r29
    7916:	cf 93       	push	r28
    7918:	00 d0       	rcall	.+0      	; 0x791a <GPIO_readPin+0x6>
    791a:	00 d0       	rcall	.+0      	; 0x791c <GPIO_readPin+0x8>
    791c:	0f 92       	push	r0
    791e:	cd b7       	in	r28, 0x3d	; 61
    7920:	de b7       	in	r29, 0x3e	; 62
    7922:	8a 83       	std	Y+2, r24	; 0x02
    7924:	6b 83       	std	Y+3, r22	; 0x03
	uint8 pin_value = LOGIC_LOW;
    7926:	19 82       	std	Y+1, r1	; 0x01
	/*
	 * Check if the input port number is greater than NUM_OF_PINS_PER_PORT value.
	 * Or if the input pin number is greater than NUM_OF_PINS_PER_PORT value.
	 * In this case the input is not valid port/pin number
	 */
	if((pin_num >= NUM_OF_PINS_PER_PORT) || (port_num >= NUM_OF_PORTS))
    7928:	8b 81       	ldd	r24, Y+3	; 0x03
    792a:	88 30       	cpi	r24, 0x08	; 8
    792c:	08 f0       	brcs	.+2      	; 0x7930 <GPIO_readPin+0x1c>
    792e:	84 c0       	rjmp	.+264    	; 0x7a38 <GPIO_readPin+0x124>
    7930:	8a 81       	ldd	r24, Y+2	; 0x02
    7932:	86 30       	cpi	r24, 0x06	; 6
    7934:	08 f0       	brcs	.+2      	; 0x7938 <GPIO_readPin+0x24>
    7936:	80 c0       	rjmp	.+256    	; 0x7a38 <GPIO_readPin+0x124>
		/* Do Nothing */
	}
	else
	{
		/* Read the pin value as required */
		switch(port_num)
    7938:	8a 81       	ldd	r24, Y+2	; 0x02
    793a:	28 2f       	mov	r18, r24
    793c:	30 e0       	ldi	r19, 0x00	; 0
    793e:	3d 83       	std	Y+5, r19	; 0x05
    7940:	2c 83       	std	Y+4, r18	; 0x04
    7942:	4c 81       	ldd	r20, Y+4	; 0x04
    7944:	5d 81       	ldd	r21, Y+5	; 0x05
    7946:	41 30       	cpi	r20, 0x01	; 1
    7948:	51 05       	cpc	r21, r1
    794a:	79 f1       	breq	.+94     	; 0x79aa <GPIO_readPin+0x96>
    794c:	8c 81       	ldd	r24, Y+4	; 0x04
    794e:	9d 81       	ldd	r25, Y+5	; 0x05
    7950:	82 30       	cpi	r24, 0x02	; 2
    7952:	91 05       	cpc	r25, r1
    7954:	34 f4       	brge	.+12     	; 0x7962 <GPIO_readPin+0x4e>
    7956:	2c 81       	ldd	r18, Y+4	; 0x04
    7958:	3d 81       	ldd	r19, Y+5	; 0x05
    795a:	21 15       	cp	r18, r1
    795c:	31 05       	cpc	r19, r1
    795e:	69 f0       	breq	.+26     	; 0x797a <GPIO_readPin+0x66>
    7960:	6b c0       	rjmp	.+214    	; 0x7a38 <GPIO_readPin+0x124>
    7962:	4c 81       	ldd	r20, Y+4	; 0x04
    7964:	5d 81       	ldd	r21, Y+5	; 0x05
    7966:	42 30       	cpi	r20, 0x02	; 2
    7968:	51 05       	cpc	r21, r1
    796a:	b9 f1       	breq	.+110    	; 0x79da <GPIO_readPin+0xc6>
    796c:	8c 81       	ldd	r24, Y+4	; 0x04
    796e:	9d 81       	ldd	r25, Y+5	; 0x05
    7970:	83 30       	cpi	r24, 0x03	; 3
    7972:	91 05       	cpc	r25, r1
    7974:	09 f4       	brne	.+2      	; 0x7978 <GPIO_readPin+0x64>
    7976:	49 c0       	rjmp	.+146    	; 0x7a0a <GPIO_readPin+0xf6>
    7978:	5f c0       	rjmp	.+190    	; 0x7a38 <GPIO_readPin+0x124>
		{
		case PORTA_ID:
			if(BIT_IS_SET(PINA,pin_num))
    797a:	e9 e3       	ldi	r30, 0x39	; 57
    797c:	f0 e0       	ldi	r31, 0x00	; 0
    797e:	80 81       	ld	r24, Z
    7980:	28 2f       	mov	r18, r24
    7982:	30 e0       	ldi	r19, 0x00	; 0
    7984:	8b 81       	ldd	r24, Y+3	; 0x03
    7986:	88 2f       	mov	r24, r24
    7988:	90 e0       	ldi	r25, 0x00	; 0
    798a:	a9 01       	movw	r20, r18
    798c:	02 c0       	rjmp	.+4      	; 0x7992 <GPIO_readPin+0x7e>
    798e:	55 95       	asr	r21
    7990:	47 95       	ror	r20
    7992:	8a 95       	dec	r24
    7994:	e2 f7       	brpl	.-8      	; 0x798e <GPIO_readPin+0x7a>
    7996:	ca 01       	movw	r24, r20
    7998:	81 70       	andi	r24, 0x01	; 1
    799a:	90 70       	andi	r25, 0x00	; 0
    799c:	88 23       	and	r24, r24
    799e:	19 f0       	breq	.+6      	; 0x79a6 <GPIO_readPin+0x92>
			{
				pin_value = LOGIC_HIGH;
    79a0:	81 e0       	ldi	r24, 0x01	; 1
    79a2:	89 83       	std	Y+1, r24	; 0x01
    79a4:	49 c0       	rjmp	.+146    	; 0x7a38 <GPIO_readPin+0x124>
			}
			else
			{
				pin_value = LOGIC_LOW;
    79a6:	19 82       	std	Y+1, r1	; 0x01
    79a8:	47 c0       	rjmp	.+142    	; 0x7a38 <GPIO_readPin+0x124>
			}
			break;
		case PORTB_ID:
			if(BIT_IS_SET(PINB,pin_num))
    79aa:	e6 e3       	ldi	r30, 0x36	; 54
    79ac:	f0 e0       	ldi	r31, 0x00	; 0
    79ae:	80 81       	ld	r24, Z
    79b0:	28 2f       	mov	r18, r24
    79b2:	30 e0       	ldi	r19, 0x00	; 0
    79b4:	8b 81       	ldd	r24, Y+3	; 0x03
    79b6:	88 2f       	mov	r24, r24
    79b8:	90 e0       	ldi	r25, 0x00	; 0
    79ba:	a9 01       	movw	r20, r18
    79bc:	02 c0       	rjmp	.+4      	; 0x79c2 <GPIO_readPin+0xae>
    79be:	55 95       	asr	r21
    79c0:	47 95       	ror	r20
    79c2:	8a 95       	dec	r24
    79c4:	e2 f7       	brpl	.-8      	; 0x79be <GPIO_readPin+0xaa>
    79c6:	ca 01       	movw	r24, r20
    79c8:	81 70       	andi	r24, 0x01	; 1
    79ca:	90 70       	andi	r25, 0x00	; 0
    79cc:	88 23       	and	r24, r24
    79ce:	19 f0       	breq	.+6      	; 0x79d6 <GPIO_readPin+0xc2>
			{
				pin_value = LOGIC_HIGH;
    79d0:	81 e0       	ldi	r24, 0x01	; 1
    79d2:	89 83       	std	Y+1, r24	; 0x01
    79d4:	31 c0       	rjmp	.+98     	; 0x7a38 <GPIO_readPin+0x124>
			}
			else
			{
				pin_value = LOGIC_LOW;
    79d6:	19 82       	std	Y+1, r1	; 0x01
    79d8:	2f c0       	rjmp	.+94     	; 0x7a38 <GPIO_readPin+0x124>
			}
			break;
		case PORTC_ID:
			if(BIT_IS_SET(PINC,pin_num))
    79da:	e3 e3       	ldi	r30, 0x33	; 51
    79dc:	f0 e0       	ldi	r31, 0x00	; 0
    79de:	80 81       	ld	r24, Z
    79e0:	28 2f       	mov	r18, r24
    79e2:	30 e0       	ldi	r19, 0x00	; 0
    79e4:	8b 81       	ldd	r24, Y+3	; 0x03
    79e6:	88 2f       	mov	r24, r24
    79e8:	90 e0       	ldi	r25, 0x00	; 0
    79ea:	a9 01       	movw	r20, r18
    79ec:	02 c0       	rjmp	.+4      	; 0x79f2 <GPIO_readPin+0xde>
    79ee:	55 95       	asr	r21
    79f0:	47 95       	ror	r20
    79f2:	8a 95       	dec	r24
    79f4:	e2 f7       	brpl	.-8      	; 0x79ee <GPIO_readPin+0xda>
    79f6:	ca 01       	movw	r24, r20
    79f8:	81 70       	andi	r24, 0x01	; 1
    79fa:	90 70       	andi	r25, 0x00	; 0
    79fc:	88 23       	and	r24, r24
    79fe:	19 f0       	breq	.+6      	; 0x7a06 <GPIO_readPin+0xf2>
			{
				pin_value = LOGIC_HIGH;
    7a00:	81 e0       	ldi	r24, 0x01	; 1
    7a02:	89 83       	std	Y+1, r24	; 0x01
    7a04:	19 c0       	rjmp	.+50     	; 0x7a38 <GPIO_readPin+0x124>
			}
			else
			{
				pin_value = LOGIC_LOW;
    7a06:	19 82       	std	Y+1, r1	; 0x01
    7a08:	17 c0       	rjmp	.+46     	; 0x7a38 <GPIO_readPin+0x124>
			}
			break;
		case PORTD_ID:
			if(BIT_IS_SET(PIND,pin_num))
    7a0a:	e0 e3       	ldi	r30, 0x30	; 48
    7a0c:	f0 e0       	ldi	r31, 0x00	; 0
    7a0e:	80 81       	ld	r24, Z
    7a10:	28 2f       	mov	r18, r24
    7a12:	30 e0       	ldi	r19, 0x00	; 0
    7a14:	8b 81       	ldd	r24, Y+3	; 0x03
    7a16:	88 2f       	mov	r24, r24
    7a18:	90 e0       	ldi	r25, 0x00	; 0
    7a1a:	a9 01       	movw	r20, r18
    7a1c:	02 c0       	rjmp	.+4      	; 0x7a22 <GPIO_readPin+0x10e>
    7a1e:	55 95       	asr	r21
    7a20:	47 95       	ror	r20
    7a22:	8a 95       	dec	r24
    7a24:	e2 f7       	brpl	.-8      	; 0x7a1e <GPIO_readPin+0x10a>
    7a26:	ca 01       	movw	r24, r20
    7a28:	81 70       	andi	r24, 0x01	; 1
    7a2a:	90 70       	andi	r25, 0x00	; 0
    7a2c:	88 23       	and	r24, r24
    7a2e:	19 f0       	breq	.+6      	; 0x7a36 <GPIO_readPin+0x122>
			{
				pin_value = LOGIC_HIGH;
    7a30:	81 e0       	ldi	r24, 0x01	; 1
    7a32:	89 83       	std	Y+1, r24	; 0x01
    7a34:	01 c0       	rjmp	.+2      	; 0x7a38 <GPIO_readPin+0x124>
			}
			else
			{
				pin_value = LOGIC_LOW;
    7a36:	19 82       	std	Y+1, r1	; 0x01
//			}
//			break;
		}
	}

	return pin_value;
    7a38:	89 81       	ldd	r24, Y+1	; 0x01
}
    7a3a:	0f 90       	pop	r0
    7a3c:	0f 90       	pop	r0
    7a3e:	0f 90       	pop	r0
    7a40:	0f 90       	pop	r0
    7a42:	0f 90       	pop	r0
    7a44:	cf 91       	pop	r28
    7a46:	df 91       	pop	r29
    7a48:	08 95       	ret

00007a4a <GPIO_setupPortDirection>:
 * If the direction value is PORT_INPUT all pins in this port should be input pins.
 * If the direction value is PORT_OUTPUT all pins in this port should be output pins.
 * If the input port number is not correct, The function will not handle the request.
 */
void GPIO_setupPortDirection(uint8 port_num, GPIO_PortDirectionType direction)
{
    7a4a:	df 93       	push	r29
    7a4c:	cf 93       	push	r28
    7a4e:	00 d0       	rcall	.+0      	; 0x7a50 <GPIO_setupPortDirection+0x6>
    7a50:	00 d0       	rcall	.+0      	; 0x7a52 <GPIO_setupPortDirection+0x8>
    7a52:	cd b7       	in	r28, 0x3d	; 61
    7a54:	de b7       	in	r29, 0x3e	; 62
    7a56:	89 83       	std	Y+1, r24	; 0x01
    7a58:	6a 83       	std	Y+2, r22	; 0x02
	/*
	 * Check if the input number is greater than NUM_OF_PORTS value.
	 * In this case the input is not valid port number
	 */
	if(port_num >= NUM_OF_PORTS)
    7a5a:	89 81       	ldd	r24, Y+1	; 0x01
    7a5c:	86 30       	cpi	r24, 0x06	; 6
    7a5e:	90 f5       	brcc	.+100    	; 0x7ac4 <GPIO_setupPortDirection+0x7a>
		/* Do Nothing */
	}
	else
	{
		/* Setup the port direction as required */
		switch(port_num)
    7a60:	89 81       	ldd	r24, Y+1	; 0x01
    7a62:	28 2f       	mov	r18, r24
    7a64:	30 e0       	ldi	r19, 0x00	; 0
    7a66:	3c 83       	std	Y+4, r19	; 0x04
    7a68:	2b 83       	std	Y+3, r18	; 0x03
    7a6a:	8b 81       	ldd	r24, Y+3	; 0x03
    7a6c:	9c 81       	ldd	r25, Y+4	; 0x04
    7a6e:	81 30       	cpi	r24, 0x01	; 1
    7a70:	91 05       	cpc	r25, r1
    7a72:	d1 f0       	breq	.+52     	; 0x7aa8 <GPIO_setupPortDirection+0x5e>
    7a74:	2b 81       	ldd	r18, Y+3	; 0x03
    7a76:	3c 81       	ldd	r19, Y+4	; 0x04
    7a78:	22 30       	cpi	r18, 0x02	; 2
    7a7a:	31 05       	cpc	r19, r1
    7a7c:	2c f4       	brge	.+10     	; 0x7a88 <GPIO_setupPortDirection+0x3e>
    7a7e:	8b 81       	ldd	r24, Y+3	; 0x03
    7a80:	9c 81       	ldd	r25, Y+4	; 0x04
    7a82:	00 97       	sbiw	r24, 0x00	; 0
    7a84:	61 f0       	breq	.+24     	; 0x7a9e <GPIO_setupPortDirection+0x54>
    7a86:	1e c0       	rjmp	.+60     	; 0x7ac4 <GPIO_setupPortDirection+0x7a>
    7a88:	2b 81       	ldd	r18, Y+3	; 0x03
    7a8a:	3c 81       	ldd	r19, Y+4	; 0x04
    7a8c:	22 30       	cpi	r18, 0x02	; 2
    7a8e:	31 05       	cpc	r19, r1
    7a90:	81 f0       	breq	.+32     	; 0x7ab2 <GPIO_setupPortDirection+0x68>
    7a92:	8b 81       	ldd	r24, Y+3	; 0x03
    7a94:	9c 81       	ldd	r25, Y+4	; 0x04
    7a96:	83 30       	cpi	r24, 0x03	; 3
    7a98:	91 05       	cpc	r25, r1
    7a9a:	81 f0       	breq	.+32     	; 0x7abc <GPIO_setupPortDirection+0x72>
    7a9c:	13 c0       	rjmp	.+38     	; 0x7ac4 <GPIO_setupPortDirection+0x7a>
		{
		case PORTA_ID:
			DDRA = direction;
    7a9e:	ea e3       	ldi	r30, 0x3A	; 58
    7aa0:	f0 e0       	ldi	r31, 0x00	; 0
    7aa2:	8a 81       	ldd	r24, Y+2	; 0x02
    7aa4:	80 83       	st	Z, r24
    7aa6:	0e c0       	rjmp	.+28     	; 0x7ac4 <GPIO_setupPortDirection+0x7a>
			break;
		case PORTB_ID:
			DDRB = direction;
    7aa8:	e7 e3       	ldi	r30, 0x37	; 55
    7aaa:	f0 e0       	ldi	r31, 0x00	; 0
    7aac:	8a 81       	ldd	r24, Y+2	; 0x02
    7aae:	80 83       	st	Z, r24
    7ab0:	09 c0       	rjmp	.+18     	; 0x7ac4 <GPIO_setupPortDirection+0x7a>
			break;
		case PORTC_ID:
			DDRC = direction;
    7ab2:	e4 e3       	ldi	r30, 0x34	; 52
    7ab4:	f0 e0       	ldi	r31, 0x00	; 0
    7ab6:	8a 81       	ldd	r24, Y+2	; 0x02
    7ab8:	80 83       	st	Z, r24
    7aba:	04 c0       	rjmp	.+8      	; 0x7ac4 <GPIO_setupPortDirection+0x7a>
			break;
		case PORTD_ID:
			DDRD = direction;
    7abc:	e1 e3       	ldi	r30, 0x31	; 49
    7abe:	f0 e0       	ldi	r31, 0x00	; 0
    7ac0:	8a 81       	ldd	r24, Y+2	; 0x02
    7ac2:	80 83       	st	Z, r24
//		case PORTF_ID:
//			DDRF = direction;
//			break;
		}
	}
}
    7ac4:	0f 90       	pop	r0
    7ac6:	0f 90       	pop	r0
    7ac8:	0f 90       	pop	r0
    7aca:	0f 90       	pop	r0
    7acc:	cf 91       	pop	r28
    7ace:	df 91       	pop	r29
    7ad0:	08 95       	ret

00007ad2 <GPIO_writePort>:
 * If any pin in the port is output pin the value will be written.
 * If any pin in the port is input pin this will activate/deactivate the internal pull-up resistor.
 * If the input port number is not correct, The function will not handle the request.
 */
void GPIO_writePort(uint8 port_num, uint8 value)
{
    7ad2:	df 93       	push	r29
    7ad4:	cf 93       	push	r28
    7ad6:	00 d0       	rcall	.+0      	; 0x7ad8 <GPIO_writePort+0x6>
    7ad8:	00 d0       	rcall	.+0      	; 0x7ada <GPIO_writePort+0x8>
    7ada:	cd b7       	in	r28, 0x3d	; 61
    7adc:	de b7       	in	r29, 0x3e	; 62
    7ade:	89 83       	std	Y+1, r24	; 0x01
    7ae0:	6a 83       	std	Y+2, r22	; 0x02
	/*
	 * Check if the input number is greater than NUM_OF_PORTS value.
	 * In this case the input is not valid port number
	 */
	if(port_num >= NUM_OF_PORTS)
    7ae2:	89 81       	ldd	r24, Y+1	; 0x01
    7ae4:	86 30       	cpi	r24, 0x06	; 6
    7ae6:	90 f5       	brcc	.+100    	; 0x7b4c <GPIO_writePort+0x7a>
		/* Do Nothing */
	}
	else
	{
		/* Write the port value as required */
		switch(port_num)
    7ae8:	89 81       	ldd	r24, Y+1	; 0x01
    7aea:	28 2f       	mov	r18, r24
    7aec:	30 e0       	ldi	r19, 0x00	; 0
    7aee:	3c 83       	std	Y+4, r19	; 0x04
    7af0:	2b 83       	std	Y+3, r18	; 0x03
    7af2:	8b 81       	ldd	r24, Y+3	; 0x03
    7af4:	9c 81       	ldd	r25, Y+4	; 0x04
    7af6:	81 30       	cpi	r24, 0x01	; 1
    7af8:	91 05       	cpc	r25, r1
    7afa:	d1 f0       	breq	.+52     	; 0x7b30 <GPIO_writePort+0x5e>
    7afc:	2b 81       	ldd	r18, Y+3	; 0x03
    7afe:	3c 81       	ldd	r19, Y+4	; 0x04
    7b00:	22 30       	cpi	r18, 0x02	; 2
    7b02:	31 05       	cpc	r19, r1
    7b04:	2c f4       	brge	.+10     	; 0x7b10 <GPIO_writePort+0x3e>
    7b06:	8b 81       	ldd	r24, Y+3	; 0x03
    7b08:	9c 81       	ldd	r25, Y+4	; 0x04
    7b0a:	00 97       	sbiw	r24, 0x00	; 0
    7b0c:	61 f0       	breq	.+24     	; 0x7b26 <GPIO_writePort+0x54>
    7b0e:	1e c0       	rjmp	.+60     	; 0x7b4c <GPIO_writePort+0x7a>
    7b10:	2b 81       	ldd	r18, Y+3	; 0x03
    7b12:	3c 81       	ldd	r19, Y+4	; 0x04
    7b14:	22 30       	cpi	r18, 0x02	; 2
    7b16:	31 05       	cpc	r19, r1
    7b18:	81 f0       	breq	.+32     	; 0x7b3a <GPIO_writePort+0x68>
    7b1a:	8b 81       	ldd	r24, Y+3	; 0x03
    7b1c:	9c 81       	ldd	r25, Y+4	; 0x04
    7b1e:	83 30       	cpi	r24, 0x03	; 3
    7b20:	91 05       	cpc	r25, r1
    7b22:	81 f0       	breq	.+32     	; 0x7b44 <GPIO_writePort+0x72>
    7b24:	13 c0       	rjmp	.+38     	; 0x7b4c <GPIO_writePort+0x7a>
		{
		case PORTA_ID:
			PORTA = value;
    7b26:	eb e3       	ldi	r30, 0x3B	; 59
    7b28:	f0 e0       	ldi	r31, 0x00	; 0
    7b2a:	8a 81       	ldd	r24, Y+2	; 0x02
    7b2c:	80 83       	st	Z, r24
    7b2e:	0e c0       	rjmp	.+28     	; 0x7b4c <GPIO_writePort+0x7a>
			break;
		case PORTB_ID:
			PORTB = value;
    7b30:	e8 e3       	ldi	r30, 0x38	; 56
    7b32:	f0 e0       	ldi	r31, 0x00	; 0
    7b34:	8a 81       	ldd	r24, Y+2	; 0x02
    7b36:	80 83       	st	Z, r24
    7b38:	09 c0       	rjmp	.+18     	; 0x7b4c <GPIO_writePort+0x7a>
			break;
		case PORTC_ID:
			PORTC = value;
    7b3a:	e5 e3       	ldi	r30, 0x35	; 53
    7b3c:	f0 e0       	ldi	r31, 0x00	; 0
    7b3e:	8a 81       	ldd	r24, Y+2	; 0x02
    7b40:	80 83       	st	Z, r24
    7b42:	04 c0       	rjmp	.+8      	; 0x7b4c <GPIO_writePort+0x7a>
			break;
		case PORTD_ID:
			PORTD = value;
    7b44:	e2 e3       	ldi	r30, 0x32	; 50
    7b46:	f0 e0       	ldi	r31, 0x00	; 0
    7b48:	8a 81       	ldd	r24, Y+2	; 0x02
    7b4a:	80 83       	st	Z, r24
//		case PORTF_ID:
//			PORTF = value;
//			break;
		}
	}
}
    7b4c:	0f 90       	pop	r0
    7b4e:	0f 90       	pop	r0
    7b50:	0f 90       	pop	r0
    7b52:	0f 90       	pop	r0
    7b54:	cf 91       	pop	r28
    7b56:	df 91       	pop	r29
    7b58:	08 95       	ret

00007b5a <GPIO_readPort>:
 * Description :
 * Read and return the value of the required port.
 * If the input port number is not correct, The function will return ZERO value.
 */
uint8 GPIO_readPort(uint8 port_num)
{
    7b5a:	df 93       	push	r29
    7b5c:	cf 93       	push	r28
    7b5e:	00 d0       	rcall	.+0      	; 0x7b60 <GPIO_readPort+0x6>
    7b60:	00 d0       	rcall	.+0      	; 0x7b62 <GPIO_readPort+0x8>
    7b62:	cd b7       	in	r28, 0x3d	; 61
    7b64:	de b7       	in	r29, 0x3e	; 62
    7b66:	8a 83       	std	Y+2, r24	; 0x02
	uint8 value = LOGIC_LOW;
    7b68:	19 82       	std	Y+1, r1	; 0x01

	/*
	 * Check if the input number is greater than NUM_OF_PORTS value.
	 * In this case the input is not valid port number
	 */
	if(port_num >= NUM_OF_PORTS)
    7b6a:	8a 81       	ldd	r24, Y+2	; 0x02
    7b6c:	86 30       	cpi	r24, 0x06	; 6
    7b6e:	90 f5       	brcc	.+100    	; 0x7bd4 <GPIO_readPort+0x7a>
		/* Do Nothing */
	}
	else
	{
		/* Read the port value as required */
		switch(port_num)
    7b70:	8a 81       	ldd	r24, Y+2	; 0x02
    7b72:	28 2f       	mov	r18, r24
    7b74:	30 e0       	ldi	r19, 0x00	; 0
    7b76:	3c 83       	std	Y+4, r19	; 0x04
    7b78:	2b 83       	std	Y+3, r18	; 0x03
    7b7a:	8b 81       	ldd	r24, Y+3	; 0x03
    7b7c:	9c 81       	ldd	r25, Y+4	; 0x04
    7b7e:	81 30       	cpi	r24, 0x01	; 1
    7b80:	91 05       	cpc	r25, r1
    7b82:	d1 f0       	breq	.+52     	; 0x7bb8 <GPIO_readPort+0x5e>
    7b84:	2b 81       	ldd	r18, Y+3	; 0x03
    7b86:	3c 81       	ldd	r19, Y+4	; 0x04
    7b88:	22 30       	cpi	r18, 0x02	; 2
    7b8a:	31 05       	cpc	r19, r1
    7b8c:	2c f4       	brge	.+10     	; 0x7b98 <GPIO_readPort+0x3e>
    7b8e:	8b 81       	ldd	r24, Y+3	; 0x03
    7b90:	9c 81       	ldd	r25, Y+4	; 0x04
    7b92:	00 97       	sbiw	r24, 0x00	; 0
    7b94:	61 f0       	breq	.+24     	; 0x7bae <GPIO_readPort+0x54>
    7b96:	1e c0       	rjmp	.+60     	; 0x7bd4 <GPIO_readPort+0x7a>
    7b98:	2b 81       	ldd	r18, Y+3	; 0x03
    7b9a:	3c 81       	ldd	r19, Y+4	; 0x04
    7b9c:	22 30       	cpi	r18, 0x02	; 2
    7b9e:	31 05       	cpc	r19, r1
    7ba0:	81 f0       	breq	.+32     	; 0x7bc2 <GPIO_readPort+0x68>
    7ba2:	8b 81       	ldd	r24, Y+3	; 0x03
    7ba4:	9c 81       	ldd	r25, Y+4	; 0x04
    7ba6:	83 30       	cpi	r24, 0x03	; 3
    7ba8:	91 05       	cpc	r25, r1
    7baa:	81 f0       	breq	.+32     	; 0x7bcc <GPIO_readPort+0x72>
    7bac:	13 c0       	rjmp	.+38     	; 0x7bd4 <GPIO_readPort+0x7a>
		{
		case PORTA_ID:
			value = PINA;
    7bae:	e9 e3       	ldi	r30, 0x39	; 57
    7bb0:	f0 e0       	ldi	r31, 0x00	; 0
    7bb2:	80 81       	ld	r24, Z
    7bb4:	89 83       	std	Y+1, r24	; 0x01
    7bb6:	0e c0       	rjmp	.+28     	; 0x7bd4 <GPIO_readPort+0x7a>
			break;
		case PORTB_ID:
			value = PINB;
    7bb8:	e6 e3       	ldi	r30, 0x36	; 54
    7bba:	f0 e0       	ldi	r31, 0x00	; 0
    7bbc:	80 81       	ld	r24, Z
    7bbe:	89 83       	std	Y+1, r24	; 0x01
    7bc0:	09 c0       	rjmp	.+18     	; 0x7bd4 <GPIO_readPort+0x7a>
			break;
		case PORTC_ID:
			value = PINC;
    7bc2:	e3 e3       	ldi	r30, 0x33	; 51
    7bc4:	f0 e0       	ldi	r31, 0x00	; 0
    7bc6:	80 81       	ld	r24, Z
    7bc8:	89 83       	std	Y+1, r24	; 0x01
    7bca:	04 c0       	rjmp	.+8      	; 0x7bd4 <GPIO_readPort+0x7a>
			break;
		case PORTD_ID:
			value = PIND;
    7bcc:	e0 e3       	ldi	r30, 0x30	; 48
    7bce:	f0 e0       	ldi	r31, 0x00	; 0
    7bd0:	80 81       	ld	r24, Z
    7bd2:	89 83       	std	Y+1, r24	; 0x01
//			value = PINF;
//			break;
		}
	}

	return value;
    7bd4:	89 81       	ldd	r24, Y+1	; 0x01
}
    7bd6:	0f 90       	pop	r0
    7bd8:	0f 90       	pop	r0
    7bda:	0f 90       	pop	r0
    7bdc:	0f 90       	pop	r0
    7bde:	cf 91       	pop	r28
    7be0:	df 91       	pop	r29
    7be2:	08 95       	ret

00007be4 <DIO_init>:


void DIO_init(void)
{
    7be4:	df 93       	push	r29
    7be6:	cf 93       	push	r28
    7be8:	00 d0       	rcall	.+0      	; 0x7bea <DIO_init+0x6>
    7bea:	00 d0       	rcall	.+0      	; 0x7bec <DIO_init+0x8>
    7bec:	cd b7       	in	r28, 0x3d	; 61
    7bee:	de b7       	in	r29, 0x3e	; 62
	uint8_t loop;
	for(loop=0u; loop < DIO_NUM_OF_CHANNELS ; loop++ ){
    7bf0:	1c 82       	std	Y+4, r1	; 0x04
    7bf2:	2f c0       	rjmp	.+94     	; 0x7c52 <DIO_init+0x6e>
		uint8_t portid=dio_config_array[loop].port_id;
    7bf4:	8c 81       	ldd	r24, Y+4	; 0x04
    7bf6:	28 2f       	mov	r18, r24
    7bf8:	30 e0       	ldi	r19, 0x00	; 0
    7bfa:	c9 01       	movw	r24, r18
    7bfc:	88 0f       	add	r24, r24
    7bfe:	99 1f       	adc	r25, r25
    7c00:	82 0f       	add	r24, r18
    7c02:	93 1f       	adc	r25, r19
    7c04:	fc 01       	movw	r30, r24
    7c06:	e9 56       	subi	r30, 0x69	; 105
    7c08:	fe 4f       	sbci	r31, 0xFE	; 254
    7c0a:	80 81       	ld	r24, Z
    7c0c:	8b 83       	std	Y+3, r24	; 0x03
		uint8_t pin_num=dio_config_array[loop].pin_num;
    7c0e:	8c 81       	ldd	r24, Y+4	; 0x04
    7c10:	28 2f       	mov	r18, r24
    7c12:	30 e0       	ldi	r19, 0x00	; 0
    7c14:	c9 01       	movw	r24, r18
    7c16:	88 0f       	add	r24, r24
    7c18:	99 1f       	adc	r25, r25
    7c1a:	82 0f       	add	r24, r18
    7c1c:	93 1f       	adc	r25, r19
    7c1e:	fc 01       	movw	r30, r24
    7c20:	e8 56       	subi	r30, 0x68	; 104
    7c22:	fe 4f       	sbci	r31, 0xFE	; 254
    7c24:	80 81       	ld	r24, Z
    7c26:	8a 83       	std	Y+2, r24	; 0x02
		uint8_t direction=dio_config_array[loop].direction;
    7c28:	8c 81       	ldd	r24, Y+4	; 0x04
    7c2a:	28 2f       	mov	r18, r24
    7c2c:	30 e0       	ldi	r19, 0x00	; 0
    7c2e:	c9 01       	movw	r24, r18
    7c30:	88 0f       	add	r24, r24
    7c32:	99 1f       	adc	r25, r25
    7c34:	82 0f       	add	r24, r18
    7c36:	93 1f       	adc	r25, r19
    7c38:	fc 01       	movw	r30, r24
    7c3a:	e7 56       	subi	r30, 0x67	; 103
    7c3c:	fe 4f       	sbci	r31, 0xFE	; 254
    7c3e:	80 81       	ld	r24, Z
    7c40:	89 83       	std	Y+1, r24	; 0x01
		GPIO_setupPinDirection(portid,pin_num,direction);
    7c42:	8b 81       	ldd	r24, Y+3	; 0x03
    7c44:	6a 81       	ldd	r22, Y+2	; 0x02
    7c46:	49 81       	ldd	r20, Y+1	; 0x01
    7c48:	0e 94 b4 3a 	call	0x7568	; 0x7568 <GPIO_setupPinDirection>


void DIO_init(void)
{
	uint8_t loop;
	for(loop=0u; loop < DIO_NUM_OF_CHANNELS ; loop++ ){
    7c4c:	8c 81       	ldd	r24, Y+4	; 0x04
    7c4e:	8f 5f       	subi	r24, 0xFF	; 255
    7c50:	8c 83       	std	Y+4, r24	; 0x04
    7c52:	8c 81       	ldd	r24, Y+4	; 0x04
    7c54:	86 30       	cpi	r24, 0x06	; 6
    7c56:	70 f2       	brcs	.-100    	; 0x7bf4 <DIO_init+0x10>
		uint8_t portid=dio_config_array[loop].port_id;
		uint8_t pin_num=dio_config_array[loop].pin_num;
		uint8_t direction=dio_config_array[loop].direction;
		GPIO_setupPinDirection(portid,pin_num,direction);
	}
}
    7c58:	0f 90       	pop	r0
    7c5a:	0f 90       	pop	r0
    7c5c:	0f 90       	pop	r0
    7c5e:	0f 90       	pop	r0
    7c60:	cf 91       	pop	r28
    7c62:	df 91       	pop	r29
    7c64:	08 95       	ret

00007c66 <DIO_ChannelGroupWrite>:


void DIO_ChannelGroupWrite(ChannelGroupType channel_group_variabe , uint8_t data)
{
    7c66:	af 92       	push	r10
    7c68:	cf 92       	push	r12
    7c6a:	df 92       	push	r13
    7c6c:	ef 92       	push	r14
    7c6e:	ff 92       	push	r15
    7c70:	0f 93       	push	r16
    7c72:	1f 93       	push	r17
    7c74:	df 93       	push	r29
    7c76:	cf 93       	push	r28
    7c78:	cd b7       	in	r28, 0x3d	; 61
    7c7a:	de b7       	in	r29, 0x3e	; 62
    7c7c:	65 97       	sbiw	r28, 0x15	; 21
    7c7e:	0f b6       	in	r0, 0x3f	; 63
    7c80:	f8 94       	cli
    7c82:	de bf       	out	0x3e, r29	; 62
    7c84:	0f be       	out	0x3f, r0	; 63
    7c86:	cd bf       	out	0x3d, r28	; 61
    7c88:	cf 82       	std	Y+7, r12	; 0x07
    7c8a:	d8 86       	std	Y+8, r13	; 0x08
    7c8c:	e9 86       	std	Y+9, r14	; 0x09
    7c8e:	fa 86       	std	Y+10, r15	; 0x0a
    7c90:	0b 87       	std	Y+11, r16	; 0x0b
    7c92:	1c 87       	std	Y+12, r17	; 0x0c
    7c94:	2d 87       	std	Y+13, r18	; 0x0d
    7c96:	3e 87       	std	Y+14, r19	; 0x0e
    7c98:	4f 87       	std	Y+15, r20	; 0x0f
    7c9a:	58 8b       	std	Y+16, r21	; 0x10
    7c9c:	69 8b       	std	Y+17, r22	; 0x11
    7c9e:	7a 8b       	std	Y+18, r23	; 0x12
    7ca0:	8b 8b       	std	Y+19, r24	; 0x13
    7ca2:	9c 8b       	std	Y+20, r25	; 0x14
    7ca4:	ad 8a       	std	Y+21, r10	; 0x15
	uint8_t loop;
	uint8_t to=channel_group_variabe.no_of_channels;
    7ca6:	8f 81       	ldd	r24, Y+7	; 0x07
    7ca8:	98 85       	ldd	r25, Y+8	; 0x08
    7caa:	8d 83       	std	Y+5, r24	; 0x05

	for(loop=0u; loop <to ; loop++ ){
    7cac:	1e 82       	std	Y+6, r1	; 0x06
    7cae:	4c c0       	rjmp	.+152    	; 0x7d48 <DIO_ChannelGroupWrite+0xe2>
		uint8_t channel_id=channel_group_variabe.group_ids[loop];
    7cb0:	8e 81       	ldd	r24, Y+6	; 0x06
    7cb2:	88 2f       	mov	r24, r24
    7cb4:	90 e0       	ldi	r25, 0x00	; 0
    7cb6:	01 96       	adiw	r24, 0x01	; 1
    7cb8:	9c 01       	movw	r18, r24
    7cba:	22 0f       	add	r18, r18
    7cbc:	33 1f       	adc	r19, r19
    7cbe:	ce 01       	movw	r24, r28
    7cc0:	01 96       	adiw	r24, 0x01	; 1
    7cc2:	82 0f       	add	r24, r18
    7cc4:	93 1f       	adc	r25, r19
    7cc6:	fc 01       	movw	r30, r24
    7cc8:	36 96       	adiw	r30, 0x06	; 6
    7cca:	80 81       	ld	r24, Z
    7ccc:	91 81       	ldd	r25, Z+1	; 0x01
    7cce:	8c 83       	std	Y+4, r24	; 0x04
		uint8_t portid=dio_config_array[channel_id].port_id;
    7cd0:	8c 81       	ldd	r24, Y+4	; 0x04
    7cd2:	28 2f       	mov	r18, r24
    7cd4:	30 e0       	ldi	r19, 0x00	; 0
    7cd6:	c9 01       	movw	r24, r18
    7cd8:	88 0f       	add	r24, r24
    7cda:	99 1f       	adc	r25, r25
    7cdc:	82 0f       	add	r24, r18
    7cde:	93 1f       	adc	r25, r19
    7ce0:	fc 01       	movw	r30, r24
    7ce2:	e9 56       	subi	r30, 0x69	; 105
    7ce4:	fe 4f       	sbci	r31, 0xFE	; 254
    7ce6:	80 81       	ld	r24, Z
    7ce8:	8b 83       	std	Y+3, r24	; 0x03
		uint8_t pin_num=dio_config_array[channel_id].pin_num;
    7cea:	8c 81       	ldd	r24, Y+4	; 0x04
    7cec:	28 2f       	mov	r18, r24
    7cee:	30 e0       	ldi	r19, 0x00	; 0
    7cf0:	c9 01       	movw	r24, r18
    7cf2:	88 0f       	add	r24, r24
    7cf4:	99 1f       	adc	r25, r25
    7cf6:	82 0f       	add	r24, r18
    7cf8:	93 1f       	adc	r25, r19
    7cfa:	fc 01       	movw	r30, r24
    7cfc:	e8 56       	subi	r30, 0x68	; 104
    7cfe:	fe 4f       	sbci	r31, 0xFE	; 254
    7d00:	80 81       	ld	r24, Z
    7d02:	8a 83       	std	Y+2, r24	; 0x02
		uint8_t bit_data=READ_BIT(data,loop);
    7d04:	8e 81       	ldd	r24, Y+6	; 0x06
    7d06:	28 2f       	mov	r18, r24
    7d08:	30 e0       	ldi	r19, 0x00	; 0
    7d0a:	81 e0       	ldi	r24, 0x01	; 1
    7d0c:	90 e0       	ldi	r25, 0x00	; 0
    7d0e:	02 c0       	rjmp	.+4      	; 0x7d14 <DIO_ChannelGroupWrite+0xae>
    7d10:	88 0f       	add	r24, r24
    7d12:	99 1f       	adc	r25, r25
    7d14:	2a 95       	dec	r18
    7d16:	e2 f7       	brpl	.-8      	; 0x7d10 <DIO_ChannelGroupWrite+0xaa>
    7d18:	98 2f       	mov	r25, r24
    7d1a:	8d 89       	ldd	r24, Y+21	; 0x15
    7d1c:	89 23       	and	r24, r25
    7d1e:	28 2f       	mov	r18, r24
    7d20:	30 e0       	ldi	r19, 0x00	; 0
    7d22:	8e 81       	ldd	r24, Y+6	; 0x06
    7d24:	88 2f       	mov	r24, r24
    7d26:	90 e0       	ldi	r25, 0x00	; 0
    7d28:	a9 01       	movw	r20, r18
    7d2a:	02 c0       	rjmp	.+4      	; 0x7d30 <DIO_ChannelGroupWrite+0xca>
    7d2c:	55 95       	asr	r21
    7d2e:	47 95       	ror	r20
    7d30:	8a 95       	dec	r24
    7d32:	e2 f7       	brpl	.-8      	; 0x7d2c <DIO_ChannelGroupWrite+0xc6>
    7d34:	ca 01       	movw	r24, r20
    7d36:	89 83       	std	Y+1, r24	; 0x01
		GPIO_writePin(portid,pin_num,bit_data);
    7d38:	8b 81       	ldd	r24, Y+3	; 0x03
    7d3a:	6a 81       	ldd	r22, Y+2	; 0x02
    7d3c:	49 81       	ldd	r20, Y+1	; 0x01
    7d3e:	0e 94 9f 3b 	call	0x773e	; 0x773e <GPIO_writePin>
void DIO_ChannelGroupWrite(ChannelGroupType channel_group_variabe , uint8_t data)
{
	uint8_t loop;
	uint8_t to=channel_group_variabe.no_of_channels;

	for(loop=0u; loop <to ; loop++ ){
    7d42:	8e 81       	ldd	r24, Y+6	; 0x06
    7d44:	8f 5f       	subi	r24, 0xFF	; 255
    7d46:	8e 83       	std	Y+6, r24	; 0x06
    7d48:	9e 81       	ldd	r25, Y+6	; 0x06
    7d4a:	8d 81       	ldd	r24, Y+5	; 0x05
    7d4c:	98 17       	cp	r25, r24
    7d4e:	08 f4       	brcc	.+2      	; 0x7d52 <DIO_ChannelGroupWrite+0xec>
    7d50:	af cf       	rjmp	.-162    	; 0x7cb0 <DIO_ChannelGroupWrite+0x4a>
		GPIO_writePin(portid,pin_num,bit_data);

	}


}
    7d52:	65 96       	adiw	r28, 0x15	; 21
    7d54:	0f b6       	in	r0, 0x3f	; 63
    7d56:	f8 94       	cli
    7d58:	de bf       	out	0x3e, r29	; 62
    7d5a:	0f be       	out	0x3f, r0	; 63
    7d5c:	cd bf       	out	0x3d, r28	; 61
    7d5e:	cf 91       	pop	r28
    7d60:	df 91       	pop	r29
    7d62:	1f 91       	pop	r17
    7d64:	0f 91       	pop	r16
    7d66:	ff 90       	pop	r15
    7d68:	ef 90       	pop	r14
    7d6a:	df 90       	pop	r13
    7d6c:	cf 90       	pop	r12
    7d6e:	af 90       	pop	r10
    7d70:	08 95       	ret

00007d72 <DIO_ChannelGroupRead>:


void DIO_ChannelGroupRead(ChannelGroupType channel_group_variabe ,uint8_t * data_ptr)
{
    7d72:	af 92       	push	r10
    7d74:	bf 92       	push	r11
    7d76:	cf 92       	push	r12
    7d78:	df 92       	push	r13
    7d7a:	ef 92       	push	r14
    7d7c:	ff 92       	push	r15
    7d7e:	0f 93       	push	r16
    7d80:	1f 93       	push	r17
    7d82:	df 93       	push	r29
    7d84:	cf 93       	push	r28
    7d86:	cd b7       	in	r28, 0x3d	; 61
    7d88:	de b7       	in	r29, 0x3e	; 62
    7d8a:	66 97       	sbiw	r28, 0x16	; 22
    7d8c:	0f b6       	in	r0, 0x3f	; 63
    7d8e:	f8 94       	cli
    7d90:	de bf       	out	0x3e, r29	; 62
    7d92:	0f be       	out	0x3f, r0	; 63
    7d94:	cd bf       	out	0x3d, r28	; 61
    7d96:	cf 82       	std	Y+7, r12	; 0x07
    7d98:	d8 86       	std	Y+8, r13	; 0x08
    7d9a:	e9 86       	std	Y+9, r14	; 0x09
    7d9c:	fa 86       	std	Y+10, r15	; 0x0a
    7d9e:	0b 87       	std	Y+11, r16	; 0x0b
    7da0:	1c 87       	std	Y+12, r17	; 0x0c
    7da2:	2d 87       	std	Y+13, r18	; 0x0d
    7da4:	3e 87       	std	Y+14, r19	; 0x0e
    7da6:	4f 87       	std	Y+15, r20	; 0x0f
    7da8:	58 8b       	std	Y+16, r21	; 0x10
    7daa:	69 8b       	std	Y+17, r22	; 0x11
    7dac:	7a 8b       	std	Y+18, r23	; 0x12
    7dae:	8b 8b       	std	Y+19, r24	; 0x13
    7db0:	9c 8b       	std	Y+20, r25	; 0x14
    7db2:	be 8a       	std	Y+22, r11	; 0x16
    7db4:	ad 8a       	std	Y+21, r10	; 0x15

	uint8_t loop;
	uint8_t to=channel_group_variabe.no_of_channels;
    7db6:	8f 81       	ldd	r24, Y+7	; 0x07
    7db8:	98 85       	ldd	r25, Y+8	; 0x08
    7dba:	8d 83       	std	Y+5, r24	; 0x05

	for(loop=0u; loop <to ; loop++ ){
    7dbc:	1e 82       	std	Y+6, r1	; 0x06
    7dbe:	5d c0       	rjmp	.+186    	; 0x7e7a <DIO_ChannelGroupRead+0x108>
		uint8_t channel_id=channel_group_variabe.group_ids[loop];
    7dc0:	8e 81       	ldd	r24, Y+6	; 0x06
    7dc2:	88 2f       	mov	r24, r24
    7dc4:	90 e0       	ldi	r25, 0x00	; 0
    7dc6:	01 96       	adiw	r24, 0x01	; 1
    7dc8:	9c 01       	movw	r18, r24
    7dca:	22 0f       	add	r18, r18
    7dcc:	33 1f       	adc	r19, r19
    7dce:	ce 01       	movw	r24, r28
    7dd0:	01 96       	adiw	r24, 0x01	; 1
    7dd2:	82 0f       	add	r24, r18
    7dd4:	93 1f       	adc	r25, r19
    7dd6:	fc 01       	movw	r30, r24
    7dd8:	36 96       	adiw	r30, 0x06	; 6
    7dda:	80 81       	ld	r24, Z
    7ddc:	91 81       	ldd	r25, Z+1	; 0x01
    7dde:	8c 83       	std	Y+4, r24	; 0x04
		uint8_t portid=dio_config_array[channel_id].port_id;
    7de0:	8c 81       	ldd	r24, Y+4	; 0x04
    7de2:	28 2f       	mov	r18, r24
    7de4:	30 e0       	ldi	r19, 0x00	; 0
    7de6:	c9 01       	movw	r24, r18
    7de8:	88 0f       	add	r24, r24
    7dea:	99 1f       	adc	r25, r25
    7dec:	82 0f       	add	r24, r18
    7dee:	93 1f       	adc	r25, r19
    7df0:	fc 01       	movw	r30, r24
    7df2:	e9 56       	subi	r30, 0x69	; 105
    7df4:	fe 4f       	sbci	r31, 0xFE	; 254
    7df6:	80 81       	ld	r24, Z
    7df8:	8b 83       	std	Y+3, r24	; 0x03
		uint8_t pin_num=dio_config_array[channel_id].pin_num;
    7dfa:	8c 81       	ldd	r24, Y+4	; 0x04
    7dfc:	28 2f       	mov	r18, r24
    7dfe:	30 e0       	ldi	r19, 0x00	; 0
    7e00:	c9 01       	movw	r24, r18
    7e02:	88 0f       	add	r24, r24
    7e04:	99 1f       	adc	r25, r25
    7e06:	82 0f       	add	r24, r18
    7e08:	93 1f       	adc	r25, r19
    7e0a:	fc 01       	movw	r30, r24
    7e0c:	e8 56       	subi	r30, 0x68	; 104
    7e0e:	fe 4f       	sbci	r31, 0xFE	; 254
    7e10:	80 81       	ld	r24, Z
    7e12:	8a 83       	std	Y+2, r24	; 0x02
		uint8_t data = GPIO_readPin(portid, pin_num);
    7e14:	8b 81       	ldd	r24, Y+3	; 0x03
    7e16:	6a 81       	ldd	r22, Y+2	; 0x02
    7e18:	0e 94 8a 3c 	call	0x7914	; 0x7914 <GPIO_readPin>
    7e1c:	89 83       	std	Y+1, r24	; 0x01
		if(data == LOGIC_HIGH){
    7e1e:	89 81       	ldd	r24, Y+1	; 0x01
    7e20:	81 30       	cpi	r24, 0x01	; 1
    7e22:	a1 f4       	brne	.+40     	; 0x7e4c <DIO_ChannelGroupRead+0xda>
			SET_BIT(* data_ptr,loop);
    7e24:	ed 89       	ldd	r30, Y+21	; 0x15
    7e26:	fe 89       	ldd	r31, Y+22	; 0x16
    7e28:	80 81       	ld	r24, Z
    7e2a:	48 2f       	mov	r20, r24
    7e2c:	8e 81       	ldd	r24, Y+6	; 0x06
    7e2e:	28 2f       	mov	r18, r24
    7e30:	30 e0       	ldi	r19, 0x00	; 0
    7e32:	81 e0       	ldi	r24, 0x01	; 1
    7e34:	90 e0       	ldi	r25, 0x00	; 0
    7e36:	02 2e       	mov	r0, r18
    7e38:	02 c0       	rjmp	.+4      	; 0x7e3e <DIO_ChannelGroupRead+0xcc>
    7e3a:	88 0f       	add	r24, r24
    7e3c:	99 1f       	adc	r25, r25
    7e3e:	0a 94       	dec	r0
    7e40:	e2 f7       	brpl	.-8      	; 0x7e3a <DIO_ChannelGroupRead+0xc8>
    7e42:	84 2b       	or	r24, r20
    7e44:	ed 89       	ldd	r30, Y+21	; 0x15
    7e46:	fe 89       	ldd	r31, Y+22	; 0x16
    7e48:	80 83       	st	Z, r24
    7e4a:	14 c0       	rjmp	.+40     	; 0x7e74 <DIO_ChannelGroupRead+0x102>
		}else{
			CLEAR_BIT(* data_ptr,loop);
    7e4c:	ed 89       	ldd	r30, Y+21	; 0x15
    7e4e:	fe 89       	ldd	r31, Y+22	; 0x16
    7e50:	80 81       	ld	r24, Z
    7e52:	48 2f       	mov	r20, r24
    7e54:	8e 81       	ldd	r24, Y+6	; 0x06
    7e56:	28 2f       	mov	r18, r24
    7e58:	30 e0       	ldi	r19, 0x00	; 0
    7e5a:	81 e0       	ldi	r24, 0x01	; 1
    7e5c:	90 e0       	ldi	r25, 0x00	; 0
    7e5e:	02 2e       	mov	r0, r18
    7e60:	02 c0       	rjmp	.+4      	; 0x7e66 <DIO_ChannelGroupRead+0xf4>
    7e62:	88 0f       	add	r24, r24
    7e64:	99 1f       	adc	r25, r25
    7e66:	0a 94       	dec	r0
    7e68:	e2 f7       	brpl	.-8      	; 0x7e62 <DIO_ChannelGroupRead+0xf0>
    7e6a:	80 95       	com	r24
    7e6c:	84 23       	and	r24, r20
    7e6e:	ed 89       	ldd	r30, Y+21	; 0x15
    7e70:	fe 89       	ldd	r31, Y+22	; 0x16
    7e72:	80 83       	st	Z, r24
{

	uint8_t loop;
	uint8_t to=channel_group_variabe.no_of_channels;

	for(loop=0u; loop <to ; loop++ ){
    7e74:	8e 81       	ldd	r24, Y+6	; 0x06
    7e76:	8f 5f       	subi	r24, 0xFF	; 255
    7e78:	8e 83       	std	Y+6, r24	; 0x06
    7e7a:	9e 81       	ldd	r25, Y+6	; 0x06
    7e7c:	8d 81       	ldd	r24, Y+5	; 0x05
    7e7e:	98 17       	cp	r25, r24
    7e80:	08 f4       	brcc	.+2      	; 0x7e84 <DIO_ChannelGroupRead+0x112>
    7e82:	9e cf       	rjmp	.-196    	; 0x7dc0 <DIO_ChannelGroupRead+0x4e>
		}else{
			CLEAR_BIT(* data_ptr,loop);
		}
	}

}
    7e84:	66 96       	adiw	r28, 0x16	; 22
    7e86:	0f b6       	in	r0, 0x3f	; 63
    7e88:	f8 94       	cli
    7e8a:	de bf       	out	0x3e, r29	; 62
    7e8c:	0f be       	out	0x3f, r0	; 63
    7e8e:	cd bf       	out	0x3d, r28	; 61
    7e90:	cf 91       	pop	r28
    7e92:	df 91       	pop	r29
    7e94:	1f 91       	pop	r17
    7e96:	0f 91       	pop	r16
    7e98:	ff 90       	pop	r15
    7e9a:	ef 90       	pop	r14
    7e9c:	df 90       	pop	r13
    7e9e:	cf 90       	pop	r12
    7ea0:	bf 90       	pop	r11
    7ea2:	af 90       	pop	r10
    7ea4:	08 95       	ret

00007ea6 <LCD_init>:
 * Initialize the LCD:
 * 1. Setup the LCD pins directions by use the GPIO driver.
 * 2. Setup the LCD Data Mode 4-bits or 8-bits.
 */
void LCD_init(void)
{
    7ea6:	df 93       	push	r29
    7ea8:	cf 93       	push	r28
    7eaa:	cd b7       	in	r28, 0x3d	; 61
    7eac:	de b7       	in	r29, 0x3e	; 62
    7eae:	2e 97       	sbiw	r28, 0x0e	; 14
    7eb0:	0f b6       	in	r0, 0x3f	; 63
    7eb2:	f8 94       	cli
    7eb4:	de bf       	out	0x3e, r29	; 62
    7eb6:	0f be       	out	0x3f, r0	; 63
    7eb8:	cd bf       	out	0x3d, r28	; 61
	/* Configure the direction for RS and E pins as output pins */
	GPIO_setupPinDirection(LCD_RS_PORT_ID,LCD_RS_PIN_ID,PIN_OUTPUT);
    7eba:	83 e0       	ldi	r24, 0x03	; 3
    7ebc:	60 e0       	ldi	r22, 0x00	; 0
    7ebe:	41 e0       	ldi	r20, 0x01	; 1
    7ec0:	0e 94 b4 3a 	call	0x7568	; 0x7568 <GPIO_setupPinDirection>
	GPIO_setupPinDirection(LCD_E_PORT_ID,LCD_E_PIN_ID,PIN_OUTPUT);
    7ec4:	83 e0       	ldi	r24, 0x03	; 3
    7ec6:	62 e0       	ldi	r22, 0x02	; 2
    7ec8:	41 e0       	ldi	r20, 0x01	; 1
    7eca:	0e 94 b4 3a 	call	0x7568	; 0x7568 <GPIO_setupPinDirection>
    7ece:	80 e0       	ldi	r24, 0x00	; 0
    7ed0:	90 e0       	ldi	r25, 0x00	; 0
    7ed2:	a0 ea       	ldi	r26, 0xA0	; 160
    7ed4:	b1 e4       	ldi	r27, 0x41	; 65
    7ed6:	8b 87       	std	Y+11, r24	; 0x0b
    7ed8:	9c 87       	std	Y+12, r25	; 0x0c
    7eda:	ad 87       	std	Y+13, r26	; 0x0d
    7edc:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    7ede:	6b 85       	ldd	r22, Y+11	; 0x0b
    7ee0:	7c 85       	ldd	r23, Y+12	; 0x0c
    7ee2:	8d 85       	ldd	r24, Y+13	; 0x0d
    7ee4:	9e 85       	ldd	r25, Y+14	; 0x0e
    7ee6:	20 e0       	ldi	r18, 0x00	; 0
    7ee8:	30 e0       	ldi	r19, 0x00	; 0
    7eea:	4a e7       	ldi	r20, 0x7A	; 122
    7eec:	53 e4       	ldi	r21, 0x43	; 67
    7eee:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    7ef2:	dc 01       	movw	r26, r24
    7ef4:	cb 01       	movw	r24, r22
    7ef6:	8f 83       	std	Y+7, r24	; 0x07
    7ef8:	98 87       	std	Y+8, r25	; 0x08
    7efa:	a9 87       	std	Y+9, r26	; 0x09
    7efc:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    7efe:	6f 81       	ldd	r22, Y+7	; 0x07
    7f00:	78 85       	ldd	r23, Y+8	; 0x08
    7f02:	89 85       	ldd	r24, Y+9	; 0x09
    7f04:	9a 85       	ldd	r25, Y+10	; 0x0a
    7f06:	20 e0       	ldi	r18, 0x00	; 0
    7f08:	30 e0       	ldi	r19, 0x00	; 0
    7f0a:	40 e8       	ldi	r20, 0x80	; 128
    7f0c:	5f e3       	ldi	r21, 0x3F	; 63
    7f0e:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    7f12:	88 23       	and	r24, r24
    7f14:	2c f4       	brge	.+10     	; 0x7f20 <LCD_init+0x7a>
		__ticks = 1;
    7f16:	81 e0       	ldi	r24, 0x01	; 1
    7f18:	90 e0       	ldi	r25, 0x00	; 0
    7f1a:	9e 83       	std	Y+6, r25	; 0x06
    7f1c:	8d 83       	std	Y+5, r24	; 0x05
    7f1e:	3f c0       	rjmp	.+126    	; 0x7f9e <LCD_init+0xf8>
	else if (__tmp > 65535)
    7f20:	6f 81       	ldd	r22, Y+7	; 0x07
    7f22:	78 85       	ldd	r23, Y+8	; 0x08
    7f24:	89 85       	ldd	r24, Y+9	; 0x09
    7f26:	9a 85       	ldd	r25, Y+10	; 0x0a
    7f28:	20 e0       	ldi	r18, 0x00	; 0
    7f2a:	3f ef       	ldi	r19, 0xFF	; 255
    7f2c:	4f e7       	ldi	r20, 0x7F	; 127
    7f2e:	57 e4       	ldi	r21, 0x47	; 71
    7f30:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    7f34:	18 16       	cp	r1, r24
    7f36:	4c f5       	brge	.+82     	; 0x7f8a <LCD_init+0xe4>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    7f38:	6b 85       	ldd	r22, Y+11	; 0x0b
    7f3a:	7c 85       	ldd	r23, Y+12	; 0x0c
    7f3c:	8d 85       	ldd	r24, Y+13	; 0x0d
    7f3e:	9e 85       	ldd	r25, Y+14	; 0x0e
    7f40:	20 e0       	ldi	r18, 0x00	; 0
    7f42:	30 e0       	ldi	r19, 0x00	; 0
    7f44:	40 e2       	ldi	r20, 0x20	; 32
    7f46:	51 e4       	ldi	r21, 0x41	; 65
    7f48:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    7f4c:	dc 01       	movw	r26, r24
    7f4e:	cb 01       	movw	r24, r22
    7f50:	bc 01       	movw	r22, r24
    7f52:	cd 01       	movw	r24, r26
    7f54:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    7f58:	dc 01       	movw	r26, r24
    7f5a:	cb 01       	movw	r24, r22
    7f5c:	9e 83       	std	Y+6, r25	; 0x06
    7f5e:	8d 83       	std	Y+5, r24	; 0x05
    7f60:	0f c0       	rjmp	.+30     	; 0x7f80 <LCD_init+0xda>
    7f62:	89 e1       	ldi	r24, 0x19	; 25
    7f64:	90 e0       	ldi	r25, 0x00	; 0
    7f66:	9c 83       	std	Y+4, r25	; 0x04
    7f68:	8b 83       	std	Y+3, r24	; 0x03
    7f6a:	8b 81       	ldd	r24, Y+3	; 0x03
    7f6c:	9c 81       	ldd	r25, Y+4	; 0x04
    7f6e:	01 97       	sbiw	r24, 0x01	; 1
    7f70:	f1 f7       	brne	.-4      	; 0x7f6e <LCD_init+0xc8>
    7f72:	9c 83       	std	Y+4, r25	; 0x04
    7f74:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    7f76:	8d 81       	ldd	r24, Y+5	; 0x05
    7f78:	9e 81       	ldd	r25, Y+6	; 0x06
    7f7a:	01 97       	sbiw	r24, 0x01	; 1
    7f7c:	9e 83       	std	Y+6, r25	; 0x06
    7f7e:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    7f80:	8d 81       	ldd	r24, Y+5	; 0x05
    7f82:	9e 81       	ldd	r25, Y+6	; 0x06
    7f84:	00 97       	sbiw	r24, 0x00	; 0
    7f86:	69 f7       	brne	.-38     	; 0x7f62 <LCD_init+0xbc>
    7f88:	14 c0       	rjmp	.+40     	; 0x7fb2 <LCD_init+0x10c>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    7f8a:	6f 81       	ldd	r22, Y+7	; 0x07
    7f8c:	78 85       	ldd	r23, Y+8	; 0x08
    7f8e:	89 85       	ldd	r24, Y+9	; 0x09
    7f90:	9a 85       	ldd	r25, Y+10	; 0x0a
    7f92:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    7f96:	dc 01       	movw	r26, r24
    7f98:	cb 01       	movw	r24, r22
    7f9a:	9e 83       	std	Y+6, r25	; 0x06
    7f9c:	8d 83       	std	Y+5, r24	; 0x05
    7f9e:	8d 81       	ldd	r24, Y+5	; 0x05
    7fa0:	9e 81       	ldd	r25, Y+6	; 0x06
    7fa2:	9a 83       	std	Y+2, r25	; 0x02
    7fa4:	89 83       	std	Y+1, r24	; 0x01
    7fa6:	89 81       	ldd	r24, Y+1	; 0x01
    7fa8:	9a 81       	ldd	r25, Y+2	; 0x02
    7faa:	01 97       	sbiw	r24, 0x01	; 1
    7fac:	f1 f7       	brne	.-4      	; 0x7faa <LCD_init+0x104>
    7fae:	9a 83       	std	Y+2, r25	; 0x02
    7fb0:	89 83       	std	Y+1, r24	; 0x01

	_delay_ms(20);		/* LCD Power ON delay always > 15ms */

#if(LCD_DATA_BITS_MODE == 4)
	/* Configure 4 pins in the data port as output pins */
	GPIO_setupPinDirection(LCD_DATA_PORT_ID,LCD_DB4_PIN_ID,PIN_OUTPUT);
    7fb2:	83 e0       	ldi	r24, 0x03	; 3
    7fb4:	64 e0       	ldi	r22, 0x04	; 4
    7fb6:	41 e0       	ldi	r20, 0x01	; 1
    7fb8:	0e 94 b4 3a 	call	0x7568	; 0x7568 <GPIO_setupPinDirection>
	GPIO_setupPinDirection(LCD_DATA_PORT_ID,LCD_DB5_PIN_ID,PIN_OUTPUT);
    7fbc:	83 e0       	ldi	r24, 0x03	; 3
    7fbe:	65 e0       	ldi	r22, 0x05	; 5
    7fc0:	41 e0       	ldi	r20, 0x01	; 1
    7fc2:	0e 94 b4 3a 	call	0x7568	; 0x7568 <GPIO_setupPinDirection>
	GPIO_setupPinDirection(LCD_DATA_PORT_ID,LCD_DB6_PIN_ID,PIN_OUTPUT);
    7fc6:	83 e0       	ldi	r24, 0x03	; 3
    7fc8:	66 e0       	ldi	r22, 0x06	; 6
    7fca:	41 e0       	ldi	r20, 0x01	; 1
    7fcc:	0e 94 b4 3a 	call	0x7568	; 0x7568 <GPIO_setupPinDirection>
	GPIO_setupPinDirection(LCD_DATA_PORT_ID,LCD_DB7_PIN_ID,PIN_OUTPUT);
    7fd0:	83 e0       	ldi	r24, 0x03	; 3
    7fd2:	67 e0       	ldi	r22, 0x07	; 7
    7fd4:	41 e0       	ldi	r20, 0x01	; 1
    7fd6:	0e 94 b4 3a 	call	0x7568	; 0x7568 <GPIO_setupPinDirection>

	/* Send for 4 bit initialization of LCD  */
	LCD_sendCommand(LCD_TWO_LINES_FOUR_BITS_MODE_INIT1);
    7fda:	83 e3       	ldi	r24, 0x33	; 51
    7fdc:	0e 94 05 40 	call	0x800a	; 0x800a <LCD_sendCommand>
	LCD_sendCommand(LCD_TWO_LINES_FOUR_BITS_MODE_INIT2);
    7fe0:	82 e3       	ldi	r24, 0x32	; 50
    7fe2:	0e 94 05 40 	call	0x800a	; 0x800a <LCD_sendCommand>

	/* use 2-lines LCD + 4-bits Data Mode + 5*7 dot display Mode */
	LCD_sendCommand(LCD_TWO_LINES_FOUR_BITS_MODE);
    7fe6:	88 e2       	ldi	r24, 0x28	; 40
    7fe8:	0e 94 05 40 	call	0x800a	; 0x800a <LCD_sendCommand>
	/* use 2-lines LCD + 8-bits Data Mode + 5*7 dot display Mode */
	LCD_sendCommand(LCD_TWO_LINES_EIGHT_BITS_MODE);

#endif

	LCD_sendCommand(LCD_CURSOR_OFF); /* cursor off */
    7fec:	8c e0       	ldi	r24, 0x0C	; 12
    7fee:	0e 94 05 40 	call	0x800a	; 0x800a <LCD_sendCommand>
	LCD_sendCommand(LCD_CLEAR_COMMAND); /* clear LCD at the beginning */
    7ff2:	81 e0       	ldi	r24, 0x01	; 1
    7ff4:	0e 94 05 40 	call	0x800a	; 0x800a <LCD_sendCommand>
}
    7ff8:	2e 96       	adiw	r28, 0x0e	; 14
    7ffa:	0f b6       	in	r0, 0x3f	; 63
    7ffc:	f8 94       	cli
    7ffe:	de bf       	out	0x3e, r29	; 62
    8000:	0f be       	out	0x3f, r0	; 63
    8002:	cd bf       	out	0x3d, r28	; 61
    8004:	cf 91       	pop	r28
    8006:	df 91       	pop	r29
    8008:	08 95       	ret

0000800a <LCD_sendCommand>:
/*
 * Description :
 * Send the required command to the screen
 */
void LCD_sendCommand(uint8 command)
{
    800a:	0f 93       	push	r16
    800c:	1f 93       	push	r17
    800e:	df 93       	push	r29
    8010:	cf 93       	push	r28
    8012:	cd b7       	in	r28, 0x3d	; 61
    8014:	de b7       	in	r29, 0x3e	; 62
    8016:	c3 56       	subi	r28, 0x63	; 99
    8018:	d0 40       	sbci	r29, 0x00	; 0
    801a:	0f b6       	in	r0, 0x3f	; 63
    801c:	f8 94       	cli
    801e:	de bf       	out	0x3e, r29	; 62
    8020:	0f be       	out	0x3f, r0	; 63
    8022:	cd bf       	out	0x3d, r28	; 61
    8024:	fe 01       	movw	r30, r28
    8026:	ed 59       	subi	r30, 0x9D	; 157
    8028:	ff 4f       	sbci	r31, 0xFF	; 255
    802a:	80 83       	st	Z, r24
	GPIO_writePin(LCD_RS_PORT_ID,LCD_RS_PIN_ID,LOGIC_LOW); /* Instruction Mode RS=0 */
    802c:	83 e0       	ldi	r24, 0x03	; 3
    802e:	60 e0       	ldi	r22, 0x00	; 0
    8030:	40 e0       	ldi	r20, 0x00	; 0
    8032:	0e 94 9f 3b 	call	0x773e	; 0x773e <GPIO_writePin>
    8036:	fe 01       	movw	r30, r28
    8038:	e1 5a       	subi	r30, 0xA1	; 161
    803a:	ff 4f       	sbci	r31, 0xFF	; 255
    803c:	80 e0       	ldi	r24, 0x00	; 0
    803e:	90 e0       	ldi	r25, 0x00	; 0
    8040:	a0 e8       	ldi	r26, 0x80	; 128
    8042:	bf e3       	ldi	r27, 0x3F	; 63
    8044:	80 83       	st	Z, r24
    8046:	91 83       	std	Z+1, r25	; 0x01
    8048:	a2 83       	std	Z+2, r26	; 0x02
    804a:	b3 83       	std	Z+3, r27	; 0x03
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    804c:	8e 01       	movw	r16, r28
    804e:	05 5a       	subi	r16, 0xA5	; 165
    8050:	1f 4f       	sbci	r17, 0xFF	; 255
    8052:	fe 01       	movw	r30, r28
    8054:	e1 5a       	subi	r30, 0xA1	; 161
    8056:	ff 4f       	sbci	r31, 0xFF	; 255
    8058:	60 81       	ld	r22, Z
    805a:	71 81       	ldd	r23, Z+1	; 0x01
    805c:	82 81       	ldd	r24, Z+2	; 0x02
    805e:	93 81       	ldd	r25, Z+3	; 0x03
    8060:	20 e0       	ldi	r18, 0x00	; 0
    8062:	30 e0       	ldi	r19, 0x00	; 0
    8064:	4a e7       	ldi	r20, 0x7A	; 122
    8066:	53 e4       	ldi	r21, 0x43	; 67
    8068:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    806c:	dc 01       	movw	r26, r24
    806e:	cb 01       	movw	r24, r22
    8070:	f8 01       	movw	r30, r16
    8072:	80 83       	st	Z, r24
    8074:	91 83       	std	Z+1, r25	; 0x01
    8076:	a2 83       	std	Z+2, r26	; 0x02
    8078:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    807a:	fe 01       	movw	r30, r28
    807c:	e5 5a       	subi	r30, 0xA5	; 165
    807e:	ff 4f       	sbci	r31, 0xFF	; 255
    8080:	60 81       	ld	r22, Z
    8082:	71 81       	ldd	r23, Z+1	; 0x01
    8084:	82 81       	ldd	r24, Z+2	; 0x02
    8086:	93 81       	ldd	r25, Z+3	; 0x03
    8088:	20 e0       	ldi	r18, 0x00	; 0
    808a:	30 e0       	ldi	r19, 0x00	; 0
    808c:	40 e8       	ldi	r20, 0x80	; 128
    808e:	5f e3       	ldi	r21, 0x3F	; 63
    8090:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    8094:	88 23       	and	r24, r24
    8096:	44 f4       	brge	.+16     	; 0x80a8 <LCD_sendCommand+0x9e>
		__ticks = 1;
    8098:	fe 01       	movw	r30, r28
    809a:	e7 5a       	subi	r30, 0xA7	; 167
    809c:	ff 4f       	sbci	r31, 0xFF	; 255
    809e:	81 e0       	ldi	r24, 0x01	; 1
    80a0:	90 e0       	ldi	r25, 0x00	; 0
    80a2:	91 83       	std	Z+1, r25	; 0x01
    80a4:	80 83       	st	Z, r24
    80a6:	64 c0       	rjmp	.+200    	; 0x8170 <LCD_sendCommand+0x166>
	else if (__tmp > 65535)
    80a8:	fe 01       	movw	r30, r28
    80aa:	e5 5a       	subi	r30, 0xA5	; 165
    80ac:	ff 4f       	sbci	r31, 0xFF	; 255
    80ae:	60 81       	ld	r22, Z
    80b0:	71 81       	ldd	r23, Z+1	; 0x01
    80b2:	82 81       	ldd	r24, Z+2	; 0x02
    80b4:	93 81       	ldd	r25, Z+3	; 0x03
    80b6:	20 e0       	ldi	r18, 0x00	; 0
    80b8:	3f ef       	ldi	r19, 0xFF	; 255
    80ba:	4f e7       	ldi	r20, 0x7F	; 127
    80bc:	57 e4       	ldi	r21, 0x47	; 71
    80be:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    80c2:	18 16       	cp	r1, r24
    80c4:	0c f0       	brlt	.+2      	; 0x80c8 <LCD_sendCommand+0xbe>
    80c6:	43 c0       	rjmp	.+134    	; 0x814e <LCD_sendCommand+0x144>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    80c8:	fe 01       	movw	r30, r28
    80ca:	e1 5a       	subi	r30, 0xA1	; 161
    80cc:	ff 4f       	sbci	r31, 0xFF	; 255
    80ce:	60 81       	ld	r22, Z
    80d0:	71 81       	ldd	r23, Z+1	; 0x01
    80d2:	82 81       	ldd	r24, Z+2	; 0x02
    80d4:	93 81       	ldd	r25, Z+3	; 0x03
    80d6:	20 e0       	ldi	r18, 0x00	; 0
    80d8:	30 e0       	ldi	r19, 0x00	; 0
    80da:	40 e2       	ldi	r20, 0x20	; 32
    80dc:	51 e4       	ldi	r21, 0x41	; 65
    80de:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    80e2:	dc 01       	movw	r26, r24
    80e4:	cb 01       	movw	r24, r22
    80e6:	8e 01       	movw	r16, r28
    80e8:	07 5a       	subi	r16, 0xA7	; 167
    80ea:	1f 4f       	sbci	r17, 0xFF	; 255
    80ec:	bc 01       	movw	r22, r24
    80ee:	cd 01       	movw	r24, r26
    80f0:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    80f4:	dc 01       	movw	r26, r24
    80f6:	cb 01       	movw	r24, r22
    80f8:	f8 01       	movw	r30, r16
    80fa:	91 83       	std	Z+1, r25	; 0x01
    80fc:	80 83       	st	Z, r24
    80fe:	1f c0       	rjmp	.+62     	; 0x813e <LCD_sendCommand+0x134>
    8100:	fe 01       	movw	r30, r28
    8102:	e9 5a       	subi	r30, 0xA9	; 169
    8104:	ff 4f       	sbci	r31, 0xFF	; 255
    8106:	89 e1       	ldi	r24, 0x19	; 25
    8108:	90 e0       	ldi	r25, 0x00	; 0
    810a:	91 83       	std	Z+1, r25	; 0x01
    810c:	80 83       	st	Z, r24
    810e:	fe 01       	movw	r30, r28
    8110:	e9 5a       	subi	r30, 0xA9	; 169
    8112:	ff 4f       	sbci	r31, 0xFF	; 255
    8114:	80 81       	ld	r24, Z
    8116:	91 81       	ldd	r25, Z+1	; 0x01
    8118:	01 97       	sbiw	r24, 0x01	; 1
    811a:	f1 f7       	brne	.-4      	; 0x8118 <LCD_sendCommand+0x10e>
    811c:	fe 01       	movw	r30, r28
    811e:	e9 5a       	subi	r30, 0xA9	; 169
    8120:	ff 4f       	sbci	r31, 0xFF	; 255
    8122:	91 83       	std	Z+1, r25	; 0x01
    8124:	80 83       	st	Z, r24
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    8126:	de 01       	movw	r26, r28
    8128:	a7 5a       	subi	r26, 0xA7	; 167
    812a:	bf 4f       	sbci	r27, 0xFF	; 255
    812c:	fe 01       	movw	r30, r28
    812e:	e7 5a       	subi	r30, 0xA7	; 167
    8130:	ff 4f       	sbci	r31, 0xFF	; 255
    8132:	80 81       	ld	r24, Z
    8134:	91 81       	ldd	r25, Z+1	; 0x01
    8136:	01 97       	sbiw	r24, 0x01	; 1
    8138:	11 96       	adiw	r26, 0x01	; 1
    813a:	9c 93       	st	X, r25
    813c:	8e 93       	st	-X, r24
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    813e:	fe 01       	movw	r30, r28
    8140:	e7 5a       	subi	r30, 0xA7	; 167
    8142:	ff 4f       	sbci	r31, 0xFF	; 255
    8144:	80 81       	ld	r24, Z
    8146:	91 81       	ldd	r25, Z+1	; 0x01
    8148:	00 97       	sbiw	r24, 0x00	; 0
    814a:	d1 f6       	brne	.-76     	; 0x8100 <LCD_sendCommand+0xf6>
    814c:	27 c0       	rjmp	.+78     	; 0x819c <LCD_sendCommand+0x192>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    814e:	8e 01       	movw	r16, r28
    8150:	07 5a       	subi	r16, 0xA7	; 167
    8152:	1f 4f       	sbci	r17, 0xFF	; 255
    8154:	fe 01       	movw	r30, r28
    8156:	e5 5a       	subi	r30, 0xA5	; 165
    8158:	ff 4f       	sbci	r31, 0xFF	; 255
    815a:	60 81       	ld	r22, Z
    815c:	71 81       	ldd	r23, Z+1	; 0x01
    815e:	82 81       	ldd	r24, Z+2	; 0x02
    8160:	93 81       	ldd	r25, Z+3	; 0x03
    8162:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    8166:	dc 01       	movw	r26, r24
    8168:	cb 01       	movw	r24, r22
    816a:	f8 01       	movw	r30, r16
    816c:	91 83       	std	Z+1, r25	; 0x01
    816e:	80 83       	st	Z, r24
    8170:	de 01       	movw	r26, r28
    8172:	ab 5a       	subi	r26, 0xAB	; 171
    8174:	bf 4f       	sbci	r27, 0xFF	; 255
    8176:	fe 01       	movw	r30, r28
    8178:	e7 5a       	subi	r30, 0xA7	; 167
    817a:	ff 4f       	sbci	r31, 0xFF	; 255
    817c:	80 81       	ld	r24, Z
    817e:	91 81       	ldd	r25, Z+1	; 0x01
    8180:	8d 93       	st	X+, r24
    8182:	9c 93       	st	X, r25
    8184:	fe 01       	movw	r30, r28
    8186:	eb 5a       	subi	r30, 0xAB	; 171
    8188:	ff 4f       	sbci	r31, 0xFF	; 255
    818a:	80 81       	ld	r24, Z
    818c:	91 81       	ldd	r25, Z+1	; 0x01
    818e:	01 97       	sbiw	r24, 0x01	; 1
    8190:	f1 f7       	brne	.-4      	; 0x818e <LCD_sendCommand+0x184>
    8192:	fe 01       	movw	r30, r28
    8194:	eb 5a       	subi	r30, 0xAB	; 171
    8196:	ff 4f       	sbci	r31, 0xFF	; 255
    8198:	91 83       	std	Z+1, r25	; 0x01
    819a:	80 83       	st	Z, r24
	_delay_ms(1); /* delay for processing Tas = 50ns */
	GPIO_writePin(LCD_E_PORT_ID,LCD_E_PIN_ID,LOGIC_HIGH); /* Enable LCD E=1 */
    819c:	83 e0       	ldi	r24, 0x03	; 3
    819e:	62 e0       	ldi	r22, 0x02	; 2
    81a0:	41 e0       	ldi	r20, 0x01	; 1
    81a2:	0e 94 9f 3b 	call	0x773e	; 0x773e <GPIO_writePin>
    81a6:	fe 01       	movw	r30, r28
    81a8:	ef 5a       	subi	r30, 0xAF	; 175
    81aa:	ff 4f       	sbci	r31, 0xFF	; 255
    81ac:	80 e0       	ldi	r24, 0x00	; 0
    81ae:	90 e0       	ldi	r25, 0x00	; 0
    81b0:	a0 e8       	ldi	r26, 0x80	; 128
    81b2:	bf e3       	ldi	r27, 0x3F	; 63
    81b4:	80 83       	st	Z, r24
    81b6:	91 83       	std	Z+1, r25	; 0x01
    81b8:	a2 83       	std	Z+2, r26	; 0x02
    81ba:	b3 83       	std	Z+3, r27	; 0x03
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    81bc:	8e 01       	movw	r16, r28
    81be:	03 5b       	subi	r16, 0xB3	; 179
    81c0:	1f 4f       	sbci	r17, 0xFF	; 255
    81c2:	fe 01       	movw	r30, r28
    81c4:	ef 5a       	subi	r30, 0xAF	; 175
    81c6:	ff 4f       	sbci	r31, 0xFF	; 255
    81c8:	60 81       	ld	r22, Z
    81ca:	71 81       	ldd	r23, Z+1	; 0x01
    81cc:	82 81       	ldd	r24, Z+2	; 0x02
    81ce:	93 81       	ldd	r25, Z+3	; 0x03
    81d0:	20 e0       	ldi	r18, 0x00	; 0
    81d2:	30 e0       	ldi	r19, 0x00	; 0
    81d4:	4a e7       	ldi	r20, 0x7A	; 122
    81d6:	53 e4       	ldi	r21, 0x43	; 67
    81d8:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    81dc:	dc 01       	movw	r26, r24
    81de:	cb 01       	movw	r24, r22
    81e0:	f8 01       	movw	r30, r16
    81e2:	80 83       	st	Z, r24
    81e4:	91 83       	std	Z+1, r25	; 0x01
    81e6:	a2 83       	std	Z+2, r26	; 0x02
    81e8:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    81ea:	fe 01       	movw	r30, r28
    81ec:	e3 5b       	subi	r30, 0xB3	; 179
    81ee:	ff 4f       	sbci	r31, 0xFF	; 255
    81f0:	60 81       	ld	r22, Z
    81f2:	71 81       	ldd	r23, Z+1	; 0x01
    81f4:	82 81       	ldd	r24, Z+2	; 0x02
    81f6:	93 81       	ldd	r25, Z+3	; 0x03
    81f8:	20 e0       	ldi	r18, 0x00	; 0
    81fa:	30 e0       	ldi	r19, 0x00	; 0
    81fc:	40 e8       	ldi	r20, 0x80	; 128
    81fe:	5f e3       	ldi	r21, 0x3F	; 63
    8200:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    8204:	88 23       	and	r24, r24
    8206:	44 f4       	brge	.+16     	; 0x8218 <LCD_sendCommand+0x20e>
		__ticks = 1;
    8208:	fe 01       	movw	r30, r28
    820a:	e5 5b       	subi	r30, 0xB5	; 181
    820c:	ff 4f       	sbci	r31, 0xFF	; 255
    820e:	81 e0       	ldi	r24, 0x01	; 1
    8210:	90 e0       	ldi	r25, 0x00	; 0
    8212:	91 83       	std	Z+1, r25	; 0x01
    8214:	80 83       	st	Z, r24
    8216:	64 c0       	rjmp	.+200    	; 0x82e0 <LCD_sendCommand+0x2d6>
	else if (__tmp > 65535)
    8218:	fe 01       	movw	r30, r28
    821a:	e3 5b       	subi	r30, 0xB3	; 179
    821c:	ff 4f       	sbci	r31, 0xFF	; 255
    821e:	60 81       	ld	r22, Z
    8220:	71 81       	ldd	r23, Z+1	; 0x01
    8222:	82 81       	ldd	r24, Z+2	; 0x02
    8224:	93 81       	ldd	r25, Z+3	; 0x03
    8226:	20 e0       	ldi	r18, 0x00	; 0
    8228:	3f ef       	ldi	r19, 0xFF	; 255
    822a:	4f e7       	ldi	r20, 0x7F	; 127
    822c:	57 e4       	ldi	r21, 0x47	; 71
    822e:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    8232:	18 16       	cp	r1, r24
    8234:	0c f0       	brlt	.+2      	; 0x8238 <LCD_sendCommand+0x22e>
    8236:	43 c0       	rjmp	.+134    	; 0x82be <LCD_sendCommand+0x2b4>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    8238:	fe 01       	movw	r30, r28
    823a:	ef 5a       	subi	r30, 0xAF	; 175
    823c:	ff 4f       	sbci	r31, 0xFF	; 255
    823e:	60 81       	ld	r22, Z
    8240:	71 81       	ldd	r23, Z+1	; 0x01
    8242:	82 81       	ldd	r24, Z+2	; 0x02
    8244:	93 81       	ldd	r25, Z+3	; 0x03
    8246:	20 e0       	ldi	r18, 0x00	; 0
    8248:	30 e0       	ldi	r19, 0x00	; 0
    824a:	40 e2       	ldi	r20, 0x20	; 32
    824c:	51 e4       	ldi	r21, 0x41	; 65
    824e:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    8252:	dc 01       	movw	r26, r24
    8254:	cb 01       	movw	r24, r22
    8256:	8e 01       	movw	r16, r28
    8258:	05 5b       	subi	r16, 0xB5	; 181
    825a:	1f 4f       	sbci	r17, 0xFF	; 255
    825c:	bc 01       	movw	r22, r24
    825e:	cd 01       	movw	r24, r26
    8260:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    8264:	dc 01       	movw	r26, r24
    8266:	cb 01       	movw	r24, r22
    8268:	f8 01       	movw	r30, r16
    826a:	91 83       	std	Z+1, r25	; 0x01
    826c:	80 83       	st	Z, r24
    826e:	1f c0       	rjmp	.+62     	; 0x82ae <LCD_sendCommand+0x2a4>
    8270:	fe 01       	movw	r30, r28
    8272:	e7 5b       	subi	r30, 0xB7	; 183
    8274:	ff 4f       	sbci	r31, 0xFF	; 255
    8276:	89 e1       	ldi	r24, 0x19	; 25
    8278:	90 e0       	ldi	r25, 0x00	; 0
    827a:	91 83       	std	Z+1, r25	; 0x01
    827c:	80 83       	st	Z, r24
    827e:	fe 01       	movw	r30, r28
    8280:	e7 5b       	subi	r30, 0xB7	; 183
    8282:	ff 4f       	sbci	r31, 0xFF	; 255
    8284:	80 81       	ld	r24, Z
    8286:	91 81       	ldd	r25, Z+1	; 0x01
    8288:	01 97       	sbiw	r24, 0x01	; 1
    828a:	f1 f7       	brne	.-4      	; 0x8288 <LCD_sendCommand+0x27e>
    828c:	fe 01       	movw	r30, r28
    828e:	e7 5b       	subi	r30, 0xB7	; 183
    8290:	ff 4f       	sbci	r31, 0xFF	; 255
    8292:	91 83       	std	Z+1, r25	; 0x01
    8294:	80 83       	st	Z, r24
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    8296:	de 01       	movw	r26, r28
    8298:	a5 5b       	subi	r26, 0xB5	; 181
    829a:	bf 4f       	sbci	r27, 0xFF	; 255
    829c:	fe 01       	movw	r30, r28
    829e:	e5 5b       	subi	r30, 0xB5	; 181
    82a0:	ff 4f       	sbci	r31, 0xFF	; 255
    82a2:	80 81       	ld	r24, Z
    82a4:	91 81       	ldd	r25, Z+1	; 0x01
    82a6:	01 97       	sbiw	r24, 0x01	; 1
    82a8:	11 96       	adiw	r26, 0x01	; 1
    82aa:	9c 93       	st	X, r25
    82ac:	8e 93       	st	-X, r24
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    82ae:	fe 01       	movw	r30, r28
    82b0:	e5 5b       	subi	r30, 0xB5	; 181
    82b2:	ff 4f       	sbci	r31, 0xFF	; 255
    82b4:	80 81       	ld	r24, Z
    82b6:	91 81       	ldd	r25, Z+1	; 0x01
    82b8:	00 97       	sbiw	r24, 0x00	; 0
    82ba:	d1 f6       	brne	.-76     	; 0x8270 <LCD_sendCommand+0x266>
    82bc:	27 c0       	rjmp	.+78     	; 0x830c <LCD_sendCommand+0x302>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    82be:	8e 01       	movw	r16, r28
    82c0:	05 5b       	subi	r16, 0xB5	; 181
    82c2:	1f 4f       	sbci	r17, 0xFF	; 255
    82c4:	fe 01       	movw	r30, r28
    82c6:	e3 5b       	subi	r30, 0xB3	; 179
    82c8:	ff 4f       	sbci	r31, 0xFF	; 255
    82ca:	60 81       	ld	r22, Z
    82cc:	71 81       	ldd	r23, Z+1	; 0x01
    82ce:	82 81       	ldd	r24, Z+2	; 0x02
    82d0:	93 81       	ldd	r25, Z+3	; 0x03
    82d2:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    82d6:	dc 01       	movw	r26, r24
    82d8:	cb 01       	movw	r24, r22
    82da:	f8 01       	movw	r30, r16
    82dc:	91 83       	std	Z+1, r25	; 0x01
    82de:	80 83       	st	Z, r24
    82e0:	de 01       	movw	r26, r28
    82e2:	a9 5b       	subi	r26, 0xB9	; 185
    82e4:	bf 4f       	sbci	r27, 0xFF	; 255
    82e6:	fe 01       	movw	r30, r28
    82e8:	e5 5b       	subi	r30, 0xB5	; 181
    82ea:	ff 4f       	sbci	r31, 0xFF	; 255
    82ec:	80 81       	ld	r24, Z
    82ee:	91 81       	ldd	r25, Z+1	; 0x01
    82f0:	8d 93       	st	X+, r24
    82f2:	9c 93       	st	X, r25
    82f4:	fe 01       	movw	r30, r28
    82f6:	e9 5b       	subi	r30, 0xB9	; 185
    82f8:	ff 4f       	sbci	r31, 0xFF	; 255
    82fa:	80 81       	ld	r24, Z
    82fc:	91 81       	ldd	r25, Z+1	; 0x01
    82fe:	01 97       	sbiw	r24, 0x01	; 1
    8300:	f1 f7       	brne	.-4      	; 0x82fe <LCD_sendCommand+0x2f4>
    8302:	fe 01       	movw	r30, r28
    8304:	e9 5b       	subi	r30, 0xB9	; 185
    8306:	ff 4f       	sbci	r31, 0xFF	; 255
    8308:	91 83       	std	Z+1, r25	; 0x01
    830a:	80 83       	st	Z, r24
	_delay_ms(1); /* delay for processing Tpw - Tdws = 190ns */

#if(LCD_DATA_BITS_MODE == 4)
	GPIO_writePin(LCD_DATA_PORT_ID,LCD_DB4_PIN_ID,GET_BIT(command,4));
    830c:	fe 01       	movw	r30, r28
    830e:	ed 59       	subi	r30, 0x9D	; 157
    8310:	ff 4f       	sbci	r31, 0xFF	; 255
    8312:	80 81       	ld	r24, Z
    8314:	88 2f       	mov	r24, r24
    8316:	90 e0       	ldi	r25, 0x00	; 0
    8318:	80 71       	andi	r24, 0x10	; 16
    831a:	90 70       	andi	r25, 0x00	; 0
    831c:	95 95       	asr	r25
    831e:	87 95       	ror	r24
    8320:	95 95       	asr	r25
    8322:	87 95       	ror	r24
    8324:	95 95       	asr	r25
    8326:	87 95       	ror	r24
    8328:	95 95       	asr	r25
    832a:	87 95       	ror	r24
    832c:	98 2f       	mov	r25, r24
    832e:	83 e0       	ldi	r24, 0x03	; 3
    8330:	64 e0       	ldi	r22, 0x04	; 4
    8332:	49 2f       	mov	r20, r25
    8334:	0e 94 9f 3b 	call	0x773e	; 0x773e <GPIO_writePin>
	GPIO_writePin(LCD_DATA_PORT_ID,LCD_DB5_PIN_ID,GET_BIT(command,5));
    8338:	fe 01       	movw	r30, r28
    833a:	ed 59       	subi	r30, 0x9D	; 157
    833c:	ff 4f       	sbci	r31, 0xFF	; 255
    833e:	80 81       	ld	r24, Z
    8340:	88 2f       	mov	r24, r24
    8342:	90 e0       	ldi	r25, 0x00	; 0
    8344:	80 72       	andi	r24, 0x20	; 32
    8346:	90 70       	andi	r25, 0x00	; 0
    8348:	95 95       	asr	r25
    834a:	87 95       	ror	r24
    834c:	95 95       	asr	r25
    834e:	87 95       	ror	r24
    8350:	95 95       	asr	r25
    8352:	87 95       	ror	r24
    8354:	95 95       	asr	r25
    8356:	87 95       	ror	r24
    8358:	95 95       	asr	r25
    835a:	87 95       	ror	r24
    835c:	98 2f       	mov	r25, r24
    835e:	83 e0       	ldi	r24, 0x03	; 3
    8360:	65 e0       	ldi	r22, 0x05	; 5
    8362:	49 2f       	mov	r20, r25
    8364:	0e 94 9f 3b 	call	0x773e	; 0x773e <GPIO_writePin>
	GPIO_writePin(LCD_DATA_PORT_ID,LCD_DB6_PIN_ID,GET_BIT(command,6));
    8368:	fe 01       	movw	r30, r28
    836a:	ed 59       	subi	r30, 0x9D	; 157
    836c:	ff 4f       	sbci	r31, 0xFF	; 255
    836e:	80 81       	ld	r24, Z
    8370:	88 2f       	mov	r24, r24
    8372:	90 e0       	ldi	r25, 0x00	; 0
    8374:	80 74       	andi	r24, 0x40	; 64
    8376:	90 70       	andi	r25, 0x00	; 0
    8378:	08 2e       	mov	r0, r24
    837a:	89 2f       	mov	r24, r25
    837c:	00 0c       	add	r0, r0
    837e:	88 1f       	adc	r24, r24
    8380:	99 0b       	sbc	r25, r25
    8382:	00 0c       	add	r0, r0
    8384:	88 1f       	adc	r24, r24
    8386:	99 1f       	adc	r25, r25
    8388:	98 2f       	mov	r25, r24
    838a:	83 e0       	ldi	r24, 0x03	; 3
    838c:	66 e0       	ldi	r22, 0x06	; 6
    838e:	49 2f       	mov	r20, r25
    8390:	0e 94 9f 3b 	call	0x773e	; 0x773e <GPIO_writePin>
	GPIO_writePin(LCD_DATA_PORT_ID,LCD_DB7_PIN_ID,GET_BIT(command,7));
    8394:	fe 01       	movw	r30, r28
    8396:	ed 59       	subi	r30, 0x9D	; 157
    8398:	ff 4f       	sbci	r31, 0xFF	; 255
    839a:	80 81       	ld	r24, Z
    839c:	98 2f       	mov	r25, r24
    839e:	99 1f       	adc	r25, r25
    83a0:	99 27       	eor	r25, r25
    83a2:	99 1f       	adc	r25, r25
    83a4:	83 e0       	ldi	r24, 0x03	; 3
    83a6:	67 e0       	ldi	r22, 0x07	; 7
    83a8:	49 2f       	mov	r20, r25
    83aa:	0e 94 9f 3b 	call	0x773e	; 0x773e <GPIO_writePin>
    83ae:	fe 01       	movw	r30, r28
    83b0:	ed 5b       	subi	r30, 0xBD	; 189
    83b2:	ff 4f       	sbci	r31, 0xFF	; 255
    83b4:	80 e0       	ldi	r24, 0x00	; 0
    83b6:	90 e0       	ldi	r25, 0x00	; 0
    83b8:	a0 e8       	ldi	r26, 0x80	; 128
    83ba:	bf e3       	ldi	r27, 0x3F	; 63
    83bc:	80 83       	st	Z, r24
    83be:	91 83       	std	Z+1, r25	; 0x01
    83c0:	a2 83       	std	Z+2, r26	; 0x02
    83c2:	b3 83       	std	Z+3, r27	; 0x03
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    83c4:	8e 01       	movw	r16, r28
    83c6:	01 5c       	subi	r16, 0xC1	; 193
    83c8:	1f 4f       	sbci	r17, 0xFF	; 255
    83ca:	fe 01       	movw	r30, r28
    83cc:	ed 5b       	subi	r30, 0xBD	; 189
    83ce:	ff 4f       	sbci	r31, 0xFF	; 255
    83d0:	60 81       	ld	r22, Z
    83d2:	71 81       	ldd	r23, Z+1	; 0x01
    83d4:	82 81       	ldd	r24, Z+2	; 0x02
    83d6:	93 81       	ldd	r25, Z+3	; 0x03
    83d8:	20 e0       	ldi	r18, 0x00	; 0
    83da:	30 e0       	ldi	r19, 0x00	; 0
    83dc:	4a e7       	ldi	r20, 0x7A	; 122
    83de:	53 e4       	ldi	r21, 0x43	; 67
    83e0:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    83e4:	dc 01       	movw	r26, r24
    83e6:	cb 01       	movw	r24, r22
    83e8:	f8 01       	movw	r30, r16
    83ea:	80 83       	st	Z, r24
    83ec:	91 83       	std	Z+1, r25	; 0x01
    83ee:	a2 83       	std	Z+2, r26	; 0x02
    83f0:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    83f2:	fe 01       	movw	r30, r28
    83f4:	ff 96       	adiw	r30, 0x3f	; 63
    83f6:	60 81       	ld	r22, Z
    83f8:	71 81       	ldd	r23, Z+1	; 0x01
    83fa:	82 81       	ldd	r24, Z+2	; 0x02
    83fc:	93 81       	ldd	r25, Z+3	; 0x03
    83fe:	20 e0       	ldi	r18, 0x00	; 0
    8400:	30 e0       	ldi	r19, 0x00	; 0
    8402:	40 e8       	ldi	r20, 0x80	; 128
    8404:	5f e3       	ldi	r21, 0x3F	; 63
    8406:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    840a:	88 23       	and	r24, r24
    840c:	2c f4       	brge	.+10     	; 0x8418 <LCD_sendCommand+0x40e>
		__ticks = 1;
    840e:	81 e0       	ldi	r24, 0x01	; 1
    8410:	90 e0       	ldi	r25, 0x00	; 0
    8412:	9e af       	std	Y+62, r25	; 0x3e
    8414:	8d af       	std	Y+61, r24	; 0x3d
    8416:	46 c0       	rjmp	.+140    	; 0x84a4 <LCD_sendCommand+0x49a>
	else if (__tmp > 65535)
    8418:	fe 01       	movw	r30, r28
    841a:	ff 96       	adiw	r30, 0x3f	; 63
    841c:	60 81       	ld	r22, Z
    841e:	71 81       	ldd	r23, Z+1	; 0x01
    8420:	82 81       	ldd	r24, Z+2	; 0x02
    8422:	93 81       	ldd	r25, Z+3	; 0x03
    8424:	20 e0       	ldi	r18, 0x00	; 0
    8426:	3f ef       	ldi	r19, 0xFF	; 255
    8428:	4f e7       	ldi	r20, 0x7F	; 127
    842a:	57 e4       	ldi	r21, 0x47	; 71
    842c:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    8430:	18 16       	cp	r1, r24
    8432:	64 f5       	brge	.+88     	; 0x848c <LCD_sendCommand+0x482>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    8434:	fe 01       	movw	r30, r28
    8436:	ed 5b       	subi	r30, 0xBD	; 189
    8438:	ff 4f       	sbci	r31, 0xFF	; 255
    843a:	60 81       	ld	r22, Z
    843c:	71 81       	ldd	r23, Z+1	; 0x01
    843e:	82 81       	ldd	r24, Z+2	; 0x02
    8440:	93 81       	ldd	r25, Z+3	; 0x03
    8442:	20 e0       	ldi	r18, 0x00	; 0
    8444:	30 e0       	ldi	r19, 0x00	; 0
    8446:	40 e2       	ldi	r20, 0x20	; 32
    8448:	51 e4       	ldi	r21, 0x41	; 65
    844a:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    844e:	dc 01       	movw	r26, r24
    8450:	cb 01       	movw	r24, r22
    8452:	bc 01       	movw	r22, r24
    8454:	cd 01       	movw	r24, r26
    8456:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    845a:	dc 01       	movw	r26, r24
    845c:	cb 01       	movw	r24, r22
    845e:	9e af       	std	Y+62, r25	; 0x3e
    8460:	8d af       	std	Y+61, r24	; 0x3d
    8462:	0f c0       	rjmp	.+30     	; 0x8482 <LCD_sendCommand+0x478>
    8464:	89 e1       	ldi	r24, 0x19	; 25
    8466:	90 e0       	ldi	r25, 0x00	; 0
    8468:	9c af       	std	Y+60, r25	; 0x3c
    846a:	8b af       	std	Y+59, r24	; 0x3b
    846c:	8b ad       	ldd	r24, Y+59	; 0x3b
    846e:	9c ad       	ldd	r25, Y+60	; 0x3c
    8470:	01 97       	sbiw	r24, 0x01	; 1
    8472:	f1 f7       	brne	.-4      	; 0x8470 <LCD_sendCommand+0x466>
    8474:	9c af       	std	Y+60, r25	; 0x3c
    8476:	8b af       	std	Y+59, r24	; 0x3b
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    8478:	8d ad       	ldd	r24, Y+61	; 0x3d
    847a:	9e ad       	ldd	r25, Y+62	; 0x3e
    847c:	01 97       	sbiw	r24, 0x01	; 1
    847e:	9e af       	std	Y+62, r25	; 0x3e
    8480:	8d af       	std	Y+61, r24	; 0x3d
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    8482:	8d ad       	ldd	r24, Y+61	; 0x3d
    8484:	9e ad       	ldd	r25, Y+62	; 0x3e
    8486:	00 97       	sbiw	r24, 0x00	; 0
    8488:	69 f7       	brne	.-38     	; 0x8464 <LCD_sendCommand+0x45a>
    848a:	16 c0       	rjmp	.+44     	; 0x84b8 <LCD_sendCommand+0x4ae>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    848c:	fe 01       	movw	r30, r28
    848e:	ff 96       	adiw	r30, 0x3f	; 63
    8490:	60 81       	ld	r22, Z
    8492:	71 81       	ldd	r23, Z+1	; 0x01
    8494:	82 81       	ldd	r24, Z+2	; 0x02
    8496:	93 81       	ldd	r25, Z+3	; 0x03
    8498:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    849c:	dc 01       	movw	r26, r24
    849e:	cb 01       	movw	r24, r22
    84a0:	9e af       	std	Y+62, r25	; 0x3e
    84a2:	8d af       	std	Y+61, r24	; 0x3d
    84a4:	8d ad       	ldd	r24, Y+61	; 0x3d
    84a6:	9e ad       	ldd	r25, Y+62	; 0x3e
    84a8:	9a af       	std	Y+58, r25	; 0x3a
    84aa:	89 af       	std	Y+57, r24	; 0x39
    84ac:	89 ad       	ldd	r24, Y+57	; 0x39
    84ae:	9a ad       	ldd	r25, Y+58	; 0x3a
    84b0:	01 97       	sbiw	r24, 0x01	; 1
    84b2:	f1 f7       	brne	.-4      	; 0x84b0 <LCD_sendCommand+0x4a6>
    84b4:	9a af       	std	Y+58, r25	; 0x3a
    84b6:	89 af       	std	Y+57, r24	; 0x39

	_delay_ms(1); /* delay for processing Tdsw = 100ns */
	GPIO_writePin(LCD_E_PORT_ID,LCD_E_PIN_ID,LOGIC_LOW); /* Disable LCD E=0 */
    84b8:	83 e0       	ldi	r24, 0x03	; 3
    84ba:	62 e0       	ldi	r22, 0x02	; 2
    84bc:	40 e0       	ldi	r20, 0x00	; 0
    84be:	0e 94 9f 3b 	call	0x773e	; 0x773e <GPIO_writePin>
    84c2:	80 e0       	ldi	r24, 0x00	; 0
    84c4:	90 e0       	ldi	r25, 0x00	; 0
    84c6:	a0 e8       	ldi	r26, 0x80	; 128
    84c8:	bf e3       	ldi	r27, 0x3F	; 63
    84ca:	8d ab       	std	Y+53, r24	; 0x35
    84cc:	9e ab       	std	Y+54, r25	; 0x36
    84ce:	af ab       	std	Y+55, r26	; 0x37
    84d0:	b8 af       	std	Y+56, r27	; 0x38
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    84d2:	6d a9       	ldd	r22, Y+53	; 0x35
    84d4:	7e a9       	ldd	r23, Y+54	; 0x36
    84d6:	8f a9       	ldd	r24, Y+55	; 0x37
    84d8:	98 ad       	ldd	r25, Y+56	; 0x38
    84da:	20 e0       	ldi	r18, 0x00	; 0
    84dc:	30 e0       	ldi	r19, 0x00	; 0
    84de:	4a e7       	ldi	r20, 0x7A	; 122
    84e0:	53 e4       	ldi	r21, 0x43	; 67
    84e2:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    84e6:	dc 01       	movw	r26, r24
    84e8:	cb 01       	movw	r24, r22
    84ea:	89 ab       	std	Y+49, r24	; 0x31
    84ec:	9a ab       	std	Y+50, r25	; 0x32
    84ee:	ab ab       	std	Y+51, r26	; 0x33
    84f0:	bc ab       	std	Y+52, r27	; 0x34
	if (__tmp < 1.0)
    84f2:	69 a9       	ldd	r22, Y+49	; 0x31
    84f4:	7a a9       	ldd	r23, Y+50	; 0x32
    84f6:	8b a9       	ldd	r24, Y+51	; 0x33
    84f8:	9c a9       	ldd	r25, Y+52	; 0x34
    84fa:	20 e0       	ldi	r18, 0x00	; 0
    84fc:	30 e0       	ldi	r19, 0x00	; 0
    84fe:	40 e8       	ldi	r20, 0x80	; 128
    8500:	5f e3       	ldi	r21, 0x3F	; 63
    8502:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    8506:	88 23       	and	r24, r24
    8508:	2c f4       	brge	.+10     	; 0x8514 <LCD_sendCommand+0x50a>
		__ticks = 1;
    850a:	81 e0       	ldi	r24, 0x01	; 1
    850c:	90 e0       	ldi	r25, 0x00	; 0
    850e:	98 ab       	std	Y+48, r25	; 0x30
    8510:	8f a7       	std	Y+47, r24	; 0x2f
    8512:	3f c0       	rjmp	.+126    	; 0x8592 <LCD_sendCommand+0x588>
	else if (__tmp > 65535)
    8514:	69 a9       	ldd	r22, Y+49	; 0x31
    8516:	7a a9       	ldd	r23, Y+50	; 0x32
    8518:	8b a9       	ldd	r24, Y+51	; 0x33
    851a:	9c a9       	ldd	r25, Y+52	; 0x34
    851c:	20 e0       	ldi	r18, 0x00	; 0
    851e:	3f ef       	ldi	r19, 0xFF	; 255
    8520:	4f e7       	ldi	r20, 0x7F	; 127
    8522:	57 e4       	ldi	r21, 0x47	; 71
    8524:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    8528:	18 16       	cp	r1, r24
    852a:	4c f5       	brge	.+82     	; 0x857e <LCD_sendCommand+0x574>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    852c:	6d a9       	ldd	r22, Y+53	; 0x35
    852e:	7e a9       	ldd	r23, Y+54	; 0x36
    8530:	8f a9       	ldd	r24, Y+55	; 0x37
    8532:	98 ad       	ldd	r25, Y+56	; 0x38
    8534:	20 e0       	ldi	r18, 0x00	; 0
    8536:	30 e0       	ldi	r19, 0x00	; 0
    8538:	40 e2       	ldi	r20, 0x20	; 32
    853a:	51 e4       	ldi	r21, 0x41	; 65
    853c:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    8540:	dc 01       	movw	r26, r24
    8542:	cb 01       	movw	r24, r22
    8544:	bc 01       	movw	r22, r24
    8546:	cd 01       	movw	r24, r26
    8548:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    854c:	dc 01       	movw	r26, r24
    854e:	cb 01       	movw	r24, r22
    8550:	98 ab       	std	Y+48, r25	; 0x30
    8552:	8f a7       	std	Y+47, r24	; 0x2f
    8554:	0f c0       	rjmp	.+30     	; 0x8574 <LCD_sendCommand+0x56a>
    8556:	89 e1       	ldi	r24, 0x19	; 25
    8558:	90 e0       	ldi	r25, 0x00	; 0
    855a:	9e a7       	std	Y+46, r25	; 0x2e
    855c:	8d a7       	std	Y+45, r24	; 0x2d
    855e:	8d a5       	ldd	r24, Y+45	; 0x2d
    8560:	9e a5       	ldd	r25, Y+46	; 0x2e
    8562:	01 97       	sbiw	r24, 0x01	; 1
    8564:	f1 f7       	brne	.-4      	; 0x8562 <LCD_sendCommand+0x558>
    8566:	9e a7       	std	Y+46, r25	; 0x2e
    8568:	8d a7       	std	Y+45, r24	; 0x2d
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    856a:	8f a5       	ldd	r24, Y+47	; 0x2f
    856c:	98 a9       	ldd	r25, Y+48	; 0x30
    856e:	01 97       	sbiw	r24, 0x01	; 1
    8570:	98 ab       	std	Y+48, r25	; 0x30
    8572:	8f a7       	std	Y+47, r24	; 0x2f
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    8574:	8f a5       	ldd	r24, Y+47	; 0x2f
    8576:	98 a9       	ldd	r25, Y+48	; 0x30
    8578:	00 97       	sbiw	r24, 0x00	; 0
    857a:	69 f7       	brne	.-38     	; 0x8556 <LCD_sendCommand+0x54c>
    857c:	14 c0       	rjmp	.+40     	; 0x85a6 <LCD_sendCommand+0x59c>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    857e:	69 a9       	ldd	r22, Y+49	; 0x31
    8580:	7a a9       	ldd	r23, Y+50	; 0x32
    8582:	8b a9       	ldd	r24, Y+51	; 0x33
    8584:	9c a9       	ldd	r25, Y+52	; 0x34
    8586:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    858a:	dc 01       	movw	r26, r24
    858c:	cb 01       	movw	r24, r22
    858e:	98 ab       	std	Y+48, r25	; 0x30
    8590:	8f a7       	std	Y+47, r24	; 0x2f
    8592:	8f a5       	ldd	r24, Y+47	; 0x2f
    8594:	98 a9       	ldd	r25, Y+48	; 0x30
    8596:	9c a7       	std	Y+44, r25	; 0x2c
    8598:	8b a7       	std	Y+43, r24	; 0x2b
    859a:	8b a5       	ldd	r24, Y+43	; 0x2b
    859c:	9c a5       	ldd	r25, Y+44	; 0x2c
    859e:	01 97       	sbiw	r24, 0x01	; 1
    85a0:	f1 f7       	brne	.-4      	; 0x859e <LCD_sendCommand+0x594>
    85a2:	9c a7       	std	Y+44, r25	; 0x2c
    85a4:	8b a7       	std	Y+43, r24	; 0x2b
	_delay_ms(1); /* delay for processing Th = 13ns */
	GPIO_writePin(LCD_E_PORT_ID,LCD_E_PIN_ID,LOGIC_HIGH); /* Enable LCD E=1 */
    85a6:	83 e0       	ldi	r24, 0x03	; 3
    85a8:	62 e0       	ldi	r22, 0x02	; 2
    85aa:	41 e0       	ldi	r20, 0x01	; 1
    85ac:	0e 94 9f 3b 	call	0x773e	; 0x773e <GPIO_writePin>
    85b0:	80 e0       	ldi	r24, 0x00	; 0
    85b2:	90 e0       	ldi	r25, 0x00	; 0
    85b4:	a0 e8       	ldi	r26, 0x80	; 128
    85b6:	bf e3       	ldi	r27, 0x3F	; 63
    85b8:	8f a3       	std	Y+39, r24	; 0x27
    85ba:	98 a7       	std	Y+40, r25	; 0x28
    85bc:	a9 a7       	std	Y+41, r26	; 0x29
    85be:	ba a7       	std	Y+42, r27	; 0x2a
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    85c0:	6f a1       	ldd	r22, Y+39	; 0x27
    85c2:	78 a5       	ldd	r23, Y+40	; 0x28
    85c4:	89 a5       	ldd	r24, Y+41	; 0x29
    85c6:	9a a5       	ldd	r25, Y+42	; 0x2a
    85c8:	20 e0       	ldi	r18, 0x00	; 0
    85ca:	30 e0       	ldi	r19, 0x00	; 0
    85cc:	4a e7       	ldi	r20, 0x7A	; 122
    85ce:	53 e4       	ldi	r21, 0x43	; 67
    85d0:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    85d4:	dc 01       	movw	r26, r24
    85d6:	cb 01       	movw	r24, r22
    85d8:	8b a3       	std	Y+35, r24	; 0x23
    85da:	9c a3       	std	Y+36, r25	; 0x24
    85dc:	ad a3       	std	Y+37, r26	; 0x25
    85de:	be a3       	std	Y+38, r27	; 0x26
	if (__tmp < 1.0)
    85e0:	6b a1       	ldd	r22, Y+35	; 0x23
    85e2:	7c a1       	ldd	r23, Y+36	; 0x24
    85e4:	8d a1       	ldd	r24, Y+37	; 0x25
    85e6:	9e a1       	ldd	r25, Y+38	; 0x26
    85e8:	20 e0       	ldi	r18, 0x00	; 0
    85ea:	30 e0       	ldi	r19, 0x00	; 0
    85ec:	40 e8       	ldi	r20, 0x80	; 128
    85ee:	5f e3       	ldi	r21, 0x3F	; 63
    85f0:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    85f4:	88 23       	and	r24, r24
    85f6:	2c f4       	brge	.+10     	; 0x8602 <LCD_sendCommand+0x5f8>
		__ticks = 1;
    85f8:	81 e0       	ldi	r24, 0x01	; 1
    85fa:	90 e0       	ldi	r25, 0x00	; 0
    85fc:	9a a3       	std	Y+34, r25	; 0x22
    85fe:	89 a3       	std	Y+33, r24	; 0x21
    8600:	3f c0       	rjmp	.+126    	; 0x8680 <LCD_sendCommand+0x676>
	else if (__tmp > 65535)
    8602:	6b a1       	ldd	r22, Y+35	; 0x23
    8604:	7c a1       	ldd	r23, Y+36	; 0x24
    8606:	8d a1       	ldd	r24, Y+37	; 0x25
    8608:	9e a1       	ldd	r25, Y+38	; 0x26
    860a:	20 e0       	ldi	r18, 0x00	; 0
    860c:	3f ef       	ldi	r19, 0xFF	; 255
    860e:	4f e7       	ldi	r20, 0x7F	; 127
    8610:	57 e4       	ldi	r21, 0x47	; 71
    8612:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    8616:	18 16       	cp	r1, r24
    8618:	4c f5       	brge	.+82     	; 0x866c <LCD_sendCommand+0x662>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    861a:	6f a1       	ldd	r22, Y+39	; 0x27
    861c:	78 a5       	ldd	r23, Y+40	; 0x28
    861e:	89 a5       	ldd	r24, Y+41	; 0x29
    8620:	9a a5       	ldd	r25, Y+42	; 0x2a
    8622:	20 e0       	ldi	r18, 0x00	; 0
    8624:	30 e0       	ldi	r19, 0x00	; 0
    8626:	40 e2       	ldi	r20, 0x20	; 32
    8628:	51 e4       	ldi	r21, 0x41	; 65
    862a:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    862e:	dc 01       	movw	r26, r24
    8630:	cb 01       	movw	r24, r22
    8632:	bc 01       	movw	r22, r24
    8634:	cd 01       	movw	r24, r26
    8636:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    863a:	dc 01       	movw	r26, r24
    863c:	cb 01       	movw	r24, r22
    863e:	9a a3       	std	Y+34, r25	; 0x22
    8640:	89 a3       	std	Y+33, r24	; 0x21
    8642:	0f c0       	rjmp	.+30     	; 0x8662 <LCD_sendCommand+0x658>
    8644:	89 e1       	ldi	r24, 0x19	; 25
    8646:	90 e0       	ldi	r25, 0x00	; 0
    8648:	98 a3       	std	Y+32, r25	; 0x20
    864a:	8f 8f       	std	Y+31, r24	; 0x1f
    864c:	8f 8d       	ldd	r24, Y+31	; 0x1f
    864e:	98 a1       	ldd	r25, Y+32	; 0x20
    8650:	01 97       	sbiw	r24, 0x01	; 1
    8652:	f1 f7       	brne	.-4      	; 0x8650 <LCD_sendCommand+0x646>
    8654:	98 a3       	std	Y+32, r25	; 0x20
    8656:	8f 8f       	std	Y+31, r24	; 0x1f
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    8658:	89 a1       	ldd	r24, Y+33	; 0x21
    865a:	9a a1       	ldd	r25, Y+34	; 0x22
    865c:	01 97       	sbiw	r24, 0x01	; 1
    865e:	9a a3       	std	Y+34, r25	; 0x22
    8660:	89 a3       	std	Y+33, r24	; 0x21
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    8662:	89 a1       	ldd	r24, Y+33	; 0x21
    8664:	9a a1       	ldd	r25, Y+34	; 0x22
    8666:	00 97       	sbiw	r24, 0x00	; 0
    8668:	69 f7       	brne	.-38     	; 0x8644 <LCD_sendCommand+0x63a>
    866a:	14 c0       	rjmp	.+40     	; 0x8694 <LCD_sendCommand+0x68a>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    866c:	6b a1       	ldd	r22, Y+35	; 0x23
    866e:	7c a1       	ldd	r23, Y+36	; 0x24
    8670:	8d a1       	ldd	r24, Y+37	; 0x25
    8672:	9e a1       	ldd	r25, Y+38	; 0x26
    8674:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    8678:	dc 01       	movw	r26, r24
    867a:	cb 01       	movw	r24, r22
    867c:	9a a3       	std	Y+34, r25	; 0x22
    867e:	89 a3       	std	Y+33, r24	; 0x21
    8680:	89 a1       	ldd	r24, Y+33	; 0x21
    8682:	9a a1       	ldd	r25, Y+34	; 0x22
    8684:	9e 8f       	std	Y+30, r25	; 0x1e
    8686:	8d 8f       	std	Y+29, r24	; 0x1d
    8688:	8d 8d       	ldd	r24, Y+29	; 0x1d
    868a:	9e 8d       	ldd	r25, Y+30	; 0x1e
    868c:	01 97       	sbiw	r24, 0x01	; 1
    868e:	f1 f7       	brne	.-4      	; 0x868c <LCD_sendCommand+0x682>
    8690:	9e 8f       	std	Y+30, r25	; 0x1e
    8692:	8d 8f       	std	Y+29, r24	; 0x1d
	_delay_ms(1); /* delay for processing Tpw - Tdws = 190ns */

	GPIO_writePin(LCD_DATA_PORT_ID,LCD_DB4_PIN_ID,GET_BIT(command,0));
    8694:	fe 01       	movw	r30, r28
    8696:	ed 59       	subi	r30, 0x9D	; 157
    8698:	ff 4f       	sbci	r31, 0xFF	; 255
    869a:	80 81       	ld	r24, Z
    869c:	98 2f       	mov	r25, r24
    869e:	91 70       	andi	r25, 0x01	; 1
    86a0:	83 e0       	ldi	r24, 0x03	; 3
    86a2:	64 e0       	ldi	r22, 0x04	; 4
    86a4:	49 2f       	mov	r20, r25
    86a6:	0e 94 9f 3b 	call	0x773e	; 0x773e <GPIO_writePin>
	GPIO_writePin(LCD_DATA_PORT_ID,LCD_DB5_PIN_ID,GET_BIT(command,1));
    86aa:	fe 01       	movw	r30, r28
    86ac:	ed 59       	subi	r30, 0x9D	; 157
    86ae:	ff 4f       	sbci	r31, 0xFF	; 255
    86b0:	80 81       	ld	r24, Z
    86b2:	88 2f       	mov	r24, r24
    86b4:	90 e0       	ldi	r25, 0x00	; 0
    86b6:	82 70       	andi	r24, 0x02	; 2
    86b8:	90 70       	andi	r25, 0x00	; 0
    86ba:	95 95       	asr	r25
    86bc:	87 95       	ror	r24
    86be:	98 2f       	mov	r25, r24
    86c0:	83 e0       	ldi	r24, 0x03	; 3
    86c2:	65 e0       	ldi	r22, 0x05	; 5
    86c4:	49 2f       	mov	r20, r25
    86c6:	0e 94 9f 3b 	call	0x773e	; 0x773e <GPIO_writePin>
	GPIO_writePin(LCD_DATA_PORT_ID,LCD_DB6_PIN_ID,GET_BIT(command,2));
    86ca:	fe 01       	movw	r30, r28
    86cc:	ed 59       	subi	r30, 0x9D	; 157
    86ce:	ff 4f       	sbci	r31, 0xFF	; 255
    86d0:	80 81       	ld	r24, Z
    86d2:	88 2f       	mov	r24, r24
    86d4:	90 e0       	ldi	r25, 0x00	; 0
    86d6:	84 70       	andi	r24, 0x04	; 4
    86d8:	90 70       	andi	r25, 0x00	; 0
    86da:	95 95       	asr	r25
    86dc:	87 95       	ror	r24
    86de:	95 95       	asr	r25
    86e0:	87 95       	ror	r24
    86e2:	98 2f       	mov	r25, r24
    86e4:	83 e0       	ldi	r24, 0x03	; 3
    86e6:	66 e0       	ldi	r22, 0x06	; 6
    86e8:	49 2f       	mov	r20, r25
    86ea:	0e 94 9f 3b 	call	0x773e	; 0x773e <GPIO_writePin>
	GPIO_writePin(LCD_DATA_PORT_ID,LCD_DB7_PIN_ID,GET_BIT(command,3));
    86ee:	fe 01       	movw	r30, r28
    86f0:	ed 59       	subi	r30, 0x9D	; 157
    86f2:	ff 4f       	sbci	r31, 0xFF	; 255
    86f4:	80 81       	ld	r24, Z
    86f6:	88 2f       	mov	r24, r24
    86f8:	90 e0       	ldi	r25, 0x00	; 0
    86fa:	88 70       	andi	r24, 0x08	; 8
    86fc:	90 70       	andi	r25, 0x00	; 0
    86fe:	95 95       	asr	r25
    8700:	87 95       	ror	r24
    8702:	95 95       	asr	r25
    8704:	87 95       	ror	r24
    8706:	95 95       	asr	r25
    8708:	87 95       	ror	r24
    870a:	98 2f       	mov	r25, r24
    870c:	83 e0       	ldi	r24, 0x03	; 3
    870e:	67 e0       	ldi	r22, 0x07	; 7
    8710:	49 2f       	mov	r20, r25
    8712:	0e 94 9f 3b 	call	0x773e	; 0x773e <GPIO_writePin>
    8716:	80 e0       	ldi	r24, 0x00	; 0
    8718:	90 e0       	ldi	r25, 0x00	; 0
    871a:	a0 e8       	ldi	r26, 0x80	; 128
    871c:	bf e3       	ldi	r27, 0x3F	; 63
    871e:	89 8f       	std	Y+25, r24	; 0x19
    8720:	9a 8f       	std	Y+26, r25	; 0x1a
    8722:	ab 8f       	std	Y+27, r26	; 0x1b
    8724:	bc 8f       	std	Y+28, r27	; 0x1c
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    8726:	69 8d       	ldd	r22, Y+25	; 0x19
    8728:	7a 8d       	ldd	r23, Y+26	; 0x1a
    872a:	8b 8d       	ldd	r24, Y+27	; 0x1b
    872c:	9c 8d       	ldd	r25, Y+28	; 0x1c
    872e:	20 e0       	ldi	r18, 0x00	; 0
    8730:	30 e0       	ldi	r19, 0x00	; 0
    8732:	4a e7       	ldi	r20, 0x7A	; 122
    8734:	53 e4       	ldi	r21, 0x43	; 67
    8736:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    873a:	dc 01       	movw	r26, r24
    873c:	cb 01       	movw	r24, r22
    873e:	8d 8b       	std	Y+21, r24	; 0x15
    8740:	9e 8b       	std	Y+22, r25	; 0x16
    8742:	af 8b       	std	Y+23, r26	; 0x17
    8744:	b8 8f       	std	Y+24, r27	; 0x18
	if (__tmp < 1.0)
    8746:	6d 89       	ldd	r22, Y+21	; 0x15
    8748:	7e 89       	ldd	r23, Y+22	; 0x16
    874a:	8f 89       	ldd	r24, Y+23	; 0x17
    874c:	98 8d       	ldd	r25, Y+24	; 0x18
    874e:	20 e0       	ldi	r18, 0x00	; 0
    8750:	30 e0       	ldi	r19, 0x00	; 0
    8752:	40 e8       	ldi	r20, 0x80	; 128
    8754:	5f e3       	ldi	r21, 0x3F	; 63
    8756:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    875a:	88 23       	and	r24, r24
    875c:	2c f4       	brge	.+10     	; 0x8768 <LCD_sendCommand+0x75e>
		__ticks = 1;
    875e:	81 e0       	ldi	r24, 0x01	; 1
    8760:	90 e0       	ldi	r25, 0x00	; 0
    8762:	9c 8b       	std	Y+20, r25	; 0x14
    8764:	8b 8b       	std	Y+19, r24	; 0x13
    8766:	3f c0       	rjmp	.+126    	; 0x87e6 <LCD_sendCommand+0x7dc>
	else if (__tmp > 65535)
    8768:	6d 89       	ldd	r22, Y+21	; 0x15
    876a:	7e 89       	ldd	r23, Y+22	; 0x16
    876c:	8f 89       	ldd	r24, Y+23	; 0x17
    876e:	98 8d       	ldd	r25, Y+24	; 0x18
    8770:	20 e0       	ldi	r18, 0x00	; 0
    8772:	3f ef       	ldi	r19, 0xFF	; 255
    8774:	4f e7       	ldi	r20, 0x7F	; 127
    8776:	57 e4       	ldi	r21, 0x47	; 71
    8778:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    877c:	18 16       	cp	r1, r24
    877e:	4c f5       	brge	.+82     	; 0x87d2 <LCD_sendCommand+0x7c8>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    8780:	69 8d       	ldd	r22, Y+25	; 0x19
    8782:	7a 8d       	ldd	r23, Y+26	; 0x1a
    8784:	8b 8d       	ldd	r24, Y+27	; 0x1b
    8786:	9c 8d       	ldd	r25, Y+28	; 0x1c
    8788:	20 e0       	ldi	r18, 0x00	; 0
    878a:	30 e0       	ldi	r19, 0x00	; 0
    878c:	40 e2       	ldi	r20, 0x20	; 32
    878e:	51 e4       	ldi	r21, 0x41	; 65
    8790:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    8794:	dc 01       	movw	r26, r24
    8796:	cb 01       	movw	r24, r22
    8798:	bc 01       	movw	r22, r24
    879a:	cd 01       	movw	r24, r26
    879c:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    87a0:	dc 01       	movw	r26, r24
    87a2:	cb 01       	movw	r24, r22
    87a4:	9c 8b       	std	Y+20, r25	; 0x14
    87a6:	8b 8b       	std	Y+19, r24	; 0x13
    87a8:	0f c0       	rjmp	.+30     	; 0x87c8 <LCD_sendCommand+0x7be>
    87aa:	89 e1       	ldi	r24, 0x19	; 25
    87ac:	90 e0       	ldi	r25, 0x00	; 0
    87ae:	9a 8b       	std	Y+18, r25	; 0x12
    87b0:	89 8b       	std	Y+17, r24	; 0x11
    87b2:	89 89       	ldd	r24, Y+17	; 0x11
    87b4:	9a 89       	ldd	r25, Y+18	; 0x12
    87b6:	01 97       	sbiw	r24, 0x01	; 1
    87b8:	f1 f7       	brne	.-4      	; 0x87b6 <LCD_sendCommand+0x7ac>
    87ba:	9a 8b       	std	Y+18, r25	; 0x12
    87bc:	89 8b       	std	Y+17, r24	; 0x11
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    87be:	8b 89       	ldd	r24, Y+19	; 0x13
    87c0:	9c 89       	ldd	r25, Y+20	; 0x14
    87c2:	01 97       	sbiw	r24, 0x01	; 1
    87c4:	9c 8b       	std	Y+20, r25	; 0x14
    87c6:	8b 8b       	std	Y+19, r24	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    87c8:	8b 89       	ldd	r24, Y+19	; 0x13
    87ca:	9c 89       	ldd	r25, Y+20	; 0x14
    87cc:	00 97       	sbiw	r24, 0x00	; 0
    87ce:	69 f7       	brne	.-38     	; 0x87aa <LCD_sendCommand+0x7a0>
    87d0:	14 c0       	rjmp	.+40     	; 0x87fa <LCD_sendCommand+0x7f0>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    87d2:	6d 89       	ldd	r22, Y+21	; 0x15
    87d4:	7e 89       	ldd	r23, Y+22	; 0x16
    87d6:	8f 89       	ldd	r24, Y+23	; 0x17
    87d8:	98 8d       	ldd	r25, Y+24	; 0x18
    87da:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    87de:	dc 01       	movw	r26, r24
    87e0:	cb 01       	movw	r24, r22
    87e2:	9c 8b       	std	Y+20, r25	; 0x14
    87e4:	8b 8b       	std	Y+19, r24	; 0x13
    87e6:	8b 89       	ldd	r24, Y+19	; 0x13
    87e8:	9c 89       	ldd	r25, Y+20	; 0x14
    87ea:	98 8b       	std	Y+16, r25	; 0x10
    87ec:	8f 87       	std	Y+15, r24	; 0x0f
    87ee:	8f 85       	ldd	r24, Y+15	; 0x0f
    87f0:	98 89       	ldd	r25, Y+16	; 0x10
    87f2:	01 97       	sbiw	r24, 0x01	; 1
    87f4:	f1 f7       	brne	.-4      	; 0x87f2 <LCD_sendCommand+0x7e8>
    87f6:	98 8b       	std	Y+16, r25	; 0x10
    87f8:	8f 87       	std	Y+15, r24	; 0x0f

	_delay_ms(1); /* delay for processing Tdsw = 100ns */
	GPIO_writePin(LCD_E_PORT_ID,LCD_E_PIN_ID,LOGIC_LOW); /* Disable LCD E=0 */
    87fa:	83 e0       	ldi	r24, 0x03	; 3
    87fc:	62 e0       	ldi	r22, 0x02	; 2
    87fe:	40 e0       	ldi	r20, 0x00	; 0
    8800:	0e 94 9f 3b 	call	0x773e	; 0x773e <GPIO_writePin>
    8804:	80 e0       	ldi	r24, 0x00	; 0
    8806:	90 e0       	ldi	r25, 0x00	; 0
    8808:	a0 e8       	ldi	r26, 0x80	; 128
    880a:	bf e3       	ldi	r27, 0x3F	; 63
    880c:	8b 87       	std	Y+11, r24	; 0x0b
    880e:	9c 87       	std	Y+12, r25	; 0x0c
    8810:	ad 87       	std	Y+13, r26	; 0x0d
    8812:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    8814:	6b 85       	ldd	r22, Y+11	; 0x0b
    8816:	7c 85       	ldd	r23, Y+12	; 0x0c
    8818:	8d 85       	ldd	r24, Y+13	; 0x0d
    881a:	9e 85       	ldd	r25, Y+14	; 0x0e
    881c:	20 e0       	ldi	r18, 0x00	; 0
    881e:	30 e0       	ldi	r19, 0x00	; 0
    8820:	4a e7       	ldi	r20, 0x7A	; 122
    8822:	53 e4       	ldi	r21, 0x43	; 67
    8824:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    8828:	dc 01       	movw	r26, r24
    882a:	cb 01       	movw	r24, r22
    882c:	8f 83       	std	Y+7, r24	; 0x07
    882e:	98 87       	std	Y+8, r25	; 0x08
    8830:	a9 87       	std	Y+9, r26	; 0x09
    8832:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    8834:	6f 81       	ldd	r22, Y+7	; 0x07
    8836:	78 85       	ldd	r23, Y+8	; 0x08
    8838:	89 85       	ldd	r24, Y+9	; 0x09
    883a:	9a 85       	ldd	r25, Y+10	; 0x0a
    883c:	20 e0       	ldi	r18, 0x00	; 0
    883e:	30 e0       	ldi	r19, 0x00	; 0
    8840:	40 e8       	ldi	r20, 0x80	; 128
    8842:	5f e3       	ldi	r21, 0x3F	; 63
    8844:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    8848:	88 23       	and	r24, r24
    884a:	2c f4       	brge	.+10     	; 0x8856 <LCD_sendCommand+0x84c>
		__ticks = 1;
    884c:	81 e0       	ldi	r24, 0x01	; 1
    884e:	90 e0       	ldi	r25, 0x00	; 0
    8850:	9e 83       	std	Y+6, r25	; 0x06
    8852:	8d 83       	std	Y+5, r24	; 0x05
    8854:	3f c0       	rjmp	.+126    	; 0x88d4 <LCD_sendCommand+0x8ca>
	else if (__tmp > 65535)
    8856:	6f 81       	ldd	r22, Y+7	; 0x07
    8858:	78 85       	ldd	r23, Y+8	; 0x08
    885a:	89 85       	ldd	r24, Y+9	; 0x09
    885c:	9a 85       	ldd	r25, Y+10	; 0x0a
    885e:	20 e0       	ldi	r18, 0x00	; 0
    8860:	3f ef       	ldi	r19, 0xFF	; 255
    8862:	4f e7       	ldi	r20, 0x7F	; 127
    8864:	57 e4       	ldi	r21, 0x47	; 71
    8866:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    886a:	18 16       	cp	r1, r24
    886c:	4c f5       	brge	.+82     	; 0x88c0 <LCD_sendCommand+0x8b6>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    886e:	6b 85       	ldd	r22, Y+11	; 0x0b
    8870:	7c 85       	ldd	r23, Y+12	; 0x0c
    8872:	8d 85       	ldd	r24, Y+13	; 0x0d
    8874:	9e 85       	ldd	r25, Y+14	; 0x0e
    8876:	20 e0       	ldi	r18, 0x00	; 0
    8878:	30 e0       	ldi	r19, 0x00	; 0
    887a:	40 e2       	ldi	r20, 0x20	; 32
    887c:	51 e4       	ldi	r21, 0x41	; 65
    887e:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    8882:	dc 01       	movw	r26, r24
    8884:	cb 01       	movw	r24, r22
    8886:	bc 01       	movw	r22, r24
    8888:	cd 01       	movw	r24, r26
    888a:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    888e:	dc 01       	movw	r26, r24
    8890:	cb 01       	movw	r24, r22
    8892:	9e 83       	std	Y+6, r25	; 0x06
    8894:	8d 83       	std	Y+5, r24	; 0x05
    8896:	0f c0       	rjmp	.+30     	; 0x88b6 <LCD_sendCommand+0x8ac>
    8898:	89 e1       	ldi	r24, 0x19	; 25
    889a:	90 e0       	ldi	r25, 0x00	; 0
    889c:	9c 83       	std	Y+4, r25	; 0x04
    889e:	8b 83       	std	Y+3, r24	; 0x03
    88a0:	8b 81       	ldd	r24, Y+3	; 0x03
    88a2:	9c 81       	ldd	r25, Y+4	; 0x04
    88a4:	01 97       	sbiw	r24, 0x01	; 1
    88a6:	f1 f7       	brne	.-4      	; 0x88a4 <LCD_sendCommand+0x89a>
    88a8:	9c 83       	std	Y+4, r25	; 0x04
    88aa:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    88ac:	8d 81       	ldd	r24, Y+5	; 0x05
    88ae:	9e 81       	ldd	r25, Y+6	; 0x06
    88b0:	01 97       	sbiw	r24, 0x01	; 1
    88b2:	9e 83       	std	Y+6, r25	; 0x06
    88b4:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    88b6:	8d 81       	ldd	r24, Y+5	; 0x05
    88b8:	9e 81       	ldd	r25, Y+6	; 0x06
    88ba:	00 97       	sbiw	r24, 0x00	; 0
    88bc:	69 f7       	brne	.-38     	; 0x8898 <LCD_sendCommand+0x88e>
    88be:	14 c0       	rjmp	.+40     	; 0x88e8 <LCD_sendCommand+0x8de>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    88c0:	6f 81       	ldd	r22, Y+7	; 0x07
    88c2:	78 85       	ldd	r23, Y+8	; 0x08
    88c4:	89 85       	ldd	r24, Y+9	; 0x09
    88c6:	9a 85       	ldd	r25, Y+10	; 0x0a
    88c8:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    88cc:	dc 01       	movw	r26, r24
    88ce:	cb 01       	movw	r24, r22
    88d0:	9e 83       	std	Y+6, r25	; 0x06
    88d2:	8d 83       	std	Y+5, r24	; 0x05
    88d4:	8d 81       	ldd	r24, Y+5	; 0x05
    88d6:	9e 81       	ldd	r25, Y+6	; 0x06
    88d8:	9a 83       	std	Y+2, r25	; 0x02
    88da:	89 83       	std	Y+1, r24	; 0x01
    88dc:	89 81       	ldd	r24, Y+1	; 0x01
    88de:	9a 81       	ldd	r25, Y+2	; 0x02
    88e0:	01 97       	sbiw	r24, 0x01	; 1
    88e2:	f1 f7       	brne	.-4      	; 0x88e0 <LCD_sendCommand+0x8d6>
    88e4:	9a 83       	std	Y+2, r25	; 0x02
    88e6:	89 83       	std	Y+1, r24	; 0x01
	GPIO_writePort(LCD_DATA_PORT_ID,command); /* out the required command to the data bus D0 --> D7 */
	_delay_ms(1); /* delay for processing Tdsw = 100ns */
	GPIO_writePin(LCD_E_PORT_ID,LCD_E_PIN_ID,LOGIC_LOW); /* Disable LCD E=0 */
	_delay_ms(1); /* delay for processing Th = 13ns */
#endif
}
    88e8:	cd 59       	subi	r28, 0x9D	; 157
    88ea:	df 4f       	sbci	r29, 0xFF	; 255
    88ec:	0f b6       	in	r0, 0x3f	; 63
    88ee:	f8 94       	cli
    88f0:	de bf       	out	0x3e, r29	; 62
    88f2:	0f be       	out	0x3f, r0	; 63
    88f4:	cd bf       	out	0x3d, r28	; 61
    88f6:	cf 91       	pop	r28
    88f8:	df 91       	pop	r29
    88fa:	1f 91       	pop	r17
    88fc:	0f 91       	pop	r16
    88fe:	08 95       	ret

00008900 <LCD_displayCharacter>:
/*
 * Description :
 * Display the required character on the screen
 */
void LCD_displayCharacter(uint8 data)
{
    8900:	0f 93       	push	r16
    8902:	1f 93       	push	r17
    8904:	df 93       	push	r29
    8906:	cf 93       	push	r28
    8908:	cd b7       	in	r28, 0x3d	; 61
    890a:	de b7       	in	r29, 0x3e	; 62
    890c:	c3 56       	subi	r28, 0x63	; 99
    890e:	d0 40       	sbci	r29, 0x00	; 0
    8910:	0f b6       	in	r0, 0x3f	; 63
    8912:	f8 94       	cli
    8914:	de bf       	out	0x3e, r29	; 62
    8916:	0f be       	out	0x3f, r0	; 63
    8918:	cd bf       	out	0x3d, r28	; 61
    891a:	fe 01       	movw	r30, r28
    891c:	ed 59       	subi	r30, 0x9D	; 157
    891e:	ff 4f       	sbci	r31, 0xFF	; 255
    8920:	80 83       	st	Z, r24
	GPIO_writePin(LCD_RS_PORT_ID,LCD_RS_PIN_ID,LOGIC_HIGH); /* Data Mode RS=1 */
    8922:	83 e0       	ldi	r24, 0x03	; 3
    8924:	60 e0       	ldi	r22, 0x00	; 0
    8926:	41 e0       	ldi	r20, 0x01	; 1
    8928:	0e 94 9f 3b 	call	0x773e	; 0x773e <GPIO_writePin>
    892c:	fe 01       	movw	r30, r28
    892e:	e1 5a       	subi	r30, 0xA1	; 161
    8930:	ff 4f       	sbci	r31, 0xFF	; 255
    8932:	80 e0       	ldi	r24, 0x00	; 0
    8934:	90 e0       	ldi	r25, 0x00	; 0
    8936:	a0 e8       	ldi	r26, 0x80	; 128
    8938:	bf e3       	ldi	r27, 0x3F	; 63
    893a:	80 83       	st	Z, r24
    893c:	91 83       	std	Z+1, r25	; 0x01
    893e:	a2 83       	std	Z+2, r26	; 0x02
    8940:	b3 83       	std	Z+3, r27	; 0x03
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    8942:	8e 01       	movw	r16, r28
    8944:	05 5a       	subi	r16, 0xA5	; 165
    8946:	1f 4f       	sbci	r17, 0xFF	; 255
    8948:	fe 01       	movw	r30, r28
    894a:	e1 5a       	subi	r30, 0xA1	; 161
    894c:	ff 4f       	sbci	r31, 0xFF	; 255
    894e:	60 81       	ld	r22, Z
    8950:	71 81       	ldd	r23, Z+1	; 0x01
    8952:	82 81       	ldd	r24, Z+2	; 0x02
    8954:	93 81       	ldd	r25, Z+3	; 0x03
    8956:	20 e0       	ldi	r18, 0x00	; 0
    8958:	30 e0       	ldi	r19, 0x00	; 0
    895a:	4a e7       	ldi	r20, 0x7A	; 122
    895c:	53 e4       	ldi	r21, 0x43	; 67
    895e:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    8962:	dc 01       	movw	r26, r24
    8964:	cb 01       	movw	r24, r22
    8966:	f8 01       	movw	r30, r16
    8968:	80 83       	st	Z, r24
    896a:	91 83       	std	Z+1, r25	; 0x01
    896c:	a2 83       	std	Z+2, r26	; 0x02
    896e:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    8970:	fe 01       	movw	r30, r28
    8972:	e5 5a       	subi	r30, 0xA5	; 165
    8974:	ff 4f       	sbci	r31, 0xFF	; 255
    8976:	60 81       	ld	r22, Z
    8978:	71 81       	ldd	r23, Z+1	; 0x01
    897a:	82 81       	ldd	r24, Z+2	; 0x02
    897c:	93 81       	ldd	r25, Z+3	; 0x03
    897e:	20 e0       	ldi	r18, 0x00	; 0
    8980:	30 e0       	ldi	r19, 0x00	; 0
    8982:	40 e8       	ldi	r20, 0x80	; 128
    8984:	5f e3       	ldi	r21, 0x3F	; 63
    8986:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    898a:	88 23       	and	r24, r24
    898c:	44 f4       	brge	.+16     	; 0x899e <LCD_displayCharacter+0x9e>
		__ticks = 1;
    898e:	fe 01       	movw	r30, r28
    8990:	e7 5a       	subi	r30, 0xA7	; 167
    8992:	ff 4f       	sbci	r31, 0xFF	; 255
    8994:	81 e0       	ldi	r24, 0x01	; 1
    8996:	90 e0       	ldi	r25, 0x00	; 0
    8998:	91 83       	std	Z+1, r25	; 0x01
    899a:	80 83       	st	Z, r24
    899c:	64 c0       	rjmp	.+200    	; 0x8a66 <LCD_displayCharacter+0x166>
	else if (__tmp > 65535)
    899e:	fe 01       	movw	r30, r28
    89a0:	e5 5a       	subi	r30, 0xA5	; 165
    89a2:	ff 4f       	sbci	r31, 0xFF	; 255
    89a4:	60 81       	ld	r22, Z
    89a6:	71 81       	ldd	r23, Z+1	; 0x01
    89a8:	82 81       	ldd	r24, Z+2	; 0x02
    89aa:	93 81       	ldd	r25, Z+3	; 0x03
    89ac:	20 e0       	ldi	r18, 0x00	; 0
    89ae:	3f ef       	ldi	r19, 0xFF	; 255
    89b0:	4f e7       	ldi	r20, 0x7F	; 127
    89b2:	57 e4       	ldi	r21, 0x47	; 71
    89b4:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    89b8:	18 16       	cp	r1, r24
    89ba:	0c f0       	brlt	.+2      	; 0x89be <LCD_displayCharacter+0xbe>
    89bc:	43 c0       	rjmp	.+134    	; 0x8a44 <LCD_displayCharacter+0x144>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    89be:	fe 01       	movw	r30, r28
    89c0:	e1 5a       	subi	r30, 0xA1	; 161
    89c2:	ff 4f       	sbci	r31, 0xFF	; 255
    89c4:	60 81       	ld	r22, Z
    89c6:	71 81       	ldd	r23, Z+1	; 0x01
    89c8:	82 81       	ldd	r24, Z+2	; 0x02
    89ca:	93 81       	ldd	r25, Z+3	; 0x03
    89cc:	20 e0       	ldi	r18, 0x00	; 0
    89ce:	30 e0       	ldi	r19, 0x00	; 0
    89d0:	40 e2       	ldi	r20, 0x20	; 32
    89d2:	51 e4       	ldi	r21, 0x41	; 65
    89d4:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    89d8:	dc 01       	movw	r26, r24
    89da:	cb 01       	movw	r24, r22
    89dc:	8e 01       	movw	r16, r28
    89de:	07 5a       	subi	r16, 0xA7	; 167
    89e0:	1f 4f       	sbci	r17, 0xFF	; 255
    89e2:	bc 01       	movw	r22, r24
    89e4:	cd 01       	movw	r24, r26
    89e6:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    89ea:	dc 01       	movw	r26, r24
    89ec:	cb 01       	movw	r24, r22
    89ee:	f8 01       	movw	r30, r16
    89f0:	91 83       	std	Z+1, r25	; 0x01
    89f2:	80 83       	st	Z, r24
    89f4:	1f c0       	rjmp	.+62     	; 0x8a34 <LCD_displayCharacter+0x134>
    89f6:	fe 01       	movw	r30, r28
    89f8:	e9 5a       	subi	r30, 0xA9	; 169
    89fa:	ff 4f       	sbci	r31, 0xFF	; 255
    89fc:	89 e1       	ldi	r24, 0x19	; 25
    89fe:	90 e0       	ldi	r25, 0x00	; 0
    8a00:	91 83       	std	Z+1, r25	; 0x01
    8a02:	80 83       	st	Z, r24
    8a04:	fe 01       	movw	r30, r28
    8a06:	e9 5a       	subi	r30, 0xA9	; 169
    8a08:	ff 4f       	sbci	r31, 0xFF	; 255
    8a0a:	80 81       	ld	r24, Z
    8a0c:	91 81       	ldd	r25, Z+1	; 0x01
    8a0e:	01 97       	sbiw	r24, 0x01	; 1
    8a10:	f1 f7       	brne	.-4      	; 0x8a0e <LCD_displayCharacter+0x10e>
    8a12:	fe 01       	movw	r30, r28
    8a14:	e9 5a       	subi	r30, 0xA9	; 169
    8a16:	ff 4f       	sbci	r31, 0xFF	; 255
    8a18:	91 83       	std	Z+1, r25	; 0x01
    8a1a:	80 83       	st	Z, r24
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    8a1c:	de 01       	movw	r26, r28
    8a1e:	a7 5a       	subi	r26, 0xA7	; 167
    8a20:	bf 4f       	sbci	r27, 0xFF	; 255
    8a22:	fe 01       	movw	r30, r28
    8a24:	e7 5a       	subi	r30, 0xA7	; 167
    8a26:	ff 4f       	sbci	r31, 0xFF	; 255
    8a28:	80 81       	ld	r24, Z
    8a2a:	91 81       	ldd	r25, Z+1	; 0x01
    8a2c:	01 97       	sbiw	r24, 0x01	; 1
    8a2e:	11 96       	adiw	r26, 0x01	; 1
    8a30:	9c 93       	st	X, r25
    8a32:	8e 93       	st	-X, r24
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    8a34:	fe 01       	movw	r30, r28
    8a36:	e7 5a       	subi	r30, 0xA7	; 167
    8a38:	ff 4f       	sbci	r31, 0xFF	; 255
    8a3a:	80 81       	ld	r24, Z
    8a3c:	91 81       	ldd	r25, Z+1	; 0x01
    8a3e:	00 97       	sbiw	r24, 0x00	; 0
    8a40:	d1 f6       	brne	.-76     	; 0x89f6 <LCD_displayCharacter+0xf6>
    8a42:	27 c0       	rjmp	.+78     	; 0x8a92 <LCD_displayCharacter+0x192>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    8a44:	8e 01       	movw	r16, r28
    8a46:	07 5a       	subi	r16, 0xA7	; 167
    8a48:	1f 4f       	sbci	r17, 0xFF	; 255
    8a4a:	fe 01       	movw	r30, r28
    8a4c:	e5 5a       	subi	r30, 0xA5	; 165
    8a4e:	ff 4f       	sbci	r31, 0xFF	; 255
    8a50:	60 81       	ld	r22, Z
    8a52:	71 81       	ldd	r23, Z+1	; 0x01
    8a54:	82 81       	ldd	r24, Z+2	; 0x02
    8a56:	93 81       	ldd	r25, Z+3	; 0x03
    8a58:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    8a5c:	dc 01       	movw	r26, r24
    8a5e:	cb 01       	movw	r24, r22
    8a60:	f8 01       	movw	r30, r16
    8a62:	91 83       	std	Z+1, r25	; 0x01
    8a64:	80 83       	st	Z, r24
    8a66:	de 01       	movw	r26, r28
    8a68:	ab 5a       	subi	r26, 0xAB	; 171
    8a6a:	bf 4f       	sbci	r27, 0xFF	; 255
    8a6c:	fe 01       	movw	r30, r28
    8a6e:	e7 5a       	subi	r30, 0xA7	; 167
    8a70:	ff 4f       	sbci	r31, 0xFF	; 255
    8a72:	80 81       	ld	r24, Z
    8a74:	91 81       	ldd	r25, Z+1	; 0x01
    8a76:	8d 93       	st	X+, r24
    8a78:	9c 93       	st	X, r25
    8a7a:	fe 01       	movw	r30, r28
    8a7c:	eb 5a       	subi	r30, 0xAB	; 171
    8a7e:	ff 4f       	sbci	r31, 0xFF	; 255
    8a80:	80 81       	ld	r24, Z
    8a82:	91 81       	ldd	r25, Z+1	; 0x01
    8a84:	01 97       	sbiw	r24, 0x01	; 1
    8a86:	f1 f7       	brne	.-4      	; 0x8a84 <LCD_displayCharacter+0x184>
    8a88:	fe 01       	movw	r30, r28
    8a8a:	eb 5a       	subi	r30, 0xAB	; 171
    8a8c:	ff 4f       	sbci	r31, 0xFF	; 255
    8a8e:	91 83       	std	Z+1, r25	; 0x01
    8a90:	80 83       	st	Z, r24
	_delay_ms(1); /* delay for processing Tas = 50ns */
	GPIO_writePin(LCD_E_PORT_ID,LCD_E_PIN_ID,LOGIC_HIGH); /* Enable LCD E=1 */
    8a92:	83 e0       	ldi	r24, 0x03	; 3
    8a94:	62 e0       	ldi	r22, 0x02	; 2
    8a96:	41 e0       	ldi	r20, 0x01	; 1
    8a98:	0e 94 9f 3b 	call	0x773e	; 0x773e <GPIO_writePin>
    8a9c:	fe 01       	movw	r30, r28
    8a9e:	ef 5a       	subi	r30, 0xAF	; 175
    8aa0:	ff 4f       	sbci	r31, 0xFF	; 255
    8aa2:	80 e0       	ldi	r24, 0x00	; 0
    8aa4:	90 e0       	ldi	r25, 0x00	; 0
    8aa6:	a0 e8       	ldi	r26, 0x80	; 128
    8aa8:	bf e3       	ldi	r27, 0x3F	; 63
    8aaa:	80 83       	st	Z, r24
    8aac:	91 83       	std	Z+1, r25	; 0x01
    8aae:	a2 83       	std	Z+2, r26	; 0x02
    8ab0:	b3 83       	std	Z+3, r27	; 0x03
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    8ab2:	8e 01       	movw	r16, r28
    8ab4:	03 5b       	subi	r16, 0xB3	; 179
    8ab6:	1f 4f       	sbci	r17, 0xFF	; 255
    8ab8:	fe 01       	movw	r30, r28
    8aba:	ef 5a       	subi	r30, 0xAF	; 175
    8abc:	ff 4f       	sbci	r31, 0xFF	; 255
    8abe:	60 81       	ld	r22, Z
    8ac0:	71 81       	ldd	r23, Z+1	; 0x01
    8ac2:	82 81       	ldd	r24, Z+2	; 0x02
    8ac4:	93 81       	ldd	r25, Z+3	; 0x03
    8ac6:	20 e0       	ldi	r18, 0x00	; 0
    8ac8:	30 e0       	ldi	r19, 0x00	; 0
    8aca:	4a e7       	ldi	r20, 0x7A	; 122
    8acc:	53 e4       	ldi	r21, 0x43	; 67
    8ace:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    8ad2:	dc 01       	movw	r26, r24
    8ad4:	cb 01       	movw	r24, r22
    8ad6:	f8 01       	movw	r30, r16
    8ad8:	80 83       	st	Z, r24
    8ada:	91 83       	std	Z+1, r25	; 0x01
    8adc:	a2 83       	std	Z+2, r26	; 0x02
    8ade:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    8ae0:	fe 01       	movw	r30, r28
    8ae2:	e3 5b       	subi	r30, 0xB3	; 179
    8ae4:	ff 4f       	sbci	r31, 0xFF	; 255
    8ae6:	60 81       	ld	r22, Z
    8ae8:	71 81       	ldd	r23, Z+1	; 0x01
    8aea:	82 81       	ldd	r24, Z+2	; 0x02
    8aec:	93 81       	ldd	r25, Z+3	; 0x03
    8aee:	20 e0       	ldi	r18, 0x00	; 0
    8af0:	30 e0       	ldi	r19, 0x00	; 0
    8af2:	40 e8       	ldi	r20, 0x80	; 128
    8af4:	5f e3       	ldi	r21, 0x3F	; 63
    8af6:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    8afa:	88 23       	and	r24, r24
    8afc:	44 f4       	brge	.+16     	; 0x8b0e <LCD_displayCharacter+0x20e>
		__ticks = 1;
    8afe:	fe 01       	movw	r30, r28
    8b00:	e5 5b       	subi	r30, 0xB5	; 181
    8b02:	ff 4f       	sbci	r31, 0xFF	; 255
    8b04:	81 e0       	ldi	r24, 0x01	; 1
    8b06:	90 e0       	ldi	r25, 0x00	; 0
    8b08:	91 83       	std	Z+1, r25	; 0x01
    8b0a:	80 83       	st	Z, r24
    8b0c:	64 c0       	rjmp	.+200    	; 0x8bd6 <LCD_displayCharacter+0x2d6>
	else if (__tmp > 65535)
    8b0e:	fe 01       	movw	r30, r28
    8b10:	e3 5b       	subi	r30, 0xB3	; 179
    8b12:	ff 4f       	sbci	r31, 0xFF	; 255
    8b14:	60 81       	ld	r22, Z
    8b16:	71 81       	ldd	r23, Z+1	; 0x01
    8b18:	82 81       	ldd	r24, Z+2	; 0x02
    8b1a:	93 81       	ldd	r25, Z+3	; 0x03
    8b1c:	20 e0       	ldi	r18, 0x00	; 0
    8b1e:	3f ef       	ldi	r19, 0xFF	; 255
    8b20:	4f e7       	ldi	r20, 0x7F	; 127
    8b22:	57 e4       	ldi	r21, 0x47	; 71
    8b24:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    8b28:	18 16       	cp	r1, r24
    8b2a:	0c f0       	brlt	.+2      	; 0x8b2e <LCD_displayCharacter+0x22e>
    8b2c:	43 c0       	rjmp	.+134    	; 0x8bb4 <LCD_displayCharacter+0x2b4>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    8b2e:	fe 01       	movw	r30, r28
    8b30:	ef 5a       	subi	r30, 0xAF	; 175
    8b32:	ff 4f       	sbci	r31, 0xFF	; 255
    8b34:	60 81       	ld	r22, Z
    8b36:	71 81       	ldd	r23, Z+1	; 0x01
    8b38:	82 81       	ldd	r24, Z+2	; 0x02
    8b3a:	93 81       	ldd	r25, Z+3	; 0x03
    8b3c:	20 e0       	ldi	r18, 0x00	; 0
    8b3e:	30 e0       	ldi	r19, 0x00	; 0
    8b40:	40 e2       	ldi	r20, 0x20	; 32
    8b42:	51 e4       	ldi	r21, 0x41	; 65
    8b44:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    8b48:	dc 01       	movw	r26, r24
    8b4a:	cb 01       	movw	r24, r22
    8b4c:	8e 01       	movw	r16, r28
    8b4e:	05 5b       	subi	r16, 0xB5	; 181
    8b50:	1f 4f       	sbci	r17, 0xFF	; 255
    8b52:	bc 01       	movw	r22, r24
    8b54:	cd 01       	movw	r24, r26
    8b56:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    8b5a:	dc 01       	movw	r26, r24
    8b5c:	cb 01       	movw	r24, r22
    8b5e:	f8 01       	movw	r30, r16
    8b60:	91 83       	std	Z+1, r25	; 0x01
    8b62:	80 83       	st	Z, r24
    8b64:	1f c0       	rjmp	.+62     	; 0x8ba4 <LCD_displayCharacter+0x2a4>
    8b66:	fe 01       	movw	r30, r28
    8b68:	e7 5b       	subi	r30, 0xB7	; 183
    8b6a:	ff 4f       	sbci	r31, 0xFF	; 255
    8b6c:	89 e1       	ldi	r24, 0x19	; 25
    8b6e:	90 e0       	ldi	r25, 0x00	; 0
    8b70:	91 83       	std	Z+1, r25	; 0x01
    8b72:	80 83       	st	Z, r24
    8b74:	fe 01       	movw	r30, r28
    8b76:	e7 5b       	subi	r30, 0xB7	; 183
    8b78:	ff 4f       	sbci	r31, 0xFF	; 255
    8b7a:	80 81       	ld	r24, Z
    8b7c:	91 81       	ldd	r25, Z+1	; 0x01
    8b7e:	01 97       	sbiw	r24, 0x01	; 1
    8b80:	f1 f7       	brne	.-4      	; 0x8b7e <LCD_displayCharacter+0x27e>
    8b82:	fe 01       	movw	r30, r28
    8b84:	e7 5b       	subi	r30, 0xB7	; 183
    8b86:	ff 4f       	sbci	r31, 0xFF	; 255
    8b88:	91 83       	std	Z+1, r25	; 0x01
    8b8a:	80 83       	st	Z, r24
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    8b8c:	de 01       	movw	r26, r28
    8b8e:	a5 5b       	subi	r26, 0xB5	; 181
    8b90:	bf 4f       	sbci	r27, 0xFF	; 255
    8b92:	fe 01       	movw	r30, r28
    8b94:	e5 5b       	subi	r30, 0xB5	; 181
    8b96:	ff 4f       	sbci	r31, 0xFF	; 255
    8b98:	80 81       	ld	r24, Z
    8b9a:	91 81       	ldd	r25, Z+1	; 0x01
    8b9c:	01 97       	sbiw	r24, 0x01	; 1
    8b9e:	11 96       	adiw	r26, 0x01	; 1
    8ba0:	9c 93       	st	X, r25
    8ba2:	8e 93       	st	-X, r24
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    8ba4:	fe 01       	movw	r30, r28
    8ba6:	e5 5b       	subi	r30, 0xB5	; 181
    8ba8:	ff 4f       	sbci	r31, 0xFF	; 255
    8baa:	80 81       	ld	r24, Z
    8bac:	91 81       	ldd	r25, Z+1	; 0x01
    8bae:	00 97       	sbiw	r24, 0x00	; 0
    8bb0:	d1 f6       	brne	.-76     	; 0x8b66 <LCD_displayCharacter+0x266>
    8bb2:	27 c0       	rjmp	.+78     	; 0x8c02 <LCD_displayCharacter+0x302>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    8bb4:	8e 01       	movw	r16, r28
    8bb6:	05 5b       	subi	r16, 0xB5	; 181
    8bb8:	1f 4f       	sbci	r17, 0xFF	; 255
    8bba:	fe 01       	movw	r30, r28
    8bbc:	e3 5b       	subi	r30, 0xB3	; 179
    8bbe:	ff 4f       	sbci	r31, 0xFF	; 255
    8bc0:	60 81       	ld	r22, Z
    8bc2:	71 81       	ldd	r23, Z+1	; 0x01
    8bc4:	82 81       	ldd	r24, Z+2	; 0x02
    8bc6:	93 81       	ldd	r25, Z+3	; 0x03
    8bc8:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    8bcc:	dc 01       	movw	r26, r24
    8bce:	cb 01       	movw	r24, r22
    8bd0:	f8 01       	movw	r30, r16
    8bd2:	91 83       	std	Z+1, r25	; 0x01
    8bd4:	80 83       	st	Z, r24
    8bd6:	de 01       	movw	r26, r28
    8bd8:	a9 5b       	subi	r26, 0xB9	; 185
    8bda:	bf 4f       	sbci	r27, 0xFF	; 255
    8bdc:	fe 01       	movw	r30, r28
    8bde:	e5 5b       	subi	r30, 0xB5	; 181
    8be0:	ff 4f       	sbci	r31, 0xFF	; 255
    8be2:	80 81       	ld	r24, Z
    8be4:	91 81       	ldd	r25, Z+1	; 0x01
    8be6:	8d 93       	st	X+, r24
    8be8:	9c 93       	st	X, r25
    8bea:	fe 01       	movw	r30, r28
    8bec:	e9 5b       	subi	r30, 0xB9	; 185
    8bee:	ff 4f       	sbci	r31, 0xFF	; 255
    8bf0:	80 81       	ld	r24, Z
    8bf2:	91 81       	ldd	r25, Z+1	; 0x01
    8bf4:	01 97       	sbiw	r24, 0x01	; 1
    8bf6:	f1 f7       	brne	.-4      	; 0x8bf4 <LCD_displayCharacter+0x2f4>
    8bf8:	fe 01       	movw	r30, r28
    8bfa:	e9 5b       	subi	r30, 0xB9	; 185
    8bfc:	ff 4f       	sbci	r31, 0xFF	; 255
    8bfe:	91 83       	std	Z+1, r25	; 0x01
    8c00:	80 83       	st	Z, r24
	_delay_ms(1); /* delay for processing Tpw - Tdws = 190ns */

#if(LCD_DATA_BITS_MODE == 4)
	GPIO_writePin(LCD_DATA_PORT_ID,LCD_DB4_PIN_ID,GET_BIT(data,4));
    8c02:	fe 01       	movw	r30, r28
    8c04:	ed 59       	subi	r30, 0x9D	; 157
    8c06:	ff 4f       	sbci	r31, 0xFF	; 255
    8c08:	80 81       	ld	r24, Z
    8c0a:	88 2f       	mov	r24, r24
    8c0c:	90 e0       	ldi	r25, 0x00	; 0
    8c0e:	80 71       	andi	r24, 0x10	; 16
    8c10:	90 70       	andi	r25, 0x00	; 0
    8c12:	95 95       	asr	r25
    8c14:	87 95       	ror	r24
    8c16:	95 95       	asr	r25
    8c18:	87 95       	ror	r24
    8c1a:	95 95       	asr	r25
    8c1c:	87 95       	ror	r24
    8c1e:	95 95       	asr	r25
    8c20:	87 95       	ror	r24
    8c22:	98 2f       	mov	r25, r24
    8c24:	83 e0       	ldi	r24, 0x03	; 3
    8c26:	64 e0       	ldi	r22, 0x04	; 4
    8c28:	49 2f       	mov	r20, r25
    8c2a:	0e 94 9f 3b 	call	0x773e	; 0x773e <GPIO_writePin>
	GPIO_writePin(LCD_DATA_PORT_ID,LCD_DB5_PIN_ID,GET_BIT(data,5));
    8c2e:	fe 01       	movw	r30, r28
    8c30:	ed 59       	subi	r30, 0x9D	; 157
    8c32:	ff 4f       	sbci	r31, 0xFF	; 255
    8c34:	80 81       	ld	r24, Z
    8c36:	88 2f       	mov	r24, r24
    8c38:	90 e0       	ldi	r25, 0x00	; 0
    8c3a:	80 72       	andi	r24, 0x20	; 32
    8c3c:	90 70       	andi	r25, 0x00	; 0
    8c3e:	95 95       	asr	r25
    8c40:	87 95       	ror	r24
    8c42:	95 95       	asr	r25
    8c44:	87 95       	ror	r24
    8c46:	95 95       	asr	r25
    8c48:	87 95       	ror	r24
    8c4a:	95 95       	asr	r25
    8c4c:	87 95       	ror	r24
    8c4e:	95 95       	asr	r25
    8c50:	87 95       	ror	r24
    8c52:	98 2f       	mov	r25, r24
    8c54:	83 e0       	ldi	r24, 0x03	; 3
    8c56:	65 e0       	ldi	r22, 0x05	; 5
    8c58:	49 2f       	mov	r20, r25
    8c5a:	0e 94 9f 3b 	call	0x773e	; 0x773e <GPIO_writePin>
	GPIO_writePin(LCD_DATA_PORT_ID,LCD_DB6_PIN_ID,GET_BIT(data,6));
    8c5e:	fe 01       	movw	r30, r28
    8c60:	ed 59       	subi	r30, 0x9D	; 157
    8c62:	ff 4f       	sbci	r31, 0xFF	; 255
    8c64:	80 81       	ld	r24, Z
    8c66:	88 2f       	mov	r24, r24
    8c68:	90 e0       	ldi	r25, 0x00	; 0
    8c6a:	80 74       	andi	r24, 0x40	; 64
    8c6c:	90 70       	andi	r25, 0x00	; 0
    8c6e:	08 2e       	mov	r0, r24
    8c70:	89 2f       	mov	r24, r25
    8c72:	00 0c       	add	r0, r0
    8c74:	88 1f       	adc	r24, r24
    8c76:	99 0b       	sbc	r25, r25
    8c78:	00 0c       	add	r0, r0
    8c7a:	88 1f       	adc	r24, r24
    8c7c:	99 1f       	adc	r25, r25
    8c7e:	98 2f       	mov	r25, r24
    8c80:	83 e0       	ldi	r24, 0x03	; 3
    8c82:	66 e0       	ldi	r22, 0x06	; 6
    8c84:	49 2f       	mov	r20, r25
    8c86:	0e 94 9f 3b 	call	0x773e	; 0x773e <GPIO_writePin>
	GPIO_writePin(LCD_DATA_PORT_ID,LCD_DB7_PIN_ID,GET_BIT(data,7));
    8c8a:	fe 01       	movw	r30, r28
    8c8c:	ed 59       	subi	r30, 0x9D	; 157
    8c8e:	ff 4f       	sbci	r31, 0xFF	; 255
    8c90:	80 81       	ld	r24, Z
    8c92:	98 2f       	mov	r25, r24
    8c94:	99 1f       	adc	r25, r25
    8c96:	99 27       	eor	r25, r25
    8c98:	99 1f       	adc	r25, r25
    8c9a:	83 e0       	ldi	r24, 0x03	; 3
    8c9c:	67 e0       	ldi	r22, 0x07	; 7
    8c9e:	49 2f       	mov	r20, r25
    8ca0:	0e 94 9f 3b 	call	0x773e	; 0x773e <GPIO_writePin>
    8ca4:	fe 01       	movw	r30, r28
    8ca6:	ed 5b       	subi	r30, 0xBD	; 189
    8ca8:	ff 4f       	sbci	r31, 0xFF	; 255
    8caa:	80 e0       	ldi	r24, 0x00	; 0
    8cac:	90 e0       	ldi	r25, 0x00	; 0
    8cae:	a0 e8       	ldi	r26, 0x80	; 128
    8cb0:	bf e3       	ldi	r27, 0x3F	; 63
    8cb2:	80 83       	st	Z, r24
    8cb4:	91 83       	std	Z+1, r25	; 0x01
    8cb6:	a2 83       	std	Z+2, r26	; 0x02
    8cb8:	b3 83       	std	Z+3, r27	; 0x03
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    8cba:	8e 01       	movw	r16, r28
    8cbc:	01 5c       	subi	r16, 0xC1	; 193
    8cbe:	1f 4f       	sbci	r17, 0xFF	; 255
    8cc0:	fe 01       	movw	r30, r28
    8cc2:	ed 5b       	subi	r30, 0xBD	; 189
    8cc4:	ff 4f       	sbci	r31, 0xFF	; 255
    8cc6:	60 81       	ld	r22, Z
    8cc8:	71 81       	ldd	r23, Z+1	; 0x01
    8cca:	82 81       	ldd	r24, Z+2	; 0x02
    8ccc:	93 81       	ldd	r25, Z+3	; 0x03
    8cce:	20 e0       	ldi	r18, 0x00	; 0
    8cd0:	30 e0       	ldi	r19, 0x00	; 0
    8cd2:	4a e7       	ldi	r20, 0x7A	; 122
    8cd4:	53 e4       	ldi	r21, 0x43	; 67
    8cd6:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    8cda:	dc 01       	movw	r26, r24
    8cdc:	cb 01       	movw	r24, r22
    8cde:	f8 01       	movw	r30, r16
    8ce0:	80 83       	st	Z, r24
    8ce2:	91 83       	std	Z+1, r25	; 0x01
    8ce4:	a2 83       	std	Z+2, r26	; 0x02
    8ce6:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    8ce8:	fe 01       	movw	r30, r28
    8cea:	ff 96       	adiw	r30, 0x3f	; 63
    8cec:	60 81       	ld	r22, Z
    8cee:	71 81       	ldd	r23, Z+1	; 0x01
    8cf0:	82 81       	ldd	r24, Z+2	; 0x02
    8cf2:	93 81       	ldd	r25, Z+3	; 0x03
    8cf4:	20 e0       	ldi	r18, 0x00	; 0
    8cf6:	30 e0       	ldi	r19, 0x00	; 0
    8cf8:	40 e8       	ldi	r20, 0x80	; 128
    8cfa:	5f e3       	ldi	r21, 0x3F	; 63
    8cfc:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    8d00:	88 23       	and	r24, r24
    8d02:	2c f4       	brge	.+10     	; 0x8d0e <LCD_displayCharacter+0x40e>
		__ticks = 1;
    8d04:	81 e0       	ldi	r24, 0x01	; 1
    8d06:	90 e0       	ldi	r25, 0x00	; 0
    8d08:	9e af       	std	Y+62, r25	; 0x3e
    8d0a:	8d af       	std	Y+61, r24	; 0x3d
    8d0c:	46 c0       	rjmp	.+140    	; 0x8d9a <LCD_displayCharacter+0x49a>
	else if (__tmp > 65535)
    8d0e:	fe 01       	movw	r30, r28
    8d10:	ff 96       	adiw	r30, 0x3f	; 63
    8d12:	60 81       	ld	r22, Z
    8d14:	71 81       	ldd	r23, Z+1	; 0x01
    8d16:	82 81       	ldd	r24, Z+2	; 0x02
    8d18:	93 81       	ldd	r25, Z+3	; 0x03
    8d1a:	20 e0       	ldi	r18, 0x00	; 0
    8d1c:	3f ef       	ldi	r19, 0xFF	; 255
    8d1e:	4f e7       	ldi	r20, 0x7F	; 127
    8d20:	57 e4       	ldi	r21, 0x47	; 71
    8d22:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    8d26:	18 16       	cp	r1, r24
    8d28:	64 f5       	brge	.+88     	; 0x8d82 <LCD_displayCharacter+0x482>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    8d2a:	fe 01       	movw	r30, r28
    8d2c:	ed 5b       	subi	r30, 0xBD	; 189
    8d2e:	ff 4f       	sbci	r31, 0xFF	; 255
    8d30:	60 81       	ld	r22, Z
    8d32:	71 81       	ldd	r23, Z+1	; 0x01
    8d34:	82 81       	ldd	r24, Z+2	; 0x02
    8d36:	93 81       	ldd	r25, Z+3	; 0x03
    8d38:	20 e0       	ldi	r18, 0x00	; 0
    8d3a:	30 e0       	ldi	r19, 0x00	; 0
    8d3c:	40 e2       	ldi	r20, 0x20	; 32
    8d3e:	51 e4       	ldi	r21, 0x41	; 65
    8d40:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    8d44:	dc 01       	movw	r26, r24
    8d46:	cb 01       	movw	r24, r22
    8d48:	bc 01       	movw	r22, r24
    8d4a:	cd 01       	movw	r24, r26
    8d4c:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    8d50:	dc 01       	movw	r26, r24
    8d52:	cb 01       	movw	r24, r22
    8d54:	9e af       	std	Y+62, r25	; 0x3e
    8d56:	8d af       	std	Y+61, r24	; 0x3d
    8d58:	0f c0       	rjmp	.+30     	; 0x8d78 <LCD_displayCharacter+0x478>
    8d5a:	89 e1       	ldi	r24, 0x19	; 25
    8d5c:	90 e0       	ldi	r25, 0x00	; 0
    8d5e:	9c af       	std	Y+60, r25	; 0x3c
    8d60:	8b af       	std	Y+59, r24	; 0x3b
    8d62:	8b ad       	ldd	r24, Y+59	; 0x3b
    8d64:	9c ad       	ldd	r25, Y+60	; 0x3c
    8d66:	01 97       	sbiw	r24, 0x01	; 1
    8d68:	f1 f7       	brne	.-4      	; 0x8d66 <LCD_displayCharacter+0x466>
    8d6a:	9c af       	std	Y+60, r25	; 0x3c
    8d6c:	8b af       	std	Y+59, r24	; 0x3b
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    8d6e:	8d ad       	ldd	r24, Y+61	; 0x3d
    8d70:	9e ad       	ldd	r25, Y+62	; 0x3e
    8d72:	01 97       	sbiw	r24, 0x01	; 1
    8d74:	9e af       	std	Y+62, r25	; 0x3e
    8d76:	8d af       	std	Y+61, r24	; 0x3d
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    8d78:	8d ad       	ldd	r24, Y+61	; 0x3d
    8d7a:	9e ad       	ldd	r25, Y+62	; 0x3e
    8d7c:	00 97       	sbiw	r24, 0x00	; 0
    8d7e:	69 f7       	brne	.-38     	; 0x8d5a <LCD_displayCharacter+0x45a>
    8d80:	16 c0       	rjmp	.+44     	; 0x8dae <LCD_displayCharacter+0x4ae>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    8d82:	fe 01       	movw	r30, r28
    8d84:	ff 96       	adiw	r30, 0x3f	; 63
    8d86:	60 81       	ld	r22, Z
    8d88:	71 81       	ldd	r23, Z+1	; 0x01
    8d8a:	82 81       	ldd	r24, Z+2	; 0x02
    8d8c:	93 81       	ldd	r25, Z+3	; 0x03
    8d8e:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    8d92:	dc 01       	movw	r26, r24
    8d94:	cb 01       	movw	r24, r22
    8d96:	9e af       	std	Y+62, r25	; 0x3e
    8d98:	8d af       	std	Y+61, r24	; 0x3d
    8d9a:	8d ad       	ldd	r24, Y+61	; 0x3d
    8d9c:	9e ad       	ldd	r25, Y+62	; 0x3e
    8d9e:	9a af       	std	Y+58, r25	; 0x3a
    8da0:	89 af       	std	Y+57, r24	; 0x39
    8da2:	89 ad       	ldd	r24, Y+57	; 0x39
    8da4:	9a ad       	ldd	r25, Y+58	; 0x3a
    8da6:	01 97       	sbiw	r24, 0x01	; 1
    8da8:	f1 f7       	brne	.-4      	; 0x8da6 <LCD_displayCharacter+0x4a6>
    8daa:	9a af       	std	Y+58, r25	; 0x3a
    8dac:	89 af       	std	Y+57, r24	; 0x39

	_delay_ms(1); /* delay for processing Tdsw = 100ns */
	GPIO_writePin(LCD_E_PORT_ID,LCD_E_PIN_ID,LOGIC_LOW); /* Disable LCD E=0 */
    8dae:	83 e0       	ldi	r24, 0x03	; 3
    8db0:	62 e0       	ldi	r22, 0x02	; 2
    8db2:	40 e0       	ldi	r20, 0x00	; 0
    8db4:	0e 94 9f 3b 	call	0x773e	; 0x773e <GPIO_writePin>
    8db8:	80 e0       	ldi	r24, 0x00	; 0
    8dba:	90 e0       	ldi	r25, 0x00	; 0
    8dbc:	a0 e8       	ldi	r26, 0x80	; 128
    8dbe:	bf e3       	ldi	r27, 0x3F	; 63
    8dc0:	8d ab       	std	Y+53, r24	; 0x35
    8dc2:	9e ab       	std	Y+54, r25	; 0x36
    8dc4:	af ab       	std	Y+55, r26	; 0x37
    8dc6:	b8 af       	std	Y+56, r27	; 0x38
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    8dc8:	6d a9       	ldd	r22, Y+53	; 0x35
    8dca:	7e a9       	ldd	r23, Y+54	; 0x36
    8dcc:	8f a9       	ldd	r24, Y+55	; 0x37
    8dce:	98 ad       	ldd	r25, Y+56	; 0x38
    8dd0:	20 e0       	ldi	r18, 0x00	; 0
    8dd2:	30 e0       	ldi	r19, 0x00	; 0
    8dd4:	4a e7       	ldi	r20, 0x7A	; 122
    8dd6:	53 e4       	ldi	r21, 0x43	; 67
    8dd8:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    8ddc:	dc 01       	movw	r26, r24
    8dde:	cb 01       	movw	r24, r22
    8de0:	89 ab       	std	Y+49, r24	; 0x31
    8de2:	9a ab       	std	Y+50, r25	; 0x32
    8de4:	ab ab       	std	Y+51, r26	; 0x33
    8de6:	bc ab       	std	Y+52, r27	; 0x34
	if (__tmp < 1.0)
    8de8:	69 a9       	ldd	r22, Y+49	; 0x31
    8dea:	7a a9       	ldd	r23, Y+50	; 0x32
    8dec:	8b a9       	ldd	r24, Y+51	; 0x33
    8dee:	9c a9       	ldd	r25, Y+52	; 0x34
    8df0:	20 e0       	ldi	r18, 0x00	; 0
    8df2:	30 e0       	ldi	r19, 0x00	; 0
    8df4:	40 e8       	ldi	r20, 0x80	; 128
    8df6:	5f e3       	ldi	r21, 0x3F	; 63
    8df8:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    8dfc:	88 23       	and	r24, r24
    8dfe:	2c f4       	brge	.+10     	; 0x8e0a <LCD_displayCharacter+0x50a>
		__ticks = 1;
    8e00:	81 e0       	ldi	r24, 0x01	; 1
    8e02:	90 e0       	ldi	r25, 0x00	; 0
    8e04:	98 ab       	std	Y+48, r25	; 0x30
    8e06:	8f a7       	std	Y+47, r24	; 0x2f
    8e08:	3f c0       	rjmp	.+126    	; 0x8e88 <LCD_displayCharacter+0x588>
	else if (__tmp > 65535)
    8e0a:	69 a9       	ldd	r22, Y+49	; 0x31
    8e0c:	7a a9       	ldd	r23, Y+50	; 0x32
    8e0e:	8b a9       	ldd	r24, Y+51	; 0x33
    8e10:	9c a9       	ldd	r25, Y+52	; 0x34
    8e12:	20 e0       	ldi	r18, 0x00	; 0
    8e14:	3f ef       	ldi	r19, 0xFF	; 255
    8e16:	4f e7       	ldi	r20, 0x7F	; 127
    8e18:	57 e4       	ldi	r21, 0x47	; 71
    8e1a:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    8e1e:	18 16       	cp	r1, r24
    8e20:	4c f5       	brge	.+82     	; 0x8e74 <LCD_displayCharacter+0x574>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    8e22:	6d a9       	ldd	r22, Y+53	; 0x35
    8e24:	7e a9       	ldd	r23, Y+54	; 0x36
    8e26:	8f a9       	ldd	r24, Y+55	; 0x37
    8e28:	98 ad       	ldd	r25, Y+56	; 0x38
    8e2a:	20 e0       	ldi	r18, 0x00	; 0
    8e2c:	30 e0       	ldi	r19, 0x00	; 0
    8e2e:	40 e2       	ldi	r20, 0x20	; 32
    8e30:	51 e4       	ldi	r21, 0x41	; 65
    8e32:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    8e36:	dc 01       	movw	r26, r24
    8e38:	cb 01       	movw	r24, r22
    8e3a:	bc 01       	movw	r22, r24
    8e3c:	cd 01       	movw	r24, r26
    8e3e:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    8e42:	dc 01       	movw	r26, r24
    8e44:	cb 01       	movw	r24, r22
    8e46:	98 ab       	std	Y+48, r25	; 0x30
    8e48:	8f a7       	std	Y+47, r24	; 0x2f
    8e4a:	0f c0       	rjmp	.+30     	; 0x8e6a <LCD_displayCharacter+0x56a>
    8e4c:	89 e1       	ldi	r24, 0x19	; 25
    8e4e:	90 e0       	ldi	r25, 0x00	; 0
    8e50:	9e a7       	std	Y+46, r25	; 0x2e
    8e52:	8d a7       	std	Y+45, r24	; 0x2d
    8e54:	8d a5       	ldd	r24, Y+45	; 0x2d
    8e56:	9e a5       	ldd	r25, Y+46	; 0x2e
    8e58:	01 97       	sbiw	r24, 0x01	; 1
    8e5a:	f1 f7       	brne	.-4      	; 0x8e58 <LCD_displayCharacter+0x558>
    8e5c:	9e a7       	std	Y+46, r25	; 0x2e
    8e5e:	8d a7       	std	Y+45, r24	; 0x2d
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    8e60:	8f a5       	ldd	r24, Y+47	; 0x2f
    8e62:	98 a9       	ldd	r25, Y+48	; 0x30
    8e64:	01 97       	sbiw	r24, 0x01	; 1
    8e66:	98 ab       	std	Y+48, r25	; 0x30
    8e68:	8f a7       	std	Y+47, r24	; 0x2f
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    8e6a:	8f a5       	ldd	r24, Y+47	; 0x2f
    8e6c:	98 a9       	ldd	r25, Y+48	; 0x30
    8e6e:	00 97       	sbiw	r24, 0x00	; 0
    8e70:	69 f7       	brne	.-38     	; 0x8e4c <LCD_displayCharacter+0x54c>
    8e72:	14 c0       	rjmp	.+40     	; 0x8e9c <LCD_displayCharacter+0x59c>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    8e74:	69 a9       	ldd	r22, Y+49	; 0x31
    8e76:	7a a9       	ldd	r23, Y+50	; 0x32
    8e78:	8b a9       	ldd	r24, Y+51	; 0x33
    8e7a:	9c a9       	ldd	r25, Y+52	; 0x34
    8e7c:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    8e80:	dc 01       	movw	r26, r24
    8e82:	cb 01       	movw	r24, r22
    8e84:	98 ab       	std	Y+48, r25	; 0x30
    8e86:	8f a7       	std	Y+47, r24	; 0x2f
    8e88:	8f a5       	ldd	r24, Y+47	; 0x2f
    8e8a:	98 a9       	ldd	r25, Y+48	; 0x30
    8e8c:	9c a7       	std	Y+44, r25	; 0x2c
    8e8e:	8b a7       	std	Y+43, r24	; 0x2b
    8e90:	8b a5       	ldd	r24, Y+43	; 0x2b
    8e92:	9c a5       	ldd	r25, Y+44	; 0x2c
    8e94:	01 97       	sbiw	r24, 0x01	; 1
    8e96:	f1 f7       	brne	.-4      	; 0x8e94 <LCD_displayCharacter+0x594>
    8e98:	9c a7       	std	Y+44, r25	; 0x2c
    8e9a:	8b a7       	std	Y+43, r24	; 0x2b
	_delay_ms(1); /* delay for processing Th = 13ns */
	GPIO_writePin(LCD_E_PORT_ID,LCD_E_PIN_ID,LOGIC_HIGH); /* Enable LCD E=1 */
    8e9c:	83 e0       	ldi	r24, 0x03	; 3
    8e9e:	62 e0       	ldi	r22, 0x02	; 2
    8ea0:	41 e0       	ldi	r20, 0x01	; 1
    8ea2:	0e 94 9f 3b 	call	0x773e	; 0x773e <GPIO_writePin>
    8ea6:	80 e0       	ldi	r24, 0x00	; 0
    8ea8:	90 e0       	ldi	r25, 0x00	; 0
    8eaa:	a0 e8       	ldi	r26, 0x80	; 128
    8eac:	bf e3       	ldi	r27, 0x3F	; 63
    8eae:	8f a3       	std	Y+39, r24	; 0x27
    8eb0:	98 a7       	std	Y+40, r25	; 0x28
    8eb2:	a9 a7       	std	Y+41, r26	; 0x29
    8eb4:	ba a7       	std	Y+42, r27	; 0x2a
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    8eb6:	6f a1       	ldd	r22, Y+39	; 0x27
    8eb8:	78 a5       	ldd	r23, Y+40	; 0x28
    8eba:	89 a5       	ldd	r24, Y+41	; 0x29
    8ebc:	9a a5       	ldd	r25, Y+42	; 0x2a
    8ebe:	20 e0       	ldi	r18, 0x00	; 0
    8ec0:	30 e0       	ldi	r19, 0x00	; 0
    8ec2:	4a e7       	ldi	r20, 0x7A	; 122
    8ec4:	53 e4       	ldi	r21, 0x43	; 67
    8ec6:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    8eca:	dc 01       	movw	r26, r24
    8ecc:	cb 01       	movw	r24, r22
    8ece:	8b a3       	std	Y+35, r24	; 0x23
    8ed0:	9c a3       	std	Y+36, r25	; 0x24
    8ed2:	ad a3       	std	Y+37, r26	; 0x25
    8ed4:	be a3       	std	Y+38, r27	; 0x26
	if (__tmp < 1.0)
    8ed6:	6b a1       	ldd	r22, Y+35	; 0x23
    8ed8:	7c a1       	ldd	r23, Y+36	; 0x24
    8eda:	8d a1       	ldd	r24, Y+37	; 0x25
    8edc:	9e a1       	ldd	r25, Y+38	; 0x26
    8ede:	20 e0       	ldi	r18, 0x00	; 0
    8ee0:	30 e0       	ldi	r19, 0x00	; 0
    8ee2:	40 e8       	ldi	r20, 0x80	; 128
    8ee4:	5f e3       	ldi	r21, 0x3F	; 63
    8ee6:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    8eea:	88 23       	and	r24, r24
    8eec:	2c f4       	brge	.+10     	; 0x8ef8 <LCD_displayCharacter+0x5f8>
		__ticks = 1;
    8eee:	81 e0       	ldi	r24, 0x01	; 1
    8ef0:	90 e0       	ldi	r25, 0x00	; 0
    8ef2:	9a a3       	std	Y+34, r25	; 0x22
    8ef4:	89 a3       	std	Y+33, r24	; 0x21
    8ef6:	3f c0       	rjmp	.+126    	; 0x8f76 <LCD_displayCharacter+0x676>
	else if (__tmp > 65535)
    8ef8:	6b a1       	ldd	r22, Y+35	; 0x23
    8efa:	7c a1       	ldd	r23, Y+36	; 0x24
    8efc:	8d a1       	ldd	r24, Y+37	; 0x25
    8efe:	9e a1       	ldd	r25, Y+38	; 0x26
    8f00:	20 e0       	ldi	r18, 0x00	; 0
    8f02:	3f ef       	ldi	r19, 0xFF	; 255
    8f04:	4f e7       	ldi	r20, 0x7F	; 127
    8f06:	57 e4       	ldi	r21, 0x47	; 71
    8f08:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    8f0c:	18 16       	cp	r1, r24
    8f0e:	4c f5       	brge	.+82     	; 0x8f62 <LCD_displayCharacter+0x662>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    8f10:	6f a1       	ldd	r22, Y+39	; 0x27
    8f12:	78 a5       	ldd	r23, Y+40	; 0x28
    8f14:	89 a5       	ldd	r24, Y+41	; 0x29
    8f16:	9a a5       	ldd	r25, Y+42	; 0x2a
    8f18:	20 e0       	ldi	r18, 0x00	; 0
    8f1a:	30 e0       	ldi	r19, 0x00	; 0
    8f1c:	40 e2       	ldi	r20, 0x20	; 32
    8f1e:	51 e4       	ldi	r21, 0x41	; 65
    8f20:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    8f24:	dc 01       	movw	r26, r24
    8f26:	cb 01       	movw	r24, r22
    8f28:	bc 01       	movw	r22, r24
    8f2a:	cd 01       	movw	r24, r26
    8f2c:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    8f30:	dc 01       	movw	r26, r24
    8f32:	cb 01       	movw	r24, r22
    8f34:	9a a3       	std	Y+34, r25	; 0x22
    8f36:	89 a3       	std	Y+33, r24	; 0x21
    8f38:	0f c0       	rjmp	.+30     	; 0x8f58 <LCD_displayCharacter+0x658>
    8f3a:	89 e1       	ldi	r24, 0x19	; 25
    8f3c:	90 e0       	ldi	r25, 0x00	; 0
    8f3e:	98 a3       	std	Y+32, r25	; 0x20
    8f40:	8f 8f       	std	Y+31, r24	; 0x1f
    8f42:	8f 8d       	ldd	r24, Y+31	; 0x1f
    8f44:	98 a1       	ldd	r25, Y+32	; 0x20
    8f46:	01 97       	sbiw	r24, 0x01	; 1
    8f48:	f1 f7       	brne	.-4      	; 0x8f46 <LCD_displayCharacter+0x646>
    8f4a:	98 a3       	std	Y+32, r25	; 0x20
    8f4c:	8f 8f       	std	Y+31, r24	; 0x1f
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    8f4e:	89 a1       	ldd	r24, Y+33	; 0x21
    8f50:	9a a1       	ldd	r25, Y+34	; 0x22
    8f52:	01 97       	sbiw	r24, 0x01	; 1
    8f54:	9a a3       	std	Y+34, r25	; 0x22
    8f56:	89 a3       	std	Y+33, r24	; 0x21
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    8f58:	89 a1       	ldd	r24, Y+33	; 0x21
    8f5a:	9a a1       	ldd	r25, Y+34	; 0x22
    8f5c:	00 97       	sbiw	r24, 0x00	; 0
    8f5e:	69 f7       	brne	.-38     	; 0x8f3a <LCD_displayCharacter+0x63a>
    8f60:	14 c0       	rjmp	.+40     	; 0x8f8a <LCD_displayCharacter+0x68a>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    8f62:	6b a1       	ldd	r22, Y+35	; 0x23
    8f64:	7c a1       	ldd	r23, Y+36	; 0x24
    8f66:	8d a1       	ldd	r24, Y+37	; 0x25
    8f68:	9e a1       	ldd	r25, Y+38	; 0x26
    8f6a:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    8f6e:	dc 01       	movw	r26, r24
    8f70:	cb 01       	movw	r24, r22
    8f72:	9a a3       	std	Y+34, r25	; 0x22
    8f74:	89 a3       	std	Y+33, r24	; 0x21
    8f76:	89 a1       	ldd	r24, Y+33	; 0x21
    8f78:	9a a1       	ldd	r25, Y+34	; 0x22
    8f7a:	9e 8f       	std	Y+30, r25	; 0x1e
    8f7c:	8d 8f       	std	Y+29, r24	; 0x1d
    8f7e:	8d 8d       	ldd	r24, Y+29	; 0x1d
    8f80:	9e 8d       	ldd	r25, Y+30	; 0x1e
    8f82:	01 97       	sbiw	r24, 0x01	; 1
    8f84:	f1 f7       	brne	.-4      	; 0x8f82 <LCD_displayCharacter+0x682>
    8f86:	9e 8f       	std	Y+30, r25	; 0x1e
    8f88:	8d 8f       	std	Y+29, r24	; 0x1d
	_delay_ms(1); /* delay for processing Tpw - Tdws = 190ns */

	GPIO_writePin(LCD_DATA_PORT_ID,LCD_DB4_PIN_ID,GET_BIT(data,0));
    8f8a:	fe 01       	movw	r30, r28
    8f8c:	ed 59       	subi	r30, 0x9D	; 157
    8f8e:	ff 4f       	sbci	r31, 0xFF	; 255
    8f90:	80 81       	ld	r24, Z
    8f92:	98 2f       	mov	r25, r24
    8f94:	91 70       	andi	r25, 0x01	; 1
    8f96:	83 e0       	ldi	r24, 0x03	; 3
    8f98:	64 e0       	ldi	r22, 0x04	; 4
    8f9a:	49 2f       	mov	r20, r25
    8f9c:	0e 94 9f 3b 	call	0x773e	; 0x773e <GPIO_writePin>
	GPIO_writePin(LCD_DATA_PORT_ID,LCD_DB5_PIN_ID,GET_BIT(data,1));
    8fa0:	fe 01       	movw	r30, r28
    8fa2:	ed 59       	subi	r30, 0x9D	; 157
    8fa4:	ff 4f       	sbci	r31, 0xFF	; 255
    8fa6:	80 81       	ld	r24, Z
    8fa8:	88 2f       	mov	r24, r24
    8faa:	90 e0       	ldi	r25, 0x00	; 0
    8fac:	82 70       	andi	r24, 0x02	; 2
    8fae:	90 70       	andi	r25, 0x00	; 0
    8fb0:	95 95       	asr	r25
    8fb2:	87 95       	ror	r24
    8fb4:	98 2f       	mov	r25, r24
    8fb6:	83 e0       	ldi	r24, 0x03	; 3
    8fb8:	65 e0       	ldi	r22, 0x05	; 5
    8fba:	49 2f       	mov	r20, r25
    8fbc:	0e 94 9f 3b 	call	0x773e	; 0x773e <GPIO_writePin>
	GPIO_writePin(LCD_DATA_PORT_ID,LCD_DB6_PIN_ID,GET_BIT(data,2));
    8fc0:	fe 01       	movw	r30, r28
    8fc2:	ed 59       	subi	r30, 0x9D	; 157
    8fc4:	ff 4f       	sbci	r31, 0xFF	; 255
    8fc6:	80 81       	ld	r24, Z
    8fc8:	88 2f       	mov	r24, r24
    8fca:	90 e0       	ldi	r25, 0x00	; 0
    8fcc:	84 70       	andi	r24, 0x04	; 4
    8fce:	90 70       	andi	r25, 0x00	; 0
    8fd0:	95 95       	asr	r25
    8fd2:	87 95       	ror	r24
    8fd4:	95 95       	asr	r25
    8fd6:	87 95       	ror	r24
    8fd8:	98 2f       	mov	r25, r24
    8fda:	83 e0       	ldi	r24, 0x03	; 3
    8fdc:	66 e0       	ldi	r22, 0x06	; 6
    8fde:	49 2f       	mov	r20, r25
    8fe0:	0e 94 9f 3b 	call	0x773e	; 0x773e <GPIO_writePin>
	GPIO_writePin(LCD_DATA_PORT_ID,LCD_DB7_PIN_ID,GET_BIT(data,3));
    8fe4:	fe 01       	movw	r30, r28
    8fe6:	ed 59       	subi	r30, 0x9D	; 157
    8fe8:	ff 4f       	sbci	r31, 0xFF	; 255
    8fea:	80 81       	ld	r24, Z
    8fec:	88 2f       	mov	r24, r24
    8fee:	90 e0       	ldi	r25, 0x00	; 0
    8ff0:	88 70       	andi	r24, 0x08	; 8
    8ff2:	90 70       	andi	r25, 0x00	; 0
    8ff4:	95 95       	asr	r25
    8ff6:	87 95       	ror	r24
    8ff8:	95 95       	asr	r25
    8ffa:	87 95       	ror	r24
    8ffc:	95 95       	asr	r25
    8ffe:	87 95       	ror	r24
    9000:	98 2f       	mov	r25, r24
    9002:	83 e0       	ldi	r24, 0x03	; 3
    9004:	67 e0       	ldi	r22, 0x07	; 7
    9006:	49 2f       	mov	r20, r25
    9008:	0e 94 9f 3b 	call	0x773e	; 0x773e <GPIO_writePin>
    900c:	80 e0       	ldi	r24, 0x00	; 0
    900e:	90 e0       	ldi	r25, 0x00	; 0
    9010:	a0 e8       	ldi	r26, 0x80	; 128
    9012:	bf e3       	ldi	r27, 0x3F	; 63
    9014:	89 8f       	std	Y+25, r24	; 0x19
    9016:	9a 8f       	std	Y+26, r25	; 0x1a
    9018:	ab 8f       	std	Y+27, r26	; 0x1b
    901a:	bc 8f       	std	Y+28, r27	; 0x1c
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    901c:	69 8d       	ldd	r22, Y+25	; 0x19
    901e:	7a 8d       	ldd	r23, Y+26	; 0x1a
    9020:	8b 8d       	ldd	r24, Y+27	; 0x1b
    9022:	9c 8d       	ldd	r25, Y+28	; 0x1c
    9024:	20 e0       	ldi	r18, 0x00	; 0
    9026:	30 e0       	ldi	r19, 0x00	; 0
    9028:	4a e7       	ldi	r20, 0x7A	; 122
    902a:	53 e4       	ldi	r21, 0x43	; 67
    902c:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    9030:	dc 01       	movw	r26, r24
    9032:	cb 01       	movw	r24, r22
    9034:	8d 8b       	std	Y+21, r24	; 0x15
    9036:	9e 8b       	std	Y+22, r25	; 0x16
    9038:	af 8b       	std	Y+23, r26	; 0x17
    903a:	b8 8f       	std	Y+24, r27	; 0x18
	if (__tmp < 1.0)
    903c:	6d 89       	ldd	r22, Y+21	; 0x15
    903e:	7e 89       	ldd	r23, Y+22	; 0x16
    9040:	8f 89       	ldd	r24, Y+23	; 0x17
    9042:	98 8d       	ldd	r25, Y+24	; 0x18
    9044:	20 e0       	ldi	r18, 0x00	; 0
    9046:	30 e0       	ldi	r19, 0x00	; 0
    9048:	40 e8       	ldi	r20, 0x80	; 128
    904a:	5f e3       	ldi	r21, 0x3F	; 63
    904c:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    9050:	88 23       	and	r24, r24
    9052:	2c f4       	brge	.+10     	; 0x905e <LCD_displayCharacter+0x75e>
		__ticks = 1;
    9054:	81 e0       	ldi	r24, 0x01	; 1
    9056:	90 e0       	ldi	r25, 0x00	; 0
    9058:	9c 8b       	std	Y+20, r25	; 0x14
    905a:	8b 8b       	std	Y+19, r24	; 0x13
    905c:	3f c0       	rjmp	.+126    	; 0x90dc <LCD_displayCharacter+0x7dc>
	else if (__tmp > 65535)
    905e:	6d 89       	ldd	r22, Y+21	; 0x15
    9060:	7e 89       	ldd	r23, Y+22	; 0x16
    9062:	8f 89       	ldd	r24, Y+23	; 0x17
    9064:	98 8d       	ldd	r25, Y+24	; 0x18
    9066:	20 e0       	ldi	r18, 0x00	; 0
    9068:	3f ef       	ldi	r19, 0xFF	; 255
    906a:	4f e7       	ldi	r20, 0x7F	; 127
    906c:	57 e4       	ldi	r21, 0x47	; 71
    906e:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    9072:	18 16       	cp	r1, r24
    9074:	4c f5       	brge	.+82     	; 0x90c8 <LCD_displayCharacter+0x7c8>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    9076:	69 8d       	ldd	r22, Y+25	; 0x19
    9078:	7a 8d       	ldd	r23, Y+26	; 0x1a
    907a:	8b 8d       	ldd	r24, Y+27	; 0x1b
    907c:	9c 8d       	ldd	r25, Y+28	; 0x1c
    907e:	20 e0       	ldi	r18, 0x00	; 0
    9080:	30 e0       	ldi	r19, 0x00	; 0
    9082:	40 e2       	ldi	r20, 0x20	; 32
    9084:	51 e4       	ldi	r21, 0x41	; 65
    9086:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    908a:	dc 01       	movw	r26, r24
    908c:	cb 01       	movw	r24, r22
    908e:	bc 01       	movw	r22, r24
    9090:	cd 01       	movw	r24, r26
    9092:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    9096:	dc 01       	movw	r26, r24
    9098:	cb 01       	movw	r24, r22
    909a:	9c 8b       	std	Y+20, r25	; 0x14
    909c:	8b 8b       	std	Y+19, r24	; 0x13
    909e:	0f c0       	rjmp	.+30     	; 0x90be <LCD_displayCharacter+0x7be>
    90a0:	89 e1       	ldi	r24, 0x19	; 25
    90a2:	90 e0       	ldi	r25, 0x00	; 0
    90a4:	9a 8b       	std	Y+18, r25	; 0x12
    90a6:	89 8b       	std	Y+17, r24	; 0x11
    90a8:	89 89       	ldd	r24, Y+17	; 0x11
    90aa:	9a 89       	ldd	r25, Y+18	; 0x12
    90ac:	01 97       	sbiw	r24, 0x01	; 1
    90ae:	f1 f7       	brne	.-4      	; 0x90ac <LCD_displayCharacter+0x7ac>
    90b0:	9a 8b       	std	Y+18, r25	; 0x12
    90b2:	89 8b       	std	Y+17, r24	; 0x11
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    90b4:	8b 89       	ldd	r24, Y+19	; 0x13
    90b6:	9c 89       	ldd	r25, Y+20	; 0x14
    90b8:	01 97       	sbiw	r24, 0x01	; 1
    90ba:	9c 8b       	std	Y+20, r25	; 0x14
    90bc:	8b 8b       	std	Y+19, r24	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    90be:	8b 89       	ldd	r24, Y+19	; 0x13
    90c0:	9c 89       	ldd	r25, Y+20	; 0x14
    90c2:	00 97       	sbiw	r24, 0x00	; 0
    90c4:	69 f7       	brne	.-38     	; 0x90a0 <LCD_displayCharacter+0x7a0>
    90c6:	14 c0       	rjmp	.+40     	; 0x90f0 <LCD_displayCharacter+0x7f0>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    90c8:	6d 89       	ldd	r22, Y+21	; 0x15
    90ca:	7e 89       	ldd	r23, Y+22	; 0x16
    90cc:	8f 89       	ldd	r24, Y+23	; 0x17
    90ce:	98 8d       	ldd	r25, Y+24	; 0x18
    90d0:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    90d4:	dc 01       	movw	r26, r24
    90d6:	cb 01       	movw	r24, r22
    90d8:	9c 8b       	std	Y+20, r25	; 0x14
    90da:	8b 8b       	std	Y+19, r24	; 0x13
    90dc:	8b 89       	ldd	r24, Y+19	; 0x13
    90de:	9c 89       	ldd	r25, Y+20	; 0x14
    90e0:	98 8b       	std	Y+16, r25	; 0x10
    90e2:	8f 87       	std	Y+15, r24	; 0x0f
    90e4:	8f 85       	ldd	r24, Y+15	; 0x0f
    90e6:	98 89       	ldd	r25, Y+16	; 0x10
    90e8:	01 97       	sbiw	r24, 0x01	; 1
    90ea:	f1 f7       	brne	.-4      	; 0x90e8 <LCD_displayCharacter+0x7e8>
    90ec:	98 8b       	std	Y+16, r25	; 0x10
    90ee:	8f 87       	std	Y+15, r24	; 0x0f

	_delay_ms(1); /* delay for processing Tdsw = 100ns */
	GPIO_writePin(LCD_E_PORT_ID,LCD_E_PIN_ID,LOGIC_LOW); /* Disable LCD E=0 */
    90f0:	83 e0       	ldi	r24, 0x03	; 3
    90f2:	62 e0       	ldi	r22, 0x02	; 2
    90f4:	40 e0       	ldi	r20, 0x00	; 0
    90f6:	0e 94 9f 3b 	call	0x773e	; 0x773e <GPIO_writePin>
    90fa:	80 e0       	ldi	r24, 0x00	; 0
    90fc:	90 e0       	ldi	r25, 0x00	; 0
    90fe:	a0 e8       	ldi	r26, 0x80	; 128
    9100:	bf e3       	ldi	r27, 0x3F	; 63
    9102:	8b 87       	std	Y+11, r24	; 0x0b
    9104:	9c 87       	std	Y+12, r25	; 0x0c
    9106:	ad 87       	std	Y+13, r26	; 0x0d
    9108:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    910a:	6b 85       	ldd	r22, Y+11	; 0x0b
    910c:	7c 85       	ldd	r23, Y+12	; 0x0c
    910e:	8d 85       	ldd	r24, Y+13	; 0x0d
    9110:	9e 85       	ldd	r25, Y+14	; 0x0e
    9112:	20 e0       	ldi	r18, 0x00	; 0
    9114:	30 e0       	ldi	r19, 0x00	; 0
    9116:	4a e7       	ldi	r20, 0x7A	; 122
    9118:	53 e4       	ldi	r21, 0x43	; 67
    911a:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    911e:	dc 01       	movw	r26, r24
    9120:	cb 01       	movw	r24, r22
    9122:	8f 83       	std	Y+7, r24	; 0x07
    9124:	98 87       	std	Y+8, r25	; 0x08
    9126:	a9 87       	std	Y+9, r26	; 0x09
    9128:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    912a:	6f 81       	ldd	r22, Y+7	; 0x07
    912c:	78 85       	ldd	r23, Y+8	; 0x08
    912e:	89 85       	ldd	r24, Y+9	; 0x09
    9130:	9a 85       	ldd	r25, Y+10	; 0x0a
    9132:	20 e0       	ldi	r18, 0x00	; 0
    9134:	30 e0       	ldi	r19, 0x00	; 0
    9136:	40 e8       	ldi	r20, 0x80	; 128
    9138:	5f e3       	ldi	r21, 0x3F	; 63
    913a:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    913e:	88 23       	and	r24, r24
    9140:	2c f4       	brge	.+10     	; 0x914c <LCD_displayCharacter+0x84c>
		__ticks = 1;
    9142:	81 e0       	ldi	r24, 0x01	; 1
    9144:	90 e0       	ldi	r25, 0x00	; 0
    9146:	9e 83       	std	Y+6, r25	; 0x06
    9148:	8d 83       	std	Y+5, r24	; 0x05
    914a:	3f c0       	rjmp	.+126    	; 0x91ca <LCD_displayCharacter+0x8ca>
	else if (__tmp > 65535)
    914c:	6f 81       	ldd	r22, Y+7	; 0x07
    914e:	78 85       	ldd	r23, Y+8	; 0x08
    9150:	89 85       	ldd	r24, Y+9	; 0x09
    9152:	9a 85       	ldd	r25, Y+10	; 0x0a
    9154:	20 e0       	ldi	r18, 0x00	; 0
    9156:	3f ef       	ldi	r19, 0xFF	; 255
    9158:	4f e7       	ldi	r20, 0x7F	; 127
    915a:	57 e4       	ldi	r21, 0x47	; 71
    915c:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    9160:	18 16       	cp	r1, r24
    9162:	4c f5       	brge	.+82     	; 0x91b6 <LCD_displayCharacter+0x8b6>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    9164:	6b 85       	ldd	r22, Y+11	; 0x0b
    9166:	7c 85       	ldd	r23, Y+12	; 0x0c
    9168:	8d 85       	ldd	r24, Y+13	; 0x0d
    916a:	9e 85       	ldd	r25, Y+14	; 0x0e
    916c:	20 e0       	ldi	r18, 0x00	; 0
    916e:	30 e0       	ldi	r19, 0x00	; 0
    9170:	40 e2       	ldi	r20, 0x20	; 32
    9172:	51 e4       	ldi	r21, 0x41	; 65
    9174:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    9178:	dc 01       	movw	r26, r24
    917a:	cb 01       	movw	r24, r22
    917c:	bc 01       	movw	r22, r24
    917e:	cd 01       	movw	r24, r26
    9180:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    9184:	dc 01       	movw	r26, r24
    9186:	cb 01       	movw	r24, r22
    9188:	9e 83       	std	Y+6, r25	; 0x06
    918a:	8d 83       	std	Y+5, r24	; 0x05
    918c:	0f c0       	rjmp	.+30     	; 0x91ac <LCD_displayCharacter+0x8ac>
    918e:	89 e1       	ldi	r24, 0x19	; 25
    9190:	90 e0       	ldi	r25, 0x00	; 0
    9192:	9c 83       	std	Y+4, r25	; 0x04
    9194:	8b 83       	std	Y+3, r24	; 0x03
    9196:	8b 81       	ldd	r24, Y+3	; 0x03
    9198:	9c 81       	ldd	r25, Y+4	; 0x04
    919a:	01 97       	sbiw	r24, 0x01	; 1
    919c:	f1 f7       	brne	.-4      	; 0x919a <LCD_displayCharacter+0x89a>
    919e:	9c 83       	std	Y+4, r25	; 0x04
    91a0:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    91a2:	8d 81       	ldd	r24, Y+5	; 0x05
    91a4:	9e 81       	ldd	r25, Y+6	; 0x06
    91a6:	01 97       	sbiw	r24, 0x01	; 1
    91a8:	9e 83       	std	Y+6, r25	; 0x06
    91aa:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    91ac:	8d 81       	ldd	r24, Y+5	; 0x05
    91ae:	9e 81       	ldd	r25, Y+6	; 0x06
    91b0:	00 97       	sbiw	r24, 0x00	; 0
    91b2:	69 f7       	brne	.-38     	; 0x918e <LCD_displayCharacter+0x88e>
    91b4:	14 c0       	rjmp	.+40     	; 0x91de <LCD_displayCharacter+0x8de>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    91b6:	6f 81       	ldd	r22, Y+7	; 0x07
    91b8:	78 85       	ldd	r23, Y+8	; 0x08
    91ba:	89 85       	ldd	r24, Y+9	; 0x09
    91bc:	9a 85       	ldd	r25, Y+10	; 0x0a
    91be:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    91c2:	dc 01       	movw	r26, r24
    91c4:	cb 01       	movw	r24, r22
    91c6:	9e 83       	std	Y+6, r25	; 0x06
    91c8:	8d 83       	std	Y+5, r24	; 0x05
    91ca:	8d 81       	ldd	r24, Y+5	; 0x05
    91cc:	9e 81       	ldd	r25, Y+6	; 0x06
    91ce:	9a 83       	std	Y+2, r25	; 0x02
    91d0:	89 83       	std	Y+1, r24	; 0x01
    91d2:	89 81       	ldd	r24, Y+1	; 0x01
    91d4:	9a 81       	ldd	r25, Y+2	; 0x02
    91d6:	01 97       	sbiw	r24, 0x01	; 1
    91d8:	f1 f7       	brne	.-4      	; 0x91d6 <LCD_displayCharacter+0x8d6>
    91da:	9a 83       	std	Y+2, r25	; 0x02
    91dc:	89 83       	std	Y+1, r24	; 0x01
	GPIO_writePort(LCD_DATA_PORT_ID,data); /* out the required command to the data bus D0 --> D7 */
	_delay_ms(1); /* delay for processing Tdsw = 100ns */
	GPIO_writePin(LCD_E_PORT_ID,LCD_E_PIN_ID,LOGIC_LOW); /* Disable LCD E=0 */
	_delay_ms(1); /* delay for processing Th = 13ns */
#endif
}
    91de:	cd 59       	subi	r28, 0x9D	; 157
    91e0:	df 4f       	sbci	r29, 0xFF	; 255
    91e2:	0f b6       	in	r0, 0x3f	; 63
    91e4:	f8 94       	cli
    91e6:	de bf       	out	0x3e, r29	; 62
    91e8:	0f be       	out	0x3f, r0	; 63
    91ea:	cd bf       	out	0x3d, r28	; 61
    91ec:	cf 91       	pop	r28
    91ee:	df 91       	pop	r29
    91f0:	1f 91       	pop	r17
    91f2:	0f 91       	pop	r16
    91f4:	08 95       	ret

000091f6 <LCD_displayString>:
/*
 * Description :
 * Display the required string on the screen
 */
void LCD_displayString(const char *Str)
{
    91f6:	df 93       	push	r29
    91f8:	cf 93       	push	r28
    91fa:	00 d0       	rcall	.+0      	; 0x91fc <LCD_displayString+0x6>
    91fc:	0f 92       	push	r0
    91fe:	cd b7       	in	r28, 0x3d	; 61
    9200:	de b7       	in	r29, 0x3e	; 62
    9202:	9b 83       	std	Y+3, r25	; 0x03
    9204:	8a 83       	std	Y+2, r24	; 0x02
	uint8 i = 0;
    9206:	19 82       	std	Y+1, r1	; 0x01
    9208:	0e c0       	rjmp	.+28     	; 0x9226 <LCD_displayString+0x30>
	while(Str[i] != '\0')
	{
		LCD_displayCharacter(Str[i]);
    920a:	89 81       	ldd	r24, Y+1	; 0x01
    920c:	28 2f       	mov	r18, r24
    920e:	30 e0       	ldi	r19, 0x00	; 0
    9210:	8a 81       	ldd	r24, Y+2	; 0x02
    9212:	9b 81       	ldd	r25, Y+3	; 0x03
    9214:	fc 01       	movw	r30, r24
    9216:	e2 0f       	add	r30, r18
    9218:	f3 1f       	adc	r31, r19
    921a:	80 81       	ld	r24, Z
    921c:	0e 94 80 44 	call	0x8900	; 0x8900 <LCD_displayCharacter>
		i++;
    9220:	89 81       	ldd	r24, Y+1	; 0x01
    9222:	8f 5f       	subi	r24, 0xFF	; 255
    9224:	89 83       	std	Y+1, r24	; 0x01
 * Display the required string on the screen
 */
void LCD_displayString(const char *Str)
{
	uint8 i = 0;
	while(Str[i] != '\0')
    9226:	89 81       	ldd	r24, Y+1	; 0x01
    9228:	28 2f       	mov	r18, r24
    922a:	30 e0       	ldi	r19, 0x00	; 0
    922c:	8a 81       	ldd	r24, Y+2	; 0x02
    922e:	9b 81       	ldd	r25, Y+3	; 0x03
    9230:	fc 01       	movw	r30, r24
    9232:	e2 0f       	add	r30, r18
    9234:	f3 1f       	adc	r31, r19
    9236:	80 81       	ld	r24, Z
    9238:	88 23       	and	r24, r24
    923a:	39 f7       	brne	.-50     	; 0x920a <LCD_displayString+0x14>
	{
		LCD_displayCharacter(*Str);
		Str++;
	}		
	*********************************************************/
}
    923c:	0f 90       	pop	r0
    923e:	0f 90       	pop	r0
    9240:	0f 90       	pop	r0
    9242:	cf 91       	pop	r28
    9244:	df 91       	pop	r29
    9246:	08 95       	ret

00009248 <LCD_moveCursor>:
/*
 * Description :
 * Move the cursor to a specified row and column index on the screen
 */
void LCD_moveCursor(uint8 row,uint8 col)
{
    9248:	df 93       	push	r29
    924a:	cf 93       	push	r28
    924c:	00 d0       	rcall	.+0      	; 0x924e <LCD_moveCursor+0x6>
    924e:	00 d0       	rcall	.+0      	; 0x9250 <LCD_moveCursor+0x8>
    9250:	0f 92       	push	r0
    9252:	cd b7       	in	r28, 0x3d	; 61
    9254:	de b7       	in	r29, 0x3e	; 62
    9256:	8a 83       	std	Y+2, r24	; 0x02
    9258:	6b 83       	std	Y+3, r22	; 0x03
	uint8 lcd_memory_address;
	
	/* Calculate the required address in the LCD DDRAM */
	switch(row)
    925a:	8a 81       	ldd	r24, Y+2	; 0x02
    925c:	28 2f       	mov	r18, r24
    925e:	30 e0       	ldi	r19, 0x00	; 0
    9260:	3d 83       	std	Y+5, r19	; 0x05
    9262:	2c 83       	std	Y+4, r18	; 0x04
    9264:	8c 81       	ldd	r24, Y+4	; 0x04
    9266:	9d 81       	ldd	r25, Y+5	; 0x05
    9268:	81 30       	cpi	r24, 0x01	; 1
    926a:	91 05       	cpc	r25, r1
    926c:	c1 f0       	breq	.+48     	; 0x929e <LCD_moveCursor+0x56>
    926e:	2c 81       	ldd	r18, Y+4	; 0x04
    9270:	3d 81       	ldd	r19, Y+5	; 0x05
    9272:	22 30       	cpi	r18, 0x02	; 2
    9274:	31 05       	cpc	r19, r1
    9276:	2c f4       	brge	.+10     	; 0x9282 <LCD_moveCursor+0x3a>
    9278:	8c 81       	ldd	r24, Y+4	; 0x04
    927a:	9d 81       	ldd	r25, Y+5	; 0x05
    927c:	00 97       	sbiw	r24, 0x00	; 0
    927e:	61 f0       	breq	.+24     	; 0x9298 <LCD_moveCursor+0x50>
    9280:	19 c0       	rjmp	.+50     	; 0x92b4 <LCD_moveCursor+0x6c>
    9282:	2c 81       	ldd	r18, Y+4	; 0x04
    9284:	3d 81       	ldd	r19, Y+5	; 0x05
    9286:	22 30       	cpi	r18, 0x02	; 2
    9288:	31 05       	cpc	r19, r1
    928a:	69 f0       	breq	.+26     	; 0x92a6 <LCD_moveCursor+0x5e>
    928c:	8c 81       	ldd	r24, Y+4	; 0x04
    928e:	9d 81       	ldd	r25, Y+5	; 0x05
    9290:	83 30       	cpi	r24, 0x03	; 3
    9292:	91 05       	cpc	r25, r1
    9294:	61 f0       	breq	.+24     	; 0x92ae <LCD_moveCursor+0x66>
    9296:	0e c0       	rjmp	.+28     	; 0x92b4 <LCD_moveCursor+0x6c>
	{
		case 0:
			lcd_memory_address=col;
    9298:	8b 81       	ldd	r24, Y+3	; 0x03
    929a:	89 83       	std	Y+1, r24	; 0x01
    929c:	0b c0       	rjmp	.+22     	; 0x92b4 <LCD_moveCursor+0x6c>
				break;
		case 1:
			lcd_memory_address=col+0x40;
    929e:	8b 81       	ldd	r24, Y+3	; 0x03
    92a0:	80 5c       	subi	r24, 0xC0	; 192
    92a2:	89 83       	std	Y+1, r24	; 0x01
    92a4:	07 c0       	rjmp	.+14     	; 0x92b4 <LCD_moveCursor+0x6c>
				break;
		case 2:
			lcd_memory_address=col+0x10;
    92a6:	8b 81       	ldd	r24, Y+3	; 0x03
    92a8:	80 5f       	subi	r24, 0xF0	; 240
    92aa:	89 83       	std	Y+1, r24	; 0x01
    92ac:	03 c0       	rjmp	.+6      	; 0x92b4 <LCD_moveCursor+0x6c>
				break;
		case 3:
			lcd_memory_address=col+0x50;
    92ae:	8b 81       	ldd	r24, Y+3	; 0x03
    92b0:	80 5b       	subi	r24, 0xB0	; 176
    92b2:	89 83       	std	Y+1, r24	; 0x01
				break;
	}					
	/* Move the LCD cursor to this specific address */
	LCD_sendCommand(lcd_memory_address | LCD_SET_CURSOR_LOCATION);
    92b4:	89 81       	ldd	r24, Y+1	; 0x01
    92b6:	80 68       	ori	r24, 0x80	; 128
    92b8:	0e 94 05 40 	call	0x800a	; 0x800a <LCD_sendCommand>
}
    92bc:	0f 90       	pop	r0
    92be:	0f 90       	pop	r0
    92c0:	0f 90       	pop	r0
    92c2:	0f 90       	pop	r0
    92c4:	0f 90       	pop	r0
    92c6:	cf 91       	pop	r28
    92c8:	df 91       	pop	r29
    92ca:	08 95       	ret

000092cc <LCD_displayStringRowColumn>:
/*
 * Description :
 * Display the required string in a specified row and column index on the screen
 */
void LCD_displayStringRowColumn(uint8 row,uint8 col,const char *Str)
{
    92cc:	df 93       	push	r29
    92ce:	cf 93       	push	r28
    92d0:	00 d0       	rcall	.+0      	; 0x92d2 <LCD_displayStringRowColumn+0x6>
    92d2:	00 d0       	rcall	.+0      	; 0x92d4 <LCD_displayStringRowColumn+0x8>
    92d4:	cd b7       	in	r28, 0x3d	; 61
    92d6:	de b7       	in	r29, 0x3e	; 62
    92d8:	89 83       	std	Y+1, r24	; 0x01
    92da:	6a 83       	std	Y+2, r22	; 0x02
    92dc:	5c 83       	std	Y+4, r21	; 0x04
    92de:	4b 83       	std	Y+3, r20	; 0x03
	LCD_moveCursor(row,col); /* go to to the required LCD position */
    92e0:	89 81       	ldd	r24, Y+1	; 0x01
    92e2:	6a 81       	ldd	r22, Y+2	; 0x02
    92e4:	0e 94 24 49 	call	0x9248	; 0x9248 <LCD_moveCursor>
	LCD_displayString(Str); /* display the string */
    92e8:	8b 81       	ldd	r24, Y+3	; 0x03
    92ea:	9c 81       	ldd	r25, Y+4	; 0x04
    92ec:	0e 94 fb 48 	call	0x91f6	; 0x91f6 <LCD_displayString>
}
    92f0:	0f 90       	pop	r0
    92f2:	0f 90       	pop	r0
    92f4:	0f 90       	pop	r0
    92f6:	0f 90       	pop	r0
    92f8:	cf 91       	pop	r28
    92fa:	df 91       	pop	r29
    92fc:	08 95       	ret

000092fe <LCD_intgerToString>:
/*
 * Description :
 * Display the required decimal value on the screen
 */
void LCD_intgerToString(int data)
{
    92fe:	df 93       	push	r29
    9300:	cf 93       	push	r28
    9302:	cd b7       	in	r28, 0x3d	; 61
    9304:	de b7       	in	r29, 0x3e	; 62
    9306:	62 97       	sbiw	r28, 0x12	; 18
    9308:	0f b6       	in	r0, 0x3f	; 63
    930a:	f8 94       	cli
    930c:	de bf       	out	0x3e, r29	; 62
    930e:	0f be       	out	0x3f, r0	; 63
    9310:	cd bf       	out	0x3d, r28	; 61
    9312:	9a 8b       	std	Y+18, r25	; 0x12
    9314:	89 8b       	std	Y+17, r24	; 0x11
   char buff[16]; /* String to hold the ascii result */
   itoa(data,buff,10); /* Use itoa C function to convert the data to its corresponding ASCII value, 10 for decimal */
    9316:	89 89       	ldd	r24, Y+17	; 0x11
    9318:	9a 89       	ldd	r25, Y+18	; 0x12
    931a:	9e 01       	movw	r18, r28
    931c:	2f 5f       	subi	r18, 0xFF	; 255
    931e:	3f 4f       	sbci	r19, 0xFF	; 255
    9320:	b9 01       	movw	r22, r18
    9322:	4a e0       	ldi	r20, 0x0A	; 10
    9324:	50 e0       	ldi	r21, 0x00	; 0
    9326:	0e 94 28 4b 	call	0x9650	; 0x9650 <itoa>
   LCD_displayString(buff); /* Display the string */
    932a:	ce 01       	movw	r24, r28
    932c:	01 96       	adiw	r24, 0x01	; 1
    932e:	0e 94 fb 48 	call	0x91f6	; 0x91f6 <LCD_displayString>
}
    9332:	62 96       	adiw	r28, 0x12	; 18
    9334:	0f b6       	in	r0, 0x3f	; 63
    9336:	f8 94       	cli
    9338:	de bf       	out	0x3e, r29	; 62
    933a:	0f be       	out	0x3f, r0	; 63
    933c:	cd bf       	out	0x3d, r28	; 61
    933e:	cf 91       	pop	r28
    9340:	df 91       	pop	r29
    9342:	08 95       	ret

00009344 <LCD_clearScreen>:
/*
 * Description :
 * Send the clear screen command
 */
void LCD_clearScreen(void)
{
    9344:	df 93       	push	r29
    9346:	cf 93       	push	r28
    9348:	cd b7       	in	r28, 0x3d	; 61
    934a:	de b7       	in	r29, 0x3e	; 62
	LCD_sendCommand(LCD_CLEAR_COMMAND); /* Send clear display command */
    934c:	81 e0       	ldi	r24, 0x01	; 1
    934e:	0e 94 05 40 	call	0x800a	; 0x800a <LCD_sendCommand>
}
    9352:	cf 91       	pop	r28
    9354:	df 91       	pop	r29
    9356:	08 95       	ret

00009358 <main>:

//void Task3_Func(void);
//TaskHandle_t task3ptr;

int main(void)
{
    9358:	ef 92       	push	r14
    935a:	ff 92       	push	r15
    935c:	0f 93       	push	r16
    935e:	df 93       	push	r29
    9360:	cf 93       	push	r28
    9362:	cd b7       	in	r28, 0x3d	; 61
    9364:	de b7       	in	r29, 0x3e	; 62
	DIO_init();
    9366:	0e 94 f2 3d 	call	0x7be4	; 0x7be4 <DIO_init>
	//	LCD_init();
	timer1_PWM_Init();
    936a:	0e 94 a2 38 	call	0x7144	; 0x7144 <timer1_PWM_Init>

	SREG |=(1<<7);			// I bit Enabled
    936e:	af e5       	ldi	r26, 0x5F	; 95
    9370:	b0 e0       	ldi	r27, 0x00	; 0
    9372:	ef e5       	ldi	r30, 0x5F	; 95
    9374:	f0 e0       	ldi	r31, 0x00	; 0
    9376:	80 81       	ld	r24, Z
    9378:	80 68       	ori	r24, 0x80	; 128
    937a:	8c 93       	st	X, r24
	xTaskCreate(Task1_Func,"first",configMINIMAL_STACK_SIZE,NULL,1,&task1ptr);
    937c:	89 e0       	ldi	r24, 0x09	; 9
    937e:	9a e4       	ldi	r25, 0x4A	; 74
    9380:	2c e7       	ldi	r18, 0x7C	; 124
    9382:	30 e0       	ldi	r19, 0x00	; 0
    9384:	e5 e5       	ldi	r30, 0x55	; 85
    9386:	f8 e0       	ldi	r31, 0x08	; 8
    9388:	b9 01       	movw	r22, r18
    938a:	45 e5       	ldi	r20, 0x55	; 85
    938c:	50 e0       	ldi	r21, 0x00	; 0
    938e:	20 e0       	ldi	r18, 0x00	; 0
    9390:	30 e0       	ldi	r19, 0x00	; 0
    9392:	01 e0       	ldi	r16, 0x01	; 1
    9394:	7f 01       	movw	r14, r30
    9396:	0e 94 1b 1b 	call	0x3636	; 0x3636 <xTaskCreate>

	xTaskCreate(Task2_Func,"second",configMINIMAL_STACK_SIZE,NULL,1,&task2ptr);
    939a:	84 e3       	ldi	r24, 0x34	; 52
    939c:	9a e4       	ldi	r25, 0x4A	; 74
    939e:	22 e8       	ldi	r18, 0x82	; 130
    93a0:	30 e0       	ldi	r19, 0x00	; 0
    93a2:	e3 e5       	ldi	r30, 0x53	; 83
    93a4:	f8 e0       	ldi	r31, 0x08	; 8
    93a6:	b9 01       	movw	r22, r18
    93a8:	45 e5       	ldi	r20, 0x55	; 85
    93aa:	50 e0       	ldi	r21, 0x00	; 0
    93ac:	20 e0       	ldi	r18, 0x00	; 0
    93ae:	30 e0       	ldi	r19, 0x00	; 0
    93b0:	01 e0       	ldi	r16, 0x01	; 1
    93b2:	7f 01       	movw	r14, r30
    93b4:	0e 94 1b 1b 	call	0x3636	; 0x3636 <xTaskCreate>

	//	xTaskCreate(Task3_Func,"first",configMINIMAL_STACK_SIZE,NULL,1,&task3ptr);

	vTaskStartScheduler();
    93b8:	0e 94 25 1e 	call	0x3c4a	; 0x3c4a <vTaskStartScheduler>
    93bc:	ff cf       	rjmp	.-2      	; 0x93bc <main+0x64>

000093be <__vector_4>:

	}
}

ISR(TIMER2_COMP_vect)
{
    93be:	1f 92       	push	r1
    93c0:	0f 92       	push	r0
    93c2:	0f b6       	in	r0, 0x3f	; 63
    93c4:	0f 92       	push	r0
    93c6:	11 24       	eor	r1, r1
    93c8:	2f 93       	push	r18
    93ca:	3f 93       	push	r19
    93cc:	4f 93       	push	r20
    93ce:	5f 93       	push	r21
    93d0:	6f 93       	push	r22
    93d2:	7f 93       	push	r23
    93d4:	8f 93       	push	r24
    93d6:	9f 93       	push	r25
    93d8:	af 93       	push	r26
    93da:	bf 93       	push	r27
    93dc:	ef 93       	push	r30
    93de:	ff 93       	push	r31
    93e0:	df 93       	push	r29
    93e2:	cf 93       	push	r28
    93e4:	cd b7       	in	r28, 0x3d	; 61
    93e6:	de b7       	in	r29, 0x3e	; 62
	Poll();
    93e8:	0e 94 4d 4a 	call	0x949a	; 0x949a <Poll>
}
    93ec:	cf 91       	pop	r28
    93ee:	df 91       	pop	r29
    93f0:	ff 91       	pop	r31
    93f2:	ef 91       	pop	r30
    93f4:	bf 91       	pop	r27
    93f6:	af 91       	pop	r26
    93f8:	9f 91       	pop	r25
    93fa:	8f 91       	pop	r24
    93fc:	7f 91       	pop	r23
    93fe:	6f 91       	pop	r22
    9400:	5f 91       	pop	r21
    9402:	4f 91       	pop	r20
    9404:	3f 91       	pop	r19
    9406:	2f 91       	pop	r18
    9408:	0f 90       	pop	r0
    940a:	0f be       	out	0x3f, r0	; 63
    940c:	0f 90       	pop	r0
    940e:	1f 90       	pop	r1
    9410:	18 95       	reti

00009412 <Task1_Func>:


void Task1_Func(void){
    9412:	df 93       	push	r29
    9414:	cf 93       	push	r28
    9416:	cd b7       	in	r28, 0x3d	; 61
    9418:	de b7       	in	r29, 0x3e	; 62
	while(1){
		//		SET_BIT(PORTB,6);
		ButtonStateTest = Get_Data();
    941a:	0e 94 eb 39 	call	0x73d6	; 0x73d6 <Get_Data>
    941e:	dc 01       	movw	r26, r24
    9420:	cb 01       	movw	r24, r22
    9422:	80 93 47 08 	sts	0x0847, r24
    9426:	90 93 48 08 	sts	0x0848, r25
    942a:	a0 93 49 08 	sts	0x0849, r26
    942e:	b0 93 4a 08 	sts	0x084A, r27
		HandlerFlag = 1;
    9432:	81 e0       	ldi	r24, 0x01	; 1
    9434:	80 93 46 08 	sts	0x0846, r24
		if(ButtonStateTest.ignition_key){
    9438:	80 91 47 08 	lds	r24, 0x0847
    943c:	88 23       	and	r24, r24
    943e:	41 f0       	breq	.+16     	; 0x9450 <Task1_Func+0x3e>
			SET_BIT(PORTB,5);
    9440:	a8 e3       	ldi	r26, 0x38	; 56
    9442:	b0 e0       	ldi	r27, 0x00	; 0
    9444:	e8 e3       	ldi	r30, 0x38	; 56
    9446:	f0 e0       	ldi	r31, 0x00	; 0
    9448:	80 81       	ld	r24, Z
    944a:	80 62       	ori	r24, 0x20	; 32
    944c:	8c 93       	st	X, r24
    944e:	07 c0       	rjmp	.+14     	; 0x945e <Task1_Func+0x4c>
		}
		else{
			CLEAR_BIT(PORTB,5);
    9450:	a8 e3       	ldi	r26, 0x38	; 56
    9452:	b0 e0       	ldi	r27, 0x00	; 0
    9454:	e8 e3       	ldi	r30, 0x38	; 56
    9456:	f0 e0       	ldi	r31, 0x00	; 0
    9458:	80 81       	ld	r24, Z
    945a:	8f 7d       	andi	r24, 0xDF	; 223
    945c:	8c 93       	st	X, r24
		}
		//				CLEAR_BIT(PORTB,6);
		vTaskDelay(50/portTICK_PERIOD_MS);
    945e:	82 e3       	ldi	r24, 0x32	; 50
    9460:	90 e0       	ldi	r25, 0x00	; 0
    9462:	0e 94 03 1e 	call	0x3c06	; 0x3c06 <vTaskDelay>
    9466:	d9 cf       	rjmp	.-78     	; 0x941a <Task1_Func+0x8>

00009468 <Task2_Func>:

	}
}

/*******************************Some unworking tests**************************************************************************/
void Task2_Func(void){
    9468:	df 93       	push	r29
    946a:	cf 93       	push	r28
    946c:	cd b7       	in	r28, 0x3d	; 61
    946e:	de b7       	in	r29, 0x3e	; 62
	//	TickType_t xLastWakeTime2;
	//	const TickType_t xPeriod2 = pdMS_TO_TICKS( 2000 );
	//	xLastWakeTime2 = xTaskGetTickCount();
	while(1){
		if(HandlerFlag == 1){
    9470:	80 91 46 08 	lds	r24, 0x0846
    9474:	81 30       	cpi	r24, 0x01	; 1
    9476:	e1 f7       	brne	.-8      	; 0x9470 <Task2_Func+0x8>
			HandlerFlag = 0;
    9478:	10 92 46 08 	sts	0x0846, r1
			timer1_SetPWM_A(0);
    947c:	80 e0       	ldi	r24, 0x00	; 0
    947e:	0e 94 23 39 	call	0x7246	; 0x7246 <timer1_SetPWM_A>
			if(ButtonStateTest.rightIndicator){
    9482:	80 91 48 08 	lds	r24, 0x0848
    9486:	88 23       	and	r24, r24
    9488:	21 f0       	breq	.+8      	; 0x9492 <Task2_Func+0x2a>
				//				SET_BIT(PORTB,5);
				timer1_SetPWM_B((255));
    948a:	8f ef       	ldi	r24, 0xFF	; 255
    948c:	0e 94 d0 38 	call	0x71a0	; 0x71a0 <timer1_SetPWM_B>
    9490:	ef cf       	rjmp	.-34     	; 0x9470 <Task2_Func+0x8>
				//				vTaskDelayUntil( &xLastWakeTime2, xPeriod2 );
				//				timer1_SetPWM_B((0));
			}
			else{
				timer1_SetPWM_B((0));
    9492:	80 e0       	ldi	r24, 0x00	; 0
    9494:	0e 94 d0 38 	call	0x71a0	; 0x71a0 <timer1_SetPWM_B>
    9498:	eb cf       	rjmp	.-42     	; 0x9470 <Task2_Func+0x8>

0000949a <Poll>:

int polling_enabled= 1;
int polling_counter= 1;
int counter = 0 ;
void Poll(void)
{
    949a:	df 93       	push	r29
    949c:	cf 93       	push	r28
    949e:	00 d0       	rcall	.+0      	; 0x94a0 <Poll+0x6>
    94a0:	00 d0       	rcall	.+0      	; 0x94a2 <Poll+0x8>
    94a2:	cd b7       	in	r28, 0x3d	; 61
    94a4:	de b7       	in	r29, 0x3e	; 62
	if(polling_enabled && (!counter))
    94a6:	80 91 93 01 	lds	r24, 0x0193
    94aa:	90 91 94 01 	lds	r25, 0x0194
    94ae:	00 97       	sbiw	r24, 0x00	; 0
    94b0:	91 f0       	breq	.+36     	; 0x94d6 <Poll+0x3c>
    94b2:	80 91 4b 08 	lds	r24, 0x084B
    94b6:	90 91 4c 08 	lds	r25, 0x084C
    94ba:	00 97       	sbiw	r24, 0x00	; 0
    94bc:	61 f4       	brne	.+24     	; 0x94d6 <Poll+0x3c>
	{
		States_GroupType data;
		data = Get_Data();
    94be:	0e 94 eb 39 	call	0x73d6	; 0x73d6 <Get_Data>
    94c2:	dc 01       	movw	r26, r24
    94c4:	cb 01       	movw	r24, r22
    94c6:	89 83       	std	Y+1, r24	; 0x01
    94c8:	9a 83       	std	Y+2, r25	; 0x02
    94ca:	ab 83       	std	Y+3, r26	; 0x03
    94cc:	bc 83       	std	Y+4, r27	; 0x04
		Handle_data(&data);
    94ce:	ce 01       	movw	r24, r28
    94d0:	01 96       	adiw	r24, 0x01	; 1
    94d2:	0e 94 67 34 	call	0x68ce	; 0x68ce <Handle_data>

	}
	counter++;
    94d6:	80 91 4b 08 	lds	r24, 0x084B
    94da:	90 91 4c 08 	lds	r25, 0x084C
    94de:	01 96       	adiw	r24, 0x01	; 1
    94e0:	90 93 4c 08 	sts	0x084C, r25
    94e4:	80 93 4b 08 	sts	0x084B, r24
	counter = counter%polling_counter;
    94e8:	80 91 4b 08 	lds	r24, 0x084B
    94ec:	90 91 4c 08 	lds	r25, 0x084C
    94f0:	20 91 95 01 	lds	r18, 0x0195
    94f4:	30 91 96 01 	lds	r19, 0x0196
    94f8:	b9 01       	movw	r22, r18
    94fa:	0e 94 ce 4a 	call	0x959c	; 0x959c <__divmodhi4>
    94fe:	90 93 4c 08 	sts	0x084C, r25
    9502:	80 93 4b 08 	sts	0x084B, r24
}
    9506:	0f 90       	pop	r0
    9508:	0f 90       	pop	r0
    950a:	0f 90       	pop	r0
    950c:	0f 90       	pop	r0
    950e:	cf 91       	pop	r28
    9510:	df 91       	pop	r29
    9512:	08 95       	ret

00009514 <StartPolling>:

void StartPolling(void)
{
    9514:	df 93       	push	r29
    9516:	cf 93       	push	r28
    9518:	cd b7       	in	r28, 0x3d	; 61
    951a:	de b7       	in	r29, 0x3e	; 62
	polling_enabled=1;
    951c:	81 e0       	ldi	r24, 0x01	; 1
    951e:	90 e0       	ldi	r25, 0x00	; 0
    9520:	90 93 94 01 	sts	0x0194, r25
    9524:	80 93 93 01 	sts	0x0193, r24
}
    9528:	cf 91       	pop	r28
    952a:	df 91       	pop	r29
    952c:	08 95       	ret

0000952e <StopPolling>:

void StopPolling(void)
{
    952e:	df 93       	push	r29
    9530:	cf 93       	push	r28
    9532:	cd b7       	in	r28, 0x3d	; 61
    9534:	de b7       	in	r29, 0x3e	; 62
	polling_enabled=0;
    9536:	10 92 94 01 	sts	0x0194, r1
    953a:	10 92 93 01 	sts	0x0193, r1
}
    953e:	cf 91       	pop	r28
    9540:	df 91       	pop	r29
    9542:	08 95       	ret

00009544 <SetPollingTime>:

void SetPollingTime(int polling_time)
{
    9544:	df 93       	push	r29
    9546:	cf 93       	push	r28
    9548:	00 d0       	rcall	.+0      	; 0x954a <SetPollingTime+0x6>
    954a:	cd b7       	in	r28, 0x3d	; 61
    954c:	de b7       	in	r29, 0x3e	; 62
    954e:	9a 83       	std	Y+2, r25	; 0x02
    9550:	89 83       	std	Y+1, r24	; 0x01
	polling_counter = polling_time/(50*2);
    9552:	89 81       	ldd	r24, Y+1	; 0x01
    9554:	9a 81       	ldd	r25, Y+2	; 0x02
    9556:	24 e6       	ldi	r18, 0x64	; 100
    9558:	30 e0       	ldi	r19, 0x00	; 0
    955a:	b9 01       	movw	r22, r18
    955c:	0e 94 ce 4a 	call	0x959c	; 0x959c <__divmodhi4>
    9560:	cb 01       	movw	r24, r22
    9562:	90 93 96 01 	sts	0x0196, r25
    9566:	80 93 95 01 	sts	0x0195, r24
	 *
	 *
	 *
	 *
	 * */
}
    956a:	0f 90       	pop	r0
    956c:	0f 90       	pop	r0
    956e:	cf 91       	pop	r28
    9570:	df 91       	pop	r29
    9572:	08 95       	ret

00009574 <__udivmodhi4>:
    9574:	aa 1b       	sub	r26, r26
    9576:	bb 1b       	sub	r27, r27
    9578:	51 e1       	ldi	r21, 0x11	; 17
    957a:	07 c0       	rjmp	.+14     	; 0x958a <__udivmodhi4_ep>

0000957c <__udivmodhi4_loop>:
    957c:	aa 1f       	adc	r26, r26
    957e:	bb 1f       	adc	r27, r27
    9580:	a6 17       	cp	r26, r22
    9582:	b7 07       	cpc	r27, r23
    9584:	10 f0       	brcs	.+4      	; 0x958a <__udivmodhi4_ep>
    9586:	a6 1b       	sub	r26, r22
    9588:	b7 0b       	sbc	r27, r23

0000958a <__udivmodhi4_ep>:
    958a:	88 1f       	adc	r24, r24
    958c:	99 1f       	adc	r25, r25
    958e:	5a 95       	dec	r21
    9590:	a9 f7       	brne	.-22     	; 0x957c <__udivmodhi4_loop>
    9592:	80 95       	com	r24
    9594:	90 95       	com	r25
    9596:	bc 01       	movw	r22, r24
    9598:	cd 01       	movw	r24, r26
    959a:	08 95       	ret

0000959c <__divmodhi4>:
    959c:	97 fb       	bst	r25, 7
    959e:	09 2e       	mov	r0, r25
    95a0:	07 26       	eor	r0, r23
    95a2:	0a d0       	rcall	.+20     	; 0x95b8 <__divmodhi4_neg1>
    95a4:	77 fd       	sbrc	r23, 7
    95a6:	04 d0       	rcall	.+8      	; 0x95b0 <__divmodhi4_neg2>
    95a8:	e5 df       	rcall	.-54     	; 0x9574 <__udivmodhi4>
    95aa:	06 d0       	rcall	.+12     	; 0x95b8 <__divmodhi4_neg1>
    95ac:	00 20       	and	r0, r0
    95ae:	1a f4       	brpl	.+6      	; 0x95b6 <__divmodhi4_exit>

000095b0 <__divmodhi4_neg2>:
    95b0:	70 95       	com	r23
    95b2:	61 95       	neg	r22
    95b4:	7f 4f       	sbci	r23, 0xFF	; 255

000095b6 <__divmodhi4_exit>:
    95b6:	08 95       	ret

000095b8 <__divmodhi4_neg1>:
    95b8:	f6 f7       	brtc	.-4      	; 0x95b6 <__divmodhi4_exit>
    95ba:	90 95       	com	r25
    95bc:	81 95       	neg	r24
    95be:	9f 4f       	sbci	r25, 0xFF	; 255
    95c0:	08 95       	ret

000095c2 <__prologue_saves__>:
    95c2:	2f 92       	push	r2
    95c4:	3f 92       	push	r3
    95c6:	4f 92       	push	r4
    95c8:	5f 92       	push	r5
    95ca:	6f 92       	push	r6
    95cc:	7f 92       	push	r7
    95ce:	8f 92       	push	r8
    95d0:	9f 92       	push	r9
    95d2:	af 92       	push	r10
    95d4:	bf 92       	push	r11
    95d6:	cf 92       	push	r12
    95d8:	df 92       	push	r13
    95da:	ef 92       	push	r14
    95dc:	ff 92       	push	r15
    95de:	0f 93       	push	r16
    95e0:	1f 93       	push	r17
    95e2:	cf 93       	push	r28
    95e4:	df 93       	push	r29
    95e6:	cd b7       	in	r28, 0x3d	; 61
    95e8:	de b7       	in	r29, 0x3e	; 62
    95ea:	ca 1b       	sub	r28, r26
    95ec:	db 0b       	sbc	r29, r27
    95ee:	0f b6       	in	r0, 0x3f	; 63
    95f0:	f8 94       	cli
    95f2:	de bf       	out	0x3e, r29	; 62
    95f4:	0f be       	out	0x3f, r0	; 63
    95f6:	cd bf       	out	0x3d, r28	; 61
    95f8:	09 94       	ijmp

000095fa <__epilogue_restores__>:
    95fa:	2a 88       	ldd	r2, Y+18	; 0x12
    95fc:	39 88       	ldd	r3, Y+17	; 0x11
    95fe:	48 88       	ldd	r4, Y+16	; 0x10
    9600:	5f 84       	ldd	r5, Y+15	; 0x0f
    9602:	6e 84       	ldd	r6, Y+14	; 0x0e
    9604:	7d 84       	ldd	r7, Y+13	; 0x0d
    9606:	8c 84       	ldd	r8, Y+12	; 0x0c
    9608:	9b 84       	ldd	r9, Y+11	; 0x0b
    960a:	aa 84       	ldd	r10, Y+10	; 0x0a
    960c:	b9 84       	ldd	r11, Y+9	; 0x09
    960e:	c8 84       	ldd	r12, Y+8	; 0x08
    9610:	df 80       	ldd	r13, Y+7	; 0x07
    9612:	ee 80       	ldd	r14, Y+6	; 0x06
    9614:	fd 80       	ldd	r15, Y+5	; 0x05
    9616:	0c 81       	ldd	r16, Y+4	; 0x04
    9618:	1b 81       	ldd	r17, Y+3	; 0x03
    961a:	aa 81       	ldd	r26, Y+2	; 0x02
    961c:	b9 81       	ldd	r27, Y+1	; 0x01
    961e:	ce 0f       	add	r28, r30
    9620:	d1 1d       	adc	r29, r1
    9622:	0f b6       	in	r0, 0x3f	; 63
    9624:	f8 94       	cli
    9626:	de bf       	out	0x3e, r29	; 62
    9628:	0f be       	out	0x3f, r0	; 63
    962a:	cd bf       	out	0x3d, r28	; 61
    962c:	ed 01       	movw	r28, r26
    962e:	08 95       	ret

00009630 <memcpy>:
    9630:	fb 01       	movw	r30, r22
    9632:	dc 01       	movw	r26, r24
    9634:	02 c0       	rjmp	.+4      	; 0x963a <memcpy+0xa>
    9636:	01 90       	ld	r0, Z+
    9638:	0d 92       	st	X+, r0
    963a:	41 50       	subi	r20, 0x01	; 1
    963c:	50 40       	sbci	r21, 0x00	; 0
    963e:	d8 f7       	brcc	.-10     	; 0x9636 <memcpy+0x6>
    9640:	08 95       	ret

00009642 <memset>:
    9642:	dc 01       	movw	r26, r24
    9644:	01 c0       	rjmp	.+2      	; 0x9648 <memset+0x6>
    9646:	6d 93       	st	X+, r22
    9648:	41 50       	subi	r20, 0x01	; 1
    964a:	50 40       	sbci	r21, 0x00	; 0
    964c:	e0 f7       	brcc	.-8      	; 0x9646 <memset+0x4>
    964e:	08 95       	ret

00009650 <itoa>:
    9650:	fb 01       	movw	r30, r22
    9652:	9f 01       	movw	r18, r30
    9654:	e8 94       	clt
    9656:	42 30       	cpi	r20, 0x02	; 2
    9658:	c4 f0       	brlt	.+48     	; 0x968a <itoa+0x3a>
    965a:	45 32       	cpi	r20, 0x25	; 37
    965c:	b4 f4       	brge	.+44     	; 0x968a <itoa+0x3a>
    965e:	4a 30       	cpi	r20, 0x0A	; 10
    9660:	29 f4       	brne	.+10     	; 0x966c <itoa+0x1c>
    9662:	97 fb       	bst	r25, 7
    9664:	1e f4       	brtc	.+6      	; 0x966c <itoa+0x1c>
    9666:	90 95       	com	r25
    9668:	81 95       	neg	r24
    966a:	9f 4f       	sbci	r25, 0xFF	; 255
    966c:	64 2f       	mov	r22, r20
    966e:	77 27       	eor	r23, r23
    9670:	0e 94 ba 4a 	call	0x9574	; 0x9574 <__udivmodhi4>
    9674:	80 5d       	subi	r24, 0xD0	; 208
    9676:	8a 33       	cpi	r24, 0x3A	; 58
    9678:	0c f0       	brlt	.+2      	; 0x967c <itoa+0x2c>
    967a:	89 5d       	subi	r24, 0xD9	; 217
    967c:	81 93       	st	Z+, r24
    967e:	cb 01       	movw	r24, r22
    9680:	00 97       	sbiw	r24, 0x00	; 0
    9682:	a1 f7       	brne	.-24     	; 0x966c <itoa+0x1c>
    9684:	16 f4       	brtc	.+4      	; 0x968a <itoa+0x3a>
    9686:	5d e2       	ldi	r21, 0x2D	; 45
    9688:	51 93       	st	Z+, r21
    968a:	10 82       	st	Z, r1
    968c:	c9 01       	movw	r24, r18
    968e:	0c 94 49 4b 	jmp	0x9692	; 0x9692 <strrev>

00009692 <strrev>:
    9692:	dc 01       	movw	r26, r24
    9694:	fc 01       	movw	r30, r24
    9696:	67 2f       	mov	r22, r23
    9698:	71 91       	ld	r23, Z+
    969a:	77 23       	and	r23, r23
    969c:	e1 f7       	brne	.-8      	; 0x9696 <strrev+0x4>
    969e:	32 97       	sbiw	r30, 0x02	; 2
    96a0:	04 c0       	rjmp	.+8      	; 0x96aa <strrev+0x18>
    96a2:	7c 91       	ld	r23, X
    96a4:	6d 93       	st	X+, r22
    96a6:	70 83       	st	Z, r23
    96a8:	62 91       	ld	r22, -Z
    96aa:	ae 17       	cp	r26, r30
    96ac:	bf 07       	cpc	r27, r31
    96ae:	c8 f3       	brcs	.-14     	; 0x96a2 <strrev+0x10>
    96b0:	08 95       	ret

000096b2 <_exit>:
    96b2:	f8 94       	cli

000096b4 <__stop_program>:
    96b4:	ff cf       	rjmp	.-2      	; 0x96b4 <__stop_program>
