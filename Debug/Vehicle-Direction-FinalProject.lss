
Vehicle-Direction-FinalProject.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000142  00800100  000092a2  00009336  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000092a2  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          000006b2  00800242  00800242  00009478  2**0
                  ALLOC
  3 .stab         0000b25c  00000000  00000000  00009478  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00006678  00000000  00000000  000146d4  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 000001a0  00000000  00000000  0001ad4c  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_pubnames 000001f2  00000000  00000000  0001aeec  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   0000240b  00000000  00000000  0001b0de  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00001386  00000000  00000000  0001d4e9  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   000011d6  00000000  00000000  0001e86f  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  000001c0  00000000  00000000  0001fa48  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    000002f6  00000000  00000000  0001fc08  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    0000096e  00000000  00000000  0001fefe  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000050  00000000  00000000  0002086c  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 46 00 	jmp	0x8c	; 0x8c <__ctors_end>
       4:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
       8:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
       c:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
      10:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
      14:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
      18:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
      1c:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
      20:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
      24:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
      28:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
      2c:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
      30:	0c 94 84 0a 	jmp	0x1508	; 0x1508 <__vector_12>
      34:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
      38:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
      3c:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
      40:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
      44:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
      48:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
      4c:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
      50:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
      54:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
      58:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
      5c:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
      60:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
      64:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
      68:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
      6c:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
      70:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
      74:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
      78:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
      7c:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
      80:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
      84:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
      88:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>

0000008c <__ctors_end>:
      8c:	11 24       	eor	r1, r1
      8e:	1f be       	out	0x3f, r1	; 63
      90:	cf ef       	ldi	r28, 0xFF	; 255
      92:	d0 e1       	ldi	r29, 0x10	; 16
      94:	de bf       	out	0x3e, r29	; 62
      96:	cd bf       	out	0x3d, r28	; 61

00000098 <__do_copy_data>:
      98:	12 e0       	ldi	r17, 0x02	; 2
      9a:	a0 e0       	ldi	r26, 0x00	; 0
      9c:	b1 e0       	ldi	r27, 0x01	; 1
      9e:	e2 ea       	ldi	r30, 0xA2	; 162
      a0:	f2 e9       	ldi	r31, 0x92	; 146
      a2:	02 c0       	rjmp	.+4      	; 0xa8 <.do_copy_data_start>

000000a4 <.do_copy_data_loop>:
      a4:	05 90       	lpm	r0, Z+
      a6:	0d 92       	st	X+, r0

000000a8 <.do_copy_data_start>:
      a8:	a2 34       	cpi	r26, 0x42	; 66
      aa:	b1 07       	cpc	r27, r17
      ac:	d9 f7       	brne	.-10     	; 0xa4 <.do_copy_data_loop>

000000ae <__do_clear_bss>:
      ae:	18 e0       	ldi	r17, 0x08	; 8
      b0:	a2 e4       	ldi	r26, 0x42	; 66
      b2:	b2 e0       	ldi	r27, 0x02	; 2
      b4:	01 c0       	rjmp	.+2      	; 0xb8 <.do_clear_bss_start>

000000b6 <.do_clear_bss_loop>:
      b6:	1d 92       	st	X+, r1

000000b8 <.do_clear_bss_start>:
      b8:	a4 3f       	cpi	r26, 0xF4	; 244
      ba:	b1 07       	cpc	r27, r17
      bc:	e1 f7       	brne	.-8      	; 0xb6 <.do_clear_bss_loop>
      be:	0e 94 8b 47 	call	0x8f16	; 0x8f16 <main>
      c2:	0c 94 4f 49 	jmp	0x929e	; 0x929e <_exit>

000000c6 <__bad_interrupt>:
      c6:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000ca <__fixunssfsi>:
      ca:	ef 92       	push	r14
      cc:	ff 92       	push	r15
      ce:	0f 93       	push	r16
      d0:	1f 93       	push	r17
      d2:	7b 01       	movw	r14, r22
      d4:	8c 01       	movw	r16, r24
      d6:	20 e0       	ldi	r18, 0x00	; 0
      d8:	30 e0       	ldi	r19, 0x00	; 0
      da:	40 e0       	ldi	r20, 0x00	; 0
      dc:	5f e4       	ldi	r21, 0x4F	; 79
      de:	0e 94 11 04 	call	0x822	; 0x822 <__gesf2>
      e2:	88 23       	and	r24, r24
      e4:	8c f0       	brlt	.+34     	; 0x108 <__fixunssfsi+0x3e>
      e6:	c8 01       	movw	r24, r16
      e8:	b7 01       	movw	r22, r14
      ea:	20 e0       	ldi	r18, 0x00	; 0
      ec:	30 e0       	ldi	r19, 0x00	; 0
      ee:	40 e0       	ldi	r20, 0x00	; 0
      f0:	5f e4       	ldi	r21, 0x4F	; 79
      f2:	0e 94 dd 01 	call	0x3ba	; 0x3ba <__subsf3>
      f6:	0e 94 71 04 	call	0x8e2	; 0x8e2 <__fixsfsi>
      fa:	9b 01       	movw	r18, r22
      fc:	ac 01       	movw	r20, r24
      fe:	20 50       	subi	r18, 0x00	; 0
     100:	30 40       	sbci	r19, 0x00	; 0
     102:	40 40       	sbci	r20, 0x00	; 0
     104:	50 48       	sbci	r21, 0x80	; 128
     106:	06 c0       	rjmp	.+12     	; 0x114 <__fixunssfsi+0x4a>
     108:	c8 01       	movw	r24, r16
     10a:	b7 01       	movw	r22, r14
     10c:	0e 94 71 04 	call	0x8e2	; 0x8e2 <__fixsfsi>
     110:	9b 01       	movw	r18, r22
     112:	ac 01       	movw	r20, r24
     114:	b9 01       	movw	r22, r18
     116:	ca 01       	movw	r24, r20
     118:	1f 91       	pop	r17
     11a:	0f 91       	pop	r16
     11c:	ff 90       	pop	r15
     11e:	ef 90       	pop	r14
     120:	08 95       	ret

00000122 <_fpadd_parts>:
     122:	a0 e0       	ldi	r26, 0x00	; 0
     124:	b0 e0       	ldi	r27, 0x00	; 0
     126:	e7 e9       	ldi	r30, 0x97	; 151
     128:	f0 e0       	ldi	r31, 0x00	; 0
     12a:	0c 94 d7 48 	jmp	0x91ae	; 0x91ae <__prologue_saves__>
     12e:	dc 01       	movw	r26, r24
     130:	2b 01       	movw	r4, r22
     132:	fa 01       	movw	r30, r20
     134:	9c 91       	ld	r25, X
     136:	92 30       	cpi	r25, 0x02	; 2
     138:	08 f4       	brcc	.+2      	; 0x13c <_fpadd_parts+0x1a>
     13a:	39 c1       	rjmp	.+626    	; 0x3ae <_fpadd_parts+0x28c>
     13c:	eb 01       	movw	r28, r22
     13e:	88 81       	ld	r24, Y
     140:	82 30       	cpi	r24, 0x02	; 2
     142:	08 f4       	brcc	.+2      	; 0x146 <_fpadd_parts+0x24>
     144:	33 c1       	rjmp	.+614    	; 0x3ac <_fpadd_parts+0x28a>
     146:	94 30       	cpi	r25, 0x04	; 4
     148:	69 f4       	brne	.+26     	; 0x164 <_fpadd_parts+0x42>
     14a:	84 30       	cpi	r24, 0x04	; 4
     14c:	09 f0       	breq	.+2      	; 0x150 <_fpadd_parts+0x2e>
     14e:	2f c1       	rjmp	.+606    	; 0x3ae <_fpadd_parts+0x28c>
     150:	11 96       	adiw	r26, 0x01	; 1
     152:	9c 91       	ld	r25, X
     154:	11 97       	sbiw	r26, 0x01	; 1
     156:	89 81       	ldd	r24, Y+1	; 0x01
     158:	98 17       	cp	r25, r24
     15a:	09 f4       	brne	.+2      	; 0x15e <_fpadd_parts+0x3c>
     15c:	28 c1       	rjmp	.+592    	; 0x3ae <_fpadd_parts+0x28c>
     15e:	a1 e2       	ldi	r26, 0x21	; 33
     160:	b1 e0       	ldi	r27, 0x01	; 1
     162:	25 c1       	rjmp	.+586    	; 0x3ae <_fpadd_parts+0x28c>
     164:	84 30       	cpi	r24, 0x04	; 4
     166:	09 f4       	brne	.+2      	; 0x16a <_fpadd_parts+0x48>
     168:	21 c1       	rjmp	.+578    	; 0x3ac <_fpadd_parts+0x28a>
     16a:	82 30       	cpi	r24, 0x02	; 2
     16c:	a9 f4       	brne	.+42     	; 0x198 <_fpadd_parts+0x76>
     16e:	92 30       	cpi	r25, 0x02	; 2
     170:	09 f0       	breq	.+2      	; 0x174 <_fpadd_parts+0x52>
     172:	1d c1       	rjmp	.+570    	; 0x3ae <_fpadd_parts+0x28c>
     174:	9a 01       	movw	r18, r20
     176:	ad 01       	movw	r20, r26
     178:	88 e0       	ldi	r24, 0x08	; 8
     17a:	ea 01       	movw	r28, r20
     17c:	09 90       	ld	r0, Y+
     17e:	ae 01       	movw	r20, r28
     180:	e9 01       	movw	r28, r18
     182:	09 92       	st	Y+, r0
     184:	9e 01       	movw	r18, r28
     186:	81 50       	subi	r24, 0x01	; 1
     188:	c1 f7       	brne	.-16     	; 0x17a <_fpadd_parts+0x58>
     18a:	e2 01       	movw	r28, r4
     18c:	89 81       	ldd	r24, Y+1	; 0x01
     18e:	11 96       	adiw	r26, 0x01	; 1
     190:	9c 91       	ld	r25, X
     192:	89 23       	and	r24, r25
     194:	81 83       	std	Z+1, r24	; 0x01
     196:	08 c1       	rjmp	.+528    	; 0x3a8 <_fpadd_parts+0x286>
     198:	92 30       	cpi	r25, 0x02	; 2
     19a:	09 f4       	brne	.+2      	; 0x19e <_fpadd_parts+0x7c>
     19c:	07 c1       	rjmp	.+526    	; 0x3ac <_fpadd_parts+0x28a>
     19e:	12 96       	adiw	r26, 0x02	; 2
     1a0:	2d 90       	ld	r2, X+
     1a2:	3c 90       	ld	r3, X
     1a4:	13 97       	sbiw	r26, 0x03	; 3
     1a6:	eb 01       	movw	r28, r22
     1a8:	8a 81       	ldd	r24, Y+2	; 0x02
     1aa:	9b 81       	ldd	r25, Y+3	; 0x03
     1ac:	14 96       	adiw	r26, 0x04	; 4
     1ae:	ad 90       	ld	r10, X+
     1b0:	bd 90       	ld	r11, X+
     1b2:	cd 90       	ld	r12, X+
     1b4:	dc 90       	ld	r13, X
     1b6:	17 97       	sbiw	r26, 0x07	; 7
     1b8:	ec 80       	ldd	r14, Y+4	; 0x04
     1ba:	fd 80       	ldd	r15, Y+5	; 0x05
     1bc:	0e 81       	ldd	r16, Y+6	; 0x06
     1be:	1f 81       	ldd	r17, Y+7	; 0x07
     1c0:	91 01       	movw	r18, r2
     1c2:	28 1b       	sub	r18, r24
     1c4:	39 0b       	sbc	r19, r25
     1c6:	b9 01       	movw	r22, r18
     1c8:	37 ff       	sbrs	r19, 7
     1ca:	04 c0       	rjmp	.+8      	; 0x1d4 <_fpadd_parts+0xb2>
     1cc:	66 27       	eor	r22, r22
     1ce:	77 27       	eor	r23, r23
     1d0:	62 1b       	sub	r22, r18
     1d2:	73 0b       	sbc	r23, r19
     1d4:	60 32       	cpi	r22, 0x20	; 32
     1d6:	71 05       	cpc	r23, r1
     1d8:	0c f0       	brlt	.+2      	; 0x1dc <_fpadd_parts+0xba>
     1da:	61 c0       	rjmp	.+194    	; 0x29e <_fpadd_parts+0x17c>
     1dc:	12 16       	cp	r1, r18
     1de:	13 06       	cpc	r1, r19
     1e0:	6c f5       	brge	.+90     	; 0x23c <_fpadd_parts+0x11a>
     1e2:	37 01       	movw	r6, r14
     1e4:	48 01       	movw	r8, r16
     1e6:	06 2e       	mov	r0, r22
     1e8:	04 c0       	rjmp	.+8      	; 0x1f2 <_fpadd_parts+0xd0>
     1ea:	96 94       	lsr	r9
     1ec:	87 94       	ror	r8
     1ee:	77 94       	ror	r7
     1f0:	67 94       	ror	r6
     1f2:	0a 94       	dec	r0
     1f4:	d2 f7       	brpl	.-12     	; 0x1ea <_fpadd_parts+0xc8>
     1f6:	21 e0       	ldi	r18, 0x01	; 1
     1f8:	30 e0       	ldi	r19, 0x00	; 0
     1fa:	40 e0       	ldi	r20, 0x00	; 0
     1fc:	50 e0       	ldi	r21, 0x00	; 0
     1fe:	04 c0       	rjmp	.+8      	; 0x208 <_fpadd_parts+0xe6>
     200:	22 0f       	add	r18, r18
     202:	33 1f       	adc	r19, r19
     204:	44 1f       	adc	r20, r20
     206:	55 1f       	adc	r21, r21
     208:	6a 95       	dec	r22
     20a:	d2 f7       	brpl	.-12     	; 0x200 <_fpadd_parts+0xde>
     20c:	21 50       	subi	r18, 0x01	; 1
     20e:	30 40       	sbci	r19, 0x00	; 0
     210:	40 40       	sbci	r20, 0x00	; 0
     212:	50 40       	sbci	r21, 0x00	; 0
     214:	2e 21       	and	r18, r14
     216:	3f 21       	and	r19, r15
     218:	40 23       	and	r20, r16
     21a:	51 23       	and	r21, r17
     21c:	21 15       	cp	r18, r1
     21e:	31 05       	cpc	r19, r1
     220:	41 05       	cpc	r20, r1
     222:	51 05       	cpc	r21, r1
     224:	21 f0       	breq	.+8      	; 0x22e <_fpadd_parts+0x10c>
     226:	21 e0       	ldi	r18, 0x01	; 1
     228:	30 e0       	ldi	r19, 0x00	; 0
     22a:	40 e0       	ldi	r20, 0x00	; 0
     22c:	50 e0       	ldi	r21, 0x00	; 0
     22e:	79 01       	movw	r14, r18
     230:	8a 01       	movw	r16, r20
     232:	e6 28       	or	r14, r6
     234:	f7 28       	or	r15, r7
     236:	08 29       	or	r16, r8
     238:	19 29       	or	r17, r9
     23a:	3c c0       	rjmp	.+120    	; 0x2b4 <_fpadd_parts+0x192>
     23c:	23 2b       	or	r18, r19
     23e:	d1 f1       	breq	.+116    	; 0x2b4 <_fpadd_parts+0x192>
     240:	26 0e       	add	r2, r22
     242:	37 1e       	adc	r3, r23
     244:	35 01       	movw	r6, r10
     246:	46 01       	movw	r8, r12
     248:	06 2e       	mov	r0, r22
     24a:	04 c0       	rjmp	.+8      	; 0x254 <_fpadd_parts+0x132>
     24c:	96 94       	lsr	r9
     24e:	87 94       	ror	r8
     250:	77 94       	ror	r7
     252:	67 94       	ror	r6
     254:	0a 94       	dec	r0
     256:	d2 f7       	brpl	.-12     	; 0x24c <_fpadd_parts+0x12a>
     258:	21 e0       	ldi	r18, 0x01	; 1
     25a:	30 e0       	ldi	r19, 0x00	; 0
     25c:	40 e0       	ldi	r20, 0x00	; 0
     25e:	50 e0       	ldi	r21, 0x00	; 0
     260:	04 c0       	rjmp	.+8      	; 0x26a <_fpadd_parts+0x148>
     262:	22 0f       	add	r18, r18
     264:	33 1f       	adc	r19, r19
     266:	44 1f       	adc	r20, r20
     268:	55 1f       	adc	r21, r21
     26a:	6a 95       	dec	r22
     26c:	d2 f7       	brpl	.-12     	; 0x262 <_fpadd_parts+0x140>
     26e:	21 50       	subi	r18, 0x01	; 1
     270:	30 40       	sbci	r19, 0x00	; 0
     272:	40 40       	sbci	r20, 0x00	; 0
     274:	50 40       	sbci	r21, 0x00	; 0
     276:	2a 21       	and	r18, r10
     278:	3b 21       	and	r19, r11
     27a:	4c 21       	and	r20, r12
     27c:	5d 21       	and	r21, r13
     27e:	21 15       	cp	r18, r1
     280:	31 05       	cpc	r19, r1
     282:	41 05       	cpc	r20, r1
     284:	51 05       	cpc	r21, r1
     286:	21 f0       	breq	.+8      	; 0x290 <_fpadd_parts+0x16e>
     288:	21 e0       	ldi	r18, 0x01	; 1
     28a:	30 e0       	ldi	r19, 0x00	; 0
     28c:	40 e0       	ldi	r20, 0x00	; 0
     28e:	50 e0       	ldi	r21, 0x00	; 0
     290:	59 01       	movw	r10, r18
     292:	6a 01       	movw	r12, r20
     294:	a6 28       	or	r10, r6
     296:	b7 28       	or	r11, r7
     298:	c8 28       	or	r12, r8
     29a:	d9 28       	or	r13, r9
     29c:	0b c0       	rjmp	.+22     	; 0x2b4 <_fpadd_parts+0x192>
     29e:	82 15       	cp	r24, r2
     2a0:	93 05       	cpc	r25, r3
     2a2:	2c f0       	brlt	.+10     	; 0x2ae <_fpadd_parts+0x18c>
     2a4:	1c 01       	movw	r2, r24
     2a6:	aa 24       	eor	r10, r10
     2a8:	bb 24       	eor	r11, r11
     2aa:	65 01       	movw	r12, r10
     2ac:	03 c0       	rjmp	.+6      	; 0x2b4 <_fpadd_parts+0x192>
     2ae:	ee 24       	eor	r14, r14
     2b0:	ff 24       	eor	r15, r15
     2b2:	87 01       	movw	r16, r14
     2b4:	11 96       	adiw	r26, 0x01	; 1
     2b6:	9c 91       	ld	r25, X
     2b8:	d2 01       	movw	r26, r4
     2ba:	11 96       	adiw	r26, 0x01	; 1
     2bc:	8c 91       	ld	r24, X
     2be:	98 17       	cp	r25, r24
     2c0:	09 f4       	brne	.+2      	; 0x2c4 <_fpadd_parts+0x1a2>
     2c2:	45 c0       	rjmp	.+138    	; 0x34e <_fpadd_parts+0x22c>
     2c4:	99 23       	and	r25, r25
     2c6:	39 f0       	breq	.+14     	; 0x2d6 <_fpadd_parts+0x1b4>
     2c8:	a8 01       	movw	r20, r16
     2ca:	97 01       	movw	r18, r14
     2cc:	2a 19       	sub	r18, r10
     2ce:	3b 09       	sbc	r19, r11
     2d0:	4c 09       	sbc	r20, r12
     2d2:	5d 09       	sbc	r21, r13
     2d4:	06 c0       	rjmp	.+12     	; 0x2e2 <_fpadd_parts+0x1c0>
     2d6:	a6 01       	movw	r20, r12
     2d8:	95 01       	movw	r18, r10
     2da:	2e 19       	sub	r18, r14
     2dc:	3f 09       	sbc	r19, r15
     2de:	40 0b       	sbc	r20, r16
     2e0:	51 0b       	sbc	r21, r17
     2e2:	57 fd       	sbrc	r21, 7
     2e4:	08 c0       	rjmp	.+16     	; 0x2f6 <_fpadd_parts+0x1d4>
     2e6:	11 82       	std	Z+1, r1	; 0x01
     2e8:	33 82       	std	Z+3, r3	; 0x03
     2ea:	22 82       	std	Z+2, r2	; 0x02
     2ec:	24 83       	std	Z+4, r18	; 0x04
     2ee:	35 83       	std	Z+5, r19	; 0x05
     2f0:	46 83       	std	Z+6, r20	; 0x06
     2f2:	57 83       	std	Z+7, r21	; 0x07
     2f4:	1d c0       	rjmp	.+58     	; 0x330 <_fpadd_parts+0x20e>
     2f6:	81 e0       	ldi	r24, 0x01	; 1
     2f8:	81 83       	std	Z+1, r24	; 0x01
     2fa:	33 82       	std	Z+3, r3	; 0x03
     2fc:	22 82       	std	Z+2, r2	; 0x02
     2fe:	88 27       	eor	r24, r24
     300:	99 27       	eor	r25, r25
     302:	dc 01       	movw	r26, r24
     304:	82 1b       	sub	r24, r18
     306:	93 0b       	sbc	r25, r19
     308:	a4 0b       	sbc	r26, r20
     30a:	b5 0b       	sbc	r27, r21
     30c:	84 83       	std	Z+4, r24	; 0x04
     30e:	95 83       	std	Z+5, r25	; 0x05
     310:	a6 83       	std	Z+6, r26	; 0x06
     312:	b7 83       	std	Z+7, r27	; 0x07
     314:	0d c0       	rjmp	.+26     	; 0x330 <_fpadd_parts+0x20e>
     316:	22 0f       	add	r18, r18
     318:	33 1f       	adc	r19, r19
     31a:	44 1f       	adc	r20, r20
     31c:	55 1f       	adc	r21, r21
     31e:	24 83       	std	Z+4, r18	; 0x04
     320:	35 83       	std	Z+5, r19	; 0x05
     322:	46 83       	std	Z+6, r20	; 0x06
     324:	57 83       	std	Z+7, r21	; 0x07
     326:	82 81       	ldd	r24, Z+2	; 0x02
     328:	93 81       	ldd	r25, Z+3	; 0x03
     32a:	01 97       	sbiw	r24, 0x01	; 1
     32c:	93 83       	std	Z+3, r25	; 0x03
     32e:	82 83       	std	Z+2, r24	; 0x02
     330:	24 81       	ldd	r18, Z+4	; 0x04
     332:	35 81       	ldd	r19, Z+5	; 0x05
     334:	46 81       	ldd	r20, Z+6	; 0x06
     336:	57 81       	ldd	r21, Z+7	; 0x07
     338:	da 01       	movw	r26, r20
     33a:	c9 01       	movw	r24, r18
     33c:	01 97       	sbiw	r24, 0x01	; 1
     33e:	a1 09       	sbc	r26, r1
     340:	b1 09       	sbc	r27, r1
     342:	8f 5f       	subi	r24, 0xFF	; 255
     344:	9f 4f       	sbci	r25, 0xFF	; 255
     346:	af 4f       	sbci	r26, 0xFF	; 255
     348:	bf 43       	sbci	r27, 0x3F	; 63
     34a:	28 f3       	brcs	.-54     	; 0x316 <_fpadd_parts+0x1f4>
     34c:	0b c0       	rjmp	.+22     	; 0x364 <_fpadd_parts+0x242>
     34e:	91 83       	std	Z+1, r25	; 0x01
     350:	33 82       	std	Z+3, r3	; 0x03
     352:	22 82       	std	Z+2, r2	; 0x02
     354:	ea 0c       	add	r14, r10
     356:	fb 1c       	adc	r15, r11
     358:	0c 1d       	adc	r16, r12
     35a:	1d 1d       	adc	r17, r13
     35c:	e4 82       	std	Z+4, r14	; 0x04
     35e:	f5 82       	std	Z+5, r15	; 0x05
     360:	06 83       	std	Z+6, r16	; 0x06
     362:	17 83       	std	Z+7, r17	; 0x07
     364:	83 e0       	ldi	r24, 0x03	; 3
     366:	80 83       	st	Z, r24
     368:	24 81       	ldd	r18, Z+4	; 0x04
     36a:	35 81       	ldd	r19, Z+5	; 0x05
     36c:	46 81       	ldd	r20, Z+6	; 0x06
     36e:	57 81       	ldd	r21, Z+7	; 0x07
     370:	57 ff       	sbrs	r21, 7
     372:	1a c0       	rjmp	.+52     	; 0x3a8 <_fpadd_parts+0x286>
     374:	c9 01       	movw	r24, r18
     376:	aa 27       	eor	r26, r26
     378:	97 fd       	sbrc	r25, 7
     37a:	a0 95       	com	r26
     37c:	ba 2f       	mov	r27, r26
     37e:	81 70       	andi	r24, 0x01	; 1
     380:	90 70       	andi	r25, 0x00	; 0
     382:	a0 70       	andi	r26, 0x00	; 0
     384:	b0 70       	andi	r27, 0x00	; 0
     386:	56 95       	lsr	r21
     388:	47 95       	ror	r20
     38a:	37 95       	ror	r19
     38c:	27 95       	ror	r18
     38e:	82 2b       	or	r24, r18
     390:	93 2b       	or	r25, r19
     392:	a4 2b       	or	r26, r20
     394:	b5 2b       	or	r27, r21
     396:	84 83       	std	Z+4, r24	; 0x04
     398:	95 83       	std	Z+5, r25	; 0x05
     39a:	a6 83       	std	Z+6, r26	; 0x06
     39c:	b7 83       	std	Z+7, r27	; 0x07
     39e:	82 81       	ldd	r24, Z+2	; 0x02
     3a0:	93 81       	ldd	r25, Z+3	; 0x03
     3a2:	01 96       	adiw	r24, 0x01	; 1
     3a4:	93 83       	std	Z+3, r25	; 0x03
     3a6:	82 83       	std	Z+2, r24	; 0x02
     3a8:	df 01       	movw	r26, r30
     3aa:	01 c0       	rjmp	.+2      	; 0x3ae <_fpadd_parts+0x28c>
     3ac:	d2 01       	movw	r26, r4
     3ae:	cd 01       	movw	r24, r26
     3b0:	cd b7       	in	r28, 0x3d	; 61
     3b2:	de b7       	in	r29, 0x3e	; 62
     3b4:	e2 e1       	ldi	r30, 0x12	; 18
     3b6:	0c 94 f3 48 	jmp	0x91e6	; 0x91e6 <__epilogue_restores__>

000003ba <__subsf3>:
     3ba:	a0 e2       	ldi	r26, 0x20	; 32
     3bc:	b0 e0       	ldi	r27, 0x00	; 0
     3be:	e3 ee       	ldi	r30, 0xE3	; 227
     3c0:	f1 e0       	ldi	r31, 0x01	; 1
     3c2:	0c 94 e3 48 	jmp	0x91c6	; 0x91c6 <__prologue_saves__+0x18>
     3c6:	69 83       	std	Y+1, r22	; 0x01
     3c8:	7a 83       	std	Y+2, r23	; 0x02
     3ca:	8b 83       	std	Y+3, r24	; 0x03
     3cc:	9c 83       	std	Y+4, r25	; 0x04
     3ce:	2d 83       	std	Y+5, r18	; 0x05
     3d0:	3e 83       	std	Y+6, r19	; 0x06
     3d2:	4f 83       	std	Y+7, r20	; 0x07
     3d4:	58 87       	std	Y+8, r21	; 0x08
     3d6:	e9 e0       	ldi	r30, 0x09	; 9
     3d8:	ee 2e       	mov	r14, r30
     3da:	f1 2c       	mov	r15, r1
     3dc:	ec 0e       	add	r14, r28
     3de:	fd 1e       	adc	r15, r29
     3e0:	ce 01       	movw	r24, r28
     3e2:	01 96       	adiw	r24, 0x01	; 1
     3e4:	b7 01       	movw	r22, r14
     3e6:	0e 94 62 06 	call	0xcc4	; 0xcc4 <__unpack_f>
     3ea:	8e 01       	movw	r16, r28
     3ec:	0f 5e       	subi	r16, 0xEF	; 239
     3ee:	1f 4f       	sbci	r17, 0xFF	; 255
     3f0:	ce 01       	movw	r24, r28
     3f2:	05 96       	adiw	r24, 0x05	; 5
     3f4:	b8 01       	movw	r22, r16
     3f6:	0e 94 62 06 	call	0xcc4	; 0xcc4 <__unpack_f>
     3fa:	8a 89       	ldd	r24, Y+18	; 0x12
     3fc:	91 e0       	ldi	r25, 0x01	; 1
     3fe:	89 27       	eor	r24, r25
     400:	8a 8b       	std	Y+18, r24	; 0x12
     402:	c7 01       	movw	r24, r14
     404:	b8 01       	movw	r22, r16
     406:	ae 01       	movw	r20, r28
     408:	47 5e       	subi	r20, 0xE7	; 231
     40a:	5f 4f       	sbci	r21, 0xFF	; 255
     40c:	0e 94 91 00 	call	0x122	; 0x122 <_fpadd_parts>
     410:	0e 94 8d 05 	call	0xb1a	; 0xb1a <__pack_f>
     414:	a0 96       	adiw	r28, 0x20	; 32
     416:	e6 e0       	ldi	r30, 0x06	; 6
     418:	0c 94 ff 48 	jmp	0x91fe	; 0x91fe <__epilogue_restores__+0x18>

0000041c <__addsf3>:
     41c:	a0 e2       	ldi	r26, 0x20	; 32
     41e:	b0 e0       	ldi	r27, 0x00	; 0
     420:	e4 e1       	ldi	r30, 0x14	; 20
     422:	f2 e0       	ldi	r31, 0x02	; 2
     424:	0c 94 e3 48 	jmp	0x91c6	; 0x91c6 <__prologue_saves__+0x18>
     428:	69 83       	std	Y+1, r22	; 0x01
     42a:	7a 83       	std	Y+2, r23	; 0x02
     42c:	8b 83       	std	Y+3, r24	; 0x03
     42e:	9c 83       	std	Y+4, r25	; 0x04
     430:	2d 83       	std	Y+5, r18	; 0x05
     432:	3e 83       	std	Y+6, r19	; 0x06
     434:	4f 83       	std	Y+7, r20	; 0x07
     436:	58 87       	std	Y+8, r21	; 0x08
     438:	f9 e0       	ldi	r31, 0x09	; 9
     43a:	ef 2e       	mov	r14, r31
     43c:	f1 2c       	mov	r15, r1
     43e:	ec 0e       	add	r14, r28
     440:	fd 1e       	adc	r15, r29
     442:	ce 01       	movw	r24, r28
     444:	01 96       	adiw	r24, 0x01	; 1
     446:	b7 01       	movw	r22, r14
     448:	0e 94 62 06 	call	0xcc4	; 0xcc4 <__unpack_f>
     44c:	8e 01       	movw	r16, r28
     44e:	0f 5e       	subi	r16, 0xEF	; 239
     450:	1f 4f       	sbci	r17, 0xFF	; 255
     452:	ce 01       	movw	r24, r28
     454:	05 96       	adiw	r24, 0x05	; 5
     456:	b8 01       	movw	r22, r16
     458:	0e 94 62 06 	call	0xcc4	; 0xcc4 <__unpack_f>
     45c:	c7 01       	movw	r24, r14
     45e:	b8 01       	movw	r22, r16
     460:	ae 01       	movw	r20, r28
     462:	47 5e       	subi	r20, 0xE7	; 231
     464:	5f 4f       	sbci	r21, 0xFF	; 255
     466:	0e 94 91 00 	call	0x122	; 0x122 <_fpadd_parts>
     46a:	0e 94 8d 05 	call	0xb1a	; 0xb1a <__pack_f>
     46e:	a0 96       	adiw	r28, 0x20	; 32
     470:	e6 e0       	ldi	r30, 0x06	; 6
     472:	0c 94 ff 48 	jmp	0x91fe	; 0x91fe <__epilogue_restores__+0x18>

00000476 <__mulsf3>:
     476:	a0 e2       	ldi	r26, 0x20	; 32
     478:	b0 e0       	ldi	r27, 0x00	; 0
     47a:	e1 e4       	ldi	r30, 0x41	; 65
     47c:	f2 e0       	ldi	r31, 0x02	; 2
     47e:	0c 94 d7 48 	jmp	0x91ae	; 0x91ae <__prologue_saves__>
     482:	69 83       	std	Y+1, r22	; 0x01
     484:	7a 83       	std	Y+2, r23	; 0x02
     486:	8b 83       	std	Y+3, r24	; 0x03
     488:	9c 83       	std	Y+4, r25	; 0x04
     48a:	2d 83       	std	Y+5, r18	; 0x05
     48c:	3e 83       	std	Y+6, r19	; 0x06
     48e:	4f 83       	std	Y+7, r20	; 0x07
     490:	58 87       	std	Y+8, r21	; 0x08
     492:	ce 01       	movw	r24, r28
     494:	01 96       	adiw	r24, 0x01	; 1
     496:	be 01       	movw	r22, r28
     498:	67 5f       	subi	r22, 0xF7	; 247
     49a:	7f 4f       	sbci	r23, 0xFF	; 255
     49c:	0e 94 62 06 	call	0xcc4	; 0xcc4 <__unpack_f>
     4a0:	ce 01       	movw	r24, r28
     4a2:	05 96       	adiw	r24, 0x05	; 5
     4a4:	be 01       	movw	r22, r28
     4a6:	6f 5e       	subi	r22, 0xEF	; 239
     4a8:	7f 4f       	sbci	r23, 0xFF	; 255
     4aa:	0e 94 62 06 	call	0xcc4	; 0xcc4 <__unpack_f>
     4ae:	99 85       	ldd	r25, Y+9	; 0x09
     4b0:	92 30       	cpi	r25, 0x02	; 2
     4b2:	88 f0       	brcs	.+34     	; 0x4d6 <__mulsf3+0x60>
     4b4:	89 89       	ldd	r24, Y+17	; 0x11
     4b6:	82 30       	cpi	r24, 0x02	; 2
     4b8:	c8 f0       	brcs	.+50     	; 0x4ec <__mulsf3+0x76>
     4ba:	94 30       	cpi	r25, 0x04	; 4
     4bc:	19 f4       	brne	.+6      	; 0x4c4 <__mulsf3+0x4e>
     4be:	82 30       	cpi	r24, 0x02	; 2
     4c0:	51 f4       	brne	.+20     	; 0x4d6 <__mulsf3+0x60>
     4c2:	04 c0       	rjmp	.+8      	; 0x4cc <__mulsf3+0x56>
     4c4:	84 30       	cpi	r24, 0x04	; 4
     4c6:	29 f4       	brne	.+10     	; 0x4d2 <__mulsf3+0x5c>
     4c8:	92 30       	cpi	r25, 0x02	; 2
     4ca:	81 f4       	brne	.+32     	; 0x4ec <__mulsf3+0x76>
     4cc:	81 e2       	ldi	r24, 0x21	; 33
     4ce:	91 e0       	ldi	r25, 0x01	; 1
     4d0:	c6 c0       	rjmp	.+396    	; 0x65e <__mulsf3+0x1e8>
     4d2:	92 30       	cpi	r25, 0x02	; 2
     4d4:	49 f4       	brne	.+18     	; 0x4e8 <__mulsf3+0x72>
     4d6:	20 e0       	ldi	r18, 0x00	; 0
     4d8:	9a 85       	ldd	r25, Y+10	; 0x0a
     4da:	8a 89       	ldd	r24, Y+18	; 0x12
     4dc:	98 13       	cpse	r25, r24
     4de:	21 e0       	ldi	r18, 0x01	; 1
     4e0:	2a 87       	std	Y+10, r18	; 0x0a
     4e2:	ce 01       	movw	r24, r28
     4e4:	09 96       	adiw	r24, 0x09	; 9
     4e6:	bb c0       	rjmp	.+374    	; 0x65e <__mulsf3+0x1e8>
     4e8:	82 30       	cpi	r24, 0x02	; 2
     4ea:	49 f4       	brne	.+18     	; 0x4fe <__mulsf3+0x88>
     4ec:	20 e0       	ldi	r18, 0x00	; 0
     4ee:	9a 85       	ldd	r25, Y+10	; 0x0a
     4f0:	8a 89       	ldd	r24, Y+18	; 0x12
     4f2:	98 13       	cpse	r25, r24
     4f4:	21 e0       	ldi	r18, 0x01	; 1
     4f6:	2a 8b       	std	Y+18, r18	; 0x12
     4f8:	ce 01       	movw	r24, r28
     4fa:	41 96       	adiw	r24, 0x11	; 17
     4fc:	b0 c0       	rjmp	.+352    	; 0x65e <__mulsf3+0x1e8>
     4fe:	2d 84       	ldd	r2, Y+13	; 0x0d
     500:	3e 84       	ldd	r3, Y+14	; 0x0e
     502:	4f 84       	ldd	r4, Y+15	; 0x0f
     504:	58 88       	ldd	r5, Y+16	; 0x10
     506:	6d 88       	ldd	r6, Y+21	; 0x15
     508:	7e 88       	ldd	r7, Y+22	; 0x16
     50a:	8f 88       	ldd	r8, Y+23	; 0x17
     50c:	98 8c       	ldd	r9, Y+24	; 0x18
     50e:	ee 24       	eor	r14, r14
     510:	ff 24       	eor	r15, r15
     512:	87 01       	movw	r16, r14
     514:	aa 24       	eor	r10, r10
     516:	bb 24       	eor	r11, r11
     518:	65 01       	movw	r12, r10
     51a:	40 e0       	ldi	r20, 0x00	; 0
     51c:	50 e0       	ldi	r21, 0x00	; 0
     51e:	60 e0       	ldi	r22, 0x00	; 0
     520:	70 e0       	ldi	r23, 0x00	; 0
     522:	e0 e0       	ldi	r30, 0x00	; 0
     524:	f0 e0       	ldi	r31, 0x00	; 0
     526:	c1 01       	movw	r24, r2
     528:	81 70       	andi	r24, 0x01	; 1
     52a:	90 70       	andi	r25, 0x00	; 0
     52c:	89 2b       	or	r24, r25
     52e:	e9 f0       	breq	.+58     	; 0x56a <__mulsf3+0xf4>
     530:	e6 0c       	add	r14, r6
     532:	f7 1c       	adc	r15, r7
     534:	08 1d       	adc	r16, r8
     536:	19 1d       	adc	r17, r9
     538:	9a 01       	movw	r18, r20
     53a:	ab 01       	movw	r20, r22
     53c:	2a 0d       	add	r18, r10
     53e:	3b 1d       	adc	r19, r11
     540:	4c 1d       	adc	r20, r12
     542:	5d 1d       	adc	r21, r13
     544:	80 e0       	ldi	r24, 0x00	; 0
     546:	90 e0       	ldi	r25, 0x00	; 0
     548:	a0 e0       	ldi	r26, 0x00	; 0
     54a:	b0 e0       	ldi	r27, 0x00	; 0
     54c:	e6 14       	cp	r14, r6
     54e:	f7 04       	cpc	r15, r7
     550:	08 05       	cpc	r16, r8
     552:	19 05       	cpc	r17, r9
     554:	20 f4       	brcc	.+8      	; 0x55e <__mulsf3+0xe8>
     556:	81 e0       	ldi	r24, 0x01	; 1
     558:	90 e0       	ldi	r25, 0x00	; 0
     55a:	a0 e0       	ldi	r26, 0x00	; 0
     55c:	b0 e0       	ldi	r27, 0x00	; 0
     55e:	ba 01       	movw	r22, r20
     560:	a9 01       	movw	r20, r18
     562:	48 0f       	add	r20, r24
     564:	59 1f       	adc	r21, r25
     566:	6a 1f       	adc	r22, r26
     568:	7b 1f       	adc	r23, r27
     56a:	aa 0c       	add	r10, r10
     56c:	bb 1c       	adc	r11, r11
     56e:	cc 1c       	adc	r12, r12
     570:	dd 1c       	adc	r13, r13
     572:	97 fe       	sbrs	r9, 7
     574:	08 c0       	rjmp	.+16     	; 0x586 <__mulsf3+0x110>
     576:	81 e0       	ldi	r24, 0x01	; 1
     578:	90 e0       	ldi	r25, 0x00	; 0
     57a:	a0 e0       	ldi	r26, 0x00	; 0
     57c:	b0 e0       	ldi	r27, 0x00	; 0
     57e:	a8 2a       	or	r10, r24
     580:	b9 2a       	or	r11, r25
     582:	ca 2a       	or	r12, r26
     584:	db 2a       	or	r13, r27
     586:	31 96       	adiw	r30, 0x01	; 1
     588:	e0 32       	cpi	r30, 0x20	; 32
     58a:	f1 05       	cpc	r31, r1
     58c:	49 f0       	breq	.+18     	; 0x5a0 <__mulsf3+0x12a>
     58e:	66 0c       	add	r6, r6
     590:	77 1c       	adc	r7, r7
     592:	88 1c       	adc	r8, r8
     594:	99 1c       	adc	r9, r9
     596:	56 94       	lsr	r5
     598:	47 94       	ror	r4
     59a:	37 94       	ror	r3
     59c:	27 94       	ror	r2
     59e:	c3 cf       	rjmp	.-122    	; 0x526 <__mulsf3+0xb0>
     5a0:	fa 85       	ldd	r31, Y+10	; 0x0a
     5a2:	ea 89       	ldd	r30, Y+18	; 0x12
     5a4:	2b 89       	ldd	r18, Y+19	; 0x13
     5a6:	3c 89       	ldd	r19, Y+20	; 0x14
     5a8:	8b 85       	ldd	r24, Y+11	; 0x0b
     5aa:	9c 85       	ldd	r25, Y+12	; 0x0c
     5ac:	28 0f       	add	r18, r24
     5ae:	39 1f       	adc	r19, r25
     5b0:	2e 5f       	subi	r18, 0xFE	; 254
     5b2:	3f 4f       	sbci	r19, 0xFF	; 255
     5b4:	17 c0       	rjmp	.+46     	; 0x5e4 <__mulsf3+0x16e>
     5b6:	ca 01       	movw	r24, r20
     5b8:	81 70       	andi	r24, 0x01	; 1
     5ba:	90 70       	andi	r25, 0x00	; 0
     5bc:	89 2b       	or	r24, r25
     5be:	61 f0       	breq	.+24     	; 0x5d8 <__mulsf3+0x162>
     5c0:	16 95       	lsr	r17
     5c2:	07 95       	ror	r16
     5c4:	f7 94       	ror	r15
     5c6:	e7 94       	ror	r14
     5c8:	80 e0       	ldi	r24, 0x00	; 0
     5ca:	90 e0       	ldi	r25, 0x00	; 0
     5cc:	a0 e0       	ldi	r26, 0x00	; 0
     5ce:	b0 e8       	ldi	r27, 0x80	; 128
     5d0:	e8 2a       	or	r14, r24
     5d2:	f9 2a       	or	r15, r25
     5d4:	0a 2b       	or	r16, r26
     5d6:	1b 2b       	or	r17, r27
     5d8:	76 95       	lsr	r23
     5da:	67 95       	ror	r22
     5dc:	57 95       	ror	r21
     5de:	47 95       	ror	r20
     5e0:	2f 5f       	subi	r18, 0xFF	; 255
     5e2:	3f 4f       	sbci	r19, 0xFF	; 255
     5e4:	77 fd       	sbrc	r23, 7
     5e6:	e7 cf       	rjmp	.-50     	; 0x5b6 <__mulsf3+0x140>
     5e8:	0c c0       	rjmp	.+24     	; 0x602 <__mulsf3+0x18c>
     5ea:	44 0f       	add	r20, r20
     5ec:	55 1f       	adc	r21, r21
     5ee:	66 1f       	adc	r22, r22
     5f0:	77 1f       	adc	r23, r23
     5f2:	17 fd       	sbrc	r17, 7
     5f4:	41 60       	ori	r20, 0x01	; 1
     5f6:	ee 0c       	add	r14, r14
     5f8:	ff 1c       	adc	r15, r15
     5fa:	00 1f       	adc	r16, r16
     5fc:	11 1f       	adc	r17, r17
     5fe:	21 50       	subi	r18, 0x01	; 1
     600:	30 40       	sbci	r19, 0x00	; 0
     602:	40 30       	cpi	r20, 0x00	; 0
     604:	90 e0       	ldi	r25, 0x00	; 0
     606:	59 07       	cpc	r21, r25
     608:	90 e0       	ldi	r25, 0x00	; 0
     60a:	69 07       	cpc	r22, r25
     60c:	90 e4       	ldi	r25, 0x40	; 64
     60e:	79 07       	cpc	r23, r25
     610:	60 f3       	brcs	.-40     	; 0x5ea <__mulsf3+0x174>
     612:	2b 8f       	std	Y+27, r18	; 0x1b
     614:	3c 8f       	std	Y+28, r19	; 0x1c
     616:	db 01       	movw	r26, r22
     618:	ca 01       	movw	r24, r20
     61a:	8f 77       	andi	r24, 0x7F	; 127
     61c:	90 70       	andi	r25, 0x00	; 0
     61e:	a0 70       	andi	r26, 0x00	; 0
     620:	b0 70       	andi	r27, 0x00	; 0
     622:	80 34       	cpi	r24, 0x40	; 64
     624:	91 05       	cpc	r25, r1
     626:	a1 05       	cpc	r26, r1
     628:	b1 05       	cpc	r27, r1
     62a:	61 f4       	brne	.+24     	; 0x644 <__mulsf3+0x1ce>
     62c:	47 fd       	sbrc	r20, 7
     62e:	0a c0       	rjmp	.+20     	; 0x644 <__mulsf3+0x1ce>
     630:	e1 14       	cp	r14, r1
     632:	f1 04       	cpc	r15, r1
     634:	01 05       	cpc	r16, r1
     636:	11 05       	cpc	r17, r1
     638:	29 f0       	breq	.+10     	; 0x644 <__mulsf3+0x1ce>
     63a:	40 5c       	subi	r20, 0xC0	; 192
     63c:	5f 4f       	sbci	r21, 0xFF	; 255
     63e:	6f 4f       	sbci	r22, 0xFF	; 255
     640:	7f 4f       	sbci	r23, 0xFF	; 255
     642:	40 78       	andi	r20, 0x80	; 128
     644:	1a 8e       	std	Y+26, r1	; 0x1a
     646:	fe 17       	cp	r31, r30
     648:	11 f0       	breq	.+4      	; 0x64e <__mulsf3+0x1d8>
     64a:	81 e0       	ldi	r24, 0x01	; 1
     64c:	8a 8f       	std	Y+26, r24	; 0x1a
     64e:	4d 8f       	std	Y+29, r20	; 0x1d
     650:	5e 8f       	std	Y+30, r21	; 0x1e
     652:	6f 8f       	std	Y+31, r22	; 0x1f
     654:	78 a3       	std	Y+32, r23	; 0x20
     656:	83 e0       	ldi	r24, 0x03	; 3
     658:	89 8f       	std	Y+25, r24	; 0x19
     65a:	ce 01       	movw	r24, r28
     65c:	49 96       	adiw	r24, 0x19	; 25
     65e:	0e 94 8d 05 	call	0xb1a	; 0xb1a <__pack_f>
     662:	a0 96       	adiw	r28, 0x20	; 32
     664:	e2 e1       	ldi	r30, 0x12	; 18
     666:	0c 94 f3 48 	jmp	0x91e6	; 0x91e6 <__epilogue_restores__>

0000066a <__divsf3>:
     66a:	a8 e1       	ldi	r26, 0x18	; 24
     66c:	b0 e0       	ldi	r27, 0x00	; 0
     66e:	eb e3       	ldi	r30, 0x3B	; 59
     670:	f3 e0       	ldi	r31, 0x03	; 3
     672:	0c 94 df 48 	jmp	0x91be	; 0x91be <__prologue_saves__+0x10>
     676:	69 83       	std	Y+1, r22	; 0x01
     678:	7a 83       	std	Y+2, r23	; 0x02
     67a:	8b 83       	std	Y+3, r24	; 0x03
     67c:	9c 83       	std	Y+4, r25	; 0x04
     67e:	2d 83       	std	Y+5, r18	; 0x05
     680:	3e 83       	std	Y+6, r19	; 0x06
     682:	4f 83       	std	Y+7, r20	; 0x07
     684:	58 87       	std	Y+8, r21	; 0x08
     686:	b9 e0       	ldi	r27, 0x09	; 9
     688:	eb 2e       	mov	r14, r27
     68a:	f1 2c       	mov	r15, r1
     68c:	ec 0e       	add	r14, r28
     68e:	fd 1e       	adc	r15, r29
     690:	ce 01       	movw	r24, r28
     692:	01 96       	adiw	r24, 0x01	; 1
     694:	b7 01       	movw	r22, r14
     696:	0e 94 62 06 	call	0xcc4	; 0xcc4 <__unpack_f>
     69a:	8e 01       	movw	r16, r28
     69c:	0f 5e       	subi	r16, 0xEF	; 239
     69e:	1f 4f       	sbci	r17, 0xFF	; 255
     6a0:	ce 01       	movw	r24, r28
     6a2:	05 96       	adiw	r24, 0x05	; 5
     6a4:	b8 01       	movw	r22, r16
     6a6:	0e 94 62 06 	call	0xcc4	; 0xcc4 <__unpack_f>
     6aa:	29 85       	ldd	r18, Y+9	; 0x09
     6ac:	22 30       	cpi	r18, 0x02	; 2
     6ae:	08 f4       	brcc	.+2      	; 0x6b2 <__divsf3+0x48>
     6b0:	7e c0       	rjmp	.+252    	; 0x7ae <__divsf3+0x144>
     6b2:	39 89       	ldd	r19, Y+17	; 0x11
     6b4:	32 30       	cpi	r19, 0x02	; 2
     6b6:	10 f4       	brcc	.+4      	; 0x6bc <__divsf3+0x52>
     6b8:	b8 01       	movw	r22, r16
     6ba:	7c c0       	rjmp	.+248    	; 0x7b4 <__divsf3+0x14a>
     6bc:	8a 85       	ldd	r24, Y+10	; 0x0a
     6be:	9a 89       	ldd	r25, Y+18	; 0x12
     6c0:	89 27       	eor	r24, r25
     6c2:	8a 87       	std	Y+10, r24	; 0x0a
     6c4:	24 30       	cpi	r18, 0x04	; 4
     6c6:	11 f0       	breq	.+4      	; 0x6cc <__divsf3+0x62>
     6c8:	22 30       	cpi	r18, 0x02	; 2
     6ca:	31 f4       	brne	.+12     	; 0x6d8 <__divsf3+0x6e>
     6cc:	23 17       	cp	r18, r19
     6ce:	09 f0       	breq	.+2      	; 0x6d2 <__divsf3+0x68>
     6d0:	6e c0       	rjmp	.+220    	; 0x7ae <__divsf3+0x144>
     6d2:	61 e2       	ldi	r22, 0x21	; 33
     6d4:	71 e0       	ldi	r23, 0x01	; 1
     6d6:	6e c0       	rjmp	.+220    	; 0x7b4 <__divsf3+0x14a>
     6d8:	34 30       	cpi	r19, 0x04	; 4
     6da:	39 f4       	brne	.+14     	; 0x6ea <__divsf3+0x80>
     6dc:	1d 86       	std	Y+13, r1	; 0x0d
     6de:	1e 86       	std	Y+14, r1	; 0x0e
     6e0:	1f 86       	std	Y+15, r1	; 0x0f
     6e2:	18 8a       	std	Y+16, r1	; 0x10
     6e4:	1c 86       	std	Y+12, r1	; 0x0c
     6e6:	1b 86       	std	Y+11, r1	; 0x0b
     6e8:	04 c0       	rjmp	.+8      	; 0x6f2 <__divsf3+0x88>
     6ea:	32 30       	cpi	r19, 0x02	; 2
     6ec:	21 f4       	brne	.+8      	; 0x6f6 <__divsf3+0x8c>
     6ee:	84 e0       	ldi	r24, 0x04	; 4
     6f0:	89 87       	std	Y+9, r24	; 0x09
     6f2:	b7 01       	movw	r22, r14
     6f4:	5f c0       	rjmp	.+190    	; 0x7b4 <__divsf3+0x14a>
     6f6:	2b 85       	ldd	r18, Y+11	; 0x0b
     6f8:	3c 85       	ldd	r19, Y+12	; 0x0c
     6fa:	8b 89       	ldd	r24, Y+19	; 0x13
     6fc:	9c 89       	ldd	r25, Y+20	; 0x14
     6fe:	28 1b       	sub	r18, r24
     700:	39 0b       	sbc	r19, r25
     702:	3c 87       	std	Y+12, r19	; 0x0c
     704:	2b 87       	std	Y+11, r18	; 0x0b
     706:	ed 84       	ldd	r14, Y+13	; 0x0d
     708:	fe 84       	ldd	r15, Y+14	; 0x0e
     70a:	0f 85       	ldd	r16, Y+15	; 0x0f
     70c:	18 89       	ldd	r17, Y+16	; 0x10
     70e:	ad 88       	ldd	r10, Y+21	; 0x15
     710:	be 88       	ldd	r11, Y+22	; 0x16
     712:	cf 88       	ldd	r12, Y+23	; 0x17
     714:	d8 8c       	ldd	r13, Y+24	; 0x18
     716:	ea 14       	cp	r14, r10
     718:	fb 04       	cpc	r15, r11
     71a:	0c 05       	cpc	r16, r12
     71c:	1d 05       	cpc	r17, r13
     71e:	40 f4       	brcc	.+16     	; 0x730 <__divsf3+0xc6>
     720:	ee 0c       	add	r14, r14
     722:	ff 1c       	adc	r15, r15
     724:	00 1f       	adc	r16, r16
     726:	11 1f       	adc	r17, r17
     728:	21 50       	subi	r18, 0x01	; 1
     72a:	30 40       	sbci	r19, 0x00	; 0
     72c:	3c 87       	std	Y+12, r19	; 0x0c
     72e:	2b 87       	std	Y+11, r18	; 0x0b
     730:	20 e0       	ldi	r18, 0x00	; 0
     732:	30 e0       	ldi	r19, 0x00	; 0
     734:	40 e0       	ldi	r20, 0x00	; 0
     736:	50 e0       	ldi	r21, 0x00	; 0
     738:	80 e0       	ldi	r24, 0x00	; 0
     73a:	90 e0       	ldi	r25, 0x00	; 0
     73c:	a0 e0       	ldi	r26, 0x00	; 0
     73e:	b0 e4       	ldi	r27, 0x40	; 64
     740:	60 e0       	ldi	r22, 0x00	; 0
     742:	70 e0       	ldi	r23, 0x00	; 0
     744:	ea 14       	cp	r14, r10
     746:	fb 04       	cpc	r15, r11
     748:	0c 05       	cpc	r16, r12
     74a:	1d 05       	cpc	r17, r13
     74c:	40 f0       	brcs	.+16     	; 0x75e <__divsf3+0xf4>
     74e:	28 2b       	or	r18, r24
     750:	39 2b       	or	r19, r25
     752:	4a 2b       	or	r20, r26
     754:	5b 2b       	or	r21, r27
     756:	ea 18       	sub	r14, r10
     758:	fb 08       	sbc	r15, r11
     75a:	0c 09       	sbc	r16, r12
     75c:	1d 09       	sbc	r17, r13
     75e:	b6 95       	lsr	r27
     760:	a7 95       	ror	r26
     762:	97 95       	ror	r25
     764:	87 95       	ror	r24
     766:	ee 0c       	add	r14, r14
     768:	ff 1c       	adc	r15, r15
     76a:	00 1f       	adc	r16, r16
     76c:	11 1f       	adc	r17, r17
     76e:	6f 5f       	subi	r22, 0xFF	; 255
     770:	7f 4f       	sbci	r23, 0xFF	; 255
     772:	6f 31       	cpi	r22, 0x1F	; 31
     774:	71 05       	cpc	r23, r1
     776:	31 f7       	brne	.-52     	; 0x744 <__divsf3+0xda>
     778:	da 01       	movw	r26, r20
     77a:	c9 01       	movw	r24, r18
     77c:	8f 77       	andi	r24, 0x7F	; 127
     77e:	90 70       	andi	r25, 0x00	; 0
     780:	a0 70       	andi	r26, 0x00	; 0
     782:	b0 70       	andi	r27, 0x00	; 0
     784:	80 34       	cpi	r24, 0x40	; 64
     786:	91 05       	cpc	r25, r1
     788:	a1 05       	cpc	r26, r1
     78a:	b1 05       	cpc	r27, r1
     78c:	61 f4       	brne	.+24     	; 0x7a6 <__divsf3+0x13c>
     78e:	27 fd       	sbrc	r18, 7
     790:	0a c0       	rjmp	.+20     	; 0x7a6 <__divsf3+0x13c>
     792:	e1 14       	cp	r14, r1
     794:	f1 04       	cpc	r15, r1
     796:	01 05       	cpc	r16, r1
     798:	11 05       	cpc	r17, r1
     79a:	29 f0       	breq	.+10     	; 0x7a6 <__divsf3+0x13c>
     79c:	20 5c       	subi	r18, 0xC0	; 192
     79e:	3f 4f       	sbci	r19, 0xFF	; 255
     7a0:	4f 4f       	sbci	r20, 0xFF	; 255
     7a2:	5f 4f       	sbci	r21, 0xFF	; 255
     7a4:	20 78       	andi	r18, 0x80	; 128
     7a6:	2d 87       	std	Y+13, r18	; 0x0d
     7a8:	3e 87       	std	Y+14, r19	; 0x0e
     7aa:	4f 87       	std	Y+15, r20	; 0x0f
     7ac:	58 8b       	std	Y+16, r21	; 0x10
     7ae:	be 01       	movw	r22, r28
     7b0:	67 5f       	subi	r22, 0xF7	; 247
     7b2:	7f 4f       	sbci	r23, 0xFF	; 255
     7b4:	cb 01       	movw	r24, r22
     7b6:	0e 94 8d 05 	call	0xb1a	; 0xb1a <__pack_f>
     7ba:	68 96       	adiw	r28, 0x18	; 24
     7bc:	ea e0       	ldi	r30, 0x0A	; 10
     7be:	0c 94 fb 48 	jmp	0x91f6	; 0x91f6 <__epilogue_restores__+0x10>

000007c2 <__gtsf2>:
     7c2:	a8 e1       	ldi	r26, 0x18	; 24
     7c4:	b0 e0       	ldi	r27, 0x00	; 0
     7c6:	e7 ee       	ldi	r30, 0xE7	; 231
     7c8:	f3 e0       	ldi	r31, 0x03	; 3
     7ca:	0c 94 e3 48 	jmp	0x91c6	; 0x91c6 <__prologue_saves__+0x18>
     7ce:	69 83       	std	Y+1, r22	; 0x01
     7d0:	7a 83       	std	Y+2, r23	; 0x02
     7d2:	8b 83       	std	Y+3, r24	; 0x03
     7d4:	9c 83       	std	Y+4, r25	; 0x04
     7d6:	2d 83       	std	Y+5, r18	; 0x05
     7d8:	3e 83       	std	Y+6, r19	; 0x06
     7da:	4f 83       	std	Y+7, r20	; 0x07
     7dc:	58 87       	std	Y+8, r21	; 0x08
     7de:	89 e0       	ldi	r24, 0x09	; 9
     7e0:	e8 2e       	mov	r14, r24
     7e2:	f1 2c       	mov	r15, r1
     7e4:	ec 0e       	add	r14, r28
     7e6:	fd 1e       	adc	r15, r29
     7e8:	ce 01       	movw	r24, r28
     7ea:	01 96       	adiw	r24, 0x01	; 1
     7ec:	b7 01       	movw	r22, r14
     7ee:	0e 94 62 06 	call	0xcc4	; 0xcc4 <__unpack_f>
     7f2:	8e 01       	movw	r16, r28
     7f4:	0f 5e       	subi	r16, 0xEF	; 239
     7f6:	1f 4f       	sbci	r17, 0xFF	; 255
     7f8:	ce 01       	movw	r24, r28
     7fa:	05 96       	adiw	r24, 0x05	; 5
     7fc:	b8 01       	movw	r22, r16
     7fe:	0e 94 62 06 	call	0xcc4	; 0xcc4 <__unpack_f>
     802:	89 85       	ldd	r24, Y+9	; 0x09
     804:	82 30       	cpi	r24, 0x02	; 2
     806:	40 f0       	brcs	.+16     	; 0x818 <__gtsf2+0x56>
     808:	89 89       	ldd	r24, Y+17	; 0x11
     80a:	82 30       	cpi	r24, 0x02	; 2
     80c:	28 f0       	brcs	.+10     	; 0x818 <__gtsf2+0x56>
     80e:	c7 01       	movw	r24, r14
     810:	b8 01       	movw	r22, r16
     812:	0e 94 da 06 	call	0xdb4	; 0xdb4 <__fpcmp_parts_f>
     816:	01 c0       	rjmp	.+2      	; 0x81a <__gtsf2+0x58>
     818:	8f ef       	ldi	r24, 0xFF	; 255
     81a:	68 96       	adiw	r28, 0x18	; 24
     81c:	e6 e0       	ldi	r30, 0x06	; 6
     81e:	0c 94 ff 48 	jmp	0x91fe	; 0x91fe <__epilogue_restores__+0x18>

00000822 <__gesf2>:
     822:	a8 e1       	ldi	r26, 0x18	; 24
     824:	b0 e0       	ldi	r27, 0x00	; 0
     826:	e7 e1       	ldi	r30, 0x17	; 23
     828:	f4 e0       	ldi	r31, 0x04	; 4
     82a:	0c 94 e3 48 	jmp	0x91c6	; 0x91c6 <__prologue_saves__+0x18>
     82e:	69 83       	std	Y+1, r22	; 0x01
     830:	7a 83       	std	Y+2, r23	; 0x02
     832:	8b 83       	std	Y+3, r24	; 0x03
     834:	9c 83       	std	Y+4, r25	; 0x04
     836:	2d 83       	std	Y+5, r18	; 0x05
     838:	3e 83       	std	Y+6, r19	; 0x06
     83a:	4f 83       	std	Y+7, r20	; 0x07
     83c:	58 87       	std	Y+8, r21	; 0x08
     83e:	89 e0       	ldi	r24, 0x09	; 9
     840:	e8 2e       	mov	r14, r24
     842:	f1 2c       	mov	r15, r1
     844:	ec 0e       	add	r14, r28
     846:	fd 1e       	adc	r15, r29
     848:	ce 01       	movw	r24, r28
     84a:	01 96       	adiw	r24, 0x01	; 1
     84c:	b7 01       	movw	r22, r14
     84e:	0e 94 62 06 	call	0xcc4	; 0xcc4 <__unpack_f>
     852:	8e 01       	movw	r16, r28
     854:	0f 5e       	subi	r16, 0xEF	; 239
     856:	1f 4f       	sbci	r17, 0xFF	; 255
     858:	ce 01       	movw	r24, r28
     85a:	05 96       	adiw	r24, 0x05	; 5
     85c:	b8 01       	movw	r22, r16
     85e:	0e 94 62 06 	call	0xcc4	; 0xcc4 <__unpack_f>
     862:	89 85       	ldd	r24, Y+9	; 0x09
     864:	82 30       	cpi	r24, 0x02	; 2
     866:	40 f0       	brcs	.+16     	; 0x878 <__gesf2+0x56>
     868:	89 89       	ldd	r24, Y+17	; 0x11
     86a:	82 30       	cpi	r24, 0x02	; 2
     86c:	28 f0       	brcs	.+10     	; 0x878 <__gesf2+0x56>
     86e:	c7 01       	movw	r24, r14
     870:	b8 01       	movw	r22, r16
     872:	0e 94 da 06 	call	0xdb4	; 0xdb4 <__fpcmp_parts_f>
     876:	01 c0       	rjmp	.+2      	; 0x87a <__gesf2+0x58>
     878:	8f ef       	ldi	r24, 0xFF	; 255
     87a:	68 96       	adiw	r28, 0x18	; 24
     87c:	e6 e0       	ldi	r30, 0x06	; 6
     87e:	0c 94 ff 48 	jmp	0x91fe	; 0x91fe <__epilogue_restores__+0x18>

00000882 <__ltsf2>:
     882:	a8 e1       	ldi	r26, 0x18	; 24
     884:	b0 e0       	ldi	r27, 0x00	; 0
     886:	e7 e4       	ldi	r30, 0x47	; 71
     888:	f4 e0       	ldi	r31, 0x04	; 4
     88a:	0c 94 e3 48 	jmp	0x91c6	; 0x91c6 <__prologue_saves__+0x18>
     88e:	69 83       	std	Y+1, r22	; 0x01
     890:	7a 83       	std	Y+2, r23	; 0x02
     892:	8b 83       	std	Y+3, r24	; 0x03
     894:	9c 83       	std	Y+4, r25	; 0x04
     896:	2d 83       	std	Y+5, r18	; 0x05
     898:	3e 83       	std	Y+6, r19	; 0x06
     89a:	4f 83       	std	Y+7, r20	; 0x07
     89c:	58 87       	std	Y+8, r21	; 0x08
     89e:	89 e0       	ldi	r24, 0x09	; 9
     8a0:	e8 2e       	mov	r14, r24
     8a2:	f1 2c       	mov	r15, r1
     8a4:	ec 0e       	add	r14, r28
     8a6:	fd 1e       	adc	r15, r29
     8a8:	ce 01       	movw	r24, r28
     8aa:	01 96       	adiw	r24, 0x01	; 1
     8ac:	b7 01       	movw	r22, r14
     8ae:	0e 94 62 06 	call	0xcc4	; 0xcc4 <__unpack_f>
     8b2:	8e 01       	movw	r16, r28
     8b4:	0f 5e       	subi	r16, 0xEF	; 239
     8b6:	1f 4f       	sbci	r17, 0xFF	; 255
     8b8:	ce 01       	movw	r24, r28
     8ba:	05 96       	adiw	r24, 0x05	; 5
     8bc:	b8 01       	movw	r22, r16
     8be:	0e 94 62 06 	call	0xcc4	; 0xcc4 <__unpack_f>
     8c2:	89 85       	ldd	r24, Y+9	; 0x09
     8c4:	82 30       	cpi	r24, 0x02	; 2
     8c6:	40 f0       	brcs	.+16     	; 0x8d8 <__ltsf2+0x56>
     8c8:	89 89       	ldd	r24, Y+17	; 0x11
     8ca:	82 30       	cpi	r24, 0x02	; 2
     8cc:	28 f0       	brcs	.+10     	; 0x8d8 <__ltsf2+0x56>
     8ce:	c7 01       	movw	r24, r14
     8d0:	b8 01       	movw	r22, r16
     8d2:	0e 94 da 06 	call	0xdb4	; 0xdb4 <__fpcmp_parts_f>
     8d6:	01 c0       	rjmp	.+2      	; 0x8da <__ltsf2+0x58>
     8d8:	81 e0       	ldi	r24, 0x01	; 1
     8da:	68 96       	adiw	r28, 0x18	; 24
     8dc:	e6 e0       	ldi	r30, 0x06	; 6
     8de:	0c 94 ff 48 	jmp	0x91fe	; 0x91fe <__epilogue_restores__+0x18>

000008e2 <__fixsfsi>:
     8e2:	ac e0       	ldi	r26, 0x0C	; 12
     8e4:	b0 e0       	ldi	r27, 0x00	; 0
     8e6:	e7 e7       	ldi	r30, 0x77	; 119
     8e8:	f4 e0       	ldi	r31, 0x04	; 4
     8ea:	0c 94 e7 48 	jmp	0x91ce	; 0x91ce <__prologue_saves__+0x20>
     8ee:	69 83       	std	Y+1, r22	; 0x01
     8f0:	7a 83       	std	Y+2, r23	; 0x02
     8f2:	8b 83       	std	Y+3, r24	; 0x03
     8f4:	9c 83       	std	Y+4, r25	; 0x04
     8f6:	ce 01       	movw	r24, r28
     8f8:	01 96       	adiw	r24, 0x01	; 1
     8fa:	be 01       	movw	r22, r28
     8fc:	6b 5f       	subi	r22, 0xFB	; 251
     8fe:	7f 4f       	sbci	r23, 0xFF	; 255
     900:	0e 94 62 06 	call	0xcc4	; 0xcc4 <__unpack_f>
     904:	8d 81       	ldd	r24, Y+5	; 0x05
     906:	82 30       	cpi	r24, 0x02	; 2
     908:	61 f1       	breq	.+88     	; 0x962 <__fixsfsi+0x80>
     90a:	82 30       	cpi	r24, 0x02	; 2
     90c:	50 f1       	brcs	.+84     	; 0x962 <__fixsfsi+0x80>
     90e:	84 30       	cpi	r24, 0x04	; 4
     910:	21 f4       	brne	.+8      	; 0x91a <__fixsfsi+0x38>
     912:	8e 81       	ldd	r24, Y+6	; 0x06
     914:	88 23       	and	r24, r24
     916:	51 f1       	breq	.+84     	; 0x96c <__fixsfsi+0x8a>
     918:	2e c0       	rjmp	.+92     	; 0x976 <__fixsfsi+0x94>
     91a:	2f 81       	ldd	r18, Y+7	; 0x07
     91c:	38 85       	ldd	r19, Y+8	; 0x08
     91e:	37 fd       	sbrc	r19, 7
     920:	20 c0       	rjmp	.+64     	; 0x962 <__fixsfsi+0x80>
     922:	6e 81       	ldd	r22, Y+6	; 0x06
     924:	2f 31       	cpi	r18, 0x1F	; 31
     926:	31 05       	cpc	r19, r1
     928:	1c f0       	brlt	.+6      	; 0x930 <__fixsfsi+0x4e>
     92a:	66 23       	and	r22, r22
     92c:	f9 f0       	breq	.+62     	; 0x96c <__fixsfsi+0x8a>
     92e:	23 c0       	rjmp	.+70     	; 0x976 <__fixsfsi+0x94>
     930:	8e e1       	ldi	r24, 0x1E	; 30
     932:	90 e0       	ldi	r25, 0x00	; 0
     934:	82 1b       	sub	r24, r18
     936:	93 0b       	sbc	r25, r19
     938:	29 85       	ldd	r18, Y+9	; 0x09
     93a:	3a 85       	ldd	r19, Y+10	; 0x0a
     93c:	4b 85       	ldd	r20, Y+11	; 0x0b
     93e:	5c 85       	ldd	r21, Y+12	; 0x0c
     940:	04 c0       	rjmp	.+8      	; 0x94a <__fixsfsi+0x68>
     942:	56 95       	lsr	r21
     944:	47 95       	ror	r20
     946:	37 95       	ror	r19
     948:	27 95       	ror	r18
     94a:	8a 95       	dec	r24
     94c:	d2 f7       	brpl	.-12     	; 0x942 <__fixsfsi+0x60>
     94e:	66 23       	and	r22, r22
     950:	b1 f0       	breq	.+44     	; 0x97e <__fixsfsi+0x9c>
     952:	50 95       	com	r21
     954:	40 95       	com	r20
     956:	30 95       	com	r19
     958:	21 95       	neg	r18
     95a:	3f 4f       	sbci	r19, 0xFF	; 255
     95c:	4f 4f       	sbci	r20, 0xFF	; 255
     95e:	5f 4f       	sbci	r21, 0xFF	; 255
     960:	0e c0       	rjmp	.+28     	; 0x97e <__fixsfsi+0x9c>
     962:	20 e0       	ldi	r18, 0x00	; 0
     964:	30 e0       	ldi	r19, 0x00	; 0
     966:	40 e0       	ldi	r20, 0x00	; 0
     968:	50 e0       	ldi	r21, 0x00	; 0
     96a:	09 c0       	rjmp	.+18     	; 0x97e <__fixsfsi+0x9c>
     96c:	2f ef       	ldi	r18, 0xFF	; 255
     96e:	3f ef       	ldi	r19, 0xFF	; 255
     970:	4f ef       	ldi	r20, 0xFF	; 255
     972:	5f e7       	ldi	r21, 0x7F	; 127
     974:	04 c0       	rjmp	.+8      	; 0x97e <__fixsfsi+0x9c>
     976:	20 e0       	ldi	r18, 0x00	; 0
     978:	30 e0       	ldi	r19, 0x00	; 0
     97a:	40 e0       	ldi	r20, 0x00	; 0
     97c:	50 e8       	ldi	r21, 0x80	; 128
     97e:	b9 01       	movw	r22, r18
     980:	ca 01       	movw	r24, r20
     982:	2c 96       	adiw	r28, 0x0c	; 12
     984:	e2 e0       	ldi	r30, 0x02	; 2
     986:	0c 94 03 49 	jmp	0x9206	; 0x9206 <__epilogue_restores__+0x20>

0000098a <__floatunsisf>:
     98a:	a8 e0       	ldi	r26, 0x08	; 8
     98c:	b0 e0       	ldi	r27, 0x00	; 0
     98e:	eb ec       	ldi	r30, 0xCB	; 203
     990:	f4 e0       	ldi	r31, 0x04	; 4
     992:	0c 94 df 48 	jmp	0x91be	; 0x91be <__prologue_saves__+0x10>
     996:	7b 01       	movw	r14, r22
     998:	8c 01       	movw	r16, r24
     99a:	61 15       	cp	r22, r1
     99c:	71 05       	cpc	r23, r1
     99e:	81 05       	cpc	r24, r1
     9a0:	91 05       	cpc	r25, r1
     9a2:	19 f4       	brne	.+6      	; 0x9aa <__floatunsisf+0x20>
     9a4:	82 e0       	ldi	r24, 0x02	; 2
     9a6:	89 83       	std	Y+1, r24	; 0x01
     9a8:	60 c0       	rjmp	.+192    	; 0xa6a <__floatunsisf+0xe0>
     9aa:	83 e0       	ldi	r24, 0x03	; 3
     9ac:	89 83       	std	Y+1, r24	; 0x01
     9ae:	8e e1       	ldi	r24, 0x1E	; 30
     9b0:	c8 2e       	mov	r12, r24
     9b2:	d1 2c       	mov	r13, r1
     9b4:	dc 82       	std	Y+4, r13	; 0x04
     9b6:	cb 82       	std	Y+3, r12	; 0x03
     9b8:	ed 82       	std	Y+5, r14	; 0x05
     9ba:	fe 82       	std	Y+6, r15	; 0x06
     9bc:	0f 83       	std	Y+7, r16	; 0x07
     9be:	18 87       	std	Y+8, r17	; 0x08
     9c0:	c8 01       	movw	r24, r16
     9c2:	b7 01       	movw	r22, r14
     9c4:	0e 94 3e 05 	call	0xa7c	; 0xa7c <__clzsi2>
     9c8:	fc 01       	movw	r30, r24
     9ca:	31 97       	sbiw	r30, 0x01	; 1
     9cc:	f7 ff       	sbrs	r31, 7
     9ce:	3b c0       	rjmp	.+118    	; 0xa46 <__floatunsisf+0xbc>
     9d0:	22 27       	eor	r18, r18
     9d2:	33 27       	eor	r19, r19
     9d4:	2e 1b       	sub	r18, r30
     9d6:	3f 0b       	sbc	r19, r31
     9d8:	57 01       	movw	r10, r14
     9da:	68 01       	movw	r12, r16
     9dc:	02 2e       	mov	r0, r18
     9de:	04 c0       	rjmp	.+8      	; 0x9e8 <__floatunsisf+0x5e>
     9e0:	d6 94       	lsr	r13
     9e2:	c7 94       	ror	r12
     9e4:	b7 94       	ror	r11
     9e6:	a7 94       	ror	r10
     9e8:	0a 94       	dec	r0
     9ea:	d2 f7       	brpl	.-12     	; 0x9e0 <__floatunsisf+0x56>
     9ec:	40 e0       	ldi	r20, 0x00	; 0
     9ee:	50 e0       	ldi	r21, 0x00	; 0
     9f0:	60 e0       	ldi	r22, 0x00	; 0
     9f2:	70 e0       	ldi	r23, 0x00	; 0
     9f4:	81 e0       	ldi	r24, 0x01	; 1
     9f6:	90 e0       	ldi	r25, 0x00	; 0
     9f8:	a0 e0       	ldi	r26, 0x00	; 0
     9fa:	b0 e0       	ldi	r27, 0x00	; 0
     9fc:	04 c0       	rjmp	.+8      	; 0xa06 <__floatunsisf+0x7c>
     9fe:	88 0f       	add	r24, r24
     a00:	99 1f       	adc	r25, r25
     a02:	aa 1f       	adc	r26, r26
     a04:	bb 1f       	adc	r27, r27
     a06:	2a 95       	dec	r18
     a08:	d2 f7       	brpl	.-12     	; 0x9fe <__floatunsisf+0x74>
     a0a:	01 97       	sbiw	r24, 0x01	; 1
     a0c:	a1 09       	sbc	r26, r1
     a0e:	b1 09       	sbc	r27, r1
     a10:	8e 21       	and	r24, r14
     a12:	9f 21       	and	r25, r15
     a14:	a0 23       	and	r26, r16
     a16:	b1 23       	and	r27, r17
     a18:	00 97       	sbiw	r24, 0x00	; 0
     a1a:	a1 05       	cpc	r26, r1
     a1c:	b1 05       	cpc	r27, r1
     a1e:	21 f0       	breq	.+8      	; 0xa28 <__floatunsisf+0x9e>
     a20:	41 e0       	ldi	r20, 0x01	; 1
     a22:	50 e0       	ldi	r21, 0x00	; 0
     a24:	60 e0       	ldi	r22, 0x00	; 0
     a26:	70 e0       	ldi	r23, 0x00	; 0
     a28:	4a 29       	or	r20, r10
     a2a:	5b 29       	or	r21, r11
     a2c:	6c 29       	or	r22, r12
     a2e:	7d 29       	or	r23, r13
     a30:	4d 83       	std	Y+5, r20	; 0x05
     a32:	5e 83       	std	Y+6, r21	; 0x06
     a34:	6f 83       	std	Y+7, r22	; 0x07
     a36:	78 87       	std	Y+8, r23	; 0x08
     a38:	8e e1       	ldi	r24, 0x1E	; 30
     a3a:	90 e0       	ldi	r25, 0x00	; 0
     a3c:	8e 1b       	sub	r24, r30
     a3e:	9f 0b       	sbc	r25, r31
     a40:	9c 83       	std	Y+4, r25	; 0x04
     a42:	8b 83       	std	Y+3, r24	; 0x03
     a44:	12 c0       	rjmp	.+36     	; 0xa6a <__floatunsisf+0xe0>
     a46:	30 97       	sbiw	r30, 0x00	; 0
     a48:	81 f0       	breq	.+32     	; 0xa6a <__floatunsisf+0xe0>
     a4a:	0e 2e       	mov	r0, r30
     a4c:	04 c0       	rjmp	.+8      	; 0xa56 <__floatunsisf+0xcc>
     a4e:	ee 0c       	add	r14, r14
     a50:	ff 1c       	adc	r15, r15
     a52:	00 1f       	adc	r16, r16
     a54:	11 1f       	adc	r17, r17
     a56:	0a 94       	dec	r0
     a58:	d2 f7       	brpl	.-12     	; 0xa4e <__floatunsisf+0xc4>
     a5a:	ed 82       	std	Y+5, r14	; 0x05
     a5c:	fe 82       	std	Y+6, r15	; 0x06
     a5e:	0f 83       	std	Y+7, r16	; 0x07
     a60:	18 87       	std	Y+8, r17	; 0x08
     a62:	ce 1a       	sub	r12, r30
     a64:	df 0a       	sbc	r13, r31
     a66:	dc 82       	std	Y+4, r13	; 0x04
     a68:	cb 82       	std	Y+3, r12	; 0x03
     a6a:	1a 82       	std	Y+2, r1	; 0x02
     a6c:	ce 01       	movw	r24, r28
     a6e:	01 96       	adiw	r24, 0x01	; 1
     a70:	0e 94 8d 05 	call	0xb1a	; 0xb1a <__pack_f>
     a74:	28 96       	adiw	r28, 0x08	; 8
     a76:	ea e0       	ldi	r30, 0x0A	; 10
     a78:	0c 94 fb 48 	jmp	0x91f6	; 0x91f6 <__epilogue_restores__+0x10>

00000a7c <__clzsi2>:
     a7c:	ef 92       	push	r14
     a7e:	ff 92       	push	r15
     a80:	0f 93       	push	r16
     a82:	1f 93       	push	r17
     a84:	7b 01       	movw	r14, r22
     a86:	8c 01       	movw	r16, r24
     a88:	80 e0       	ldi	r24, 0x00	; 0
     a8a:	e8 16       	cp	r14, r24
     a8c:	80 e0       	ldi	r24, 0x00	; 0
     a8e:	f8 06       	cpc	r15, r24
     a90:	81 e0       	ldi	r24, 0x01	; 1
     a92:	08 07       	cpc	r16, r24
     a94:	80 e0       	ldi	r24, 0x00	; 0
     a96:	18 07       	cpc	r17, r24
     a98:	88 f4       	brcc	.+34     	; 0xabc <__clzsi2+0x40>
     a9a:	8f ef       	ldi	r24, 0xFF	; 255
     a9c:	e8 16       	cp	r14, r24
     a9e:	f1 04       	cpc	r15, r1
     aa0:	01 05       	cpc	r16, r1
     aa2:	11 05       	cpc	r17, r1
     aa4:	31 f0       	breq	.+12     	; 0xab2 <__clzsi2+0x36>
     aa6:	28 f0       	brcs	.+10     	; 0xab2 <__clzsi2+0x36>
     aa8:	88 e0       	ldi	r24, 0x08	; 8
     aaa:	90 e0       	ldi	r25, 0x00	; 0
     aac:	a0 e0       	ldi	r26, 0x00	; 0
     aae:	b0 e0       	ldi	r27, 0x00	; 0
     ab0:	17 c0       	rjmp	.+46     	; 0xae0 <__clzsi2+0x64>
     ab2:	80 e0       	ldi	r24, 0x00	; 0
     ab4:	90 e0       	ldi	r25, 0x00	; 0
     ab6:	a0 e0       	ldi	r26, 0x00	; 0
     ab8:	b0 e0       	ldi	r27, 0x00	; 0
     aba:	12 c0       	rjmp	.+36     	; 0xae0 <__clzsi2+0x64>
     abc:	80 e0       	ldi	r24, 0x00	; 0
     abe:	e8 16       	cp	r14, r24
     ac0:	80 e0       	ldi	r24, 0x00	; 0
     ac2:	f8 06       	cpc	r15, r24
     ac4:	80 e0       	ldi	r24, 0x00	; 0
     ac6:	08 07       	cpc	r16, r24
     ac8:	81 e0       	ldi	r24, 0x01	; 1
     aca:	18 07       	cpc	r17, r24
     acc:	28 f0       	brcs	.+10     	; 0xad8 <__clzsi2+0x5c>
     ace:	88 e1       	ldi	r24, 0x18	; 24
     ad0:	90 e0       	ldi	r25, 0x00	; 0
     ad2:	a0 e0       	ldi	r26, 0x00	; 0
     ad4:	b0 e0       	ldi	r27, 0x00	; 0
     ad6:	04 c0       	rjmp	.+8      	; 0xae0 <__clzsi2+0x64>
     ad8:	80 e1       	ldi	r24, 0x10	; 16
     ada:	90 e0       	ldi	r25, 0x00	; 0
     adc:	a0 e0       	ldi	r26, 0x00	; 0
     ade:	b0 e0       	ldi	r27, 0x00	; 0
     ae0:	20 e2       	ldi	r18, 0x20	; 32
     ae2:	30 e0       	ldi	r19, 0x00	; 0
     ae4:	40 e0       	ldi	r20, 0x00	; 0
     ae6:	50 e0       	ldi	r21, 0x00	; 0
     ae8:	28 1b       	sub	r18, r24
     aea:	39 0b       	sbc	r19, r25
     aec:	4a 0b       	sbc	r20, r26
     aee:	5b 0b       	sbc	r21, r27
     af0:	04 c0       	rjmp	.+8      	; 0xafa <__clzsi2+0x7e>
     af2:	16 95       	lsr	r17
     af4:	07 95       	ror	r16
     af6:	f7 94       	ror	r15
     af8:	e7 94       	ror	r14
     afa:	8a 95       	dec	r24
     afc:	d2 f7       	brpl	.-12     	; 0xaf2 <__clzsi2+0x76>
     afe:	f7 01       	movw	r30, r14
     b00:	e7 5d       	subi	r30, 0xD7	; 215
     b02:	fe 4f       	sbci	r31, 0xFE	; 254
     b04:	80 81       	ld	r24, Z
     b06:	28 1b       	sub	r18, r24
     b08:	31 09       	sbc	r19, r1
     b0a:	41 09       	sbc	r20, r1
     b0c:	51 09       	sbc	r21, r1
     b0e:	c9 01       	movw	r24, r18
     b10:	1f 91       	pop	r17
     b12:	0f 91       	pop	r16
     b14:	ff 90       	pop	r15
     b16:	ef 90       	pop	r14
     b18:	08 95       	ret

00000b1a <__pack_f>:
     b1a:	df 92       	push	r13
     b1c:	ef 92       	push	r14
     b1e:	ff 92       	push	r15
     b20:	0f 93       	push	r16
     b22:	1f 93       	push	r17
     b24:	fc 01       	movw	r30, r24
     b26:	e4 80       	ldd	r14, Z+4	; 0x04
     b28:	f5 80       	ldd	r15, Z+5	; 0x05
     b2a:	06 81       	ldd	r16, Z+6	; 0x06
     b2c:	17 81       	ldd	r17, Z+7	; 0x07
     b2e:	d1 80       	ldd	r13, Z+1	; 0x01
     b30:	80 81       	ld	r24, Z
     b32:	82 30       	cpi	r24, 0x02	; 2
     b34:	48 f4       	brcc	.+18     	; 0xb48 <__pack_f+0x2e>
     b36:	80 e0       	ldi	r24, 0x00	; 0
     b38:	90 e0       	ldi	r25, 0x00	; 0
     b3a:	a0 e1       	ldi	r26, 0x10	; 16
     b3c:	b0 e0       	ldi	r27, 0x00	; 0
     b3e:	e8 2a       	or	r14, r24
     b40:	f9 2a       	or	r15, r25
     b42:	0a 2b       	or	r16, r26
     b44:	1b 2b       	or	r17, r27
     b46:	a5 c0       	rjmp	.+330    	; 0xc92 <__pack_f+0x178>
     b48:	84 30       	cpi	r24, 0x04	; 4
     b4a:	09 f4       	brne	.+2      	; 0xb4e <__pack_f+0x34>
     b4c:	9f c0       	rjmp	.+318    	; 0xc8c <__pack_f+0x172>
     b4e:	82 30       	cpi	r24, 0x02	; 2
     b50:	21 f4       	brne	.+8      	; 0xb5a <__pack_f+0x40>
     b52:	ee 24       	eor	r14, r14
     b54:	ff 24       	eor	r15, r15
     b56:	87 01       	movw	r16, r14
     b58:	05 c0       	rjmp	.+10     	; 0xb64 <__pack_f+0x4a>
     b5a:	e1 14       	cp	r14, r1
     b5c:	f1 04       	cpc	r15, r1
     b5e:	01 05       	cpc	r16, r1
     b60:	11 05       	cpc	r17, r1
     b62:	19 f4       	brne	.+6      	; 0xb6a <__pack_f+0x50>
     b64:	e0 e0       	ldi	r30, 0x00	; 0
     b66:	f0 e0       	ldi	r31, 0x00	; 0
     b68:	96 c0       	rjmp	.+300    	; 0xc96 <__pack_f+0x17c>
     b6a:	62 81       	ldd	r22, Z+2	; 0x02
     b6c:	73 81       	ldd	r23, Z+3	; 0x03
     b6e:	9f ef       	ldi	r25, 0xFF	; 255
     b70:	62 38       	cpi	r22, 0x82	; 130
     b72:	79 07       	cpc	r23, r25
     b74:	0c f0       	brlt	.+2      	; 0xb78 <__pack_f+0x5e>
     b76:	5b c0       	rjmp	.+182    	; 0xc2e <__pack_f+0x114>
     b78:	22 e8       	ldi	r18, 0x82	; 130
     b7a:	3f ef       	ldi	r19, 0xFF	; 255
     b7c:	26 1b       	sub	r18, r22
     b7e:	37 0b       	sbc	r19, r23
     b80:	2a 31       	cpi	r18, 0x1A	; 26
     b82:	31 05       	cpc	r19, r1
     b84:	2c f0       	brlt	.+10     	; 0xb90 <__pack_f+0x76>
     b86:	20 e0       	ldi	r18, 0x00	; 0
     b88:	30 e0       	ldi	r19, 0x00	; 0
     b8a:	40 e0       	ldi	r20, 0x00	; 0
     b8c:	50 e0       	ldi	r21, 0x00	; 0
     b8e:	2a c0       	rjmp	.+84     	; 0xbe4 <__pack_f+0xca>
     b90:	b8 01       	movw	r22, r16
     b92:	a7 01       	movw	r20, r14
     b94:	02 2e       	mov	r0, r18
     b96:	04 c0       	rjmp	.+8      	; 0xba0 <__pack_f+0x86>
     b98:	76 95       	lsr	r23
     b9a:	67 95       	ror	r22
     b9c:	57 95       	ror	r21
     b9e:	47 95       	ror	r20
     ba0:	0a 94       	dec	r0
     ba2:	d2 f7       	brpl	.-12     	; 0xb98 <__pack_f+0x7e>
     ba4:	81 e0       	ldi	r24, 0x01	; 1
     ba6:	90 e0       	ldi	r25, 0x00	; 0
     ba8:	a0 e0       	ldi	r26, 0x00	; 0
     baa:	b0 e0       	ldi	r27, 0x00	; 0
     bac:	04 c0       	rjmp	.+8      	; 0xbb6 <__pack_f+0x9c>
     bae:	88 0f       	add	r24, r24
     bb0:	99 1f       	adc	r25, r25
     bb2:	aa 1f       	adc	r26, r26
     bb4:	bb 1f       	adc	r27, r27
     bb6:	2a 95       	dec	r18
     bb8:	d2 f7       	brpl	.-12     	; 0xbae <__pack_f+0x94>
     bba:	01 97       	sbiw	r24, 0x01	; 1
     bbc:	a1 09       	sbc	r26, r1
     bbe:	b1 09       	sbc	r27, r1
     bc0:	8e 21       	and	r24, r14
     bc2:	9f 21       	and	r25, r15
     bc4:	a0 23       	and	r26, r16
     bc6:	b1 23       	and	r27, r17
     bc8:	00 97       	sbiw	r24, 0x00	; 0
     bca:	a1 05       	cpc	r26, r1
     bcc:	b1 05       	cpc	r27, r1
     bce:	21 f0       	breq	.+8      	; 0xbd8 <__pack_f+0xbe>
     bd0:	81 e0       	ldi	r24, 0x01	; 1
     bd2:	90 e0       	ldi	r25, 0x00	; 0
     bd4:	a0 e0       	ldi	r26, 0x00	; 0
     bd6:	b0 e0       	ldi	r27, 0x00	; 0
     bd8:	9a 01       	movw	r18, r20
     bda:	ab 01       	movw	r20, r22
     bdc:	28 2b       	or	r18, r24
     bde:	39 2b       	or	r19, r25
     be0:	4a 2b       	or	r20, r26
     be2:	5b 2b       	or	r21, r27
     be4:	da 01       	movw	r26, r20
     be6:	c9 01       	movw	r24, r18
     be8:	8f 77       	andi	r24, 0x7F	; 127
     bea:	90 70       	andi	r25, 0x00	; 0
     bec:	a0 70       	andi	r26, 0x00	; 0
     bee:	b0 70       	andi	r27, 0x00	; 0
     bf0:	80 34       	cpi	r24, 0x40	; 64
     bf2:	91 05       	cpc	r25, r1
     bf4:	a1 05       	cpc	r26, r1
     bf6:	b1 05       	cpc	r27, r1
     bf8:	39 f4       	brne	.+14     	; 0xc08 <__pack_f+0xee>
     bfa:	27 ff       	sbrs	r18, 7
     bfc:	09 c0       	rjmp	.+18     	; 0xc10 <__pack_f+0xf6>
     bfe:	20 5c       	subi	r18, 0xC0	; 192
     c00:	3f 4f       	sbci	r19, 0xFF	; 255
     c02:	4f 4f       	sbci	r20, 0xFF	; 255
     c04:	5f 4f       	sbci	r21, 0xFF	; 255
     c06:	04 c0       	rjmp	.+8      	; 0xc10 <__pack_f+0xf6>
     c08:	21 5c       	subi	r18, 0xC1	; 193
     c0a:	3f 4f       	sbci	r19, 0xFF	; 255
     c0c:	4f 4f       	sbci	r20, 0xFF	; 255
     c0e:	5f 4f       	sbci	r21, 0xFF	; 255
     c10:	e0 e0       	ldi	r30, 0x00	; 0
     c12:	f0 e0       	ldi	r31, 0x00	; 0
     c14:	20 30       	cpi	r18, 0x00	; 0
     c16:	a0 e0       	ldi	r26, 0x00	; 0
     c18:	3a 07       	cpc	r19, r26
     c1a:	a0 e0       	ldi	r26, 0x00	; 0
     c1c:	4a 07       	cpc	r20, r26
     c1e:	a0 e4       	ldi	r26, 0x40	; 64
     c20:	5a 07       	cpc	r21, r26
     c22:	10 f0       	brcs	.+4      	; 0xc28 <__pack_f+0x10e>
     c24:	e1 e0       	ldi	r30, 0x01	; 1
     c26:	f0 e0       	ldi	r31, 0x00	; 0
     c28:	79 01       	movw	r14, r18
     c2a:	8a 01       	movw	r16, r20
     c2c:	27 c0       	rjmp	.+78     	; 0xc7c <__pack_f+0x162>
     c2e:	60 38       	cpi	r22, 0x80	; 128
     c30:	71 05       	cpc	r23, r1
     c32:	64 f5       	brge	.+88     	; 0xc8c <__pack_f+0x172>
     c34:	fb 01       	movw	r30, r22
     c36:	e1 58       	subi	r30, 0x81	; 129
     c38:	ff 4f       	sbci	r31, 0xFF	; 255
     c3a:	d8 01       	movw	r26, r16
     c3c:	c7 01       	movw	r24, r14
     c3e:	8f 77       	andi	r24, 0x7F	; 127
     c40:	90 70       	andi	r25, 0x00	; 0
     c42:	a0 70       	andi	r26, 0x00	; 0
     c44:	b0 70       	andi	r27, 0x00	; 0
     c46:	80 34       	cpi	r24, 0x40	; 64
     c48:	91 05       	cpc	r25, r1
     c4a:	a1 05       	cpc	r26, r1
     c4c:	b1 05       	cpc	r27, r1
     c4e:	39 f4       	brne	.+14     	; 0xc5e <__pack_f+0x144>
     c50:	e7 fe       	sbrs	r14, 7
     c52:	0d c0       	rjmp	.+26     	; 0xc6e <__pack_f+0x154>
     c54:	80 e4       	ldi	r24, 0x40	; 64
     c56:	90 e0       	ldi	r25, 0x00	; 0
     c58:	a0 e0       	ldi	r26, 0x00	; 0
     c5a:	b0 e0       	ldi	r27, 0x00	; 0
     c5c:	04 c0       	rjmp	.+8      	; 0xc66 <__pack_f+0x14c>
     c5e:	8f e3       	ldi	r24, 0x3F	; 63
     c60:	90 e0       	ldi	r25, 0x00	; 0
     c62:	a0 e0       	ldi	r26, 0x00	; 0
     c64:	b0 e0       	ldi	r27, 0x00	; 0
     c66:	e8 0e       	add	r14, r24
     c68:	f9 1e       	adc	r15, r25
     c6a:	0a 1f       	adc	r16, r26
     c6c:	1b 1f       	adc	r17, r27
     c6e:	17 ff       	sbrs	r17, 7
     c70:	05 c0       	rjmp	.+10     	; 0xc7c <__pack_f+0x162>
     c72:	16 95       	lsr	r17
     c74:	07 95       	ror	r16
     c76:	f7 94       	ror	r15
     c78:	e7 94       	ror	r14
     c7a:	31 96       	adiw	r30, 0x01	; 1
     c7c:	87 e0       	ldi	r24, 0x07	; 7
     c7e:	16 95       	lsr	r17
     c80:	07 95       	ror	r16
     c82:	f7 94       	ror	r15
     c84:	e7 94       	ror	r14
     c86:	8a 95       	dec	r24
     c88:	d1 f7       	brne	.-12     	; 0xc7e <__pack_f+0x164>
     c8a:	05 c0       	rjmp	.+10     	; 0xc96 <__pack_f+0x17c>
     c8c:	ee 24       	eor	r14, r14
     c8e:	ff 24       	eor	r15, r15
     c90:	87 01       	movw	r16, r14
     c92:	ef ef       	ldi	r30, 0xFF	; 255
     c94:	f0 e0       	ldi	r31, 0x00	; 0
     c96:	6e 2f       	mov	r22, r30
     c98:	67 95       	ror	r22
     c9a:	66 27       	eor	r22, r22
     c9c:	67 95       	ror	r22
     c9e:	90 2f       	mov	r25, r16
     ca0:	9f 77       	andi	r25, 0x7F	; 127
     ca2:	d7 94       	ror	r13
     ca4:	dd 24       	eor	r13, r13
     ca6:	d7 94       	ror	r13
     ca8:	8e 2f       	mov	r24, r30
     caa:	86 95       	lsr	r24
     cac:	49 2f       	mov	r20, r25
     cae:	46 2b       	or	r20, r22
     cb0:	58 2f       	mov	r21, r24
     cb2:	5d 29       	or	r21, r13
     cb4:	b7 01       	movw	r22, r14
     cb6:	ca 01       	movw	r24, r20
     cb8:	1f 91       	pop	r17
     cba:	0f 91       	pop	r16
     cbc:	ff 90       	pop	r15
     cbe:	ef 90       	pop	r14
     cc0:	df 90       	pop	r13
     cc2:	08 95       	ret

00000cc4 <__unpack_f>:
     cc4:	fc 01       	movw	r30, r24
     cc6:	db 01       	movw	r26, r22
     cc8:	40 81       	ld	r20, Z
     cca:	51 81       	ldd	r21, Z+1	; 0x01
     ccc:	22 81       	ldd	r18, Z+2	; 0x02
     cce:	62 2f       	mov	r22, r18
     cd0:	6f 77       	andi	r22, 0x7F	; 127
     cd2:	70 e0       	ldi	r23, 0x00	; 0
     cd4:	22 1f       	adc	r18, r18
     cd6:	22 27       	eor	r18, r18
     cd8:	22 1f       	adc	r18, r18
     cda:	93 81       	ldd	r25, Z+3	; 0x03
     cdc:	89 2f       	mov	r24, r25
     cde:	88 0f       	add	r24, r24
     ce0:	82 2b       	or	r24, r18
     ce2:	28 2f       	mov	r18, r24
     ce4:	30 e0       	ldi	r19, 0x00	; 0
     ce6:	99 1f       	adc	r25, r25
     ce8:	99 27       	eor	r25, r25
     cea:	99 1f       	adc	r25, r25
     cec:	11 96       	adiw	r26, 0x01	; 1
     cee:	9c 93       	st	X, r25
     cf0:	11 97       	sbiw	r26, 0x01	; 1
     cf2:	21 15       	cp	r18, r1
     cf4:	31 05       	cpc	r19, r1
     cf6:	a9 f5       	brne	.+106    	; 0xd62 <__unpack_f+0x9e>
     cf8:	41 15       	cp	r20, r1
     cfa:	51 05       	cpc	r21, r1
     cfc:	61 05       	cpc	r22, r1
     cfe:	71 05       	cpc	r23, r1
     d00:	11 f4       	brne	.+4      	; 0xd06 <__unpack_f+0x42>
     d02:	82 e0       	ldi	r24, 0x02	; 2
     d04:	37 c0       	rjmp	.+110    	; 0xd74 <__unpack_f+0xb0>
     d06:	82 e8       	ldi	r24, 0x82	; 130
     d08:	9f ef       	ldi	r25, 0xFF	; 255
     d0a:	13 96       	adiw	r26, 0x03	; 3
     d0c:	9c 93       	st	X, r25
     d0e:	8e 93       	st	-X, r24
     d10:	12 97       	sbiw	r26, 0x02	; 2
     d12:	9a 01       	movw	r18, r20
     d14:	ab 01       	movw	r20, r22
     d16:	67 e0       	ldi	r22, 0x07	; 7
     d18:	22 0f       	add	r18, r18
     d1a:	33 1f       	adc	r19, r19
     d1c:	44 1f       	adc	r20, r20
     d1e:	55 1f       	adc	r21, r21
     d20:	6a 95       	dec	r22
     d22:	d1 f7       	brne	.-12     	; 0xd18 <__unpack_f+0x54>
     d24:	83 e0       	ldi	r24, 0x03	; 3
     d26:	8c 93       	st	X, r24
     d28:	0d c0       	rjmp	.+26     	; 0xd44 <__unpack_f+0x80>
     d2a:	22 0f       	add	r18, r18
     d2c:	33 1f       	adc	r19, r19
     d2e:	44 1f       	adc	r20, r20
     d30:	55 1f       	adc	r21, r21
     d32:	12 96       	adiw	r26, 0x02	; 2
     d34:	8d 91       	ld	r24, X+
     d36:	9c 91       	ld	r25, X
     d38:	13 97       	sbiw	r26, 0x03	; 3
     d3a:	01 97       	sbiw	r24, 0x01	; 1
     d3c:	13 96       	adiw	r26, 0x03	; 3
     d3e:	9c 93       	st	X, r25
     d40:	8e 93       	st	-X, r24
     d42:	12 97       	sbiw	r26, 0x02	; 2
     d44:	20 30       	cpi	r18, 0x00	; 0
     d46:	80 e0       	ldi	r24, 0x00	; 0
     d48:	38 07       	cpc	r19, r24
     d4a:	80 e0       	ldi	r24, 0x00	; 0
     d4c:	48 07       	cpc	r20, r24
     d4e:	80 e4       	ldi	r24, 0x40	; 64
     d50:	58 07       	cpc	r21, r24
     d52:	58 f3       	brcs	.-42     	; 0xd2a <__unpack_f+0x66>
     d54:	14 96       	adiw	r26, 0x04	; 4
     d56:	2d 93       	st	X+, r18
     d58:	3d 93       	st	X+, r19
     d5a:	4d 93       	st	X+, r20
     d5c:	5c 93       	st	X, r21
     d5e:	17 97       	sbiw	r26, 0x07	; 7
     d60:	08 95       	ret
     d62:	2f 3f       	cpi	r18, 0xFF	; 255
     d64:	31 05       	cpc	r19, r1
     d66:	79 f4       	brne	.+30     	; 0xd86 <__unpack_f+0xc2>
     d68:	41 15       	cp	r20, r1
     d6a:	51 05       	cpc	r21, r1
     d6c:	61 05       	cpc	r22, r1
     d6e:	71 05       	cpc	r23, r1
     d70:	19 f4       	brne	.+6      	; 0xd78 <__unpack_f+0xb4>
     d72:	84 e0       	ldi	r24, 0x04	; 4
     d74:	8c 93       	st	X, r24
     d76:	08 95       	ret
     d78:	64 ff       	sbrs	r22, 4
     d7a:	03 c0       	rjmp	.+6      	; 0xd82 <__unpack_f+0xbe>
     d7c:	81 e0       	ldi	r24, 0x01	; 1
     d7e:	8c 93       	st	X, r24
     d80:	12 c0       	rjmp	.+36     	; 0xda6 <__unpack_f+0xe2>
     d82:	1c 92       	st	X, r1
     d84:	10 c0       	rjmp	.+32     	; 0xda6 <__unpack_f+0xe2>
     d86:	2f 57       	subi	r18, 0x7F	; 127
     d88:	30 40       	sbci	r19, 0x00	; 0
     d8a:	13 96       	adiw	r26, 0x03	; 3
     d8c:	3c 93       	st	X, r19
     d8e:	2e 93       	st	-X, r18
     d90:	12 97       	sbiw	r26, 0x02	; 2
     d92:	83 e0       	ldi	r24, 0x03	; 3
     d94:	8c 93       	st	X, r24
     d96:	87 e0       	ldi	r24, 0x07	; 7
     d98:	44 0f       	add	r20, r20
     d9a:	55 1f       	adc	r21, r21
     d9c:	66 1f       	adc	r22, r22
     d9e:	77 1f       	adc	r23, r23
     da0:	8a 95       	dec	r24
     da2:	d1 f7       	brne	.-12     	; 0xd98 <__unpack_f+0xd4>
     da4:	70 64       	ori	r23, 0x40	; 64
     da6:	14 96       	adiw	r26, 0x04	; 4
     da8:	4d 93       	st	X+, r20
     daa:	5d 93       	st	X+, r21
     dac:	6d 93       	st	X+, r22
     dae:	7c 93       	st	X, r23
     db0:	17 97       	sbiw	r26, 0x07	; 7
     db2:	08 95       	ret

00000db4 <__fpcmp_parts_f>:
     db4:	1f 93       	push	r17
     db6:	dc 01       	movw	r26, r24
     db8:	fb 01       	movw	r30, r22
     dba:	9c 91       	ld	r25, X
     dbc:	92 30       	cpi	r25, 0x02	; 2
     dbe:	08 f4       	brcc	.+2      	; 0xdc2 <__fpcmp_parts_f+0xe>
     dc0:	47 c0       	rjmp	.+142    	; 0xe50 <__fpcmp_parts_f+0x9c>
     dc2:	80 81       	ld	r24, Z
     dc4:	82 30       	cpi	r24, 0x02	; 2
     dc6:	08 f4       	brcc	.+2      	; 0xdca <__fpcmp_parts_f+0x16>
     dc8:	43 c0       	rjmp	.+134    	; 0xe50 <__fpcmp_parts_f+0x9c>
     dca:	94 30       	cpi	r25, 0x04	; 4
     dcc:	51 f4       	brne	.+20     	; 0xde2 <__fpcmp_parts_f+0x2e>
     dce:	11 96       	adiw	r26, 0x01	; 1
     dd0:	1c 91       	ld	r17, X
     dd2:	84 30       	cpi	r24, 0x04	; 4
     dd4:	99 f5       	brne	.+102    	; 0xe3c <__fpcmp_parts_f+0x88>
     dd6:	81 81       	ldd	r24, Z+1	; 0x01
     dd8:	68 2f       	mov	r22, r24
     dda:	70 e0       	ldi	r23, 0x00	; 0
     ddc:	61 1b       	sub	r22, r17
     dde:	71 09       	sbc	r23, r1
     de0:	3f c0       	rjmp	.+126    	; 0xe60 <__fpcmp_parts_f+0xac>
     de2:	84 30       	cpi	r24, 0x04	; 4
     de4:	21 f0       	breq	.+8      	; 0xdee <__fpcmp_parts_f+0x3a>
     de6:	92 30       	cpi	r25, 0x02	; 2
     de8:	31 f4       	brne	.+12     	; 0xdf6 <__fpcmp_parts_f+0x42>
     dea:	82 30       	cpi	r24, 0x02	; 2
     dec:	b9 f1       	breq	.+110    	; 0xe5c <__fpcmp_parts_f+0xa8>
     dee:	81 81       	ldd	r24, Z+1	; 0x01
     df0:	88 23       	and	r24, r24
     df2:	89 f1       	breq	.+98     	; 0xe56 <__fpcmp_parts_f+0xa2>
     df4:	2d c0       	rjmp	.+90     	; 0xe50 <__fpcmp_parts_f+0x9c>
     df6:	11 96       	adiw	r26, 0x01	; 1
     df8:	1c 91       	ld	r17, X
     dfa:	11 97       	sbiw	r26, 0x01	; 1
     dfc:	82 30       	cpi	r24, 0x02	; 2
     dfe:	f1 f0       	breq	.+60     	; 0xe3c <__fpcmp_parts_f+0x88>
     e00:	81 81       	ldd	r24, Z+1	; 0x01
     e02:	18 17       	cp	r17, r24
     e04:	d9 f4       	brne	.+54     	; 0xe3c <__fpcmp_parts_f+0x88>
     e06:	12 96       	adiw	r26, 0x02	; 2
     e08:	2d 91       	ld	r18, X+
     e0a:	3c 91       	ld	r19, X
     e0c:	13 97       	sbiw	r26, 0x03	; 3
     e0e:	82 81       	ldd	r24, Z+2	; 0x02
     e10:	93 81       	ldd	r25, Z+3	; 0x03
     e12:	82 17       	cp	r24, r18
     e14:	93 07       	cpc	r25, r19
     e16:	94 f0       	brlt	.+36     	; 0xe3c <__fpcmp_parts_f+0x88>
     e18:	28 17       	cp	r18, r24
     e1a:	39 07       	cpc	r19, r25
     e1c:	bc f0       	brlt	.+46     	; 0xe4c <__fpcmp_parts_f+0x98>
     e1e:	14 96       	adiw	r26, 0x04	; 4
     e20:	8d 91       	ld	r24, X+
     e22:	9d 91       	ld	r25, X+
     e24:	0d 90       	ld	r0, X+
     e26:	bc 91       	ld	r27, X
     e28:	a0 2d       	mov	r26, r0
     e2a:	24 81       	ldd	r18, Z+4	; 0x04
     e2c:	35 81       	ldd	r19, Z+5	; 0x05
     e2e:	46 81       	ldd	r20, Z+6	; 0x06
     e30:	57 81       	ldd	r21, Z+7	; 0x07
     e32:	28 17       	cp	r18, r24
     e34:	39 07       	cpc	r19, r25
     e36:	4a 07       	cpc	r20, r26
     e38:	5b 07       	cpc	r21, r27
     e3a:	18 f4       	brcc	.+6      	; 0xe42 <__fpcmp_parts_f+0x8e>
     e3c:	11 23       	and	r17, r17
     e3e:	41 f0       	breq	.+16     	; 0xe50 <__fpcmp_parts_f+0x9c>
     e40:	0a c0       	rjmp	.+20     	; 0xe56 <__fpcmp_parts_f+0xa2>
     e42:	82 17       	cp	r24, r18
     e44:	93 07       	cpc	r25, r19
     e46:	a4 07       	cpc	r26, r20
     e48:	b5 07       	cpc	r27, r21
     e4a:	40 f4       	brcc	.+16     	; 0xe5c <__fpcmp_parts_f+0xa8>
     e4c:	11 23       	and	r17, r17
     e4e:	19 f0       	breq	.+6      	; 0xe56 <__fpcmp_parts_f+0xa2>
     e50:	61 e0       	ldi	r22, 0x01	; 1
     e52:	70 e0       	ldi	r23, 0x00	; 0
     e54:	05 c0       	rjmp	.+10     	; 0xe60 <__fpcmp_parts_f+0xac>
     e56:	6f ef       	ldi	r22, 0xFF	; 255
     e58:	7f ef       	ldi	r23, 0xFF	; 255
     e5a:	02 c0       	rjmp	.+4      	; 0xe60 <__fpcmp_parts_f+0xac>
     e5c:	60 e0       	ldi	r22, 0x00	; 0
     e5e:	70 e0       	ldi	r23, 0x00	; 0
     e60:	cb 01       	movw	r24, r22
     e62:	1f 91       	pop	r17
     e64:	08 95       	ret

00000e66 <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void * pvPortMalloc( size_t xWantedSize )
{
     e66:	df 93       	push	r29
     e68:	cf 93       	push	r28
     e6a:	00 d0       	rcall	.+0      	; 0xe6c <pvPortMalloc+0x6>
     e6c:	00 d0       	rcall	.+0      	; 0xe6e <pvPortMalloc+0x8>
     e6e:	cd b7       	in	r28, 0x3d	; 61
     e70:	de b7       	in	r29, 0x3e	; 62
     e72:	9c 83       	std	Y+4, r25	; 0x04
     e74:	8b 83       	std	Y+3, r24	; 0x03
    void * pvReturn = NULL;
     e76:	1a 82       	std	Y+2, r1	; 0x02
     e78:	19 82       	std	Y+1, r1	; 0x01
                }
            }
        }
    #endif

    vTaskSuspendAll();
     e7a:	0e 94 88 1e 	call	0x3d10	; 0x3d10 <vTaskSuspendAll>
    {
        if( pucAlignedHeap == NULL )
     e7e:	80 91 44 02 	lds	r24, 0x0244
     e82:	90 91 45 02 	lds	r25, 0x0245
     e86:	00 97       	sbiw	r24, 0x00	; 0
     e88:	31 f4       	brne	.+12     	; 0xe96 <pvPortMalloc+0x30>
        {
            /* Ensure the heap starts on a correctly aligned boundary. */
            pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) & ucHeap[ portBYTE_ALIGNMENT - 1 ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
     e8a:	86 e4       	ldi	r24, 0x46	; 70
     e8c:	92 e0       	ldi	r25, 0x02	; 2
     e8e:	90 93 45 02 	sts	0x0245, r25
     e92:	80 93 44 02 	sts	0x0244, r24
        }

        /* Check there is enough room left for the allocation and. */
        if( ( xWantedSize > 0 ) && /* valid size */
     e96:	8b 81       	ldd	r24, Y+3	; 0x03
     e98:	9c 81       	ldd	r25, Y+4	; 0x04
     e9a:	00 97       	sbiw	r24, 0x00	; 0
     e9c:	99 f1       	breq	.+102    	; 0xf04 <pvPortMalloc+0x9e>
     e9e:	80 91 42 02 	lds	r24, 0x0242
     ea2:	90 91 43 02 	lds	r25, 0x0243
     ea6:	2b 81       	ldd	r18, Y+3	; 0x03
     ea8:	3c 81       	ldd	r19, Y+4	; 0x04
     eaa:	82 0f       	add	r24, r18
     eac:	93 1f       	adc	r25, r19
     eae:	25 e0       	ldi	r18, 0x05	; 5
     eb0:	8b 3d       	cpi	r24, 0xDB	; 219
     eb2:	92 07       	cpc	r25, r18
     eb4:	38 f5       	brcc	.+78     	; 0xf04 <pvPortMalloc+0x9e>
     eb6:	20 91 42 02 	lds	r18, 0x0242
     eba:	30 91 43 02 	lds	r19, 0x0243
     ebe:	8b 81       	ldd	r24, Y+3	; 0x03
     ec0:	9c 81       	ldd	r25, Y+4	; 0x04
     ec2:	28 0f       	add	r18, r24
     ec4:	39 1f       	adc	r19, r25
     ec6:	80 91 42 02 	lds	r24, 0x0242
     eca:	90 91 43 02 	lds	r25, 0x0243
     ece:	82 17       	cp	r24, r18
     ed0:	93 07       	cpc	r25, r19
     ed2:	c0 f4       	brcc	.+48     	; 0xf04 <pvPortMalloc+0x9e>
            ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
            ( ( xNextFreeByte + xWantedSize ) > xNextFreeByte ) ) /* Check for overflow. */
        {
            /* Return the next free byte then increment the index past this
             * block. */
            pvReturn = pucAlignedHeap + xNextFreeByte;
     ed4:	20 91 44 02 	lds	r18, 0x0244
     ed8:	30 91 45 02 	lds	r19, 0x0245
     edc:	80 91 42 02 	lds	r24, 0x0242
     ee0:	90 91 43 02 	lds	r25, 0x0243
     ee4:	82 0f       	add	r24, r18
     ee6:	93 1f       	adc	r25, r19
     ee8:	9a 83       	std	Y+2, r25	; 0x02
     eea:	89 83       	std	Y+1, r24	; 0x01
            xNextFreeByte += xWantedSize;
     eec:	20 91 42 02 	lds	r18, 0x0242
     ef0:	30 91 43 02 	lds	r19, 0x0243
     ef4:	8b 81       	ldd	r24, Y+3	; 0x03
     ef6:	9c 81       	ldd	r25, Y+4	; 0x04
     ef8:	82 0f       	add	r24, r18
     efa:	93 1f       	adc	r25, r19
     efc:	90 93 43 02 	sts	0x0243, r25
     f00:	80 93 42 02 	sts	0x0242, r24
        }

        traceMALLOC( pvReturn, xWantedSize );
    }
    ( void ) xTaskResumeAll();
     f04:	0e 94 94 1e 	call	0x3d28	; 0x3d28 <xTaskResumeAll>
                vApplicationMallocFailedHook();
            }
        }
    #endif

    return pvReturn;
     f08:	89 81       	ldd	r24, Y+1	; 0x01
     f0a:	9a 81       	ldd	r25, Y+2	; 0x02
}
     f0c:	0f 90       	pop	r0
     f0e:	0f 90       	pop	r0
     f10:	0f 90       	pop	r0
     f12:	0f 90       	pop	r0
     f14:	cf 91       	pop	r28
     f16:	df 91       	pop	r29
     f18:	08 95       	ret

00000f1a <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void * pv )
{
     f1a:	df 93       	push	r29
     f1c:	cf 93       	push	r28
     f1e:	00 d0       	rcall	.+0      	; 0xf20 <vPortFree+0x6>
     f20:	cd b7       	in	r28, 0x3d	; 61
     f22:	de b7       	in	r29, 0x3e	; 62
     f24:	9a 83       	std	Y+2, r25	; 0x02
     f26:	89 83       	std	Y+1, r24	; 0x01
     * https://www.FreeRTOS.org for more information. */
    ( void ) pv;

    /* Force an assert as it is invalid to call this function. */
    configASSERT( pv == NULL );
}
     f28:	0f 90       	pop	r0
     f2a:	0f 90       	pop	r0
     f2c:	cf 91       	pop	r28
     f2e:	df 91       	pop	r29
     f30:	08 95       	ret

00000f32 <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
     f32:	df 93       	push	r29
     f34:	cf 93       	push	r28
     f36:	cd b7       	in	r28, 0x3d	; 61
     f38:	de b7       	in	r29, 0x3e	; 62
    /* Only required when static memory is not cleared. */
    xNextFreeByte = ( size_t ) 0;
     f3a:	10 92 43 02 	sts	0x0243, r1
     f3e:	10 92 42 02 	sts	0x0242, r1
}
     f42:	cf 91       	pop	r28
     f44:	df 91       	pop	r29
     f46:	08 95       	ret

00000f48 <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
     f48:	df 93       	push	r29
     f4a:	cf 93       	push	r28
     f4c:	cd b7       	in	r28, 0x3d	; 61
     f4e:	de b7       	in	r29, 0x3e	; 62
    return( configADJUSTED_HEAP_SIZE - xNextFreeByte );
     f50:	20 91 42 02 	lds	r18, 0x0242
     f54:	30 91 43 02 	lds	r19, 0x0243
     f58:	8b ed       	ldi	r24, 0xDB	; 219
     f5a:	95 e0       	ldi	r25, 0x05	; 5
     f5c:	82 1b       	sub	r24, r18
     f5e:	93 0b       	sbc	r25, r19
}
     f60:	cf 91       	pop	r28
     f62:	df 91       	pop	r29
     f64:	08 95       	ret

00000f66 <pxPortInitialiseStack>:

/* 
 * See header file for description. 
 */
StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
{
     f66:	df 93       	push	r29
     f68:	cf 93       	push	r28
     f6a:	cd b7       	in	r28, 0x3d	; 61
     f6c:	de b7       	in	r29, 0x3e	; 62
     f6e:	28 97       	sbiw	r28, 0x08	; 8
     f70:	0f b6       	in	r0, 0x3f	; 63
     f72:	f8 94       	cli
     f74:	de bf       	out	0x3e, r29	; 62
     f76:	0f be       	out	0x3f, r0	; 63
     f78:	cd bf       	out	0x3d, r28	; 61
     f7a:	9c 83       	std	Y+4, r25	; 0x04
     f7c:	8b 83       	std	Y+3, r24	; 0x03
     f7e:	7e 83       	std	Y+6, r23	; 0x06
     f80:	6d 83       	std	Y+5, r22	; 0x05
     f82:	58 87       	std	Y+8, r21	; 0x08
     f84:	4f 83       	std	Y+7, r20	; 0x07
uint16_t usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
     f86:	eb 81       	ldd	r30, Y+3	; 0x03
     f88:	fc 81       	ldd	r31, Y+4	; 0x04
     f8a:	81 e1       	ldi	r24, 0x11	; 17
     f8c:	80 83       	st	Z, r24
	pxTopOfStack--;
     f8e:	8b 81       	ldd	r24, Y+3	; 0x03
     f90:	9c 81       	ldd	r25, Y+4	; 0x04
     f92:	01 97       	sbiw	r24, 0x01	; 1
     f94:	9c 83       	std	Y+4, r25	; 0x04
     f96:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x22;
     f98:	eb 81       	ldd	r30, Y+3	; 0x03
     f9a:	fc 81       	ldd	r31, Y+4	; 0x04
     f9c:	82 e2       	ldi	r24, 0x22	; 34
     f9e:	80 83       	st	Z, r24
	pxTopOfStack--;
     fa0:	8b 81       	ldd	r24, Y+3	; 0x03
     fa2:	9c 81       	ldd	r25, Y+4	; 0x04
     fa4:	01 97       	sbiw	r24, 0x01	; 1
     fa6:	9c 83       	std	Y+4, r25	; 0x04
     fa8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x33;
     faa:	eb 81       	ldd	r30, Y+3	; 0x03
     fac:	fc 81       	ldd	r31, Y+4	; 0x04
     fae:	83 e3       	ldi	r24, 0x33	; 51
     fb0:	80 83       	st	Z, r24
	pxTopOfStack--;
     fb2:	8b 81       	ldd	r24, Y+3	; 0x03
     fb4:	9c 81       	ldd	r25, Y+4	; 0x04
     fb6:	01 97       	sbiw	r24, 0x01	; 1
     fb8:	9c 83       	std	Y+4, r25	; 0x04
     fba:	8b 83       	std	Y+3, r24	; 0x03

	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( uint16_t ) pxCode;
     fbc:	8d 81       	ldd	r24, Y+5	; 0x05
     fbe:	9e 81       	ldd	r25, Y+6	; 0x06
     fc0:	9a 83       	std	Y+2, r25	; 0x02
     fc2:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     fc4:	89 81       	ldd	r24, Y+1	; 0x01
     fc6:	eb 81       	ldd	r30, Y+3	; 0x03
     fc8:	fc 81       	ldd	r31, Y+4	; 0x04
     fca:	80 83       	st	Z, r24
	pxTopOfStack--;
     fcc:	8b 81       	ldd	r24, Y+3	; 0x03
     fce:	9c 81       	ldd	r25, Y+4	; 0x04
     fd0:	01 97       	sbiw	r24, 0x01	; 1
     fd2:	9c 83       	std	Y+4, r25	; 0x04
     fd4:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
     fd6:	89 81       	ldd	r24, Y+1	; 0x01
     fd8:	9a 81       	ldd	r25, Y+2	; 0x02
     fda:	89 2f       	mov	r24, r25
     fdc:	99 27       	eor	r25, r25
     fde:	9a 83       	std	Y+2, r25	; 0x02
     fe0:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     fe2:	89 81       	ldd	r24, Y+1	; 0x01
     fe4:	eb 81       	ldd	r30, Y+3	; 0x03
     fe6:	fc 81       	ldd	r31, Y+4	; 0x04
     fe8:	80 83       	st	Z, r24
	pxTopOfStack--;
     fea:	8b 81       	ldd	r24, Y+3	; 0x03
     fec:	9c 81       	ldd	r25, Y+4	; 0x04
     fee:	01 97       	sbiw	r24, 0x01	; 1
     ff0:	9c 83       	std	Y+4, r25	; 0x04
     ff2:	8b 83       	std	Y+3, r24	; 0x03

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R0 */
     ff4:	eb 81       	ldd	r30, Y+3	; 0x03
     ff6:	fc 81       	ldd	r31, Y+4	; 0x04
     ff8:	10 82       	st	Z, r1
	pxTopOfStack--;
     ffa:	8b 81       	ldd	r24, Y+3	; 0x03
     ffc:	9c 81       	ldd	r25, Y+4	; 0x04
     ffe:	01 97       	sbiw	r24, 0x01	; 1
    1000:	9c 83       	std	Y+4, r25	; 0x04
    1002:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = portFLAGS_INT_ENABLED;
    1004:	eb 81       	ldd	r30, Y+3	; 0x03
    1006:	fc 81       	ldd	r31, Y+4	; 0x04
    1008:	80 e8       	ldi	r24, 0x80	; 128
    100a:	80 83       	st	Z, r24
	pxTopOfStack--;
    100c:	8b 81       	ldd	r24, Y+3	; 0x03
    100e:	9c 81       	ldd	r25, Y+4	; 0x04
    1010:	01 97       	sbiw	r24, 0x01	; 1
    1012:	9c 83       	std	Y+4, r25	; 0x04
    1014:	8b 83       	std	Y+3, r24	; 0x03


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R1 */
    1016:	eb 81       	ldd	r30, Y+3	; 0x03
    1018:	fc 81       	ldd	r31, Y+4	; 0x04
    101a:	10 82       	st	Z, r1
	pxTopOfStack--;
    101c:	8b 81       	ldd	r24, Y+3	; 0x03
    101e:	9c 81       	ldd	r25, Y+4	; 0x04
    1020:	01 97       	sbiw	r24, 0x01	; 1
    1022:	9c 83       	std	Y+4, r25	; 0x04
    1024:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x02;	/* R2 */
    1026:	eb 81       	ldd	r30, Y+3	; 0x03
    1028:	fc 81       	ldd	r31, Y+4	; 0x04
    102a:	82 e0       	ldi	r24, 0x02	; 2
    102c:	80 83       	st	Z, r24
	pxTopOfStack--;
    102e:	8b 81       	ldd	r24, Y+3	; 0x03
    1030:	9c 81       	ldd	r25, Y+4	; 0x04
    1032:	01 97       	sbiw	r24, 0x01	; 1
    1034:	9c 83       	std	Y+4, r25	; 0x04
    1036:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x03;	/* R3 */
    1038:	eb 81       	ldd	r30, Y+3	; 0x03
    103a:	fc 81       	ldd	r31, Y+4	; 0x04
    103c:	83 e0       	ldi	r24, 0x03	; 3
    103e:	80 83       	st	Z, r24
	pxTopOfStack--;
    1040:	8b 81       	ldd	r24, Y+3	; 0x03
    1042:	9c 81       	ldd	r25, Y+4	; 0x04
    1044:	01 97       	sbiw	r24, 0x01	; 1
    1046:	9c 83       	std	Y+4, r25	; 0x04
    1048:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x04;	/* R4 */
    104a:	eb 81       	ldd	r30, Y+3	; 0x03
    104c:	fc 81       	ldd	r31, Y+4	; 0x04
    104e:	84 e0       	ldi	r24, 0x04	; 4
    1050:	80 83       	st	Z, r24
	pxTopOfStack--;
    1052:	8b 81       	ldd	r24, Y+3	; 0x03
    1054:	9c 81       	ldd	r25, Y+4	; 0x04
    1056:	01 97       	sbiw	r24, 0x01	; 1
    1058:	9c 83       	std	Y+4, r25	; 0x04
    105a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x05;	/* R5 */
    105c:	eb 81       	ldd	r30, Y+3	; 0x03
    105e:	fc 81       	ldd	r31, Y+4	; 0x04
    1060:	85 e0       	ldi	r24, 0x05	; 5
    1062:	80 83       	st	Z, r24
	pxTopOfStack--;
    1064:	8b 81       	ldd	r24, Y+3	; 0x03
    1066:	9c 81       	ldd	r25, Y+4	; 0x04
    1068:	01 97       	sbiw	r24, 0x01	; 1
    106a:	9c 83       	std	Y+4, r25	; 0x04
    106c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x06;	/* R6 */
    106e:	eb 81       	ldd	r30, Y+3	; 0x03
    1070:	fc 81       	ldd	r31, Y+4	; 0x04
    1072:	86 e0       	ldi	r24, 0x06	; 6
    1074:	80 83       	st	Z, r24
	pxTopOfStack--;
    1076:	8b 81       	ldd	r24, Y+3	; 0x03
    1078:	9c 81       	ldd	r25, Y+4	; 0x04
    107a:	01 97       	sbiw	r24, 0x01	; 1
    107c:	9c 83       	std	Y+4, r25	; 0x04
    107e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x07;	/* R7 */
    1080:	eb 81       	ldd	r30, Y+3	; 0x03
    1082:	fc 81       	ldd	r31, Y+4	; 0x04
    1084:	87 e0       	ldi	r24, 0x07	; 7
    1086:	80 83       	st	Z, r24
	pxTopOfStack--;
    1088:	8b 81       	ldd	r24, Y+3	; 0x03
    108a:	9c 81       	ldd	r25, Y+4	; 0x04
    108c:	01 97       	sbiw	r24, 0x01	; 1
    108e:	9c 83       	std	Y+4, r25	; 0x04
    1090:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x08;	/* R8 */
    1092:	eb 81       	ldd	r30, Y+3	; 0x03
    1094:	fc 81       	ldd	r31, Y+4	; 0x04
    1096:	88 e0       	ldi	r24, 0x08	; 8
    1098:	80 83       	st	Z, r24
	pxTopOfStack--;
    109a:	8b 81       	ldd	r24, Y+3	; 0x03
    109c:	9c 81       	ldd	r25, Y+4	; 0x04
    109e:	01 97       	sbiw	r24, 0x01	; 1
    10a0:	9c 83       	std	Y+4, r25	; 0x04
    10a2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x09;	/* R9 */
    10a4:	eb 81       	ldd	r30, Y+3	; 0x03
    10a6:	fc 81       	ldd	r31, Y+4	; 0x04
    10a8:	89 e0       	ldi	r24, 0x09	; 9
    10aa:	80 83       	st	Z, r24
	pxTopOfStack--;
    10ac:	8b 81       	ldd	r24, Y+3	; 0x03
    10ae:	9c 81       	ldd	r25, Y+4	; 0x04
    10b0:	01 97       	sbiw	r24, 0x01	; 1
    10b2:	9c 83       	std	Y+4, r25	; 0x04
    10b4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x10;	/* R10 */
    10b6:	eb 81       	ldd	r30, Y+3	; 0x03
    10b8:	fc 81       	ldd	r31, Y+4	; 0x04
    10ba:	80 e1       	ldi	r24, 0x10	; 16
    10bc:	80 83       	st	Z, r24
	pxTopOfStack--;
    10be:	8b 81       	ldd	r24, Y+3	; 0x03
    10c0:	9c 81       	ldd	r25, Y+4	; 0x04
    10c2:	01 97       	sbiw	r24, 0x01	; 1
    10c4:	9c 83       	std	Y+4, r25	; 0x04
    10c6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x11;	/* R11 */
    10c8:	eb 81       	ldd	r30, Y+3	; 0x03
    10ca:	fc 81       	ldd	r31, Y+4	; 0x04
    10cc:	81 e1       	ldi	r24, 0x11	; 17
    10ce:	80 83       	st	Z, r24
	pxTopOfStack--;
    10d0:	8b 81       	ldd	r24, Y+3	; 0x03
    10d2:	9c 81       	ldd	r25, Y+4	; 0x04
    10d4:	01 97       	sbiw	r24, 0x01	; 1
    10d6:	9c 83       	std	Y+4, r25	; 0x04
    10d8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x12;	/* R12 */
    10da:	eb 81       	ldd	r30, Y+3	; 0x03
    10dc:	fc 81       	ldd	r31, Y+4	; 0x04
    10de:	82 e1       	ldi	r24, 0x12	; 18
    10e0:	80 83       	st	Z, r24
	pxTopOfStack--;
    10e2:	8b 81       	ldd	r24, Y+3	; 0x03
    10e4:	9c 81       	ldd	r25, Y+4	; 0x04
    10e6:	01 97       	sbiw	r24, 0x01	; 1
    10e8:	9c 83       	std	Y+4, r25	; 0x04
    10ea:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x13;	/* R13 */
    10ec:	eb 81       	ldd	r30, Y+3	; 0x03
    10ee:	fc 81       	ldd	r31, Y+4	; 0x04
    10f0:	83 e1       	ldi	r24, 0x13	; 19
    10f2:	80 83       	st	Z, r24
	pxTopOfStack--;
    10f4:	8b 81       	ldd	r24, Y+3	; 0x03
    10f6:	9c 81       	ldd	r25, Y+4	; 0x04
    10f8:	01 97       	sbiw	r24, 0x01	; 1
    10fa:	9c 83       	std	Y+4, r25	; 0x04
    10fc:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x14;	/* R14 */
    10fe:	eb 81       	ldd	r30, Y+3	; 0x03
    1100:	fc 81       	ldd	r31, Y+4	; 0x04
    1102:	84 e1       	ldi	r24, 0x14	; 20
    1104:	80 83       	st	Z, r24
	pxTopOfStack--;
    1106:	8b 81       	ldd	r24, Y+3	; 0x03
    1108:	9c 81       	ldd	r25, Y+4	; 0x04
    110a:	01 97       	sbiw	r24, 0x01	; 1
    110c:	9c 83       	std	Y+4, r25	; 0x04
    110e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x15;	/* R15 */
    1110:	eb 81       	ldd	r30, Y+3	; 0x03
    1112:	fc 81       	ldd	r31, Y+4	; 0x04
    1114:	85 e1       	ldi	r24, 0x15	; 21
    1116:	80 83       	st	Z, r24
	pxTopOfStack--;
    1118:	8b 81       	ldd	r24, Y+3	; 0x03
    111a:	9c 81       	ldd	r25, Y+4	; 0x04
    111c:	01 97       	sbiw	r24, 0x01	; 1
    111e:	9c 83       	std	Y+4, r25	; 0x04
    1120:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x16;	/* R16 */
    1122:	eb 81       	ldd	r30, Y+3	; 0x03
    1124:	fc 81       	ldd	r31, Y+4	; 0x04
    1126:	86 e1       	ldi	r24, 0x16	; 22
    1128:	80 83       	st	Z, r24
	pxTopOfStack--;
    112a:	8b 81       	ldd	r24, Y+3	; 0x03
    112c:	9c 81       	ldd	r25, Y+4	; 0x04
    112e:	01 97       	sbiw	r24, 0x01	; 1
    1130:	9c 83       	std	Y+4, r25	; 0x04
    1132:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x17;	/* R17 */
    1134:	eb 81       	ldd	r30, Y+3	; 0x03
    1136:	fc 81       	ldd	r31, Y+4	; 0x04
    1138:	87 e1       	ldi	r24, 0x17	; 23
    113a:	80 83       	st	Z, r24
	pxTopOfStack--;
    113c:	8b 81       	ldd	r24, Y+3	; 0x03
    113e:	9c 81       	ldd	r25, Y+4	; 0x04
    1140:	01 97       	sbiw	r24, 0x01	; 1
    1142:	9c 83       	std	Y+4, r25	; 0x04
    1144:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x18;	/* R18 */
    1146:	eb 81       	ldd	r30, Y+3	; 0x03
    1148:	fc 81       	ldd	r31, Y+4	; 0x04
    114a:	88 e1       	ldi	r24, 0x18	; 24
    114c:	80 83       	st	Z, r24
	pxTopOfStack--;
    114e:	8b 81       	ldd	r24, Y+3	; 0x03
    1150:	9c 81       	ldd	r25, Y+4	; 0x04
    1152:	01 97       	sbiw	r24, 0x01	; 1
    1154:	9c 83       	std	Y+4, r25	; 0x04
    1156:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x19;	/* R19 */
    1158:	eb 81       	ldd	r30, Y+3	; 0x03
    115a:	fc 81       	ldd	r31, Y+4	; 0x04
    115c:	89 e1       	ldi	r24, 0x19	; 25
    115e:	80 83       	st	Z, r24
	pxTopOfStack--;
    1160:	8b 81       	ldd	r24, Y+3	; 0x03
    1162:	9c 81       	ldd	r25, Y+4	; 0x04
    1164:	01 97       	sbiw	r24, 0x01	; 1
    1166:	9c 83       	std	Y+4, r25	; 0x04
    1168:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x20;	/* R20 */
    116a:	eb 81       	ldd	r30, Y+3	; 0x03
    116c:	fc 81       	ldd	r31, Y+4	; 0x04
    116e:	80 e2       	ldi	r24, 0x20	; 32
    1170:	80 83       	st	Z, r24
	pxTopOfStack--;
    1172:	8b 81       	ldd	r24, Y+3	; 0x03
    1174:	9c 81       	ldd	r25, Y+4	; 0x04
    1176:	01 97       	sbiw	r24, 0x01	; 1
    1178:	9c 83       	std	Y+4, r25	; 0x04
    117a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x21;	/* R21 */
    117c:	eb 81       	ldd	r30, Y+3	; 0x03
    117e:	fc 81       	ldd	r31, Y+4	; 0x04
    1180:	81 e2       	ldi	r24, 0x21	; 33
    1182:	80 83       	st	Z, r24
	pxTopOfStack--;
    1184:	8b 81       	ldd	r24, Y+3	; 0x03
    1186:	9c 81       	ldd	r25, Y+4	; 0x04
    1188:	01 97       	sbiw	r24, 0x01	; 1
    118a:	9c 83       	std	Y+4, r25	; 0x04
    118c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x22;	/* R22 */
    118e:	eb 81       	ldd	r30, Y+3	; 0x03
    1190:	fc 81       	ldd	r31, Y+4	; 0x04
    1192:	82 e2       	ldi	r24, 0x22	; 34
    1194:	80 83       	st	Z, r24
	pxTopOfStack--;
    1196:	8b 81       	ldd	r24, Y+3	; 0x03
    1198:	9c 81       	ldd	r25, Y+4	; 0x04
    119a:	01 97       	sbiw	r24, 0x01	; 1
    119c:	9c 83       	std	Y+4, r25	; 0x04
    119e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x23;	/* R23 */
    11a0:	eb 81       	ldd	r30, Y+3	; 0x03
    11a2:	fc 81       	ldd	r31, Y+4	; 0x04
    11a4:	83 e2       	ldi	r24, 0x23	; 35
    11a6:	80 83       	st	Z, r24
	pxTopOfStack--;
    11a8:	8b 81       	ldd	r24, Y+3	; 0x03
    11aa:	9c 81       	ldd	r25, Y+4	; 0x04
    11ac:	01 97       	sbiw	r24, 0x01	; 1
    11ae:	9c 83       	std	Y+4, r25	; 0x04
    11b0:	8b 83       	std	Y+3, r24	; 0x03

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( uint16_t ) pvParameters;
    11b2:	8f 81       	ldd	r24, Y+7	; 0x07
    11b4:	98 85       	ldd	r25, Y+8	; 0x08
    11b6:	9a 83       	std	Y+2, r25	; 0x02
    11b8:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    11ba:	89 81       	ldd	r24, Y+1	; 0x01
    11bc:	eb 81       	ldd	r30, Y+3	; 0x03
    11be:	fc 81       	ldd	r31, Y+4	; 0x04
    11c0:	80 83       	st	Z, r24
	pxTopOfStack--;
    11c2:	8b 81       	ldd	r24, Y+3	; 0x03
    11c4:	9c 81       	ldd	r25, Y+4	; 0x04
    11c6:	01 97       	sbiw	r24, 0x01	; 1
    11c8:	9c 83       	std	Y+4, r25	; 0x04
    11ca:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    11cc:	89 81       	ldd	r24, Y+1	; 0x01
    11ce:	9a 81       	ldd	r25, Y+2	; 0x02
    11d0:	89 2f       	mov	r24, r25
    11d2:	99 27       	eor	r25, r25
    11d4:	9a 83       	std	Y+2, r25	; 0x02
    11d6:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    11d8:	89 81       	ldd	r24, Y+1	; 0x01
    11da:	eb 81       	ldd	r30, Y+3	; 0x03
    11dc:	fc 81       	ldd	r31, Y+4	; 0x04
    11de:	80 83       	st	Z, r24
	pxTopOfStack--;
    11e0:	8b 81       	ldd	r24, Y+3	; 0x03
    11e2:	9c 81       	ldd	r25, Y+4	; 0x04
    11e4:	01 97       	sbiw	r24, 0x01	; 1
    11e6:	9c 83       	std	Y+4, r25	; 0x04
    11e8:	8b 83       	std	Y+3, r24	; 0x03

	*pxTopOfStack = ( StackType_t ) 0x26;	/* R26 X */
    11ea:	eb 81       	ldd	r30, Y+3	; 0x03
    11ec:	fc 81       	ldd	r31, Y+4	; 0x04
    11ee:	86 e2       	ldi	r24, 0x26	; 38
    11f0:	80 83       	st	Z, r24
	pxTopOfStack--;
    11f2:	8b 81       	ldd	r24, Y+3	; 0x03
    11f4:	9c 81       	ldd	r25, Y+4	; 0x04
    11f6:	01 97       	sbiw	r24, 0x01	; 1
    11f8:	9c 83       	std	Y+4, r25	; 0x04
    11fa:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x27;	/* R27 */
    11fc:	eb 81       	ldd	r30, Y+3	; 0x03
    11fe:	fc 81       	ldd	r31, Y+4	; 0x04
    1200:	87 e2       	ldi	r24, 0x27	; 39
    1202:	80 83       	st	Z, r24
	pxTopOfStack--;
    1204:	8b 81       	ldd	r24, Y+3	; 0x03
    1206:	9c 81       	ldd	r25, Y+4	; 0x04
    1208:	01 97       	sbiw	r24, 0x01	; 1
    120a:	9c 83       	std	Y+4, r25	; 0x04
    120c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x28;	/* R28 Y */
    120e:	eb 81       	ldd	r30, Y+3	; 0x03
    1210:	fc 81       	ldd	r31, Y+4	; 0x04
    1212:	88 e2       	ldi	r24, 0x28	; 40
    1214:	80 83       	st	Z, r24
	pxTopOfStack--;
    1216:	8b 81       	ldd	r24, Y+3	; 0x03
    1218:	9c 81       	ldd	r25, Y+4	; 0x04
    121a:	01 97       	sbiw	r24, 0x01	; 1
    121c:	9c 83       	std	Y+4, r25	; 0x04
    121e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x29;	/* R29 */
    1220:	eb 81       	ldd	r30, Y+3	; 0x03
    1222:	fc 81       	ldd	r31, Y+4	; 0x04
    1224:	89 e2       	ldi	r24, 0x29	; 41
    1226:	80 83       	st	Z, r24
	pxTopOfStack--;
    1228:	8b 81       	ldd	r24, Y+3	; 0x03
    122a:	9c 81       	ldd	r25, Y+4	; 0x04
    122c:	01 97       	sbiw	r24, 0x01	; 1
    122e:	9c 83       	std	Y+4, r25	; 0x04
    1230:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x30;	/* R30 Z */
    1232:	eb 81       	ldd	r30, Y+3	; 0x03
    1234:	fc 81       	ldd	r31, Y+4	; 0x04
    1236:	80 e3       	ldi	r24, 0x30	; 48
    1238:	80 83       	st	Z, r24
	pxTopOfStack--;
    123a:	8b 81       	ldd	r24, Y+3	; 0x03
    123c:	9c 81       	ldd	r25, Y+4	; 0x04
    123e:	01 97       	sbiw	r24, 0x01	; 1
    1240:	9c 83       	std	Y+4, r25	; 0x04
    1242:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x031;	/* R31 */
    1244:	eb 81       	ldd	r30, Y+3	; 0x03
    1246:	fc 81       	ldd	r31, Y+4	; 0x04
    1248:	81 e3       	ldi	r24, 0x31	; 49
    124a:	80 83       	st	Z, r24
	pxTopOfStack--;
    124c:	8b 81       	ldd	r24, Y+3	; 0x03
    124e:	9c 81       	ldd	r25, Y+4	; 0x04
    1250:	01 97       	sbiw	r24, 0x01	; 1
    1252:	9c 83       	std	Y+4, r25	; 0x04
    1254:	8b 83       	std	Y+3, r24	; 0x03

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
    1256:	8b 81       	ldd	r24, Y+3	; 0x03
    1258:	9c 81       	ldd	r25, Y+4	; 0x04
}
    125a:	28 96       	adiw	r28, 0x08	; 8
    125c:	0f b6       	in	r0, 0x3f	; 63
    125e:	f8 94       	cli
    1260:	de bf       	out	0x3e, r29	; 62
    1262:	0f be       	out	0x3f, r0	; 63
    1264:	cd bf       	out	0x3d, r28	; 61
    1266:	cf 91       	pop	r28
    1268:	df 91       	pop	r29
    126a:	08 95       	ret

0000126c <xPortStartScheduler>:
/*-----------------------------------------------------------*/

BaseType_t xPortStartScheduler( void )
{
    126c:	df 93       	push	r29
    126e:	cf 93       	push	r28
    1270:	cd b7       	in	r28, 0x3d	; 61
    1272:	de b7       	in	r29, 0x3e	; 62
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();
    1274:	0e 94 28 0a 	call	0x1450	; 0x1450 <prvSetupTimerInterrupt>

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    1278:	a0 91 5c 08 	lds	r26, 0x085C
    127c:	b0 91 5d 08 	lds	r27, 0x085D
    1280:	cd 91       	ld	r28, X+
    1282:	cd bf       	out	0x3d, r28	; 61
    1284:	dd 91       	ld	r29, X+
    1286:	de bf       	out	0x3e, r29	; 62
    1288:	ff 91       	pop	r31
    128a:	ef 91       	pop	r30
    128c:	df 91       	pop	r29
    128e:	cf 91       	pop	r28
    1290:	bf 91       	pop	r27
    1292:	af 91       	pop	r26
    1294:	9f 91       	pop	r25
    1296:	8f 91       	pop	r24
    1298:	7f 91       	pop	r23
    129a:	6f 91       	pop	r22
    129c:	5f 91       	pop	r21
    129e:	4f 91       	pop	r20
    12a0:	3f 91       	pop	r19
    12a2:	2f 91       	pop	r18
    12a4:	1f 91       	pop	r17
    12a6:	0f 91       	pop	r16
    12a8:	ff 90       	pop	r15
    12aa:	ef 90       	pop	r14
    12ac:	df 90       	pop	r13
    12ae:	cf 90       	pop	r12
    12b0:	bf 90       	pop	r11
    12b2:	af 90       	pop	r10
    12b4:	9f 90       	pop	r9
    12b6:	8f 90       	pop	r8
    12b8:	7f 90       	pop	r7
    12ba:	6f 90       	pop	r6
    12bc:	5f 90       	pop	r5
    12be:	4f 90       	pop	r4
    12c0:	3f 90       	pop	r3
    12c2:	2f 90       	pop	r2
    12c4:	1f 90       	pop	r1
    12c6:	0f 90       	pop	r0
    12c8:	0f be       	out	0x3f, r0	; 63
    12ca:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
    12cc:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
    12ce:	81 e0       	ldi	r24, 0x01	; 1
}
    12d0:	cf 91       	pop	r28
    12d2:	df 91       	pop	r29
    12d4:	08 95       	ret

000012d6 <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    12d6:	df 93       	push	r29
    12d8:	cf 93       	push	r28
    12da:	cd b7       	in	r28, 0x3d	; 61
    12dc:	de b7       	in	r29, 0x3e	; 62
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
    12de:	cf 91       	pop	r28
    12e0:	df 91       	pop	r29
    12e2:	08 95       	ret

000012e4 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    12e4:	0f 92       	push	r0
    12e6:	0f b6       	in	r0, 0x3f	; 63
    12e8:	f8 94       	cli
    12ea:	0f 92       	push	r0
    12ec:	1f 92       	push	r1
    12ee:	11 24       	eor	r1, r1
    12f0:	2f 92       	push	r2
    12f2:	3f 92       	push	r3
    12f4:	4f 92       	push	r4
    12f6:	5f 92       	push	r5
    12f8:	6f 92       	push	r6
    12fa:	7f 92       	push	r7
    12fc:	8f 92       	push	r8
    12fe:	9f 92       	push	r9
    1300:	af 92       	push	r10
    1302:	bf 92       	push	r11
    1304:	cf 92       	push	r12
    1306:	df 92       	push	r13
    1308:	ef 92       	push	r14
    130a:	ff 92       	push	r15
    130c:	0f 93       	push	r16
    130e:	1f 93       	push	r17
    1310:	2f 93       	push	r18
    1312:	3f 93       	push	r19
    1314:	4f 93       	push	r20
    1316:	5f 93       	push	r21
    1318:	6f 93       	push	r22
    131a:	7f 93       	push	r23
    131c:	8f 93       	push	r24
    131e:	9f 93       	push	r25
    1320:	af 93       	push	r26
    1322:	bf 93       	push	r27
    1324:	cf 93       	push	r28
    1326:	df 93       	push	r29
    1328:	ef 93       	push	r30
    132a:	ff 93       	push	r31
    132c:	a0 91 5c 08 	lds	r26, 0x085C
    1330:	b0 91 5d 08 	lds	r27, 0x085D
    1334:	0d b6       	in	r0, 0x3d	; 61
    1336:	0d 92       	st	X+, r0
    1338:	0e b6       	in	r0, 0x3e	; 62
    133a:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    133c:	0e 94 f8 21 	call	0x43f0	; 0x43f0 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    1340:	a0 91 5c 08 	lds	r26, 0x085C
    1344:	b0 91 5d 08 	lds	r27, 0x085D
    1348:	cd 91       	ld	r28, X+
    134a:	cd bf       	out	0x3d, r28	; 61
    134c:	dd 91       	ld	r29, X+
    134e:	de bf       	out	0x3e, r29	; 62
    1350:	ff 91       	pop	r31
    1352:	ef 91       	pop	r30
    1354:	df 91       	pop	r29
    1356:	cf 91       	pop	r28
    1358:	bf 91       	pop	r27
    135a:	af 91       	pop	r26
    135c:	9f 91       	pop	r25
    135e:	8f 91       	pop	r24
    1360:	7f 91       	pop	r23
    1362:	6f 91       	pop	r22
    1364:	5f 91       	pop	r21
    1366:	4f 91       	pop	r20
    1368:	3f 91       	pop	r19
    136a:	2f 91       	pop	r18
    136c:	1f 91       	pop	r17
    136e:	0f 91       	pop	r16
    1370:	ff 90       	pop	r15
    1372:	ef 90       	pop	r14
    1374:	df 90       	pop	r13
    1376:	cf 90       	pop	r12
    1378:	bf 90       	pop	r11
    137a:	af 90       	pop	r10
    137c:	9f 90       	pop	r9
    137e:	8f 90       	pop	r8
    1380:	7f 90       	pop	r7
    1382:	6f 90       	pop	r6
    1384:	5f 90       	pop	r5
    1386:	4f 90       	pop	r4
    1388:	3f 90       	pop	r3
    138a:	2f 90       	pop	r2
    138c:	1f 90       	pop	r1
    138e:	0f 90       	pop	r0
    1390:	0f be       	out	0x3f, r0	; 63
    1392:	0f 90       	pop	r0

	asm volatile ( "ret" );
    1394:	08 95       	ret

00001396 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    1396:	0f 92       	push	r0
    1398:	0f b6       	in	r0, 0x3f	; 63
    139a:	f8 94       	cli
    139c:	0f 92       	push	r0
    139e:	1f 92       	push	r1
    13a0:	11 24       	eor	r1, r1
    13a2:	2f 92       	push	r2
    13a4:	3f 92       	push	r3
    13a6:	4f 92       	push	r4
    13a8:	5f 92       	push	r5
    13aa:	6f 92       	push	r6
    13ac:	7f 92       	push	r7
    13ae:	8f 92       	push	r8
    13b0:	9f 92       	push	r9
    13b2:	af 92       	push	r10
    13b4:	bf 92       	push	r11
    13b6:	cf 92       	push	r12
    13b8:	df 92       	push	r13
    13ba:	ef 92       	push	r14
    13bc:	ff 92       	push	r15
    13be:	0f 93       	push	r16
    13c0:	1f 93       	push	r17
    13c2:	2f 93       	push	r18
    13c4:	3f 93       	push	r19
    13c6:	4f 93       	push	r20
    13c8:	5f 93       	push	r21
    13ca:	6f 93       	push	r22
    13cc:	7f 93       	push	r23
    13ce:	8f 93       	push	r24
    13d0:	9f 93       	push	r25
    13d2:	af 93       	push	r26
    13d4:	bf 93       	push	r27
    13d6:	cf 93       	push	r28
    13d8:	df 93       	push	r29
    13da:	ef 93       	push	r30
    13dc:	ff 93       	push	r31
    13de:	a0 91 5c 08 	lds	r26, 0x085C
    13e2:	b0 91 5d 08 	lds	r27, 0x085D
    13e6:	0d b6       	in	r0, 0x3d	; 61
    13e8:	0d 92       	st	X+, r0
    13ea:	0e b6       	in	r0, 0x3e	; 62
    13ec:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
    13ee:	0e 94 61 20 	call	0x40c2	; 0x40c2 <xTaskIncrementTick>
    13f2:	88 23       	and	r24, r24
    13f4:	11 f0       	breq	.+4      	; 0x13fa <vPortYieldFromTick+0x64>
	{
		vTaskSwitchContext();
    13f6:	0e 94 f8 21 	call	0x43f0	; 0x43f0 <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
    13fa:	a0 91 5c 08 	lds	r26, 0x085C
    13fe:	b0 91 5d 08 	lds	r27, 0x085D
    1402:	cd 91       	ld	r28, X+
    1404:	cd bf       	out	0x3d, r28	; 61
    1406:	dd 91       	ld	r29, X+
    1408:	de bf       	out	0x3e, r29	; 62
    140a:	ff 91       	pop	r31
    140c:	ef 91       	pop	r30
    140e:	df 91       	pop	r29
    1410:	cf 91       	pop	r28
    1412:	bf 91       	pop	r27
    1414:	af 91       	pop	r26
    1416:	9f 91       	pop	r25
    1418:	8f 91       	pop	r24
    141a:	7f 91       	pop	r23
    141c:	6f 91       	pop	r22
    141e:	5f 91       	pop	r21
    1420:	4f 91       	pop	r20
    1422:	3f 91       	pop	r19
    1424:	2f 91       	pop	r18
    1426:	1f 91       	pop	r17
    1428:	0f 91       	pop	r16
    142a:	ff 90       	pop	r15
    142c:	ef 90       	pop	r14
    142e:	df 90       	pop	r13
    1430:	cf 90       	pop	r12
    1432:	bf 90       	pop	r11
    1434:	af 90       	pop	r10
    1436:	9f 90       	pop	r9
    1438:	8f 90       	pop	r8
    143a:	7f 90       	pop	r7
    143c:	6f 90       	pop	r6
    143e:	5f 90       	pop	r5
    1440:	4f 90       	pop	r4
    1442:	3f 90       	pop	r3
    1444:	2f 90       	pop	r2
    1446:	1f 90       	pop	r1
    1448:	0f 90       	pop	r0
    144a:	0f be       	out	0x3f, r0	; 63
    144c:	0f 90       	pop	r0

	asm volatile ( "ret" );
    144e:	08 95       	ret

00001450 <prvSetupTimerInterrupt>:

/*
 * Setup timer 1 compare match A to generate a tick interrupt.
 */
static void prvSetupTimerInterrupt( void )
{
    1450:	df 93       	push	r29
    1452:	cf 93       	push	r28
    1454:	00 d0       	rcall	.+0      	; 0x1456 <prvSetupTimerInterrupt+0x6>
    1456:	00 d0       	rcall	.+0      	; 0x1458 <prvSetupTimerInterrupt+0x8>
    1458:	00 d0       	rcall	.+0      	; 0x145a <prvSetupTimerInterrupt+0xa>
    145a:	cd b7       	in	r28, 0x3d	; 61
    145c:	de b7       	in	r29, 0x3e	; 62
uint8_t ucHighByte, ucLowByte;

	/* Using 16bit timer 1 to generate the tick.  Correct fuses must be
	selected for the configCPU_CLOCK_HZ clock. */

	ulCompareMatch = configCPU_CLOCK_HZ / configTICK_RATE_HZ;
    145e:	80 e8       	ldi	r24, 0x80	; 128
    1460:	9e e3       	ldi	r25, 0x3E	; 62
    1462:	a0 e0       	ldi	r26, 0x00	; 0
    1464:	b0 e0       	ldi	r27, 0x00	; 0
    1466:	8b 83       	std	Y+3, r24	; 0x03
    1468:	9c 83       	std	Y+4, r25	; 0x04
    146a:	ad 83       	std	Y+5, r26	; 0x05
    146c:	be 83       	std	Y+6, r27	; 0x06

	/* We only have 16 bits so have to scale to get our required tick rate. */
	ulCompareMatch /= portCLOCK_PRESCALER;
    146e:	8b 81       	ldd	r24, Y+3	; 0x03
    1470:	9c 81       	ldd	r25, Y+4	; 0x04
    1472:	ad 81       	ldd	r26, Y+5	; 0x05
    1474:	be 81       	ldd	r27, Y+6	; 0x06
    1476:	68 94       	set
    1478:	15 f8       	bld	r1, 5
    147a:	b6 95       	lsr	r27
    147c:	a7 95       	ror	r26
    147e:	97 95       	ror	r25
    1480:	87 95       	ror	r24
    1482:	16 94       	lsr	r1
    1484:	d1 f7       	brne	.-12     	; 0x147a <prvSetupTimerInterrupt+0x2a>
    1486:	8b 83       	std	Y+3, r24	; 0x03
    1488:	9c 83       	std	Y+4, r25	; 0x04
    148a:	ad 83       	std	Y+5, r26	; 0x05
    148c:	be 83       	std	Y+6, r27	; 0x06

	/* Adjust for correct value. */
	ulCompareMatch -= ( uint32_t ) 1;
    148e:	8b 81       	ldd	r24, Y+3	; 0x03
    1490:	9c 81       	ldd	r25, Y+4	; 0x04
    1492:	ad 81       	ldd	r26, Y+5	; 0x05
    1494:	be 81       	ldd	r27, Y+6	; 0x06
    1496:	01 97       	sbiw	r24, 0x01	; 1
    1498:	a1 09       	sbc	r26, r1
    149a:	b1 09       	sbc	r27, r1
    149c:	8b 83       	std	Y+3, r24	; 0x03
    149e:	9c 83       	std	Y+4, r25	; 0x04
    14a0:	ad 83       	std	Y+5, r26	; 0x05
    14a2:	be 83       	std	Y+6, r27	; 0x06

	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
    14a4:	8b 81       	ldd	r24, Y+3	; 0x03
    14a6:	89 83       	std	Y+1, r24	; 0x01
	ulCompareMatch >>= 8;
    14a8:	8b 81       	ldd	r24, Y+3	; 0x03
    14aa:	9c 81       	ldd	r25, Y+4	; 0x04
    14ac:	ad 81       	ldd	r26, Y+5	; 0x05
    14ae:	be 81       	ldd	r27, Y+6	; 0x06
    14b0:	89 2f       	mov	r24, r25
    14b2:	9a 2f       	mov	r25, r26
    14b4:	ab 2f       	mov	r26, r27
    14b6:	bb 27       	eor	r27, r27
    14b8:	8b 83       	std	Y+3, r24	; 0x03
    14ba:	9c 83       	std	Y+4, r25	; 0x04
    14bc:	ad 83       	std	Y+5, r26	; 0x05
    14be:	be 83       	std	Y+6, r27	; 0x06
	ucHighByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
    14c0:	8b 81       	ldd	r24, Y+3	; 0x03
    14c2:	8a 83       	std	Y+2, r24	; 0x02
	OCR1AH = ucHighByte;
    14c4:	eb e4       	ldi	r30, 0x4B	; 75
    14c6:	f0 e0       	ldi	r31, 0x00	; 0
    14c8:	8a 81       	ldd	r24, Y+2	; 0x02
    14ca:	80 83       	st	Z, r24
	OCR1AL = ucLowByte;
    14cc:	ea e4       	ldi	r30, 0x4A	; 74
    14ce:	f0 e0       	ldi	r31, 0x00	; 0
    14d0:	89 81       	ldd	r24, Y+1	; 0x01
    14d2:	80 83       	st	Z, r24

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
    14d4:	8b e0       	ldi	r24, 0x0B	; 11
    14d6:	89 83       	std	Y+1, r24	; 0x01
	TCCR1B = ucLowByte;
    14d8:	ee e4       	ldi	r30, 0x4E	; 78
    14da:	f0 e0       	ldi	r31, 0x00	; 0
    14dc:	89 81       	ldd	r24, Y+1	; 0x01
    14de:	80 83       	st	Z, r24

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK;
    14e0:	e7 e5       	ldi	r30, 0x57	; 87
    14e2:	f0 e0       	ldi	r31, 0x00	; 0
    14e4:	80 81       	ld	r24, Z
    14e6:	89 83       	std	Y+1, r24	; 0x01
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    14e8:	89 81       	ldd	r24, Y+1	; 0x01
    14ea:	80 61       	ori	r24, 0x10	; 16
    14ec:	89 83       	std	Y+1, r24	; 0x01
	TIMSK = ucLowByte;
    14ee:	e7 e5       	ldi	r30, 0x57	; 87
    14f0:	f0 e0       	ldi	r31, 0x00	; 0
    14f2:	89 81       	ldd	r24, Y+1	; 0x01
    14f4:	80 83       	st	Z, r24
}
    14f6:	26 96       	adiw	r28, 0x06	; 6
    14f8:	0f b6       	in	r0, 0x3f	; 63
    14fa:	f8 94       	cli
    14fc:	de bf       	out	0x3e, r29	; 62
    14fe:	0f be       	out	0x3f, r0	; 63
    1500:	cd bf       	out	0x3d, r28	; 61
    1502:	cf 91       	pop	r28
    1504:	df 91       	pop	r29
    1506:	08 95       	ret

00001508 <__vector_12>:
	 * count is incremented after the context is saved.
	 */
	void TIMER1_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
	void TIMER1_COMPA_vect( void )
	{
		vPortYieldFromTick();
    1508:	0e 94 cb 09 	call	0x1396	; 0x1396 <vPortYieldFromTick>
		asm volatile ( "reti" );
    150c:	18 95       	reti

0000150e <xCoRoutineCreate>:
/*-----------------------------------------------------------*/

    BaseType_t xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode,
                                 UBaseType_t uxPriority,
                                 UBaseType_t uxIndex )
    {
    150e:	df 93       	push	r29
    1510:	cf 93       	push	r28
    1512:	cd b7       	in	r28, 0x3d	; 61
    1514:	de b7       	in	r29, 0x3e	; 62
    1516:	27 97       	sbiw	r28, 0x07	; 7
    1518:	0f b6       	in	r0, 0x3f	; 63
    151a:	f8 94       	cli
    151c:	de bf       	out	0x3e, r29	; 62
    151e:	0f be       	out	0x3f, r0	; 63
    1520:	cd bf       	out	0x3d, r28	; 61
    1522:	9d 83       	std	Y+5, r25	; 0x05
    1524:	8c 83       	std	Y+4, r24	; 0x04
    1526:	6e 83       	std	Y+6, r22	; 0x06
    1528:	4f 83       	std	Y+7, r20	; 0x07
        BaseType_t xReturn;
        CRCB_t * pxCoRoutine;

        /* Allocate the memory that will store the co-routine control block. */
        pxCoRoutine = ( CRCB_t * ) pvPortMalloc( sizeof( CRCB_t ) );
    152a:	8a e1       	ldi	r24, 0x1A	; 26
    152c:	90 e0       	ldi	r25, 0x00	; 0
    152e:	0e 94 33 07 	call	0xe66	; 0xe66 <pvPortMalloc>
    1532:	9a 83       	std	Y+2, r25	; 0x02
    1534:	89 83       	std	Y+1, r24	; 0x01

        if( pxCoRoutine )
    1536:	89 81       	ldd	r24, Y+1	; 0x01
    1538:	9a 81       	ldd	r25, Y+2	; 0x02
    153a:	00 97       	sbiw	r24, 0x00	; 0
    153c:	09 f4       	brne	.+2      	; 0x1540 <xCoRoutineCreate+0x32>
    153e:	6f c0       	rjmp	.+222    	; 0x161e <xCoRoutineCreate+0x110>
        {
            /* If pxCurrentCoRoutine is NULL then this is the first co-routine to
            * be created and the co-routine data structures need initialising. */
            if( pxCurrentCoRoutine == NULL )
    1540:	80 91 26 08 	lds	r24, 0x0826
    1544:	90 91 27 08 	lds	r25, 0x0827
    1548:	00 97       	sbiw	r24, 0x00	; 0
    154a:	41 f4       	brne	.+16     	; 0x155c <xCoRoutineCreate+0x4e>
            {
                pxCurrentCoRoutine = pxCoRoutine;
    154c:	89 81       	ldd	r24, Y+1	; 0x01
    154e:	9a 81       	ldd	r25, Y+2	; 0x02
    1550:	90 93 27 08 	sts	0x0827, r25
    1554:	80 93 26 08 	sts	0x0826, r24
                prvInitialiseCoRoutineLists();
    1558:	0e 94 f5 0c 	call	0x19ea	; 0x19ea <prvInitialiseCoRoutineLists>
            }

            /* Check the priority is within limits. */
            if( uxPriority >= configMAX_CO_ROUTINE_PRIORITIES )
    155c:	8e 81       	ldd	r24, Y+6	; 0x06
    155e:	82 30       	cpi	r24, 0x02	; 2
    1560:	10 f0       	brcs	.+4      	; 0x1566 <xCoRoutineCreate+0x58>
            {
                uxPriority = configMAX_CO_ROUTINE_PRIORITIES - 1;
    1562:	81 e0       	ldi	r24, 0x01	; 1
    1564:	8e 83       	std	Y+6, r24	; 0x06
            }

            /* Fill out the co-routine control block from the function parameters. */
            pxCoRoutine->uxState = corINITIAL_STATE;
    1566:	e9 81       	ldd	r30, Y+1	; 0x01
    1568:	fa 81       	ldd	r31, Y+2	; 0x02
    156a:	11 8e       	std	Z+25, r1	; 0x19
    156c:	10 8e       	std	Z+24, r1	; 0x18
            pxCoRoutine->uxPriority = uxPriority;
    156e:	e9 81       	ldd	r30, Y+1	; 0x01
    1570:	fa 81       	ldd	r31, Y+2	; 0x02
    1572:	8e 81       	ldd	r24, Y+6	; 0x06
    1574:	86 8b       	std	Z+22, r24	; 0x16
            pxCoRoutine->uxIndex = uxIndex;
    1576:	e9 81       	ldd	r30, Y+1	; 0x01
    1578:	fa 81       	ldd	r31, Y+2	; 0x02
    157a:	8f 81       	ldd	r24, Y+7	; 0x07
    157c:	87 8b       	std	Z+23, r24	; 0x17
            pxCoRoutine->pxCoRoutineFunction = pxCoRoutineCode;
    157e:	e9 81       	ldd	r30, Y+1	; 0x01
    1580:	fa 81       	ldd	r31, Y+2	; 0x02
    1582:	8c 81       	ldd	r24, Y+4	; 0x04
    1584:	9d 81       	ldd	r25, Y+5	; 0x05
    1586:	91 83       	std	Z+1, r25	; 0x01
    1588:	80 83       	st	Z, r24

            /* Initialise all the other co-routine control block parameters. */
            vListInitialiseItem( &( pxCoRoutine->xGenericListItem ) );
    158a:	89 81       	ldd	r24, Y+1	; 0x01
    158c:	9a 81       	ldd	r25, Y+2	; 0x02
    158e:	02 96       	adiw	r24, 0x02	; 2
    1590:	0e 94 d5 10 	call	0x21aa	; 0x21aa <vListInitialiseItem>
            vListInitialiseItem( &( pxCoRoutine->xEventListItem ) );
    1594:	89 81       	ldd	r24, Y+1	; 0x01
    1596:	9a 81       	ldd	r25, Y+2	; 0x02
    1598:	0c 96       	adiw	r24, 0x0c	; 12
    159a:	0e 94 d5 10 	call	0x21aa	; 0x21aa <vListInitialiseItem>

            /* Set the co-routine control block as a link back from the ListItem_t.
             * This is so we can get back to the containing CRCB from a generic item
             * in a list. */
            listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xGenericListItem ), pxCoRoutine );
    159e:	e9 81       	ldd	r30, Y+1	; 0x01
    15a0:	fa 81       	ldd	r31, Y+2	; 0x02
    15a2:	89 81       	ldd	r24, Y+1	; 0x01
    15a4:	9a 81       	ldd	r25, Y+2	; 0x02
    15a6:	91 87       	std	Z+9, r25	; 0x09
    15a8:	80 87       	std	Z+8, r24	; 0x08
            listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xEventListItem ), pxCoRoutine );
    15aa:	e9 81       	ldd	r30, Y+1	; 0x01
    15ac:	fa 81       	ldd	r31, Y+2	; 0x02
    15ae:	89 81       	ldd	r24, Y+1	; 0x01
    15b0:	9a 81       	ldd	r25, Y+2	; 0x02
    15b2:	93 8b       	std	Z+19, r25	; 0x13
    15b4:	82 8b       	std	Z+18, r24	; 0x12

            /* Event lists are always in priority order. */
            listSET_LIST_ITEM_VALUE( &( pxCoRoutine->xEventListItem ), ( ( TickType_t ) configMAX_CO_ROUTINE_PRIORITIES - ( TickType_t ) uxPriority ) );
    15b6:	8e 81       	ldd	r24, Y+6	; 0x06
    15b8:	28 2f       	mov	r18, r24
    15ba:	30 e0       	ldi	r19, 0x00	; 0
    15bc:	82 e0       	ldi	r24, 0x02	; 2
    15be:	90 e0       	ldi	r25, 0x00	; 0
    15c0:	82 1b       	sub	r24, r18
    15c2:	93 0b       	sbc	r25, r19
    15c4:	e9 81       	ldd	r30, Y+1	; 0x01
    15c6:	fa 81       	ldd	r31, Y+2	; 0x02
    15c8:	95 87       	std	Z+13, r25	; 0x0d
    15ca:	84 87       	std	Z+12, r24	; 0x0c

            /* Now the co-routine has been initialised it can be added to the ready
             * list at the correct priority. */
            prvAddCoRoutineToReadyQueue( pxCoRoutine );
    15cc:	e9 81       	ldd	r30, Y+1	; 0x01
    15ce:	fa 81       	ldd	r31, Y+2	; 0x02
    15d0:	96 89       	ldd	r25, Z+22	; 0x16
    15d2:	80 91 28 08 	lds	r24, 0x0828
    15d6:	89 17       	cp	r24, r25
    15d8:	28 f4       	brcc	.+10     	; 0x15e4 <xCoRoutineCreate+0xd6>
    15da:	e9 81       	ldd	r30, Y+1	; 0x01
    15dc:	fa 81       	ldd	r31, Y+2	; 0x02
    15de:	86 89       	ldd	r24, Z+22	; 0x16
    15e0:	80 93 28 08 	sts	0x0828, r24
    15e4:	e9 81       	ldd	r30, Y+1	; 0x01
    15e6:	fa 81       	ldd	r31, Y+2	; 0x02
    15e8:	86 89       	ldd	r24, Z+22	; 0x16
    15ea:	28 2f       	mov	r18, r24
    15ec:	30 e0       	ldi	r19, 0x00	; 0
    15ee:	c9 01       	movw	r24, r18
    15f0:	88 0f       	add	r24, r24
    15f2:	99 1f       	adc	r25, r25
    15f4:	88 0f       	add	r24, r24
    15f6:	99 1f       	adc	r25, r25
    15f8:	88 0f       	add	r24, r24
    15fa:	99 1f       	adc	r25, r25
    15fc:	82 0f       	add	r24, r18
    15fe:	93 1f       	adc	r25, r19
    1600:	ac 01       	movw	r20, r24
    1602:	41 5d       	subi	r20, 0xD1	; 209
    1604:	57 4f       	sbci	r21, 0xF7	; 247
    1606:	89 81       	ldd	r24, Y+1	; 0x01
    1608:	9a 81       	ldd	r25, Y+2	; 0x02
    160a:	9c 01       	movw	r18, r24
    160c:	2e 5f       	subi	r18, 0xFE	; 254
    160e:	3f 4f       	sbci	r19, 0xFF	; 255
    1610:	ca 01       	movw	r24, r20
    1612:	b9 01       	movw	r22, r18
    1614:	0e 94 e5 10 	call	0x21ca	; 0x21ca <vListInsertEnd>

            xReturn = pdPASS;
    1618:	81 e0       	ldi	r24, 0x01	; 1
    161a:	8b 83       	std	Y+3, r24	; 0x03
    161c:	02 c0       	rjmp	.+4      	; 0x1622 <xCoRoutineCreate+0x114>
        }
        else
        {
            xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    161e:	8f ef       	ldi	r24, 0xFF	; 255
    1620:	8b 83       	std	Y+3, r24	; 0x03
        }

        return xReturn;
    1622:	8b 81       	ldd	r24, Y+3	; 0x03
    }
    1624:	27 96       	adiw	r28, 0x07	; 7
    1626:	0f b6       	in	r0, 0x3f	; 63
    1628:	f8 94       	cli
    162a:	de bf       	out	0x3e, r29	; 62
    162c:	0f be       	out	0x3f, r0	; 63
    162e:	cd bf       	out	0x3d, r28	; 61
    1630:	cf 91       	pop	r28
    1632:	df 91       	pop	r29
    1634:	08 95       	ret

00001636 <vCoRoutineAddToDelayedList>:
/*-----------------------------------------------------------*/

    void vCoRoutineAddToDelayedList( TickType_t xTicksToDelay,
                                     List_t * pxEventList )
    {
    1636:	df 93       	push	r29
    1638:	cf 93       	push	r28
    163a:	00 d0       	rcall	.+0      	; 0x163c <vCoRoutineAddToDelayedList+0x6>
    163c:	00 d0       	rcall	.+0      	; 0x163e <vCoRoutineAddToDelayedList+0x8>
    163e:	00 d0       	rcall	.+0      	; 0x1640 <vCoRoutineAddToDelayedList+0xa>
    1640:	cd b7       	in	r28, 0x3d	; 61
    1642:	de b7       	in	r29, 0x3e	; 62
    1644:	9c 83       	std	Y+4, r25	; 0x04
    1646:	8b 83       	std	Y+3, r24	; 0x03
    1648:	7e 83       	std	Y+6, r23	; 0x06
    164a:	6d 83       	std	Y+5, r22	; 0x05
        TickType_t xTimeToWake;

        /* Calculate the time to wake - this may overflow but this is
         * not a problem. */
        xTimeToWake = xCoRoutineTickCount + xTicksToDelay;
    164c:	20 91 29 08 	lds	r18, 0x0829
    1650:	30 91 2a 08 	lds	r19, 0x082A
    1654:	8b 81       	ldd	r24, Y+3	; 0x03
    1656:	9c 81       	ldd	r25, Y+4	; 0x04
    1658:	82 0f       	add	r24, r18
    165a:	93 1f       	adc	r25, r19
    165c:	9a 83       	std	Y+2, r25	; 0x02
    165e:	89 83       	std	Y+1, r24	; 0x01

        /* We must remove ourselves from the ready list before adding
         * ourselves to the blocked list as the same list item is used for
         * both lists. */
        ( void ) uxListRemove( ( ListItem_t * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    1660:	80 91 26 08 	lds	r24, 0x0826
    1664:	90 91 27 08 	lds	r25, 0x0827
    1668:	02 96       	adiw	r24, 0x02	; 2
    166a:	0e 94 95 11 	call	0x232a	; 0x232a <uxListRemove>

        /* The list item will be inserted in wake time order. */
        listSET_LIST_ITEM_VALUE( &( pxCurrentCoRoutine->xGenericListItem ), xTimeToWake );
    166e:	e0 91 26 08 	lds	r30, 0x0826
    1672:	f0 91 27 08 	lds	r31, 0x0827
    1676:	89 81       	ldd	r24, Y+1	; 0x01
    1678:	9a 81       	ldd	r25, Y+2	; 0x02
    167a:	93 83       	std	Z+3, r25	; 0x03
    167c:	82 83       	std	Z+2, r24	; 0x02

        if( xTimeToWake < xCoRoutineTickCount )
    167e:	20 91 29 08 	lds	r18, 0x0829
    1682:	30 91 2a 08 	lds	r19, 0x082A
    1686:	89 81       	ldd	r24, Y+1	; 0x01
    1688:	9a 81       	ldd	r25, Y+2	; 0x02
    168a:	82 17       	cp	r24, r18
    168c:	93 07       	cpc	r25, r19
    168e:	70 f4       	brcc	.+28     	; 0x16ac <vCoRoutineAddToDelayedList+0x76>
        {
            /* Wake time has overflowed.  Place this item in the
             * overflow list. */
            vListInsert( ( List_t * ) pxOverflowDelayedCoRoutineList, ( ListItem_t * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    1690:	80 91 24 08 	lds	r24, 0x0824
    1694:	90 91 25 08 	lds	r25, 0x0825
    1698:	20 91 26 08 	lds	r18, 0x0826
    169c:	30 91 27 08 	lds	r19, 0x0827
    16a0:	2e 5f       	subi	r18, 0xFE	; 254
    16a2:	3f 4f       	sbci	r19, 0xFF	; 255
    16a4:	b9 01       	movw	r22, r18
    16a6:	0e 94 29 11 	call	0x2252	; 0x2252 <vListInsert>
    16aa:	0d c0       	rjmp	.+26     	; 0x16c6 <vCoRoutineAddToDelayedList+0x90>
        }
        else
        {
            /* The wake time has not overflowed, so we can use the
             * current block list. */
            vListInsert( ( List_t * ) pxDelayedCoRoutineList, ( ListItem_t * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    16ac:	80 91 22 08 	lds	r24, 0x0822
    16b0:	90 91 23 08 	lds	r25, 0x0823
    16b4:	20 91 26 08 	lds	r18, 0x0826
    16b8:	30 91 27 08 	lds	r19, 0x0827
    16bc:	2e 5f       	subi	r18, 0xFE	; 254
    16be:	3f 4f       	sbci	r19, 0xFF	; 255
    16c0:	b9 01       	movw	r22, r18
    16c2:	0e 94 29 11 	call	0x2252	; 0x2252 <vListInsert>
        }

        if( pxEventList )
    16c6:	8d 81       	ldd	r24, Y+5	; 0x05
    16c8:	9e 81       	ldd	r25, Y+6	; 0x06
    16ca:	00 97       	sbiw	r24, 0x00	; 0
    16cc:	61 f0       	breq	.+24     	; 0x16e6 <vCoRoutineAddToDelayedList+0xb0>
        {
            /* Also add the co-routine to an event list.  If this is done then the
             * function must be called with interrupts disabled. */
            vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
    16ce:	80 91 26 08 	lds	r24, 0x0826
    16d2:	90 91 27 08 	lds	r25, 0x0827
    16d6:	9c 01       	movw	r18, r24
    16d8:	24 5f       	subi	r18, 0xF4	; 244
    16da:	3f 4f       	sbci	r19, 0xFF	; 255
    16dc:	8d 81       	ldd	r24, Y+5	; 0x05
    16de:	9e 81       	ldd	r25, Y+6	; 0x06
    16e0:	b9 01       	movw	r22, r18
    16e2:	0e 94 29 11 	call	0x2252	; 0x2252 <vListInsert>
        }
    }
    16e6:	26 96       	adiw	r28, 0x06	; 6
    16e8:	0f b6       	in	r0, 0x3f	; 63
    16ea:	f8 94       	cli
    16ec:	de bf       	out	0x3e, r29	; 62
    16ee:	0f be       	out	0x3f, r0	; 63
    16f0:	cd bf       	out	0x3d, r28	; 61
    16f2:	cf 91       	pop	r28
    16f4:	df 91       	pop	r29
    16f6:	08 95       	ret

000016f8 <prvCheckPendingReadyList>:
/*-----------------------------------------------------------*/

    static void prvCheckPendingReadyList( void )
    {
    16f8:	df 93       	push	r29
    16fa:	cf 93       	push	r28
    16fc:	00 d0       	rcall	.+0      	; 0x16fe <prvCheckPendingReadyList+0x6>
    16fe:	cd b7       	in	r28, 0x3d	; 61
    1700:	de b7       	in	r29, 0x3e	; 62
    1702:	3a c0       	rjmp	.+116    	; 0x1778 <prvCheckPendingReadyList+0x80>
        while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
        {
            CRCB_t * pxUnblockedCRCB;

            /* The pending ready list can be accessed by an ISR. */
            portDISABLE_INTERRUPTS();
    1704:	f8 94       	cli
            {
                pxUnblockedCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyCoRoutineList ) );
    1706:	e0 91 58 08 	lds	r30, 0x0858
    170a:	f0 91 59 08 	lds	r31, 0x0859
    170e:	86 81       	ldd	r24, Z+6	; 0x06
    1710:	97 81       	ldd	r25, Z+7	; 0x07
    1712:	9a 83       	std	Y+2, r25	; 0x02
    1714:	89 83       	std	Y+1, r24	; 0x01
                ( void ) uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    1716:	89 81       	ldd	r24, Y+1	; 0x01
    1718:	9a 81       	ldd	r25, Y+2	; 0x02
    171a:	0c 96       	adiw	r24, 0x0c	; 12
    171c:	0e 94 95 11 	call	0x232a	; 0x232a <uxListRemove>
            }
            portENABLE_INTERRUPTS();
    1720:	78 94       	sei

            ( void ) uxListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
    1722:	89 81       	ldd	r24, Y+1	; 0x01
    1724:	9a 81       	ldd	r25, Y+2	; 0x02
    1726:	02 96       	adiw	r24, 0x02	; 2
    1728:	0e 94 95 11 	call	0x232a	; 0x232a <uxListRemove>
            prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );
    172c:	e9 81       	ldd	r30, Y+1	; 0x01
    172e:	fa 81       	ldd	r31, Y+2	; 0x02
    1730:	96 89       	ldd	r25, Z+22	; 0x16
    1732:	80 91 28 08 	lds	r24, 0x0828
    1736:	89 17       	cp	r24, r25
    1738:	28 f4       	brcc	.+10     	; 0x1744 <prvCheckPendingReadyList+0x4c>
    173a:	e9 81       	ldd	r30, Y+1	; 0x01
    173c:	fa 81       	ldd	r31, Y+2	; 0x02
    173e:	86 89       	ldd	r24, Z+22	; 0x16
    1740:	80 93 28 08 	sts	0x0828, r24
    1744:	e9 81       	ldd	r30, Y+1	; 0x01
    1746:	fa 81       	ldd	r31, Y+2	; 0x02
    1748:	86 89       	ldd	r24, Z+22	; 0x16
    174a:	28 2f       	mov	r18, r24
    174c:	30 e0       	ldi	r19, 0x00	; 0
    174e:	c9 01       	movw	r24, r18
    1750:	88 0f       	add	r24, r24
    1752:	99 1f       	adc	r25, r25
    1754:	88 0f       	add	r24, r24
    1756:	99 1f       	adc	r25, r25
    1758:	88 0f       	add	r24, r24
    175a:	99 1f       	adc	r25, r25
    175c:	82 0f       	add	r24, r18
    175e:	93 1f       	adc	r25, r19
    1760:	ac 01       	movw	r20, r24
    1762:	41 5d       	subi	r20, 0xD1	; 209
    1764:	57 4f       	sbci	r21, 0xF7	; 247
    1766:	89 81       	ldd	r24, Y+1	; 0x01
    1768:	9a 81       	ldd	r25, Y+2	; 0x02
    176a:	9c 01       	movw	r18, r24
    176c:	2e 5f       	subi	r18, 0xFE	; 254
    176e:	3f 4f       	sbci	r19, 0xFF	; 255
    1770:	ca 01       	movw	r24, r20
    1772:	b9 01       	movw	r22, r18
    1774:	0e 94 e5 10 	call	0x21ca	; 0x21ca <vListInsertEnd>
    static void prvCheckPendingReadyList( void )
    {
        /* Are there any co-routines waiting to get moved to the ready list?  These
         * are co-routines that have been readied by an ISR.  The ISR cannot access
         * the ready lists itself. */
        while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
    1778:	80 91 53 08 	lds	r24, 0x0853
    177c:	88 23       	and	r24, r24
    177e:	09 f0       	breq	.+2      	; 0x1782 <prvCheckPendingReadyList+0x8a>
    1780:	c1 cf       	rjmp	.-126    	; 0x1704 <prvCheckPendingReadyList+0xc>
            portENABLE_INTERRUPTS();

            ( void ) uxListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
            prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );
        }
    }
    1782:	0f 90       	pop	r0
    1784:	0f 90       	pop	r0
    1786:	cf 91       	pop	r28
    1788:	df 91       	pop	r29
    178a:	08 95       	ret

0000178c <prvCheckDelayedList>:
/*-----------------------------------------------------------*/

    static void prvCheckDelayedList( void )
    {
    178c:	df 93       	push	r29
    178e:	cf 93       	push	r28
    1790:	00 d0       	rcall	.+0      	; 0x1792 <prvCheckDelayedList+0x6>
    1792:	00 d0       	rcall	.+0      	; 0x1794 <prvCheckDelayedList+0x8>
    1794:	cd b7       	in	r28, 0x3d	; 61
    1796:	de b7       	in	r29, 0x3e	; 62
        CRCB_t * pxCRCB;

        xPassedTicks = xTaskGetTickCount() - xLastTickCount;
    1798:	0e 94 e4 1f 	call	0x3fc8	; 0x3fc8 <xTaskGetTickCount>
    179c:	20 91 2b 08 	lds	r18, 0x082B
    17a0:	30 91 2c 08 	lds	r19, 0x082C
    17a4:	82 1b       	sub	r24, r18
    17a6:	93 0b       	sbc	r25, r19
    17a8:	90 93 2e 08 	sts	0x082E, r25
    17ac:	80 93 2d 08 	sts	0x082D, r24
    17b0:	85 c0       	rjmp	.+266    	; 0x18bc <prvCheckDelayedList+0x130>

        while( xPassedTicks )
        {
            xCoRoutineTickCount++;
    17b2:	80 91 29 08 	lds	r24, 0x0829
    17b6:	90 91 2a 08 	lds	r25, 0x082A
    17ba:	01 96       	adiw	r24, 0x01	; 1
    17bc:	90 93 2a 08 	sts	0x082A, r25
    17c0:	80 93 29 08 	sts	0x0829, r24
            xPassedTicks--;
    17c4:	80 91 2d 08 	lds	r24, 0x082D
    17c8:	90 91 2e 08 	lds	r25, 0x082E
    17cc:	01 97       	sbiw	r24, 0x01	; 1
    17ce:	90 93 2e 08 	sts	0x082E, r25
    17d2:	80 93 2d 08 	sts	0x082D, r24

            /* If the tick count has overflowed we need to swap the ready lists. */
            if( xCoRoutineTickCount == 0 )
    17d6:	80 91 29 08 	lds	r24, 0x0829
    17da:	90 91 2a 08 	lds	r25, 0x082A
    17de:	00 97       	sbiw	r24, 0x00	; 0
    17e0:	09 f0       	breq	.+2      	; 0x17e4 <prvCheckDelayedList+0x58>
    17e2:	64 c0       	rjmp	.+200    	; 0x18ac <prvCheckDelayedList+0x120>
            {
                List_t * pxTemp;

                /* Tick count has overflowed so we need to swap the delay lists.  If there are
                 * any items in pxDelayedCoRoutineList here then there is an error! */
                pxTemp = pxDelayedCoRoutineList;
    17e4:	80 91 22 08 	lds	r24, 0x0822
    17e8:	90 91 23 08 	lds	r25, 0x0823
    17ec:	9a 83       	std	Y+2, r25	; 0x02
    17ee:	89 83       	std	Y+1, r24	; 0x01
                pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
    17f0:	80 91 24 08 	lds	r24, 0x0824
    17f4:	90 91 25 08 	lds	r25, 0x0825
    17f8:	90 93 23 08 	sts	0x0823, r25
    17fc:	80 93 22 08 	sts	0x0822, r24
                pxOverflowDelayedCoRoutineList = pxTemp;
    1800:	89 81       	ldd	r24, Y+1	; 0x01
    1802:	9a 81       	ldd	r25, Y+2	; 0x02
    1804:	90 93 25 08 	sts	0x0825, r25
    1808:	80 93 24 08 	sts	0x0824, r24
    180c:	4f c0       	rjmp	.+158    	; 0x18ac <prvCheckDelayedList+0x120>
            }

            /* See if this tick has made a timeout expire. */
            while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
            {
                pxCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList );
    180e:	e0 91 22 08 	lds	r30, 0x0822
    1812:	f0 91 23 08 	lds	r31, 0x0823
    1816:	05 80       	ldd	r0, Z+5	; 0x05
    1818:	f6 81       	ldd	r31, Z+6	; 0x06
    181a:	e0 2d       	mov	r30, r0
    181c:	86 81       	ldd	r24, Z+6	; 0x06
    181e:	97 81       	ldd	r25, Z+7	; 0x07
    1820:	9c 83       	std	Y+4, r25	; 0x04
    1822:	8b 83       	std	Y+3, r24	; 0x03

                if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )
    1824:	eb 81       	ldd	r30, Y+3	; 0x03
    1826:	fc 81       	ldd	r31, Y+4	; 0x04
    1828:	22 81       	ldd	r18, Z+2	; 0x02
    182a:	33 81       	ldd	r19, Z+3	; 0x03
    182c:	80 91 29 08 	lds	r24, 0x0829
    1830:	90 91 2a 08 	lds	r25, 0x082A
    1834:	82 17       	cp	r24, r18
    1836:	93 07       	cpc	r25, r19
    1838:	08 f4       	brcc	.+2      	; 0x183c <prvCheckDelayedList+0xb0>
    183a:	40 c0       	rjmp	.+128    	; 0x18bc <prvCheckDelayedList+0x130>
                {
                    /* Timeout not yet expired. */
                    break;
                }

                portDISABLE_INTERRUPTS();
    183c:	f8 94       	cli
                    /* The event could have occurred just before this critical
                     *  section.  If this is the case then the generic list item will
                     *  have been moved to the pending ready list and the following
                     *  line is still valid.  Also the pvContainer parameter will have
                     *  been set to NULL so the following lines are also valid. */
                    ( void ) uxListRemove( &( pxCRCB->xGenericListItem ) );
    183e:	8b 81       	ldd	r24, Y+3	; 0x03
    1840:	9c 81       	ldd	r25, Y+4	; 0x04
    1842:	02 96       	adiw	r24, 0x02	; 2
    1844:	0e 94 95 11 	call	0x232a	; 0x232a <uxListRemove>

                    /* Is the co-routine waiting on an event also? */
                    if( pxCRCB->xEventListItem.pxContainer )
    1848:	eb 81       	ldd	r30, Y+3	; 0x03
    184a:	fc 81       	ldd	r31, Y+4	; 0x04
    184c:	84 89       	ldd	r24, Z+20	; 0x14
    184e:	95 89       	ldd	r25, Z+21	; 0x15
    1850:	00 97       	sbiw	r24, 0x00	; 0
    1852:	29 f0       	breq	.+10     	; 0x185e <prvCheckDelayedList+0xd2>
                    {
                        ( void ) uxListRemove( &( pxCRCB->xEventListItem ) );
    1854:	8b 81       	ldd	r24, Y+3	; 0x03
    1856:	9c 81       	ldd	r25, Y+4	; 0x04
    1858:	0c 96       	adiw	r24, 0x0c	; 12
    185a:	0e 94 95 11 	call	0x232a	; 0x232a <uxListRemove>
                    }
                }
                portENABLE_INTERRUPTS();
    185e:	78 94       	sei

                prvAddCoRoutineToReadyQueue( pxCRCB );
    1860:	eb 81       	ldd	r30, Y+3	; 0x03
    1862:	fc 81       	ldd	r31, Y+4	; 0x04
    1864:	96 89       	ldd	r25, Z+22	; 0x16
    1866:	80 91 28 08 	lds	r24, 0x0828
    186a:	89 17       	cp	r24, r25
    186c:	28 f4       	brcc	.+10     	; 0x1878 <prvCheckDelayedList+0xec>
    186e:	eb 81       	ldd	r30, Y+3	; 0x03
    1870:	fc 81       	ldd	r31, Y+4	; 0x04
    1872:	86 89       	ldd	r24, Z+22	; 0x16
    1874:	80 93 28 08 	sts	0x0828, r24
    1878:	eb 81       	ldd	r30, Y+3	; 0x03
    187a:	fc 81       	ldd	r31, Y+4	; 0x04
    187c:	86 89       	ldd	r24, Z+22	; 0x16
    187e:	28 2f       	mov	r18, r24
    1880:	30 e0       	ldi	r19, 0x00	; 0
    1882:	c9 01       	movw	r24, r18
    1884:	88 0f       	add	r24, r24
    1886:	99 1f       	adc	r25, r25
    1888:	88 0f       	add	r24, r24
    188a:	99 1f       	adc	r25, r25
    188c:	88 0f       	add	r24, r24
    188e:	99 1f       	adc	r25, r25
    1890:	82 0f       	add	r24, r18
    1892:	93 1f       	adc	r25, r19
    1894:	ac 01       	movw	r20, r24
    1896:	41 5d       	subi	r20, 0xD1	; 209
    1898:	57 4f       	sbci	r21, 0xF7	; 247
    189a:	8b 81       	ldd	r24, Y+3	; 0x03
    189c:	9c 81       	ldd	r25, Y+4	; 0x04
    189e:	9c 01       	movw	r18, r24
    18a0:	2e 5f       	subi	r18, 0xFE	; 254
    18a2:	3f 4f       	sbci	r19, 0xFF	; 255
    18a4:	ca 01       	movw	r24, r20
    18a6:	b9 01       	movw	r22, r18
    18a8:	0e 94 e5 10 	call	0x21ca	; 0x21ca <vListInsertEnd>
                pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
                pxOverflowDelayedCoRoutineList = pxTemp;
            }

            /* See if this tick has made a timeout expire. */
            while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
    18ac:	e0 91 22 08 	lds	r30, 0x0822
    18b0:	f0 91 23 08 	lds	r31, 0x0823
    18b4:	80 81       	ld	r24, Z
    18b6:	88 23       	and	r24, r24
    18b8:	09 f0       	breq	.+2      	; 0x18bc <prvCheckDelayedList+0x130>
    18ba:	a9 cf       	rjmp	.-174    	; 0x180e <prvCheckDelayedList+0x82>
    {
        CRCB_t * pxCRCB;

        xPassedTicks = xTaskGetTickCount() - xLastTickCount;

        while( xPassedTicks )
    18bc:	80 91 2d 08 	lds	r24, 0x082D
    18c0:	90 91 2e 08 	lds	r25, 0x082E
    18c4:	00 97       	sbiw	r24, 0x00	; 0
    18c6:	09 f0       	breq	.+2      	; 0x18ca <prvCheckDelayedList+0x13e>
    18c8:	74 cf       	rjmp	.-280    	; 0x17b2 <prvCheckDelayedList+0x26>

                prvAddCoRoutineToReadyQueue( pxCRCB );
            }
        }

        xLastTickCount = xCoRoutineTickCount;
    18ca:	80 91 29 08 	lds	r24, 0x0829
    18ce:	90 91 2a 08 	lds	r25, 0x082A
    18d2:	90 93 2c 08 	sts	0x082C, r25
    18d6:	80 93 2b 08 	sts	0x082B, r24
    }
    18da:	0f 90       	pop	r0
    18dc:	0f 90       	pop	r0
    18de:	0f 90       	pop	r0
    18e0:	0f 90       	pop	r0
    18e2:	cf 91       	pop	r28
    18e4:	df 91       	pop	r29
    18e6:	08 95       	ret

000018e8 <vCoRoutineSchedule>:
/*-----------------------------------------------------------*/

    void vCoRoutineSchedule( void )
    {
    18e8:	df 93       	push	r29
    18ea:	cf 93       	push	r28
    18ec:	00 d0       	rcall	.+0      	; 0x18ee <vCoRoutineSchedule+0x6>
    18ee:	cd b7       	in	r28, 0x3d	; 61
    18f0:	de b7       	in	r29, 0x3e	; 62
        /* Only run a co-routine after prvInitialiseCoRoutineLists() has been
         * called.  prvInitialiseCoRoutineLists() is called automatically when a
         * co-routine is created. */
        if( pxDelayedCoRoutineList != NULL )
    18f2:	80 91 22 08 	lds	r24, 0x0822
    18f6:	90 91 23 08 	lds	r25, 0x0823
    18fa:	00 97       	sbiw	r24, 0x00	; 0
    18fc:	09 f4       	brne	.+2      	; 0x1900 <vCoRoutineSchedule+0x18>
    18fe:	70 c0       	rjmp	.+224    	; 0x19e0 <vCoRoutineSchedule+0xf8>
        {
            /* See if any co-routines readied by events need moving to the ready lists. */
            prvCheckPendingReadyList();
    1900:	0e 94 7c 0b 	call	0x16f8	; 0x16f8 <prvCheckPendingReadyList>

            /* See if any delayed co-routines have timed out. */
            prvCheckDelayedList();
    1904:	0e 94 c6 0b 	call	0x178c	; 0x178c <prvCheckDelayedList>
    1908:	0a c0       	rjmp	.+20     	; 0x191e <vCoRoutineSchedule+0x36>

            /* Find the highest priority queue that contains ready co-routines. */
            while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
            {
                if( uxTopCoRoutineReadyPriority == 0 )
    190a:	80 91 28 08 	lds	r24, 0x0828
    190e:	88 23       	and	r24, r24
    1910:	09 f4       	brne	.+2      	; 0x1914 <vCoRoutineSchedule+0x2c>
    1912:	66 c0       	rjmp	.+204    	; 0x19e0 <vCoRoutineSchedule+0xf8>
                {
                    /* No more co-routines to check. */
                    return;
                }

                --uxTopCoRoutineReadyPriority;
    1914:	80 91 28 08 	lds	r24, 0x0828
    1918:	81 50       	subi	r24, 0x01	; 1
    191a:	80 93 28 08 	sts	0x0828, r24

            /* See if any delayed co-routines have timed out. */
            prvCheckDelayedList();

            /* Find the highest priority queue that contains ready co-routines. */
            while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
    191e:	80 91 28 08 	lds	r24, 0x0828
    1922:	28 2f       	mov	r18, r24
    1924:	30 e0       	ldi	r19, 0x00	; 0
    1926:	c9 01       	movw	r24, r18
    1928:	88 0f       	add	r24, r24
    192a:	99 1f       	adc	r25, r25
    192c:	88 0f       	add	r24, r24
    192e:	99 1f       	adc	r25, r25
    1930:	88 0f       	add	r24, r24
    1932:	99 1f       	adc	r25, r25
    1934:	82 0f       	add	r24, r18
    1936:	93 1f       	adc	r25, r19
    1938:	fc 01       	movw	r30, r24
    193a:	e1 5d       	subi	r30, 0xD1	; 209
    193c:	f7 4f       	sbci	r31, 0xF7	; 247
    193e:	80 81       	ld	r24, Z
    1940:	88 23       	and	r24, r24
    1942:	19 f3       	breq	.-58     	; 0x190a <vCoRoutineSchedule+0x22>
                --uxTopCoRoutineReadyPriority;
            }

            /* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
             * of the same priority get an equal share of the processor time. */
            listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );
    1944:	80 91 28 08 	lds	r24, 0x0828
    1948:	28 2f       	mov	r18, r24
    194a:	30 e0       	ldi	r19, 0x00	; 0
    194c:	c9 01       	movw	r24, r18
    194e:	88 0f       	add	r24, r24
    1950:	99 1f       	adc	r25, r25
    1952:	88 0f       	add	r24, r24
    1954:	99 1f       	adc	r25, r25
    1956:	88 0f       	add	r24, r24
    1958:	99 1f       	adc	r25, r25
    195a:	82 0f       	add	r24, r18
    195c:	93 1f       	adc	r25, r19
    195e:	81 5d       	subi	r24, 0xD1	; 209
    1960:	97 4f       	sbci	r25, 0xF7	; 247
    1962:	9a 83       	std	Y+2, r25	; 0x02
    1964:	89 83       	std	Y+1, r24	; 0x01
    1966:	e9 81       	ldd	r30, Y+1	; 0x01
    1968:	fa 81       	ldd	r31, Y+2	; 0x02
    196a:	01 80       	ldd	r0, Z+1	; 0x01
    196c:	f2 81       	ldd	r31, Z+2	; 0x02
    196e:	e0 2d       	mov	r30, r0
    1970:	82 81       	ldd	r24, Z+2	; 0x02
    1972:	93 81       	ldd	r25, Z+3	; 0x03
    1974:	e9 81       	ldd	r30, Y+1	; 0x01
    1976:	fa 81       	ldd	r31, Y+2	; 0x02
    1978:	92 83       	std	Z+2, r25	; 0x02
    197a:	81 83       	std	Z+1, r24	; 0x01
    197c:	e9 81       	ldd	r30, Y+1	; 0x01
    197e:	fa 81       	ldd	r31, Y+2	; 0x02
    1980:	21 81       	ldd	r18, Z+1	; 0x01
    1982:	32 81       	ldd	r19, Z+2	; 0x02
    1984:	89 81       	ldd	r24, Y+1	; 0x01
    1986:	9a 81       	ldd	r25, Y+2	; 0x02
    1988:	03 96       	adiw	r24, 0x03	; 3
    198a:	28 17       	cp	r18, r24
    198c:	39 07       	cpc	r19, r25
    198e:	59 f4       	brne	.+22     	; 0x19a6 <vCoRoutineSchedule+0xbe>
    1990:	e9 81       	ldd	r30, Y+1	; 0x01
    1992:	fa 81       	ldd	r31, Y+2	; 0x02
    1994:	01 80       	ldd	r0, Z+1	; 0x01
    1996:	f2 81       	ldd	r31, Z+2	; 0x02
    1998:	e0 2d       	mov	r30, r0
    199a:	82 81       	ldd	r24, Z+2	; 0x02
    199c:	93 81       	ldd	r25, Z+3	; 0x03
    199e:	e9 81       	ldd	r30, Y+1	; 0x01
    19a0:	fa 81       	ldd	r31, Y+2	; 0x02
    19a2:	92 83       	std	Z+2, r25	; 0x02
    19a4:	81 83       	std	Z+1, r24	; 0x01
    19a6:	e9 81       	ldd	r30, Y+1	; 0x01
    19a8:	fa 81       	ldd	r31, Y+2	; 0x02
    19aa:	01 80       	ldd	r0, Z+1	; 0x01
    19ac:	f2 81       	ldd	r31, Z+2	; 0x02
    19ae:	e0 2d       	mov	r30, r0
    19b0:	86 81       	ldd	r24, Z+6	; 0x06
    19b2:	97 81       	ldd	r25, Z+7	; 0x07
    19b4:	90 93 27 08 	sts	0x0827, r25
    19b8:	80 93 26 08 	sts	0x0826, r24

            /* Call the co-routine. */
            ( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
    19bc:	e0 91 26 08 	lds	r30, 0x0826
    19c0:	f0 91 27 08 	lds	r31, 0x0827
    19c4:	40 81       	ld	r20, Z
    19c6:	51 81       	ldd	r21, Z+1	; 0x01
    19c8:	80 91 26 08 	lds	r24, 0x0826
    19cc:	90 91 27 08 	lds	r25, 0x0827
    19d0:	e0 91 26 08 	lds	r30, 0x0826
    19d4:	f0 91 27 08 	lds	r31, 0x0827
    19d8:	27 89       	ldd	r18, Z+23	; 0x17
    19da:	62 2f       	mov	r22, r18
    19dc:	fa 01       	movw	r30, r20
    19de:	09 95       	icall
        }
    }
    19e0:	0f 90       	pop	r0
    19e2:	0f 90       	pop	r0
    19e4:	cf 91       	pop	r28
    19e6:	df 91       	pop	r29
    19e8:	08 95       	ret

000019ea <prvInitialiseCoRoutineLists>:
/*-----------------------------------------------------------*/

    static void prvInitialiseCoRoutineLists( void )
    {
    19ea:	df 93       	push	r29
    19ec:	cf 93       	push	r28
    19ee:	0f 92       	push	r0
    19f0:	cd b7       	in	r28, 0x3d	; 61
    19f2:	de b7       	in	r29, 0x3e	; 62
        UBaseType_t uxPriority;

        for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
    19f4:	19 82       	std	Y+1, r1	; 0x01
    19f6:	13 c0       	rjmp	.+38     	; 0x1a1e <prvInitialiseCoRoutineLists+0x34>
        {
            vListInitialise( ( List_t * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
    19f8:	89 81       	ldd	r24, Y+1	; 0x01
    19fa:	28 2f       	mov	r18, r24
    19fc:	30 e0       	ldi	r19, 0x00	; 0
    19fe:	c9 01       	movw	r24, r18
    1a00:	88 0f       	add	r24, r24
    1a02:	99 1f       	adc	r25, r25
    1a04:	88 0f       	add	r24, r24
    1a06:	99 1f       	adc	r25, r25
    1a08:	88 0f       	add	r24, r24
    1a0a:	99 1f       	adc	r25, r25
    1a0c:	82 0f       	add	r24, r18
    1a0e:	93 1f       	adc	r25, r19
    1a10:	81 5d       	subi	r24, 0xD1	; 209
    1a12:	97 4f       	sbci	r25, 0xF7	; 247
    1a14:	0e 94 ab 10 	call	0x2156	; 0x2156 <vListInitialise>

    static void prvInitialiseCoRoutineLists( void )
    {
        UBaseType_t uxPriority;

        for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
    1a18:	89 81       	ldd	r24, Y+1	; 0x01
    1a1a:	8f 5f       	subi	r24, 0xFF	; 255
    1a1c:	89 83       	std	Y+1, r24	; 0x01
    1a1e:	89 81       	ldd	r24, Y+1	; 0x01
    1a20:	82 30       	cpi	r24, 0x02	; 2
    1a22:	50 f3       	brcs	.-44     	; 0x19f8 <prvInitialiseCoRoutineLists+0xe>
        {
            vListInitialise( ( List_t * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
        }

        vListInitialise( ( List_t * ) &xDelayedCoRoutineList1 );
    1a24:	81 e4       	ldi	r24, 0x41	; 65
    1a26:	98 e0       	ldi	r25, 0x08	; 8
    1a28:	0e 94 ab 10 	call	0x2156	; 0x2156 <vListInitialise>
        vListInitialise( ( List_t * ) &xDelayedCoRoutineList2 );
    1a2c:	8a e4       	ldi	r24, 0x4A	; 74
    1a2e:	98 e0       	ldi	r25, 0x08	; 8
    1a30:	0e 94 ab 10 	call	0x2156	; 0x2156 <vListInitialise>
        vListInitialise( ( List_t * ) &xPendingReadyCoRoutineList );
    1a34:	83 e5       	ldi	r24, 0x53	; 83
    1a36:	98 e0       	ldi	r25, 0x08	; 8
    1a38:	0e 94 ab 10 	call	0x2156	; 0x2156 <vListInitialise>

        /* Start with pxDelayedCoRoutineList using list1 and the
         * pxOverflowDelayedCoRoutineList using list2. */
        pxDelayedCoRoutineList = &xDelayedCoRoutineList1;
    1a3c:	81 e4       	ldi	r24, 0x41	; 65
    1a3e:	98 e0       	ldi	r25, 0x08	; 8
    1a40:	90 93 23 08 	sts	0x0823, r25
    1a44:	80 93 22 08 	sts	0x0822, r24
        pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
    1a48:	8a e4       	ldi	r24, 0x4A	; 74
    1a4a:	98 e0       	ldi	r25, 0x08	; 8
    1a4c:	90 93 25 08 	sts	0x0825, r25
    1a50:	80 93 24 08 	sts	0x0824, r24
    }
    1a54:	0f 90       	pop	r0
    1a56:	cf 91       	pop	r28
    1a58:	df 91       	pop	r29
    1a5a:	08 95       	ret

00001a5c <xCoRoutineRemoveFromEventList>:
/*-----------------------------------------------------------*/

    BaseType_t xCoRoutineRemoveFromEventList( const List_t * pxEventList )
    {
    1a5c:	df 93       	push	r29
    1a5e:	cf 93       	push	r28
    1a60:	00 d0       	rcall	.+0      	; 0x1a62 <xCoRoutineRemoveFromEventList+0x6>
    1a62:	00 d0       	rcall	.+0      	; 0x1a64 <xCoRoutineRemoveFromEventList+0x8>
    1a64:	0f 92       	push	r0
    1a66:	cd b7       	in	r28, 0x3d	; 61
    1a68:	de b7       	in	r29, 0x3e	; 62
    1a6a:	9d 83       	std	Y+5, r25	; 0x05
    1a6c:	8c 83       	std	Y+4, r24	; 0x04
        BaseType_t xReturn;

        /* This function is called from within an interrupt.  It can only access
         * event lists and the pending ready list.  This function assumes that a
         * check has already been made to ensure pxEventList is not empty. */
        pxUnblockedCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    1a6e:	ec 81       	ldd	r30, Y+4	; 0x04
    1a70:	fd 81       	ldd	r31, Y+5	; 0x05
    1a72:	05 80       	ldd	r0, Z+5	; 0x05
    1a74:	f6 81       	ldd	r31, Z+6	; 0x06
    1a76:	e0 2d       	mov	r30, r0
    1a78:	86 81       	ldd	r24, Z+6	; 0x06
    1a7a:	97 81       	ldd	r25, Z+7	; 0x07
    1a7c:	9b 83       	std	Y+3, r25	; 0x03
    1a7e:	8a 83       	std	Y+2, r24	; 0x02
        ( void ) uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    1a80:	8a 81       	ldd	r24, Y+2	; 0x02
    1a82:	9b 81       	ldd	r25, Y+3	; 0x03
    1a84:	0c 96       	adiw	r24, 0x0c	; 12
    1a86:	0e 94 95 11 	call	0x232a	; 0x232a <uxListRemove>
        vListInsertEnd( ( List_t * ) &( xPendingReadyCoRoutineList ), &( pxUnblockedCRCB->xEventListItem ) );
    1a8a:	8a 81       	ldd	r24, Y+2	; 0x02
    1a8c:	9b 81       	ldd	r25, Y+3	; 0x03
    1a8e:	9c 01       	movw	r18, r24
    1a90:	24 5f       	subi	r18, 0xF4	; 244
    1a92:	3f 4f       	sbci	r19, 0xFF	; 255
    1a94:	83 e5       	ldi	r24, 0x53	; 83
    1a96:	98 e0       	ldi	r25, 0x08	; 8
    1a98:	b9 01       	movw	r22, r18
    1a9a:	0e 94 e5 10 	call	0x21ca	; 0x21ca <vListInsertEnd>

        if( pxUnblockedCRCB->uxPriority >= pxCurrentCoRoutine->uxPriority )
    1a9e:	ea 81       	ldd	r30, Y+2	; 0x02
    1aa0:	fb 81       	ldd	r31, Y+3	; 0x03
    1aa2:	96 89       	ldd	r25, Z+22	; 0x16
    1aa4:	e0 91 26 08 	lds	r30, 0x0826
    1aa8:	f0 91 27 08 	lds	r31, 0x0827
    1aac:	86 89       	ldd	r24, Z+22	; 0x16
    1aae:	98 17       	cp	r25, r24
    1ab0:	18 f0       	brcs	.+6      	; 0x1ab8 <xCoRoutineRemoveFromEventList+0x5c>
        {
            xReturn = pdTRUE;
    1ab2:	81 e0       	ldi	r24, 0x01	; 1
    1ab4:	89 83       	std	Y+1, r24	; 0x01
    1ab6:	01 c0       	rjmp	.+2      	; 0x1aba <xCoRoutineRemoveFromEventList+0x5e>
        }
        else
        {
            xReturn = pdFALSE;
    1ab8:	19 82       	std	Y+1, r1	; 0x01
        }

        return xReturn;
    1aba:	89 81       	ldd	r24, Y+1	; 0x01
    }
    1abc:	0f 90       	pop	r0
    1abe:	0f 90       	pop	r0
    1ac0:	0f 90       	pop	r0
    1ac2:	0f 90       	pop	r0
    1ac4:	0f 90       	pop	r0
    1ac6:	cf 91       	pop	r28
    1ac8:	df 91       	pop	r29
    1aca:	08 95       	ret

00001acc <xEventGroupCreate>:
/*-----------------------------------------------------------*/

#if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

    EventGroupHandle_t xEventGroupCreate( void )
    {
    1acc:	df 93       	push	r29
    1ace:	cf 93       	push	r28
    1ad0:	00 d0       	rcall	.+0      	; 0x1ad2 <xEventGroupCreate+0x6>
    1ad2:	cd b7       	in	r28, 0x3d	; 61
    1ad4:	de b7       	in	r29, 0x3e	; 62
         * TickType_t alignment requirements the cast is safe.  In other cases,
         * where the natural word size of the architecture is less than
         * sizeof( TickType_t ), the TickType_t variables will be accessed in two
         * or more reads operations, and the alignment requirements is only that
         * of each individual read. */
        pxEventBits = ( EventGroup_t * ) pvPortMalloc( sizeof( EventGroup_t ) ); /*lint !e9087 !e9079 see comment above. */
    1ad6:	8b e0       	ldi	r24, 0x0B	; 11
    1ad8:	90 e0       	ldi	r25, 0x00	; 0
    1ada:	0e 94 33 07 	call	0xe66	; 0xe66 <pvPortMalloc>
    1ade:	9a 83       	std	Y+2, r25	; 0x02
    1ae0:	89 83       	std	Y+1, r24	; 0x01

        if( pxEventBits != NULL )
    1ae2:	89 81       	ldd	r24, Y+1	; 0x01
    1ae4:	9a 81       	ldd	r25, Y+2	; 0x02
    1ae6:	00 97       	sbiw	r24, 0x00	; 0
    1ae8:	49 f0       	breq	.+18     	; 0x1afc <xEventGroupCreate+0x30>
        {
            pxEventBits->uxEventBits = 0;
    1aea:	e9 81       	ldd	r30, Y+1	; 0x01
    1aec:	fa 81       	ldd	r31, Y+2	; 0x02
    1aee:	11 82       	std	Z+1, r1	; 0x01
    1af0:	10 82       	st	Z, r1
            vListInitialise( &( pxEventBits->xTasksWaitingForBits ) );
    1af2:	89 81       	ldd	r24, Y+1	; 0x01
    1af4:	9a 81       	ldd	r25, Y+2	; 0x02
    1af6:	02 96       	adiw	r24, 0x02	; 2
    1af8:	0e 94 ab 10 	call	0x2156	; 0x2156 <vListInitialise>
        else
        {
            traceEVENT_GROUP_CREATE_FAILED(); /*lint !e9063 Else branch only exists to allow tracing and does not generate code if trace macros are not defined. */
        }

        return pxEventBits;
    1afc:	89 81       	ldd	r24, Y+1	; 0x01
    1afe:	9a 81       	ldd	r25, Y+2	; 0x02
    }
    1b00:	0f 90       	pop	r0
    1b02:	0f 90       	pop	r0
    1b04:	cf 91       	pop	r28
    1b06:	df 91       	pop	r29
    1b08:	08 95       	ret

00001b0a <xEventGroupSync>:

EventBits_t xEventGroupSync( EventGroupHandle_t xEventGroup,
                             const EventBits_t uxBitsToSet,
                             const EventBits_t uxBitsToWaitFor,
                             TickType_t xTicksToWait )
{
    1b0a:	df 93       	push	r29
    1b0c:	cf 93       	push	r28
    1b0e:	cd b7       	in	r28, 0x3d	; 61
    1b10:	de b7       	in	r29, 0x3e	; 62
    1b12:	60 97       	sbiw	r28, 0x10	; 16
    1b14:	0f b6       	in	r0, 0x3f	; 63
    1b16:	f8 94       	cli
    1b18:	de bf       	out	0x3e, r29	; 62
    1b1a:	0f be       	out	0x3f, r0	; 63
    1b1c:	cd bf       	out	0x3d, r28	; 61
    1b1e:	9a 87       	std	Y+10, r25	; 0x0a
    1b20:	89 87       	std	Y+9, r24	; 0x09
    1b22:	7c 87       	std	Y+12, r23	; 0x0c
    1b24:	6b 87       	std	Y+11, r22	; 0x0b
    1b26:	5e 87       	std	Y+14, r21	; 0x0e
    1b28:	4d 87       	std	Y+13, r20	; 0x0d
    1b2a:	38 8b       	std	Y+16, r19	; 0x10
    1b2c:	2f 87       	std	Y+15, r18	; 0x0f
    EventBits_t uxOriginalBitValue, uxReturn;
    EventGroup_t * pxEventBits = xEventGroup;
    1b2e:	89 85       	ldd	r24, Y+9	; 0x09
    1b30:	9a 85       	ldd	r25, Y+10	; 0x0a
    1b32:	9c 83       	std	Y+4, r25	; 0x04
    1b34:	8b 83       	std	Y+3, r24	; 0x03
    BaseType_t xAlreadyYielded;
    BaseType_t xTimeoutOccurred = pdFALSE;
    1b36:	19 82       	std	Y+1, r1	; 0x01
        {
            configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
        }
    #endif

    vTaskSuspendAll();
    1b38:	0e 94 88 1e 	call	0x3d10	; 0x3d10 <vTaskSuspendAll>
    {
        uxOriginalBitValue = pxEventBits->uxEventBits;
    1b3c:	eb 81       	ldd	r30, Y+3	; 0x03
    1b3e:	fc 81       	ldd	r31, Y+4	; 0x04
    1b40:	80 81       	ld	r24, Z
    1b42:	91 81       	ldd	r25, Z+1	; 0x01
    1b44:	98 87       	std	Y+8, r25	; 0x08
    1b46:	8f 83       	std	Y+7, r24	; 0x07

        ( void ) xEventGroupSetBits( xEventGroup, uxBitsToSet );
    1b48:	89 85       	ldd	r24, Y+9	; 0x09
    1b4a:	9a 85       	ldd	r25, Y+10	; 0x0a
    1b4c:	2b 85       	ldd	r18, Y+11	; 0x0b
    1b4e:	3c 85       	ldd	r19, Y+12	; 0x0c
    1b50:	b9 01       	movw	r22, r18
    1b52:	0e 94 5c 0f 	call	0x1eb8	; 0x1eb8 <xEventGroupSetBits>

        if( ( ( uxOriginalBitValue | uxBitsToSet ) & uxBitsToWaitFor ) == uxBitsToWaitFor )
    1b56:	2f 81       	ldd	r18, Y+7	; 0x07
    1b58:	38 85       	ldd	r19, Y+8	; 0x08
    1b5a:	8b 85       	ldd	r24, Y+11	; 0x0b
    1b5c:	9c 85       	ldd	r25, Y+12	; 0x0c
    1b5e:	28 2b       	or	r18, r24
    1b60:	39 2b       	or	r19, r25
    1b62:	8d 85       	ldd	r24, Y+13	; 0x0d
    1b64:	9e 85       	ldd	r25, Y+14	; 0x0e
    1b66:	28 23       	and	r18, r24
    1b68:	39 23       	and	r19, r25
    1b6a:	8d 85       	ldd	r24, Y+13	; 0x0d
    1b6c:	9e 85       	ldd	r25, Y+14	; 0x0e
    1b6e:	28 17       	cp	r18, r24
    1b70:	39 07       	cpc	r19, r25
    1b72:	c9 f4       	brne	.+50     	; 0x1ba6 <xEventGroupSync+0x9c>
        {
            /* All the rendezvous bits are now set - no need to block. */
            uxReturn = ( uxOriginalBitValue | uxBitsToSet );
    1b74:	2f 81       	ldd	r18, Y+7	; 0x07
    1b76:	38 85       	ldd	r19, Y+8	; 0x08
    1b78:	8b 85       	ldd	r24, Y+11	; 0x0b
    1b7a:	9c 85       	ldd	r25, Y+12	; 0x0c
    1b7c:	82 2b       	or	r24, r18
    1b7e:	93 2b       	or	r25, r19
    1b80:	9e 83       	std	Y+6, r25	; 0x06
    1b82:	8d 83       	std	Y+5, r24	; 0x05

            /* Rendezvous always clear the bits.  They will have been cleared
             * already unless this is the only task in the rendezvous. */
            pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    1b84:	eb 81       	ldd	r30, Y+3	; 0x03
    1b86:	fc 81       	ldd	r31, Y+4	; 0x04
    1b88:	20 81       	ld	r18, Z
    1b8a:	31 81       	ldd	r19, Z+1	; 0x01
    1b8c:	8d 85       	ldd	r24, Y+13	; 0x0d
    1b8e:	9e 85       	ldd	r25, Y+14	; 0x0e
    1b90:	80 95       	com	r24
    1b92:	90 95       	com	r25
    1b94:	82 23       	and	r24, r18
    1b96:	93 23       	and	r25, r19
    1b98:	eb 81       	ldd	r30, Y+3	; 0x03
    1b9a:	fc 81       	ldd	r31, Y+4	; 0x04
    1b9c:	91 83       	std	Z+1, r25	; 0x01
    1b9e:	80 83       	st	Z, r24

            xTicksToWait = 0;
    1ba0:	18 8a       	std	Y+16, r1	; 0x10
    1ba2:	1f 86       	std	Y+15, r1	; 0x0f
    1ba4:	1e c0       	rjmp	.+60     	; 0x1be2 <xEventGroupSync+0xd8>
        }
        else
        {
            if( xTicksToWait != ( TickType_t ) 0 )
    1ba6:	8f 85       	ldd	r24, Y+15	; 0x0f
    1ba8:	98 89       	ldd	r25, Y+16	; 0x10
    1baa:	00 97       	sbiw	r24, 0x00	; 0
    1bac:	91 f0       	breq	.+36     	; 0x1bd2 <xEventGroupSync+0xc8>
                traceEVENT_GROUP_SYNC_BLOCK( xEventGroup, uxBitsToSet, uxBitsToWaitFor );

                /* Store the bits that the calling task is waiting for in the
                 * task's event list item so the kernel knows when a match is
                 * found.  Then enter the blocked state. */
                vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | eventCLEAR_EVENTS_ON_EXIT_BIT | eventWAIT_FOR_ALL_BITS ), xTicksToWait );
    1bae:	8b 81       	ldd	r24, Y+3	; 0x03
    1bb0:	9c 81       	ldd	r25, Y+4	; 0x04
    1bb2:	bc 01       	movw	r22, r24
    1bb4:	6e 5f       	subi	r22, 0xFE	; 254
    1bb6:	7f 4f       	sbci	r23, 0xFF	; 255
    1bb8:	8d 85       	ldd	r24, Y+13	; 0x0d
    1bba:	9e 85       	ldd	r25, Y+14	; 0x0e
    1bbc:	9c 01       	movw	r18, r24
    1bbe:	35 60       	ori	r19, 0x05	; 5
    1bc0:	4f 85       	ldd	r20, Y+15	; 0x0f
    1bc2:	58 89       	ldd	r21, Y+16	; 0x10
    1bc4:	cb 01       	movw	r24, r22
    1bc6:	b9 01       	movw	r22, r18
    1bc8:	0e 94 87 22 	call	0x450e	; 0x450e <vTaskPlaceOnUnorderedEventList>

                /* This assignment is obsolete as uxReturn will get set after
                 * the task unblocks, but some compilers mistakenly generate a
                 * warning about uxReturn being returned without being set if the
                 * assignment is omitted. */
                uxReturn = 0;
    1bcc:	1e 82       	std	Y+6, r1	; 0x06
    1bce:	1d 82       	std	Y+5, r1	; 0x05
    1bd0:	08 c0       	rjmp	.+16     	; 0x1be2 <xEventGroupSync+0xd8>
            }
            else
            {
                /* The rendezvous bits were not set, but no block time was
                 * specified - just return the current event bit value. */
                uxReturn = pxEventBits->uxEventBits;
    1bd2:	eb 81       	ldd	r30, Y+3	; 0x03
    1bd4:	fc 81       	ldd	r31, Y+4	; 0x04
    1bd6:	80 81       	ld	r24, Z
    1bd8:	91 81       	ldd	r25, Z+1	; 0x01
    1bda:	9e 83       	std	Y+6, r25	; 0x06
    1bdc:	8d 83       	std	Y+5, r24	; 0x05
                xTimeoutOccurred = pdTRUE;
    1bde:	81 e0       	ldi	r24, 0x01	; 1
    1be0:	89 83       	std	Y+1, r24	; 0x01
            }
        }
    }
    xAlreadyYielded = xTaskResumeAll();
    1be2:	0e 94 94 1e 	call	0x3d28	; 0x3d28 <xTaskResumeAll>
    1be6:	8a 83       	std	Y+2, r24	; 0x02

    if( xTicksToWait != ( TickType_t ) 0 )
    1be8:	8f 85       	ldd	r24, Y+15	; 0x0f
    1bea:	98 89       	ldd	r25, Y+16	; 0x10
    1bec:	00 97       	sbiw	r24, 0x00	; 0
    1bee:	09 f4       	brne	.+2      	; 0x1bf2 <xEventGroupSync+0xe8>
    1bf0:	3a c0       	rjmp	.+116    	; 0x1c66 <xEventGroupSync+0x15c>
    {
        if( xAlreadyYielded == pdFALSE )
    1bf2:	8a 81       	ldd	r24, Y+2	; 0x02
    1bf4:	88 23       	and	r24, r24
    1bf6:	11 f4       	brne	.+4      	; 0x1bfc <xEventGroupSync+0xf2>
        {
            portYIELD_WITHIN_API();
    1bf8:	0e 94 72 09 	call	0x12e4	; 0x12e4 <vPortYield>

        /* The task blocked to wait for its required bits to be set - at this
         * point either the required bits were set or the block time expired.  If
         * the required bits were set they will have been stored in the task's
         * event list item, and they should now be retrieved then cleared. */
        uxReturn = uxTaskResetEventItemValue();
    1bfc:	0e 94 15 27 	call	0x4e2a	; 0x4e2a <uxTaskResetEventItemValue>
    1c00:	9e 83       	std	Y+6, r25	; 0x06
    1c02:	8d 83       	std	Y+5, r24	; 0x05

        if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
    1c04:	8d 81       	ldd	r24, Y+5	; 0x05
    1c06:	9e 81       	ldd	r25, Y+6	; 0x06
    1c08:	80 70       	andi	r24, 0x00	; 0
    1c0a:	92 70       	andi	r25, 0x02	; 2
    1c0c:	00 97       	sbiw	r24, 0x00	; 0
    1c0e:	31 f5       	brne	.+76     	; 0x1c5c <xEventGroupSync+0x152>
        {
            /* The task timed out, just return the current event bit value. */
            taskENTER_CRITICAL();
    1c10:	0f b6       	in	r0, 0x3f	; 63
    1c12:	f8 94       	cli
    1c14:	0f 92       	push	r0
            {
                uxReturn = pxEventBits->uxEventBits;
    1c16:	eb 81       	ldd	r30, Y+3	; 0x03
    1c18:	fc 81       	ldd	r31, Y+4	; 0x04
    1c1a:	80 81       	ld	r24, Z
    1c1c:	91 81       	ldd	r25, Z+1	; 0x01
    1c1e:	9e 83       	std	Y+6, r25	; 0x06
    1c20:	8d 83       	std	Y+5, r24	; 0x05

                /* Although the task got here because it timed out before the
                 * bits it was waiting for were set, it is possible that since it
                 * unblocked another task has set the bits.  If this is the case
                 * then it needs to clear the bits before exiting. */
                if( ( uxReturn & uxBitsToWaitFor ) == uxBitsToWaitFor )
    1c22:	2d 81       	ldd	r18, Y+5	; 0x05
    1c24:	3e 81       	ldd	r19, Y+6	; 0x06
    1c26:	8d 85       	ldd	r24, Y+13	; 0x0d
    1c28:	9e 85       	ldd	r25, Y+14	; 0x0e
    1c2a:	28 23       	and	r18, r24
    1c2c:	39 23       	and	r19, r25
    1c2e:	8d 85       	ldd	r24, Y+13	; 0x0d
    1c30:	9e 85       	ldd	r25, Y+14	; 0x0e
    1c32:	28 17       	cp	r18, r24
    1c34:	39 07       	cpc	r19, r25
    1c36:	71 f4       	brne	.+28     	; 0x1c54 <xEventGroupSync+0x14a>
                {
                    pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    1c38:	eb 81       	ldd	r30, Y+3	; 0x03
    1c3a:	fc 81       	ldd	r31, Y+4	; 0x04
    1c3c:	20 81       	ld	r18, Z
    1c3e:	31 81       	ldd	r19, Z+1	; 0x01
    1c40:	8d 85       	ldd	r24, Y+13	; 0x0d
    1c42:	9e 85       	ldd	r25, Y+14	; 0x0e
    1c44:	80 95       	com	r24
    1c46:	90 95       	com	r25
    1c48:	82 23       	and	r24, r18
    1c4a:	93 23       	and	r25, r19
    1c4c:	eb 81       	ldd	r30, Y+3	; 0x03
    1c4e:	fc 81       	ldd	r31, Y+4	; 0x04
    1c50:	91 83       	std	Z+1, r25	; 0x01
    1c52:	80 83       	st	Z, r24
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }
            }
            taskEXIT_CRITICAL();
    1c54:	0f 90       	pop	r0
    1c56:	0f be       	out	0x3f, r0	; 63

            xTimeoutOccurred = pdTRUE;
    1c58:	81 e0       	ldi	r24, 0x01	; 1
    1c5a:	89 83       	std	Y+1, r24	; 0x01
            /* The task unblocked because the bits were set. */
        }

        /* Control bits might be set as the task had blocked should not be
         * returned. */
        uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
    1c5c:	8d 81       	ldd	r24, Y+5	; 0x05
    1c5e:	9e 81       	ldd	r25, Y+6	; 0x06
    1c60:	90 70       	andi	r25, 0x00	; 0
    1c62:	9e 83       	std	Y+6, r25	; 0x06
    1c64:	8d 83       	std	Y+5, r24	; 0x05
    traceEVENT_GROUP_SYNC_END( xEventGroup, uxBitsToSet, uxBitsToWaitFor, xTimeoutOccurred );

    /* Prevent compiler warnings when trace macros are not used. */
    ( void ) xTimeoutOccurred;

    return uxReturn;
    1c66:	8d 81       	ldd	r24, Y+5	; 0x05
    1c68:	9e 81       	ldd	r25, Y+6	; 0x06
}
    1c6a:	60 96       	adiw	r28, 0x10	; 16
    1c6c:	0f b6       	in	r0, 0x3f	; 63
    1c6e:	f8 94       	cli
    1c70:	de bf       	out	0x3e, r29	; 62
    1c72:	0f be       	out	0x3f, r0	; 63
    1c74:	cd bf       	out	0x3d, r28	; 61
    1c76:	cf 91       	pop	r28
    1c78:	df 91       	pop	r29
    1c7a:	08 95       	ret

00001c7c <xEventGroupWaitBits>:
EventBits_t xEventGroupWaitBits( EventGroupHandle_t xEventGroup,
                                 const EventBits_t uxBitsToWaitFor,
                                 const BaseType_t xClearOnExit,
                                 const BaseType_t xWaitForAllBits,
                                 TickType_t xTicksToWait )
{
    1c7c:	0f 93       	push	r16
    1c7e:	1f 93       	push	r17
    1c80:	df 93       	push	r29
    1c82:	cf 93       	push	r28
    1c84:	cd b7       	in	r28, 0x3d	; 61
    1c86:	de b7       	in	r29, 0x3e	; 62
    1c88:	63 97       	sbiw	r28, 0x13	; 19
    1c8a:	0f b6       	in	r0, 0x3f	; 63
    1c8c:	f8 94       	cli
    1c8e:	de bf       	out	0x3e, r29	; 62
    1c90:	0f be       	out	0x3f, r0	; 63
    1c92:	cd bf       	out	0x3d, r28	; 61
    1c94:	9d 87       	std	Y+13, r25	; 0x0d
    1c96:	8c 87       	std	Y+12, r24	; 0x0c
    1c98:	7f 87       	std	Y+15, r23	; 0x0f
    1c9a:	6e 87       	std	Y+14, r22	; 0x0e
    1c9c:	48 8b       	std	Y+16, r20	; 0x10
    1c9e:	29 8b       	std	Y+17, r18	; 0x11
    1ca0:	1b 8b       	std	Y+19, r17	; 0x13
    1ca2:	0a 8b       	std	Y+18, r16	; 0x12
    EventGroup_t * pxEventBits = xEventGroup;
    1ca4:	8c 85       	ldd	r24, Y+12	; 0x0c
    1ca6:	9d 85       	ldd	r25, Y+13	; 0x0d
    1ca8:	9b 87       	std	Y+11, r25	; 0x0b
    1caa:	8a 87       	std	Y+10, r24	; 0x0a
    EventBits_t uxReturn, uxControlBits = 0;
    1cac:	1f 82       	std	Y+7, r1	; 0x07
    1cae:	1e 82       	std	Y+6, r1	; 0x06
    BaseType_t xWaitConditionMet, xAlreadyYielded;
    BaseType_t xTimeoutOccurred = pdFALSE;
    1cb0:	1b 82       	std	Y+3, r1	; 0x03
        {
            configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
        }
    #endif

    vTaskSuspendAll();
    1cb2:	0e 94 88 1e 	call	0x3d10	; 0x3d10 <vTaskSuspendAll>
    {
        const EventBits_t uxCurrentEventBits = pxEventBits->uxEventBits;
    1cb6:	ea 85       	ldd	r30, Y+10	; 0x0a
    1cb8:	fb 85       	ldd	r31, Y+11	; 0x0b
    1cba:	80 81       	ld	r24, Z
    1cbc:	91 81       	ldd	r25, Z+1	; 0x01
    1cbe:	9a 83       	std	Y+2, r25	; 0x02
    1cc0:	89 83       	std	Y+1, r24	; 0x01

        /* Check to see if the wait condition is already met or not. */
        xWaitConditionMet = prvTestWaitCondition( uxCurrentEventBits, uxBitsToWaitFor, xWaitForAllBits );
    1cc2:	89 81       	ldd	r24, Y+1	; 0x01
    1cc4:	9a 81       	ldd	r25, Y+2	; 0x02
    1cc6:	2e 85       	ldd	r18, Y+14	; 0x0e
    1cc8:	3f 85       	ldd	r19, Y+15	; 0x0f
    1cca:	b9 01       	movw	r22, r18
    1ccc:	49 89       	ldd	r20, Y+17	; 0x11
    1cce:	0e 94 79 10 	call	0x20f2	; 0x20f2 <prvTestWaitCondition>
    1cd2:	8d 83       	std	Y+5, r24	; 0x05

        if( xWaitConditionMet != pdFALSE )
    1cd4:	8d 81       	ldd	r24, Y+5	; 0x05
    1cd6:	88 23       	and	r24, r24
    1cd8:	c1 f0       	breq	.+48     	; 0x1d0a <xEventGroupWaitBits+0x8e>
        {
            /* The wait condition has already been met so there is no need to
             * block. */
            uxReturn = uxCurrentEventBits;
    1cda:	89 81       	ldd	r24, Y+1	; 0x01
    1cdc:	9a 81       	ldd	r25, Y+2	; 0x02
    1cde:	99 87       	std	Y+9, r25	; 0x09
    1ce0:	88 87       	std	Y+8, r24	; 0x08
            xTicksToWait = ( TickType_t ) 0;
    1ce2:	1b 8a       	std	Y+19, r1	; 0x13
    1ce4:	1a 8a       	std	Y+18, r1	; 0x12

            /* Clear the wait bits if requested to do so. */
            if( xClearOnExit != pdFALSE )
    1ce6:	88 89       	ldd	r24, Y+16	; 0x10
    1ce8:	88 23       	and	r24, r24
    1cea:	e9 f1       	breq	.+122    	; 0x1d66 <xEventGroupWaitBits+0xea>
            {
                pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    1cec:	ea 85       	ldd	r30, Y+10	; 0x0a
    1cee:	fb 85       	ldd	r31, Y+11	; 0x0b
    1cf0:	20 81       	ld	r18, Z
    1cf2:	31 81       	ldd	r19, Z+1	; 0x01
    1cf4:	8e 85       	ldd	r24, Y+14	; 0x0e
    1cf6:	9f 85       	ldd	r25, Y+15	; 0x0f
    1cf8:	80 95       	com	r24
    1cfa:	90 95       	com	r25
    1cfc:	82 23       	and	r24, r18
    1cfe:	93 23       	and	r25, r19
    1d00:	ea 85       	ldd	r30, Y+10	; 0x0a
    1d02:	fb 85       	ldd	r31, Y+11	; 0x0b
    1d04:	91 83       	std	Z+1, r25	; 0x01
    1d06:	80 83       	st	Z, r24
    1d08:	2e c0       	rjmp	.+92     	; 0x1d66 <xEventGroupWaitBits+0xea>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        else if( xTicksToWait == ( TickType_t ) 0 )
    1d0a:	8a 89       	ldd	r24, Y+18	; 0x12
    1d0c:	9b 89       	ldd	r25, Y+19	; 0x13
    1d0e:	00 97       	sbiw	r24, 0x00	; 0
    1d10:	39 f4       	brne	.+14     	; 0x1d20 <xEventGroupWaitBits+0xa4>
        {
            /* The wait condition has not been met, but no block time was
             * specified, so just return the current value. */
            uxReturn = uxCurrentEventBits;
    1d12:	89 81       	ldd	r24, Y+1	; 0x01
    1d14:	9a 81       	ldd	r25, Y+2	; 0x02
    1d16:	99 87       	std	Y+9, r25	; 0x09
    1d18:	88 87       	std	Y+8, r24	; 0x08
            xTimeoutOccurred = pdTRUE;
    1d1a:	81 e0       	ldi	r24, 0x01	; 1
    1d1c:	8b 83       	std	Y+3, r24	; 0x03
    1d1e:	23 c0       	rjmp	.+70     	; 0x1d66 <xEventGroupWaitBits+0xea>
        {
            /* The task is going to block to wait for its required bits to be
             * set.  uxControlBits are used to remember the specified behaviour of
             * this call to xEventGroupWaitBits() - for use when the event bits
             * unblock the task. */
            if( xClearOnExit != pdFALSE )
    1d20:	88 89       	ldd	r24, Y+16	; 0x10
    1d22:	88 23       	and	r24, r24
    1d24:	29 f0       	breq	.+10     	; 0x1d30 <xEventGroupWaitBits+0xb4>
            {
                uxControlBits |= eventCLEAR_EVENTS_ON_EXIT_BIT;
    1d26:	8e 81       	ldd	r24, Y+6	; 0x06
    1d28:	9f 81       	ldd	r25, Y+7	; 0x07
    1d2a:	91 60       	ori	r25, 0x01	; 1
    1d2c:	9f 83       	std	Y+7, r25	; 0x07
    1d2e:	8e 83       	std	Y+6, r24	; 0x06
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }

            if( xWaitForAllBits != pdFALSE )
    1d30:	89 89       	ldd	r24, Y+17	; 0x11
    1d32:	88 23       	and	r24, r24
    1d34:	29 f0       	breq	.+10     	; 0x1d40 <xEventGroupWaitBits+0xc4>
            {
                uxControlBits |= eventWAIT_FOR_ALL_BITS;
    1d36:	8e 81       	ldd	r24, Y+6	; 0x06
    1d38:	9f 81       	ldd	r25, Y+7	; 0x07
    1d3a:	94 60       	ori	r25, 0x04	; 4
    1d3c:	9f 83       	std	Y+7, r25	; 0x07
    1d3e:	8e 83       	std	Y+6, r24	; 0x06
            }

            /* Store the bits that the calling task is waiting for in the
             * task's event list item so the kernel knows when a match is
             * found.  Then enter the blocked state. */
            vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | uxControlBits ), xTicksToWait );
    1d40:	8a 85       	ldd	r24, Y+10	; 0x0a
    1d42:	9b 85       	ldd	r25, Y+11	; 0x0b
    1d44:	bc 01       	movw	r22, r24
    1d46:	6e 5f       	subi	r22, 0xFE	; 254
    1d48:	7f 4f       	sbci	r23, 0xFF	; 255
    1d4a:	2e 85       	ldd	r18, Y+14	; 0x0e
    1d4c:	3f 85       	ldd	r19, Y+15	; 0x0f
    1d4e:	8e 81       	ldd	r24, Y+6	; 0x06
    1d50:	9f 81       	ldd	r25, Y+7	; 0x07
    1d52:	28 2b       	or	r18, r24
    1d54:	39 2b       	or	r19, r25
    1d56:	4a 89       	ldd	r20, Y+18	; 0x12
    1d58:	5b 89       	ldd	r21, Y+19	; 0x13
    1d5a:	cb 01       	movw	r24, r22
    1d5c:	b9 01       	movw	r22, r18
    1d5e:	0e 94 87 22 	call	0x450e	; 0x450e <vTaskPlaceOnUnorderedEventList>

            /* This is obsolete as it will get set after the task unblocks, but
             * some compilers mistakenly generate a warning about the variable
             * being returned without being set if it is not done. */
            uxReturn = 0;
    1d62:	19 86       	std	Y+9, r1	; 0x09
    1d64:	18 86       	std	Y+8, r1	; 0x08

            traceEVENT_GROUP_WAIT_BITS_BLOCK( xEventGroup, uxBitsToWaitFor );
        }
    }
    xAlreadyYielded = xTaskResumeAll();
    1d66:	0e 94 94 1e 	call	0x3d28	; 0x3d28 <xTaskResumeAll>
    1d6a:	8c 83       	std	Y+4, r24	; 0x04

    if( xTicksToWait != ( TickType_t ) 0 )
    1d6c:	8a 89       	ldd	r24, Y+18	; 0x12
    1d6e:	9b 89       	ldd	r25, Y+19	; 0x13
    1d70:	00 97       	sbiw	r24, 0x00	; 0
    1d72:	09 f4       	brne	.+2      	; 0x1d76 <xEventGroupWaitBits+0xfa>
    1d74:	3c c0       	rjmp	.+120    	; 0x1dee <xEventGroupWaitBits+0x172>
    {
        if( xAlreadyYielded == pdFALSE )
    1d76:	8c 81       	ldd	r24, Y+4	; 0x04
    1d78:	88 23       	and	r24, r24
    1d7a:	11 f4       	brne	.+4      	; 0x1d80 <xEventGroupWaitBits+0x104>
        {
            portYIELD_WITHIN_API();
    1d7c:	0e 94 72 09 	call	0x12e4	; 0x12e4 <vPortYield>

        /* The task blocked to wait for its required bits to be set - at this
         * point either the required bits were set or the block time expired.  If
         * the required bits were set they will have been stored in the task's
         * event list item, and they should now be retrieved then cleared. */
        uxReturn = uxTaskResetEventItemValue();
    1d80:	0e 94 15 27 	call	0x4e2a	; 0x4e2a <uxTaskResetEventItemValue>
    1d84:	99 87       	std	Y+9, r25	; 0x09
    1d86:	88 87       	std	Y+8, r24	; 0x08

        if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
    1d88:	88 85       	ldd	r24, Y+8	; 0x08
    1d8a:	99 85       	ldd	r25, Y+9	; 0x09
    1d8c:	80 70       	andi	r24, 0x00	; 0
    1d8e:	92 70       	andi	r25, 0x02	; 2
    1d90:	00 97       	sbiw	r24, 0x00	; 0
    1d92:	41 f5       	brne	.+80     	; 0x1de4 <xEventGroupWaitBits+0x168>
        {
            taskENTER_CRITICAL();
    1d94:	0f b6       	in	r0, 0x3f	; 63
    1d96:	f8 94       	cli
    1d98:	0f 92       	push	r0
            {
                /* The task timed out, just return the current event bit value. */
                uxReturn = pxEventBits->uxEventBits;
    1d9a:	ea 85       	ldd	r30, Y+10	; 0x0a
    1d9c:	fb 85       	ldd	r31, Y+11	; 0x0b
    1d9e:	80 81       	ld	r24, Z
    1da0:	91 81       	ldd	r25, Z+1	; 0x01
    1da2:	99 87       	std	Y+9, r25	; 0x09
    1da4:	88 87       	std	Y+8, r24	; 0x08

                /* It is possible that the event bits were updated between this
                 * task leaving the Blocked state and running again. */
                if( prvTestWaitCondition( uxReturn, uxBitsToWaitFor, xWaitForAllBits ) != pdFALSE )
    1da6:	88 85       	ldd	r24, Y+8	; 0x08
    1da8:	99 85       	ldd	r25, Y+9	; 0x09
    1daa:	2e 85       	ldd	r18, Y+14	; 0x0e
    1dac:	3f 85       	ldd	r19, Y+15	; 0x0f
    1dae:	b9 01       	movw	r22, r18
    1db0:	49 89       	ldd	r20, Y+17	; 0x11
    1db2:	0e 94 79 10 	call	0x20f2	; 0x20f2 <prvTestWaitCondition>
    1db6:	88 23       	and	r24, r24
    1db8:	89 f0       	breq	.+34     	; 0x1ddc <xEventGroupWaitBits+0x160>
                {
                    if( xClearOnExit != pdFALSE )
    1dba:	88 89       	ldd	r24, Y+16	; 0x10
    1dbc:	88 23       	and	r24, r24
    1dbe:	71 f0       	breq	.+28     	; 0x1ddc <xEventGroupWaitBits+0x160>
                    {
                        pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    1dc0:	ea 85       	ldd	r30, Y+10	; 0x0a
    1dc2:	fb 85       	ldd	r31, Y+11	; 0x0b
    1dc4:	20 81       	ld	r18, Z
    1dc6:	31 81       	ldd	r19, Z+1	; 0x01
    1dc8:	8e 85       	ldd	r24, Y+14	; 0x0e
    1dca:	9f 85       	ldd	r25, Y+15	; 0x0f
    1dcc:	80 95       	com	r24
    1dce:	90 95       	com	r25
    1dd0:	82 23       	and	r24, r18
    1dd2:	93 23       	and	r25, r19
    1dd4:	ea 85       	ldd	r30, Y+10	; 0x0a
    1dd6:	fb 85       	ldd	r31, Y+11	; 0x0b
    1dd8:	91 83       	std	Z+1, r25	; 0x01
    1dda:	80 83       	st	Z, r24
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                xTimeoutOccurred = pdTRUE;
    1ddc:	81 e0       	ldi	r24, 0x01	; 1
    1dde:	8b 83       	std	Y+3, r24	; 0x03
            }
            taskEXIT_CRITICAL();
    1de0:	0f 90       	pop	r0
    1de2:	0f be       	out	0x3f, r0	; 63
        {
            /* The task unblocked because the bits were set. */
        }

        /* The task blocked so control bits may have been set. */
        uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
    1de4:	88 85       	ldd	r24, Y+8	; 0x08
    1de6:	99 85       	ldd	r25, Y+9	; 0x09
    1de8:	90 70       	andi	r25, 0x00	; 0
    1dea:	99 87       	std	Y+9, r25	; 0x09
    1dec:	88 87       	std	Y+8, r24	; 0x08
    traceEVENT_GROUP_WAIT_BITS_END( xEventGroup, uxBitsToWaitFor, xTimeoutOccurred );

    /* Prevent compiler warnings when trace macros are not used. */
    ( void ) xTimeoutOccurred;

    return uxReturn;
    1dee:	88 85       	ldd	r24, Y+8	; 0x08
    1df0:	99 85       	ldd	r25, Y+9	; 0x09
}
    1df2:	63 96       	adiw	r28, 0x13	; 19
    1df4:	0f b6       	in	r0, 0x3f	; 63
    1df6:	f8 94       	cli
    1df8:	de bf       	out	0x3e, r29	; 62
    1dfa:	0f be       	out	0x3f, r0	; 63
    1dfc:	cd bf       	out	0x3d, r28	; 61
    1dfe:	cf 91       	pop	r28
    1e00:	df 91       	pop	r29
    1e02:	1f 91       	pop	r17
    1e04:	0f 91       	pop	r16
    1e06:	08 95       	ret

00001e08 <xEventGroupClearBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupClearBits( EventGroupHandle_t xEventGroup,
                                  const EventBits_t uxBitsToClear )
{
    1e08:	df 93       	push	r29
    1e0a:	cf 93       	push	r28
    1e0c:	cd b7       	in	r28, 0x3d	; 61
    1e0e:	de b7       	in	r29, 0x3e	; 62
    1e10:	28 97       	sbiw	r28, 0x08	; 8
    1e12:	0f b6       	in	r0, 0x3f	; 63
    1e14:	f8 94       	cli
    1e16:	de bf       	out	0x3e, r29	; 62
    1e18:	0f be       	out	0x3f, r0	; 63
    1e1a:	cd bf       	out	0x3d, r28	; 61
    1e1c:	9e 83       	std	Y+6, r25	; 0x06
    1e1e:	8d 83       	std	Y+5, r24	; 0x05
    1e20:	78 87       	std	Y+8, r23	; 0x08
    1e22:	6f 83       	std	Y+7, r22	; 0x07
    EventGroup_t * pxEventBits = xEventGroup;
    1e24:	8d 81       	ldd	r24, Y+5	; 0x05
    1e26:	9e 81       	ldd	r25, Y+6	; 0x06
    1e28:	9c 83       	std	Y+4, r25	; 0x04
    1e2a:	8b 83       	std	Y+3, r24	; 0x03
    /* Check the user is not attempting to clear the bits used by the kernel
     * itself. */
    configASSERT( xEventGroup );
    configASSERT( ( uxBitsToClear & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

    taskENTER_CRITICAL();
    1e2c:	0f b6       	in	r0, 0x3f	; 63
    1e2e:	f8 94       	cli
    1e30:	0f 92       	push	r0
    {
        traceEVENT_GROUP_CLEAR_BITS( xEventGroup, uxBitsToClear );

        /* The value returned is the event group value prior to the bits being
         * cleared. */
        uxReturn = pxEventBits->uxEventBits;
    1e32:	eb 81       	ldd	r30, Y+3	; 0x03
    1e34:	fc 81       	ldd	r31, Y+4	; 0x04
    1e36:	80 81       	ld	r24, Z
    1e38:	91 81       	ldd	r25, Z+1	; 0x01
    1e3a:	9a 83       	std	Y+2, r25	; 0x02
    1e3c:	89 83       	std	Y+1, r24	; 0x01

        /* Clear the bits. */
        pxEventBits->uxEventBits &= ~uxBitsToClear;
    1e3e:	eb 81       	ldd	r30, Y+3	; 0x03
    1e40:	fc 81       	ldd	r31, Y+4	; 0x04
    1e42:	20 81       	ld	r18, Z
    1e44:	31 81       	ldd	r19, Z+1	; 0x01
    1e46:	8f 81       	ldd	r24, Y+7	; 0x07
    1e48:	98 85       	ldd	r25, Y+8	; 0x08
    1e4a:	80 95       	com	r24
    1e4c:	90 95       	com	r25
    1e4e:	82 23       	and	r24, r18
    1e50:	93 23       	and	r25, r19
    1e52:	eb 81       	ldd	r30, Y+3	; 0x03
    1e54:	fc 81       	ldd	r31, Y+4	; 0x04
    1e56:	91 83       	std	Z+1, r25	; 0x01
    1e58:	80 83       	st	Z, r24
    }
    taskEXIT_CRITICAL();
    1e5a:	0f 90       	pop	r0
    1e5c:	0f be       	out	0x3f, r0	; 63

    return uxReturn;
    1e5e:	89 81       	ldd	r24, Y+1	; 0x01
    1e60:	9a 81       	ldd	r25, Y+2	; 0x02
}
    1e62:	28 96       	adiw	r28, 0x08	; 8
    1e64:	0f b6       	in	r0, 0x3f	; 63
    1e66:	f8 94       	cli
    1e68:	de bf       	out	0x3e, r29	; 62
    1e6a:	0f be       	out	0x3f, r0	; 63
    1e6c:	cd bf       	out	0x3d, r28	; 61
    1e6e:	cf 91       	pop	r28
    1e70:	df 91       	pop	r29
    1e72:	08 95       	ret

00001e74 <xEventGroupGetBitsFromISR>:

#endif /* if ( ( configUSE_TRACE_FACILITY == 1 ) && ( INCLUDE_xTimerPendFunctionCall == 1 ) && ( configUSE_TIMERS == 1 ) ) */
/*-----------------------------------------------------------*/

EventBits_t xEventGroupGetBitsFromISR( EventGroupHandle_t xEventGroup )
{
    1e74:	df 93       	push	r29
    1e76:	cf 93       	push	r28
    1e78:	cd b7       	in	r28, 0x3d	; 61
    1e7a:	de b7       	in	r29, 0x3e	; 62
    1e7c:	27 97       	sbiw	r28, 0x07	; 7
    1e7e:	0f b6       	in	r0, 0x3f	; 63
    1e80:	f8 94       	cli
    1e82:	de bf       	out	0x3e, r29	; 62
    1e84:	0f be       	out	0x3f, r0	; 63
    1e86:	cd bf       	out	0x3d, r28	; 61
    1e88:	9f 83       	std	Y+7, r25	; 0x07
    1e8a:	8e 83       	std	Y+6, r24	; 0x06
    UBaseType_t uxSavedInterruptStatus;
    EventGroup_t const * const pxEventBits = xEventGroup;
    1e8c:	8e 81       	ldd	r24, Y+6	; 0x06
    1e8e:	9f 81       	ldd	r25, Y+7	; 0x07
    1e90:	9c 83       	std	Y+4, r25	; 0x04
    1e92:	8b 83       	std	Y+3, r24	; 0x03
    EventBits_t uxReturn;

    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    1e94:	1d 82       	std	Y+5, r1	; 0x05
    {
        uxReturn = pxEventBits->uxEventBits;
    1e96:	eb 81       	ldd	r30, Y+3	; 0x03
    1e98:	fc 81       	ldd	r31, Y+4	; 0x04
    1e9a:	80 81       	ld	r24, Z
    1e9c:	91 81       	ldd	r25, Z+1	; 0x01
    1e9e:	9a 83       	std	Y+2, r25	; 0x02
    1ea0:	89 83       	std	Y+1, r24	; 0x01
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return uxReturn;
    1ea2:	89 81       	ldd	r24, Y+1	; 0x01
    1ea4:	9a 81       	ldd	r25, Y+2	; 0x02
} /*lint !e818 EventGroupHandle_t is a typedef used in other functions to so can't be pointer to const. */
    1ea6:	27 96       	adiw	r28, 0x07	; 7
    1ea8:	0f b6       	in	r0, 0x3f	; 63
    1eaa:	f8 94       	cli
    1eac:	de bf       	out	0x3e, r29	; 62
    1eae:	0f be       	out	0x3f, r0	; 63
    1eb0:	cd bf       	out	0x3d, r28	; 61
    1eb2:	cf 91       	pop	r28
    1eb4:	df 91       	pop	r29
    1eb6:	08 95       	ret

00001eb8 <xEventGroupSetBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup,
                                const EventBits_t uxBitsToSet )
{
    1eb8:	df 93       	push	r29
    1eba:	cf 93       	push	r28
    1ebc:	cd b7       	in	r28, 0x3d	; 61
    1ebe:	de b7       	in	r29, 0x3e	; 62
    1ec0:	65 97       	sbiw	r28, 0x15	; 21
    1ec2:	0f b6       	in	r0, 0x3f	; 63
    1ec4:	f8 94       	cli
    1ec6:	de bf       	out	0x3e, r29	; 62
    1ec8:	0f be       	out	0x3f, r0	; 63
    1eca:	cd bf       	out	0x3d, r28	; 61
    1ecc:	9b 8b       	std	Y+19, r25	; 0x13
    1ece:	8a 8b       	std	Y+18, r24	; 0x12
    1ed0:	7d 8b       	std	Y+21, r23	; 0x15
    1ed2:	6c 8b       	std	Y+20, r22	; 0x14
    ListItem_t * pxListItem, * pxNext;
    ListItem_t const * pxListEnd;
    List_t const * pxList;
    EventBits_t uxBitsToClear = 0, uxBitsWaitedFor, uxControlBits;
    1ed4:	19 86       	std	Y+9, r1	; 0x09
    1ed6:	18 86       	std	Y+8, r1	; 0x08
    EventGroup_t * pxEventBits = xEventGroup;
    1ed8:	8a 89       	ldd	r24, Y+18	; 0x12
    1eda:	9b 89       	ldd	r25, Y+19	; 0x13
    1edc:	9b 83       	std	Y+3, r25	; 0x03
    1ede:	8a 83       	std	Y+2, r24	; 0x02
    BaseType_t xMatchFound = pdFALSE;
    1ee0:	19 82       	std	Y+1, r1	; 0x01
    /* Check the user is not attempting to set the bits used by the kernel
     * itself. */
    configASSERT( xEventGroup );
    configASSERT( ( uxBitsToSet & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

    pxList = &( pxEventBits->xTasksWaitingForBits );
    1ee2:	8a 81       	ldd	r24, Y+2	; 0x02
    1ee4:	9b 81       	ldd	r25, Y+3	; 0x03
    1ee6:	02 96       	adiw	r24, 0x02	; 2
    1ee8:	9b 87       	std	Y+11, r25	; 0x0b
    1eea:	8a 87       	std	Y+10, r24	; 0x0a
    pxListEnd = listGET_END_MARKER( pxList ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1eec:	8a 85       	ldd	r24, Y+10	; 0x0a
    1eee:	9b 85       	ldd	r25, Y+11	; 0x0b
    1ef0:	03 96       	adiw	r24, 0x03	; 3
    1ef2:	9d 87       	std	Y+13, r25	; 0x0d
    1ef4:	8c 87       	std	Y+12, r24	; 0x0c
    vTaskSuspendAll();
    1ef6:	0e 94 88 1e 	call	0x3d10	; 0x3d10 <vTaskSuspendAll>
    {
        traceEVENT_GROUP_SET_BITS( xEventGroup, uxBitsToSet );

        pxListItem = listGET_HEAD_ENTRY( pxList );
    1efa:	ea 85       	ldd	r30, Y+10	; 0x0a
    1efc:	fb 85       	ldd	r31, Y+11	; 0x0b
    1efe:	85 81       	ldd	r24, Z+5	; 0x05
    1f00:	96 81       	ldd	r25, Z+6	; 0x06
    1f02:	99 8b       	std	Y+17, r25	; 0x11
    1f04:	88 8b       	std	Y+16, r24	; 0x10

        /* Set the bits. */
        pxEventBits->uxEventBits |= uxBitsToSet;
    1f06:	ea 81       	ldd	r30, Y+2	; 0x02
    1f08:	fb 81       	ldd	r31, Y+3	; 0x03
    1f0a:	20 81       	ld	r18, Z
    1f0c:	31 81       	ldd	r19, Z+1	; 0x01
    1f0e:	8c 89       	ldd	r24, Y+20	; 0x14
    1f10:	9d 89       	ldd	r25, Y+21	; 0x15
    1f12:	82 2b       	or	r24, r18
    1f14:	93 2b       	or	r25, r19
    1f16:	ea 81       	ldd	r30, Y+2	; 0x02
    1f18:	fb 81       	ldd	r31, Y+3	; 0x03
    1f1a:	91 83       	std	Z+1, r25	; 0x01
    1f1c:	80 83       	st	Z, r24
    1f1e:	59 c0       	rjmp	.+178    	; 0x1fd2 <xEventGroupSetBits+0x11a>

        /* See if the new bit value should unblock any tasks. */
        while( pxListItem != pxListEnd )
        {
            pxNext = listGET_NEXT( pxListItem );
    1f20:	e8 89       	ldd	r30, Y+16	; 0x10
    1f22:	f9 89       	ldd	r31, Y+17	; 0x11
    1f24:	82 81       	ldd	r24, Z+2	; 0x02
    1f26:	93 81       	ldd	r25, Z+3	; 0x03
    1f28:	9f 87       	std	Y+15, r25	; 0x0f
    1f2a:	8e 87       	std	Y+14, r24	; 0x0e
            uxBitsWaitedFor = listGET_LIST_ITEM_VALUE( pxListItem );
    1f2c:	e8 89       	ldd	r30, Y+16	; 0x10
    1f2e:	f9 89       	ldd	r31, Y+17	; 0x11
    1f30:	80 81       	ld	r24, Z
    1f32:	91 81       	ldd	r25, Z+1	; 0x01
    1f34:	9f 83       	std	Y+7, r25	; 0x07
    1f36:	8e 83       	std	Y+6, r24	; 0x06
            xMatchFound = pdFALSE;
    1f38:	19 82       	std	Y+1, r1	; 0x01

            /* Split the bits waited for from the control bits. */
            uxControlBits = uxBitsWaitedFor & eventEVENT_BITS_CONTROL_BYTES;
    1f3a:	8e 81       	ldd	r24, Y+6	; 0x06
    1f3c:	9f 81       	ldd	r25, Y+7	; 0x07
    1f3e:	80 70       	andi	r24, 0x00	; 0
    1f40:	9d 83       	std	Y+5, r25	; 0x05
    1f42:	8c 83       	std	Y+4, r24	; 0x04
            uxBitsWaitedFor &= ~eventEVENT_BITS_CONTROL_BYTES;
    1f44:	8e 81       	ldd	r24, Y+6	; 0x06
    1f46:	9f 81       	ldd	r25, Y+7	; 0x07
    1f48:	90 70       	andi	r25, 0x00	; 0
    1f4a:	9f 83       	std	Y+7, r25	; 0x07
    1f4c:	8e 83       	std	Y+6, r24	; 0x06

            if( ( uxControlBits & eventWAIT_FOR_ALL_BITS ) == ( EventBits_t ) 0 )
    1f4e:	8c 81       	ldd	r24, Y+4	; 0x04
    1f50:	9d 81       	ldd	r25, Y+5	; 0x05
    1f52:	80 70       	andi	r24, 0x00	; 0
    1f54:	94 70       	andi	r25, 0x04	; 4
    1f56:	00 97       	sbiw	r24, 0x00	; 0
    1f58:	69 f4       	brne	.+26     	; 0x1f74 <xEventGroupSetBits+0xbc>
            {
                /* Just looking for single bit being set. */
                if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) != ( EventBits_t ) 0 )
    1f5a:	ea 81       	ldd	r30, Y+2	; 0x02
    1f5c:	fb 81       	ldd	r31, Y+3	; 0x03
    1f5e:	20 81       	ld	r18, Z
    1f60:	31 81       	ldd	r19, Z+1	; 0x01
    1f62:	8e 81       	ldd	r24, Y+6	; 0x06
    1f64:	9f 81       	ldd	r25, Y+7	; 0x07
    1f66:	82 23       	and	r24, r18
    1f68:	93 23       	and	r25, r19
    1f6a:	00 97       	sbiw	r24, 0x00	; 0
    1f6c:	91 f0       	breq	.+36     	; 0x1f92 <xEventGroupSetBits+0xda>
                {
                    xMatchFound = pdTRUE;
    1f6e:	81 e0       	ldi	r24, 0x01	; 1
    1f70:	89 83       	std	Y+1, r24	; 0x01
    1f72:	0f c0       	rjmp	.+30     	; 0x1f92 <xEventGroupSetBits+0xda>
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }
            }
            else if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) == uxBitsWaitedFor )
    1f74:	ea 81       	ldd	r30, Y+2	; 0x02
    1f76:	fb 81       	ldd	r31, Y+3	; 0x03
    1f78:	20 81       	ld	r18, Z
    1f7a:	31 81       	ldd	r19, Z+1	; 0x01
    1f7c:	8e 81       	ldd	r24, Y+6	; 0x06
    1f7e:	9f 81       	ldd	r25, Y+7	; 0x07
    1f80:	28 23       	and	r18, r24
    1f82:	39 23       	and	r19, r25
    1f84:	8e 81       	ldd	r24, Y+6	; 0x06
    1f86:	9f 81       	ldd	r25, Y+7	; 0x07
    1f88:	28 17       	cp	r18, r24
    1f8a:	39 07       	cpc	r19, r25
    1f8c:	11 f4       	brne	.+4      	; 0x1f92 <xEventGroupSetBits+0xda>
            {
                /* All bits are set. */
                xMatchFound = pdTRUE;
    1f8e:	81 e0       	ldi	r24, 0x01	; 1
    1f90:	89 83       	std	Y+1, r24	; 0x01
            else
            {
                /* Need all bits to be set, but not all the bits were set. */
            }

            if( xMatchFound != pdFALSE )
    1f92:	89 81       	ldd	r24, Y+1	; 0x01
    1f94:	88 23       	and	r24, r24
    1f96:	c9 f0       	breq	.+50     	; 0x1fca <xEventGroupSetBits+0x112>
            {
                /* The bits match.  Should the bits be cleared on exit? */
                if( ( uxControlBits & eventCLEAR_EVENTS_ON_EXIT_BIT ) != ( EventBits_t ) 0 )
    1f98:	8c 81       	ldd	r24, Y+4	; 0x04
    1f9a:	9d 81       	ldd	r25, Y+5	; 0x05
    1f9c:	80 70       	andi	r24, 0x00	; 0
    1f9e:	91 70       	andi	r25, 0x01	; 1
    1fa0:	00 97       	sbiw	r24, 0x00	; 0
    1fa2:	41 f0       	breq	.+16     	; 0x1fb4 <xEventGroupSetBits+0xfc>
                {
                    uxBitsToClear |= uxBitsWaitedFor;
    1fa4:	88 85       	ldd	r24, Y+8	; 0x08
    1fa6:	99 85       	ldd	r25, Y+9	; 0x09
    1fa8:	2e 81       	ldd	r18, Y+6	; 0x06
    1faa:	3f 81       	ldd	r19, Y+7	; 0x07
    1fac:	82 2b       	or	r24, r18
    1fae:	93 2b       	or	r25, r19
    1fb0:	99 87       	std	Y+9, r25	; 0x09
    1fb2:	88 87       	std	Y+8, r24	; 0x08
                /* Store the actual event flag value in the task's event list
                 * item before removing the task from the event list.  The
                 * eventUNBLOCKED_DUE_TO_BIT_SET bit is set so the task knows
                 * that is was unblocked due to its required bits matching, rather
                 * than because it timed out. */
                vTaskRemoveFromUnorderedEventList( pxListItem, pxEventBits->uxEventBits | eventUNBLOCKED_DUE_TO_BIT_SET );
    1fb4:	ea 81       	ldd	r30, Y+2	; 0x02
    1fb6:	fb 81       	ldd	r31, Y+3	; 0x03
    1fb8:	80 81       	ld	r24, Z
    1fba:	91 81       	ldd	r25, Z+1	; 0x01
    1fbc:	9c 01       	movw	r18, r24
    1fbe:	32 60       	ori	r19, 0x02	; 2
    1fc0:	88 89       	ldd	r24, Y+16	; 0x10
    1fc2:	99 89       	ldd	r25, Y+17	; 0x11
    1fc4:	b9 01       	movw	r22, r18
    1fc6:	0e 94 92 24 	call	0x4924	; 0x4924 <vTaskRemoveFromUnorderedEventList>
            }

            /* Move onto the next list item.  Note pxListItem->pxNext is not
             * used here as the list item may have been removed from the event list
             * and inserted into the ready/pending reading list. */
            pxListItem = pxNext;
    1fca:	8e 85       	ldd	r24, Y+14	; 0x0e
    1fcc:	9f 85       	ldd	r25, Y+15	; 0x0f
    1fce:	99 8b       	std	Y+17, r25	; 0x11
    1fd0:	88 8b       	std	Y+16, r24	; 0x10

        /* Set the bits. */
        pxEventBits->uxEventBits |= uxBitsToSet;

        /* See if the new bit value should unblock any tasks. */
        while( pxListItem != pxListEnd )
    1fd2:	28 89       	ldd	r18, Y+16	; 0x10
    1fd4:	39 89       	ldd	r19, Y+17	; 0x11
    1fd6:	8c 85       	ldd	r24, Y+12	; 0x0c
    1fd8:	9d 85       	ldd	r25, Y+13	; 0x0d
    1fda:	28 17       	cp	r18, r24
    1fdc:	39 07       	cpc	r19, r25
    1fde:	09 f0       	breq	.+2      	; 0x1fe2 <xEventGroupSetBits+0x12a>
    1fe0:	9f cf       	rjmp	.-194    	; 0x1f20 <xEventGroupSetBits+0x68>
            pxListItem = pxNext;
        }

        /* Clear any bits that matched when the eventCLEAR_EVENTS_ON_EXIT_BIT
         * bit was set in the control word. */
        pxEventBits->uxEventBits &= ~uxBitsToClear;
    1fe2:	ea 81       	ldd	r30, Y+2	; 0x02
    1fe4:	fb 81       	ldd	r31, Y+3	; 0x03
    1fe6:	20 81       	ld	r18, Z
    1fe8:	31 81       	ldd	r19, Z+1	; 0x01
    1fea:	88 85       	ldd	r24, Y+8	; 0x08
    1fec:	99 85       	ldd	r25, Y+9	; 0x09
    1fee:	80 95       	com	r24
    1ff0:	90 95       	com	r25
    1ff2:	82 23       	and	r24, r18
    1ff4:	93 23       	and	r25, r19
    1ff6:	ea 81       	ldd	r30, Y+2	; 0x02
    1ff8:	fb 81       	ldd	r31, Y+3	; 0x03
    1ffa:	91 83       	std	Z+1, r25	; 0x01
    1ffc:	80 83       	st	Z, r24
    }
    ( void ) xTaskResumeAll();
    1ffe:	0e 94 94 1e 	call	0x3d28	; 0x3d28 <xTaskResumeAll>

    return pxEventBits->uxEventBits;
    2002:	ea 81       	ldd	r30, Y+2	; 0x02
    2004:	fb 81       	ldd	r31, Y+3	; 0x03
    2006:	80 81       	ld	r24, Z
    2008:	91 81       	ldd	r25, Z+1	; 0x01
}
    200a:	65 96       	adiw	r28, 0x15	; 21
    200c:	0f b6       	in	r0, 0x3f	; 63
    200e:	f8 94       	cli
    2010:	de bf       	out	0x3e, r29	; 62
    2012:	0f be       	out	0x3f, r0	; 63
    2014:	cd bf       	out	0x3d, r28	; 61
    2016:	cf 91       	pop	r28
    2018:	df 91       	pop	r29
    201a:	08 95       	ret

0000201c <vEventGroupDelete>:
/*-----------------------------------------------------------*/

void vEventGroupDelete( EventGroupHandle_t xEventGroup )
{
    201c:	df 93       	push	r29
    201e:	cf 93       	push	r28
    2020:	00 d0       	rcall	.+0      	; 0x2022 <vEventGroupDelete+0x6>
    2022:	00 d0       	rcall	.+0      	; 0x2024 <vEventGroupDelete+0x8>
    2024:	00 d0       	rcall	.+0      	; 0x2026 <vEventGroupDelete+0xa>
    2026:	cd b7       	in	r28, 0x3d	; 61
    2028:	de b7       	in	r29, 0x3e	; 62
    202a:	9e 83       	std	Y+6, r25	; 0x06
    202c:	8d 83       	std	Y+5, r24	; 0x05
    EventGroup_t * pxEventBits = xEventGroup;
    202e:	8d 81       	ldd	r24, Y+5	; 0x05
    2030:	9e 81       	ldd	r25, Y+6	; 0x06
    2032:	9c 83       	std	Y+4, r25	; 0x04
    2034:	8b 83       	std	Y+3, r24	; 0x03
    const List_t * pxTasksWaitingForBits;

    configASSERT( pxEventBits );

    pxTasksWaitingForBits = &( pxEventBits->xTasksWaitingForBits );
    2036:	8b 81       	ldd	r24, Y+3	; 0x03
    2038:	9c 81       	ldd	r25, Y+4	; 0x04
    203a:	02 96       	adiw	r24, 0x02	; 2
    203c:	9a 83       	std	Y+2, r25	; 0x02
    203e:	89 83       	std	Y+1, r24	; 0x01

    vTaskSuspendAll();
    2040:	0e 94 88 1e 	call	0x3d10	; 0x3d10 <vTaskSuspendAll>
    2044:	08 c0       	rjmp	.+16     	; 0x2056 <vEventGroupDelete+0x3a>
        while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
        {
            /* Unblock the task, returning 0 as the event list is being deleted
             * and cannot therefore have any bits set. */
            configASSERT( pxTasksWaitingForBits->xListEnd.pxNext != ( const ListItem_t * ) &( pxTasksWaitingForBits->xListEnd ) );
            vTaskRemoveFromUnorderedEventList( pxTasksWaitingForBits->xListEnd.pxNext, eventUNBLOCKED_DUE_TO_BIT_SET );
    2046:	e9 81       	ldd	r30, Y+1	; 0x01
    2048:	fa 81       	ldd	r31, Y+2	; 0x02
    204a:	85 81       	ldd	r24, Z+5	; 0x05
    204c:	96 81       	ldd	r25, Z+6	; 0x06
    204e:	60 e0       	ldi	r22, 0x00	; 0
    2050:	72 e0       	ldi	r23, 0x02	; 2
    2052:	0e 94 92 24 	call	0x4924	; 0x4924 <vTaskRemoveFromUnorderedEventList>

    vTaskSuspendAll();
    {
        traceEVENT_GROUP_DELETE( xEventGroup );

        while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
    2056:	e9 81       	ldd	r30, Y+1	; 0x01
    2058:	fa 81       	ldd	r31, Y+2	; 0x02
    205a:	80 81       	ld	r24, Z
    205c:	88 23       	and	r24, r24
    205e:	99 f7       	brne	.-26     	; 0x2046 <vEventGroupDelete+0x2a>

        #if ( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
            {
                /* The event group can only have been allocated dynamically - free
                 * it again. */
                vPortFree( pxEventBits );
    2060:	8b 81       	ldd	r24, Y+3	; 0x03
    2062:	9c 81       	ldd	r25, Y+4	; 0x04
    2064:	0e 94 8d 07 	call	0xf1a	; 0xf1a <vPortFree>
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        #endif /* configSUPPORT_DYNAMIC_ALLOCATION */
    }
    ( void ) xTaskResumeAll();
    2068:	0e 94 94 1e 	call	0x3d28	; 0x3d28 <xTaskResumeAll>
}
    206c:	26 96       	adiw	r28, 0x06	; 6
    206e:	0f b6       	in	r0, 0x3f	; 63
    2070:	f8 94       	cli
    2072:	de bf       	out	0x3e, r29	; 62
    2074:	0f be       	out	0x3f, r0	; 63
    2076:	cd bf       	out	0x3d, r28	; 61
    2078:	cf 91       	pop	r28
    207a:	df 91       	pop	r29
    207c:	08 95       	ret

0000207e <vEventGroupSetBitsCallback>:

/* For internal use only - execute a 'set bits' command that was pended from
 * an interrupt. */
void vEventGroupSetBitsCallback( void * pvEventGroup,
                                 const uint32_t ulBitsToSet )
{
    207e:	df 93       	push	r29
    2080:	cf 93       	push	r28
    2082:	00 d0       	rcall	.+0      	; 0x2084 <vEventGroupSetBitsCallback+0x6>
    2084:	00 d0       	rcall	.+0      	; 0x2086 <vEventGroupSetBitsCallback+0x8>
    2086:	00 d0       	rcall	.+0      	; 0x2088 <vEventGroupSetBitsCallback+0xa>
    2088:	cd b7       	in	r28, 0x3d	; 61
    208a:	de b7       	in	r29, 0x3e	; 62
    208c:	9a 83       	std	Y+2, r25	; 0x02
    208e:	89 83       	std	Y+1, r24	; 0x01
    2090:	4b 83       	std	Y+3, r20	; 0x03
    2092:	5c 83       	std	Y+4, r21	; 0x04
    2094:	6d 83       	std	Y+5, r22	; 0x05
    2096:	7e 83       	std	Y+6, r23	; 0x06
    ( void ) xEventGroupSetBits( pvEventGroup, ( EventBits_t ) ulBitsToSet ); /*lint !e9079 Can't avoid cast to void* as a generic timer callback prototype. Callback casts back to original type so safe. */
    2098:	89 81       	ldd	r24, Y+1	; 0x01
    209a:	9a 81       	ldd	r25, Y+2	; 0x02
    209c:	2b 81       	ldd	r18, Y+3	; 0x03
    209e:	3c 81       	ldd	r19, Y+4	; 0x04
    20a0:	b9 01       	movw	r22, r18
    20a2:	0e 94 5c 0f 	call	0x1eb8	; 0x1eb8 <xEventGroupSetBits>
}
    20a6:	26 96       	adiw	r28, 0x06	; 6
    20a8:	0f b6       	in	r0, 0x3f	; 63
    20aa:	f8 94       	cli
    20ac:	de bf       	out	0x3e, r29	; 62
    20ae:	0f be       	out	0x3f, r0	; 63
    20b0:	cd bf       	out	0x3d, r28	; 61
    20b2:	cf 91       	pop	r28
    20b4:	df 91       	pop	r29
    20b6:	08 95       	ret

000020b8 <vEventGroupClearBitsCallback>:

/* For internal use only - execute a 'clear bits' command that was pended from
 * an interrupt. */
void vEventGroupClearBitsCallback( void * pvEventGroup,
                                   const uint32_t ulBitsToClear )
{
    20b8:	df 93       	push	r29
    20ba:	cf 93       	push	r28
    20bc:	00 d0       	rcall	.+0      	; 0x20be <vEventGroupClearBitsCallback+0x6>
    20be:	00 d0       	rcall	.+0      	; 0x20c0 <vEventGroupClearBitsCallback+0x8>
    20c0:	00 d0       	rcall	.+0      	; 0x20c2 <vEventGroupClearBitsCallback+0xa>
    20c2:	cd b7       	in	r28, 0x3d	; 61
    20c4:	de b7       	in	r29, 0x3e	; 62
    20c6:	9a 83       	std	Y+2, r25	; 0x02
    20c8:	89 83       	std	Y+1, r24	; 0x01
    20ca:	4b 83       	std	Y+3, r20	; 0x03
    20cc:	5c 83       	std	Y+4, r21	; 0x04
    20ce:	6d 83       	std	Y+5, r22	; 0x05
    20d0:	7e 83       	std	Y+6, r23	; 0x06
    ( void ) xEventGroupClearBits( pvEventGroup, ( EventBits_t ) ulBitsToClear ); /*lint !e9079 Can't avoid cast to void* as a generic timer callback prototype. Callback casts back to original type so safe. */
    20d2:	89 81       	ldd	r24, Y+1	; 0x01
    20d4:	9a 81       	ldd	r25, Y+2	; 0x02
    20d6:	2b 81       	ldd	r18, Y+3	; 0x03
    20d8:	3c 81       	ldd	r19, Y+4	; 0x04
    20da:	b9 01       	movw	r22, r18
    20dc:	0e 94 04 0f 	call	0x1e08	; 0x1e08 <xEventGroupClearBits>
}
    20e0:	26 96       	adiw	r28, 0x06	; 6
    20e2:	0f b6       	in	r0, 0x3f	; 63
    20e4:	f8 94       	cli
    20e6:	de bf       	out	0x3e, r29	; 62
    20e8:	0f be       	out	0x3f, r0	; 63
    20ea:	cd bf       	out	0x3d, r28	; 61
    20ec:	cf 91       	pop	r28
    20ee:	df 91       	pop	r29
    20f0:	08 95       	ret

000020f2 <prvTestWaitCondition>:
/*-----------------------------------------------------------*/

static BaseType_t prvTestWaitCondition( const EventBits_t uxCurrentEventBits,
                                        const EventBits_t uxBitsToWaitFor,
                                        const BaseType_t xWaitForAllBits )
{
    20f2:	df 93       	push	r29
    20f4:	cf 93       	push	r28
    20f6:	00 d0       	rcall	.+0      	; 0x20f8 <prvTestWaitCondition+0x6>
    20f8:	00 d0       	rcall	.+0      	; 0x20fa <prvTestWaitCondition+0x8>
    20fa:	00 d0       	rcall	.+0      	; 0x20fc <prvTestWaitCondition+0xa>
    20fc:	cd b7       	in	r28, 0x3d	; 61
    20fe:	de b7       	in	r29, 0x3e	; 62
    2100:	9b 83       	std	Y+3, r25	; 0x03
    2102:	8a 83       	std	Y+2, r24	; 0x02
    2104:	7d 83       	std	Y+5, r23	; 0x05
    2106:	6c 83       	std	Y+4, r22	; 0x04
    2108:	4e 83       	std	Y+6, r20	; 0x06
    BaseType_t xWaitConditionMet = pdFALSE;
    210a:	19 82       	std	Y+1, r1	; 0x01

    if( xWaitForAllBits == pdFALSE )
    210c:	8e 81       	ldd	r24, Y+6	; 0x06
    210e:	88 23       	and	r24, r24
    2110:	59 f4       	brne	.+22     	; 0x2128 <prvTestWaitCondition+0x36>
    {
        /* Task only has to wait for one bit within uxBitsToWaitFor to be
         * set.  Is one already set? */
        if( ( uxCurrentEventBits & uxBitsToWaitFor ) != ( EventBits_t ) 0 )
    2112:	8a 81       	ldd	r24, Y+2	; 0x02
    2114:	9b 81       	ldd	r25, Y+3	; 0x03
    2116:	2c 81       	ldd	r18, Y+4	; 0x04
    2118:	3d 81       	ldd	r19, Y+5	; 0x05
    211a:	82 23       	and	r24, r18
    211c:	93 23       	and	r25, r19
    211e:	00 97       	sbiw	r24, 0x00	; 0
    2120:	81 f0       	breq	.+32     	; 0x2142 <prvTestWaitCondition+0x50>
        {
            xWaitConditionMet = pdTRUE;
    2122:	81 e0       	ldi	r24, 0x01	; 1
    2124:	89 83       	std	Y+1, r24	; 0x01
    2126:	0d c0       	rjmp	.+26     	; 0x2142 <prvTestWaitCondition+0x50>
    }
    else
    {
        /* Task has to wait for all the bits in uxBitsToWaitFor to be set.
         * Are they set already? */
        if( ( uxCurrentEventBits & uxBitsToWaitFor ) == uxBitsToWaitFor )
    2128:	2a 81       	ldd	r18, Y+2	; 0x02
    212a:	3b 81       	ldd	r19, Y+3	; 0x03
    212c:	8c 81       	ldd	r24, Y+4	; 0x04
    212e:	9d 81       	ldd	r25, Y+5	; 0x05
    2130:	28 23       	and	r18, r24
    2132:	39 23       	and	r19, r25
    2134:	8c 81       	ldd	r24, Y+4	; 0x04
    2136:	9d 81       	ldd	r25, Y+5	; 0x05
    2138:	28 17       	cp	r18, r24
    213a:	39 07       	cpc	r19, r25
    213c:	11 f4       	brne	.+4      	; 0x2142 <prvTestWaitCondition+0x50>
        {
            xWaitConditionMet = pdTRUE;
    213e:	81 e0       	ldi	r24, 0x01	; 1
    2140:	89 83       	std	Y+1, r24	; 0x01
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }

    return xWaitConditionMet;
    2142:	89 81       	ldd	r24, Y+1	; 0x01
}
    2144:	26 96       	adiw	r28, 0x06	; 6
    2146:	0f b6       	in	r0, 0x3f	; 63
    2148:	f8 94       	cli
    214a:	de bf       	out	0x3e, r29	; 62
    214c:	0f be       	out	0x3f, r0	; 63
    214e:	cd bf       	out	0x3d, r28	; 61
    2150:	cf 91       	pop	r28
    2152:	df 91       	pop	r29
    2154:	08 95       	ret

00002156 <vListInitialise>:
/*-----------------------------------------------------------
* PUBLIC LIST API documented in list.h
*----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
    2156:	df 93       	push	r29
    2158:	cf 93       	push	r28
    215a:	00 d0       	rcall	.+0      	; 0x215c <vListInitialise+0x6>
    215c:	cd b7       	in	r28, 0x3d	; 61
    215e:	de b7       	in	r29, 0x3e	; 62
    2160:	9a 83       	std	Y+2, r25	; 0x02
    2162:	89 83       	std	Y+1, r24	; 0x01
    /* The list structure contains a list item which is used to mark the
     * end of the list.  To initialise the list the list end is inserted
     * as the only list entry. */
    pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    2164:	89 81       	ldd	r24, Y+1	; 0x01
    2166:	9a 81       	ldd	r25, Y+2	; 0x02
    2168:	03 96       	adiw	r24, 0x03	; 3
    216a:	e9 81       	ldd	r30, Y+1	; 0x01
    216c:	fa 81       	ldd	r31, Y+2	; 0x02
    216e:	92 83       	std	Z+2, r25	; 0x02
    2170:	81 83       	std	Z+1, r24	; 0x01

    /* The list end value is the highest possible value in the list to
     * ensure it remains at the end of the list. */
    pxList->xListEnd.xItemValue = portMAX_DELAY;
    2172:	e9 81       	ldd	r30, Y+1	; 0x01
    2174:	fa 81       	ldd	r31, Y+2	; 0x02
    2176:	8f ef       	ldi	r24, 0xFF	; 255
    2178:	9f ef       	ldi	r25, 0xFF	; 255
    217a:	94 83       	std	Z+4, r25	; 0x04
    217c:	83 83       	std	Z+3, r24	; 0x03

    /* The list end next and previous pointers point to itself so we know
     * when the list is empty. */
    pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );     /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    217e:	89 81       	ldd	r24, Y+1	; 0x01
    2180:	9a 81       	ldd	r25, Y+2	; 0x02
    2182:	03 96       	adiw	r24, 0x03	; 3
    2184:	e9 81       	ldd	r30, Y+1	; 0x01
    2186:	fa 81       	ldd	r31, Y+2	; 0x02
    2188:	96 83       	std	Z+6, r25	; 0x06
    218a:	85 83       	std	Z+5, r24	; 0x05
    pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    218c:	89 81       	ldd	r24, Y+1	; 0x01
    218e:	9a 81       	ldd	r25, Y+2	; 0x02
    2190:	03 96       	adiw	r24, 0x03	; 3
    2192:	e9 81       	ldd	r30, Y+1	; 0x01
    2194:	fa 81       	ldd	r31, Y+2	; 0x02
    2196:	90 87       	std	Z+8, r25	; 0x08
    2198:	87 83       	std	Z+7, r24	; 0x07

    pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    219a:	e9 81       	ldd	r30, Y+1	; 0x01
    219c:	fa 81       	ldd	r31, Y+2	; 0x02
    219e:	10 82       	st	Z, r1

    /* Write known values into the list if
     * configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
    listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
    listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
    21a0:	0f 90       	pop	r0
    21a2:	0f 90       	pop	r0
    21a4:	cf 91       	pop	r28
    21a6:	df 91       	pop	r29
    21a8:	08 95       	ret

000021aa <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
    21aa:	df 93       	push	r29
    21ac:	cf 93       	push	r28
    21ae:	00 d0       	rcall	.+0      	; 0x21b0 <vListInitialiseItem+0x6>
    21b0:	cd b7       	in	r28, 0x3d	; 61
    21b2:	de b7       	in	r29, 0x3e	; 62
    21b4:	9a 83       	std	Y+2, r25	; 0x02
    21b6:	89 83       	std	Y+1, r24	; 0x01
    /* Make sure the list item is not recorded as being on a list. */
    pxItem->pxContainer = NULL;
    21b8:	e9 81       	ldd	r30, Y+1	; 0x01
    21ba:	fa 81       	ldd	r31, Y+2	; 0x02
    21bc:	11 86       	std	Z+9, r1	; 0x09
    21be:	10 86       	std	Z+8, r1	; 0x08

    /* Write known values into the list item if
     * configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
    listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
    listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
    21c0:	0f 90       	pop	r0
    21c2:	0f 90       	pop	r0
    21c4:	cf 91       	pop	r28
    21c6:	df 91       	pop	r29
    21c8:	08 95       	ret

000021ca <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList,
                     ListItem_t * const pxNewListItem )
{
    21ca:	df 93       	push	r29
    21cc:	cf 93       	push	r28
    21ce:	00 d0       	rcall	.+0      	; 0x21d0 <vListInsertEnd+0x6>
    21d0:	00 d0       	rcall	.+0      	; 0x21d2 <vListInsertEnd+0x8>
    21d2:	00 d0       	rcall	.+0      	; 0x21d4 <vListInsertEnd+0xa>
    21d4:	cd b7       	in	r28, 0x3d	; 61
    21d6:	de b7       	in	r29, 0x3e	; 62
    21d8:	9c 83       	std	Y+4, r25	; 0x04
    21da:	8b 83       	std	Y+3, r24	; 0x03
    21dc:	7e 83       	std	Y+6, r23	; 0x06
    21de:	6d 83       	std	Y+5, r22	; 0x05
    ListItem_t * const pxIndex = pxList->pxIndex;
    21e0:	eb 81       	ldd	r30, Y+3	; 0x03
    21e2:	fc 81       	ldd	r31, Y+4	; 0x04
    21e4:	81 81       	ldd	r24, Z+1	; 0x01
    21e6:	92 81       	ldd	r25, Z+2	; 0x02
    21e8:	9a 83       	std	Y+2, r25	; 0x02
    21ea:	89 83       	std	Y+1, r24	; 0x01
    listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

    /* Insert a new list item into pxList, but rather than sort the list,
     * makes the new list item the last item to be removed by a call to
     * listGET_OWNER_OF_NEXT_ENTRY(). */
    pxNewListItem->pxNext = pxIndex;
    21ec:	ed 81       	ldd	r30, Y+5	; 0x05
    21ee:	fe 81       	ldd	r31, Y+6	; 0x06
    21f0:	89 81       	ldd	r24, Y+1	; 0x01
    21f2:	9a 81       	ldd	r25, Y+2	; 0x02
    21f4:	93 83       	std	Z+3, r25	; 0x03
    21f6:	82 83       	std	Z+2, r24	; 0x02
    pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    21f8:	e9 81       	ldd	r30, Y+1	; 0x01
    21fa:	fa 81       	ldd	r31, Y+2	; 0x02
    21fc:	84 81       	ldd	r24, Z+4	; 0x04
    21fe:	95 81       	ldd	r25, Z+5	; 0x05
    2200:	ed 81       	ldd	r30, Y+5	; 0x05
    2202:	fe 81       	ldd	r31, Y+6	; 0x06
    2204:	95 83       	std	Z+5, r25	; 0x05
    2206:	84 83       	std	Z+4, r24	; 0x04

    /* Only used during decision coverage testing. */
    mtCOVERAGE_TEST_DELAY();

    pxIndex->pxPrevious->pxNext = pxNewListItem;
    2208:	e9 81       	ldd	r30, Y+1	; 0x01
    220a:	fa 81       	ldd	r31, Y+2	; 0x02
    220c:	04 80       	ldd	r0, Z+4	; 0x04
    220e:	f5 81       	ldd	r31, Z+5	; 0x05
    2210:	e0 2d       	mov	r30, r0
    2212:	8d 81       	ldd	r24, Y+5	; 0x05
    2214:	9e 81       	ldd	r25, Y+6	; 0x06
    2216:	93 83       	std	Z+3, r25	; 0x03
    2218:	82 83       	std	Z+2, r24	; 0x02
    pxIndex->pxPrevious = pxNewListItem;
    221a:	e9 81       	ldd	r30, Y+1	; 0x01
    221c:	fa 81       	ldd	r31, Y+2	; 0x02
    221e:	8d 81       	ldd	r24, Y+5	; 0x05
    2220:	9e 81       	ldd	r25, Y+6	; 0x06
    2222:	95 83       	std	Z+5, r25	; 0x05
    2224:	84 83       	std	Z+4, r24	; 0x04

    /* Remember which list the item is in. */
    pxNewListItem->pxContainer = pxList;
    2226:	ed 81       	ldd	r30, Y+5	; 0x05
    2228:	fe 81       	ldd	r31, Y+6	; 0x06
    222a:	8b 81       	ldd	r24, Y+3	; 0x03
    222c:	9c 81       	ldd	r25, Y+4	; 0x04
    222e:	91 87       	std	Z+9, r25	; 0x09
    2230:	80 87       	std	Z+8, r24	; 0x08

    ( pxList->uxNumberOfItems )++;
    2232:	eb 81       	ldd	r30, Y+3	; 0x03
    2234:	fc 81       	ldd	r31, Y+4	; 0x04
    2236:	80 81       	ld	r24, Z
    2238:	8f 5f       	subi	r24, 0xFF	; 255
    223a:	eb 81       	ldd	r30, Y+3	; 0x03
    223c:	fc 81       	ldd	r31, Y+4	; 0x04
    223e:	80 83       	st	Z, r24
}
    2240:	26 96       	adiw	r28, 0x06	; 6
    2242:	0f b6       	in	r0, 0x3f	; 63
    2244:	f8 94       	cli
    2246:	de bf       	out	0x3e, r29	; 62
    2248:	0f be       	out	0x3f, r0	; 63
    224a:	cd bf       	out	0x3d, r28	; 61
    224c:	cf 91       	pop	r28
    224e:	df 91       	pop	r29
    2250:	08 95       	ret

00002252 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList,
                  ListItem_t * const pxNewListItem )
{
    2252:	df 93       	push	r29
    2254:	cf 93       	push	r28
    2256:	cd b7       	in	r28, 0x3d	; 61
    2258:	de b7       	in	r29, 0x3e	; 62
    225a:	28 97       	sbiw	r28, 0x08	; 8
    225c:	0f b6       	in	r0, 0x3f	; 63
    225e:	f8 94       	cli
    2260:	de bf       	out	0x3e, r29	; 62
    2262:	0f be       	out	0x3f, r0	; 63
    2264:	cd bf       	out	0x3d, r28	; 61
    2266:	9e 83       	std	Y+6, r25	; 0x06
    2268:	8d 83       	std	Y+5, r24	; 0x05
    226a:	78 87       	std	Y+8, r23	; 0x08
    226c:	6f 83       	std	Y+7, r22	; 0x07
    ListItem_t * pxIterator;
    const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    226e:	ef 81       	ldd	r30, Y+7	; 0x07
    2270:	f8 85       	ldd	r31, Y+8	; 0x08
    2272:	80 81       	ld	r24, Z
    2274:	91 81       	ldd	r25, Z+1	; 0x01
    2276:	9a 83       	std	Y+2, r25	; 0x02
    2278:	89 83       	std	Y+1, r24	; 0x01
     * new list item should be placed after it.  This ensures that TCBs which are
     * stored in ready lists (all of which have the same xItemValue value) get a
     * share of the CPU.  However, if the xItemValue is the same as the back marker
     * the iteration loop below will not end.  Therefore the value is checked
     * first, and the algorithm slightly modified if necessary. */
    if( xValueOfInsertion == portMAX_DELAY )
    227a:	89 81       	ldd	r24, Y+1	; 0x01
    227c:	9a 81       	ldd	r25, Y+2	; 0x02
    227e:	2f ef       	ldi	r18, 0xFF	; 255
    2280:	8f 3f       	cpi	r24, 0xFF	; 255
    2282:	92 07       	cpc	r25, r18
    2284:	39 f4       	brne	.+14     	; 0x2294 <vListInsert+0x42>
    {
        pxIterator = pxList->xListEnd.pxPrevious;
    2286:	ed 81       	ldd	r30, Y+5	; 0x05
    2288:	fe 81       	ldd	r31, Y+6	; 0x06
    228a:	87 81       	ldd	r24, Z+7	; 0x07
    228c:	90 85       	ldd	r25, Z+8	; 0x08
    228e:	9c 83       	std	Y+4, r25	; 0x04
    2290:	8b 83       	std	Y+3, r24	; 0x03
    2292:	18 c0       	rjmp	.+48     	; 0x22c4 <vListInsert+0x72>
        *   5) If the FreeRTOS port supports interrupt nesting then ensure that
        *      the priority of the tick interrupt is at or below
        *      configMAX_SYSCALL_INTERRUPT_PRIORITY.
        **********************************************************************/

        for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
    2294:	8d 81       	ldd	r24, Y+5	; 0x05
    2296:	9e 81       	ldd	r25, Y+6	; 0x06
    2298:	03 96       	adiw	r24, 0x03	; 3
    229a:	9c 83       	std	Y+4, r25	; 0x04
    229c:	8b 83       	std	Y+3, r24	; 0x03
    229e:	06 c0       	rjmp	.+12     	; 0x22ac <vListInsert+0x5a>
    22a0:	eb 81       	ldd	r30, Y+3	; 0x03
    22a2:	fc 81       	ldd	r31, Y+4	; 0x04
    22a4:	82 81       	ldd	r24, Z+2	; 0x02
    22a6:	93 81       	ldd	r25, Z+3	; 0x03
    22a8:	9c 83       	std	Y+4, r25	; 0x04
    22aa:	8b 83       	std	Y+3, r24	; 0x03
    22ac:	eb 81       	ldd	r30, Y+3	; 0x03
    22ae:	fc 81       	ldd	r31, Y+4	; 0x04
    22b0:	02 80       	ldd	r0, Z+2	; 0x02
    22b2:	f3 81       	ldd	r31, Z+3	; 0x03
    22b4:	e0 2d       	mov	r30, r0
    22b6:	20 81       	ld	r18, Z
    22b8:	31 81       	ldd	r19, Z+1	; 0x01
    22ba:	89 81       	ldd	r24, Y+1	; 0x01
    22bc:	9a 81       	ldd	r25, Y+2	; 0x02
    22be:	82 17       	cp	r24, r18
    22c0:	93 07       	cpc	r25, r19
    22c2:	70 f7       	brcc	.-36     	; 0x22a0 <vListInsert+0x4e>
            /* There is nothing to do here, just iterating to the wanted
             * insertion position. */
        }
    }

    pxNewListItem->pxNext = pxIterator->pxNext;
    22c4:	eb 81       	ldd	r30, Y+3	; 0x03
    22c6:	fc 81       	ldd	r31, Y+4	; 0x04
    22c8:	82 81       	ldd	r24, Z+2	; 0x02
    22ca:	93 81       	ldd	r25, Z+3	; 0x03
    22cc:	ef 81       	ldd	r30, Y+7	; 0x07
    22ce:	f8 85       	ldd	r31, Y+8	; 0x08
    22d0:	93 83       	std	Z+3, r25	; 0x03
    22d2:	82 83       	std	Z+2, r24	; 0x02
    pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    22d4:	ef 81       	ldd	r30, Y+7	; 0x07
    22d6:	f8 85       	ldd	r31, Y+8	; 0x08
    22d8:	02 80       	ldd	r0, Z+2	; 0x02
    22da:	f3 81       	ldd	r31, Z+3	; 0x03
    22dc:	e0 2d       	mov	r30, r0
    22de:	8f 81       	ldd	r24, Y+7	; 0x07
    22e0:	98 85       	ldd	r25, Y+8	; 0x08
    22e2:	95 83       	std	Z+5, r25	; 0x05
    22e4:	84 83       	std	Z+4, r24	; 0x04
    pxNewListItem->pxPrevious = pxIterator;
    22e6:	ef 81       	ldd	r30, Y+7	; 0x07
    22e8:	f8 85       	ldd	r31, Y+8	; 0x08
    22ea:	8b 81       	ldd	r24, Y+3	; 0x03
    22ec:	9c 81       	ldd	r25, Y+4	; 0x04
    22ee:	95 83       	std	Z+5, r25	; 0x05
    22f0:	84 83       	std	Z+4, r24	; 0x04
    pxIterator->pxNext = pxNewListItem;
    22f2:	eb 81       	ldd	r30, Y+3	; 0x03
    22f4:	fc 81       	ldd	r31, Y+4	; 0x04
    22f6:	8f 81       	ldd	r24, Y+7	; 0x07
    22f8:	98 85       	ldd	r25, Y+8	; 0x08
    22fa:	93 83       	std	Z+3, r25	; 0x03
    22fc:	82 83       	std	Z+2, r24	; 0x02

    /* Remember which list the item is in.  This allows fast removal of the
     * item later. */
    pxNewListItem->pxContainer = pxList;
    22fe:	ef 81       	ldd	r30, Y+7	; 0x07
    2300:	f8 85       	ldd	r31, Y+8	; 0x08
    2302:	8d 81       	ldd	r24, Y+5	; 0x05
    2304:	9e 81       	ldd	r25, Y+6	; 0x06
    2306:	91 87       	std	Z+9, r25	; 0x09
    2308:	80 87       	std	Z+8, r24	; 0x08

    ( pxList->uxNumberOfItems )++;
    230a:	ed 81       	ldd	r30, Y+5	; 0x05
    230c:	fe 81       	ldd	r31, Y+6	; 0x06
    230e:	80 81       	ld	r24, Z
    2310:	8f 5f       	subi	r24, 0xFF	; 255
    2312:	ed 81       	ldd	r30, Y+5	; 0x05
    2314:	fe 81       	ldd	r31, Y+6	; 0x06
    2316:	80 83       	st	Z, r24
}
    2318:	28 96       	adiw	r28, 0x08	; 8
    231a:	0f b6       	in	r0, 0x3f	; 63
    231c:	f8 94       	cli
    231e:	de bf       	out	0x3e, r29	; 62
    2320:	0f be       	out	0x3f, r0	; 63
    2322:	cd bf       	out	0x3d, r28	; 61
    2324:	cf 91       	pop	r28
    2326:	df 91       	pop	r29
    2328:	08 95       	ret

0000232a <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    232a:	df 93       	push	r29
    232c:	cf 93       	push	r28
    232e:	00 d0       	rcall	.+0      	; 0x2330 <uxListRemove+0x6>
    2330:	00 d0       	rcall	.+0      	; 0x2332 <uxListRemove+0x8>
    2332:	cd b7       	in	r28, 0x3d	; 61
    2334:	de b7       	in	r29, 0x3e	; 62
    2336:	9c 83       	std	Y+4, r25	; 0x04
    2338:	8b 83       	std	Y+3, r24	; 0x03
/* The list item knows which list it is in.  Obtain the list from the list
 * item. */
    List_t * const pxList = pxItemToRemove->pxContainer;
    233a:	eb 81       	ldd	r30, Y+3	; 0x03
    233c:	fc 81       	ldd	r31, Y+4	; 0x04
    233e:	80 85       	ldd	r24, Z+8	; 0x08
    2340:	91 85       	ldd	r25, Z+9	; 0x09
    2342:	9a 83       	std	Y+2, r25	; 0x02
    2344:	89 83       	std	Y+1, r24	; 0x01

    pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    2346:	eb 81       	ldd	r30, Y+3	; 0x03
    2348:	fc 81       	ldd	r31, Y+4	; 0x04
    234a:	a2 81       	ldd	r26, Z+2	; 0x02
    234c:	b3 81       	ldd	r27, Z+3	; 0x03
    234e:	eb 81       	ldd	r30, Y+3	; 0x03
    2350:	fc 81       	ldd	r31, Y+4	; 0x04
    2352:	84 81       	ldd	r24, Z+4	; 0x04
    2354:	95 81       	ldd	r25, Z+5	; 0x05
    2356:	15 96       	adiw	r26, 0x05	; 5
    2358:	9c 93       	st	X, r25
    235a:	8e 93       	st	-X, r24
    235c:	14 97       	sbiw	r26, 0x04	; 4
    pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    235e:	eb 81       	ldd	r30, Y+3	; 0x03
    2360:	fc 81       	ldd	r31, Y+4	; 0x04
    2362:	a4 81       	ldd	r26, Z+4	; 0x04
    2364:	b5 81       	ldd	r27, Z+5	; 0x05
    2366:	eb 81       	ldd	r30, Y+3	; 0x03
    2368:	fc 81       	ldd	r31, Y+4	; 0x04
    236a:	82 81       	ldd	r24, Z+2	; 0x02
    236c:	93 81       	ldd	r25, Z+3	; 0x03
    236e:	13 96       	adiw	r26, 0x03	; 3
    2370:	9c 93       	st	X, r25
    2372:	8e 93       	st	-X, r24
    2374:	12 97       	sbiw	r26, 0x02	; 2

    /* Only used during decision coverage testing. */
    mtCOVERAGE_TEST_DELAY();

    /* Make sure the index is left pointing to a valid item. */
    if( pxList->pxIndex == pxItemToRemove )
    2376:	e9 81       	ldd	r30, Y+1	; 0x01
    2378:	fa 81       	ldd	r31, Y+2	; 0x02
    237a:	21 81       	ldd	r18, Z+1	; 0x01
    237c:	32 81       	ldd	r19, Z+2	; 0x02
    237e:	8b 81       	ldd	r24, Y+3	; 0x03
    2380:	9c 81       	ldd	r25, Y+4	; 0x04
    2382:	28 17       	cp	r18, r24
    2384:	39 07       	cpc	r19, r25
    2386:	41 f4       	brne	.+16     	; 0x2398 <uxListRemove+0x6e>
    {
        pxList->pxIndex = pxItemToRemove->pxPrevious;
    2388:	eb 81       	ldd	r30, Y+3	; 0x03
    238a:	fc 81       	ldd	r31, Y+4	; 0x04
    238c:	84 81       	ldd	r24, Z+4	; 0x04
    238e:	95 81       	ldd	r25, Z+5	; 0x05
    2390:	e9 81       	ldd	r30, Y+1	; 0x01
    2392:	fa 81       	ldd	r31, Y+2	; 0x02
    2394:	92 83       	std	Z+2, r25	; 0x02
    2396:	81 83       	std	Z+1, r24	; 0x01
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    pxItemToRemove->pxContainer = NULL;
    2398:	eb 81       	ldd	r30, Y+3	; 0x03
    239a:	fc 81       	ldd	r31, Y+4	; 0x04
    239c:	11 86       	std	Z+9, r1	; 0x09
    239e:	10 86       	std	Z+8, r1	; 0x08
    ( pxList->uxNumberOfItems )--;
    23a0:	e9 81       	ldd	r30, Y+1	; 0x01
    23a2:	fa 81       	ldd	r31, Y+2	; 0x02
    23a4:	80 81       	ld	r24, Z
    23a6:	81 50       	subi	r24, 0x01	; 1
    23a8:	e9 81       	ldd	r30, Y+1	; 0x01
    23aa:	fa 81       	ldd	r31, Y+2	; 0x02
    23ac:	80 83       	st	Z, r24

    return pxList->uxNumberOfItems;
    23ae:	e9 81       	ldd	r30, Y+1	; 0x01
    23b0:	fa 81       	ldd	r31, Y+2	; 0x02
    23b2:	80 81       	ld	r24, Z
}
    23b4:	0f 90       	pop	r0
    23b6:	0f 90       	pop	r0
    23b8:	0f 90       	pop	r0
    23ba:	0f 90       	pop	r0
    23bc:	cf 91       	pop	r28
    23be:	df 91       	pop	r29
    23c0:	08 95       	ret

000023c2 <xQueueGenericReset>:
    taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue,
                               BaseType_t xNewQueue )
{
    23c2:	df 93       	push	r29
    23c4:	cf 93       	push	r28
    23c6:	00 d0       	rcall	.+0      	; 0x23c8 <xQueueGenericReset+0x6>
    23c8:	00 d0       	rcall	.+0      	; 0x23ca <xQueueGenericReset+0x8>
    23ca:	00 d0       	rcall	.+0      	; 0x23cc <xQueueGenericReset+0xa>
    23cc:	cd b7       	in	r28, 0x3d	; 61
    23ce:	de b7       	in	r29, 0x3e	; 62
    23d0:	9d 83       	std	Y+5, r25	; 0x05
    23d2:	8c 83       	std	Y+4, r24	; 0x04
    23d4:	6e 83       	std	Y+6, r22	; 0x06
    BaseType_t xReturn = pdPASS;
    23d6:	81 e0       	ldi	r24, 0x01	; 1
    23d8:	8b 83       	std	Y+3, r24	; 0x03
    Queue_t * const pxQueue = xQueue;
    23da:	8c 81       	ldd	r24, Y+4	; 0x04
    23dc:	9d 81       	ldd	r25, Y+5	; 0x05
    23de:	9a 83       	std	Y+2, r25	; 0x02
    23e0:	89 83       	std	Y+1, r24	; 0x01

    configASSERT( pxQueue );

    if( ( pxQueue != NULL ) &&
    23e2:	89 81       	ldd	r24, Y+1	; 0x01
    23e4:	9a 81       	ldd	r25, Y+2	; 0x02
    23e6:	00 97       	sbiw	r24, 0x00	; 0
    23e8:	09 f4       	brne	.+2      	; 0x23ec <xQueueGenericReset+0x2a>
    23ea:	8b c0       	rjmp	.+278    	; 0x2502 <xQueueGenericReset+0x140>
    23ec:	e9 81       	ldd	r30, Y+1	; 0x01
    23ee:	fa 81       	ldd	r31, Y+2	; 0x02
    23f0:	83 8d       	ldd	r24, Z+27	; 0x1b
    23f2:	88 23       	and	r24, r24
    23f4:	09 f4       	brne	.+2      	; 0x23f8 <xQueueGenericReset+0x36>
    23f6:	85 c0       	rjmp	.+266    	; 0x2502 <xQueueGenericReset+0x140>
    23f8:	e9 81       	ldd	r30, Y+1	; 0x01
    23fa:	fa 81       	ldd	r31, Y+2	; 0x02
    23fc:	83 8d       	ldd	r24, Z+27	; 0x1b
    23fe:	28 2f       	mov	r18, r24
    2400:	30 e0       	ldi	r19, 0x00	; 0
    2402:	8f ef       	ldi	r24, 0xFF	; 255
    2404:	9f e7       	ldi	r25, 0x7F	; 127
    2406:	b9 01       	movw	r22, r18
    2408:	0e 94 b0 48 	call	0x9160	; 0x9160 <__udivmodhi4>
    240c:	cb 01       	movw	r24, r22
    240e:	9c 01       	movw	r18, r24
    2410:	e9 81       	ldd	r30, Y+1	; 0x01
    2412:	fa 81       	ldd	r31, Y+2	; 0x02
    2414:	84 8d       	ldd	r24, Z+28	; 0x1c
    2416:	88 2f       	mov	r24, r24
    2418:	90 e0       	ldi	r25, 0x00	; 0
    241a:	28 17       	cp	r18, r24
    241c:	39 07       	cpc	r19, r25
    241e:	08 f4       	brcc	.+2      	; 0x2422 <xQueueGenericReset+0x60>
    2420:	70 c0       	rjmp	.+224    	; 0x2502 <xQueueGenericReset+0x140>
        ( pxQueue->uxLength >= 1U ) &&
        /* Check for multiplication overflow. */
        ( ( SIZE_MAX / pxQueue->uxLength ) >= pxQueue->uxItemSize ) )
    {
        taskENTER_CRITICAL();
    2422:	0f b6       	in	r0, 0x3f	; 63
    2424:	f8 94       	cli
    2426:	0f 92       	push	r0
        {
            pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    2428:	e9 81       	ldd	r30, Y+1	; 0x01
    242a:	fa 81       	ldd	r31, Y+2	; 0x02
    242c:	40 81       	ld	r20, Z
    242e:	51 81       	ldd	r21, Z+1	; 0x01
    2430:	e9 81       	ldd	r30, Y+1	; 0x01
    2432:	fa 81       	ldd	r31, Y+2	; 0x02
    2434:	83 8d       	ldd	r24, Z+27	; 0x1b
    2436:	28 2f       	mov	r18, r24
    2438:	30 e0       	ldi	r19, 0x00	; 0
    243a:	e9 81       	ldd	r30, Y+1	; 0x01
    243c:	fa 81       	ldd	r31, Y+2	; 0x02
    243e:	84 8d       	ldd	r24, Z+28	; 0x1c
    2440:	88 2f       	mov	r24, r24
    2442:	90 e0       	ldi	r25, 0x00	; 0
    2444:	bc 01       	movw	r22, r24
    2446:	26 9f       	mul	r18, r22
    2448:	c0 01       	movw	r24, r0
    244a:	27 9f       	mul	r18, r23
    244c:	90 0d       	add	r25, r0
    244e:	36 9f       	mul	r19, r22
    2450:	90 0d       	add	r25, r0
    2452:	11 24       	eor	r1, r1
    2454:	84 0f       	add	r24, r20
    2456:	95 1f       	adc	r25, r21
    2458:	e9 81       	ldd	r30, Y+1	; 0x01
    245a:	fa 81       	ldd	r31, Y+2	; 0x02
    245c:	95 83       	std	Z+5, r25	; 0x05
    245e:	84 83       	std	Z+4, r24	; 0x04
            pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    2460:	e9 81       	ldd	r30, Y+1	; 0x01
    2462:	fa 81       	ldd	r31, Y+2	; 0x02
    2464:	12 8e       	std	Z+26, r1	; 0x1a
            pxQueue->pcWriteTo = pxQueue->pcHead;
    2466:	e9 81       	ldd	r30, Y+1	; 0x01
    2468:	fa 81       	ldd	r31, Y+2	; 0x02
    246a:	80 81       	ld	r24, Z
    246c:	91 81       	ldd	r25, Z+1	; 0x01
    246e:	e9 81       	ldd	r30, Y+1	; 0x01
    2470:	fa 81       	ldd	r31, Y+2	; 0x02
    2472:	93 83       	std	Z+3, r25	; 0x03
    2474:	82 83       	std	Z+2, r24	; 0x02
            pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    2476:	e9 81       	ldd	r30, Y+1	; 0x01
    2478:	fa 81       	ldd	r31, Y+2	; 0x02
    247a:	40 81       	ld	r20, Z
    247c:	51 81       	ldd	r21, Z+1	; 0x01
    247e:	e9 81       	ldd	r30, Y+1	; 0x01
    2480:	fa 81       	ldd	r31, Y+2	; 0x02
    2482:	83 8d       	ldd	r24, Z+27	; 0x1b
    2484:	88 2f       	mov	r24, r24
    2486:	90 e0       	ldi	r25, 0x00	; 0
    2488:	9c 01       	movw	r18, r24
    248a:	21 50       	subi	r18, 0x01	; 1
    248c:	30 40       	sbci	r19, 0x00	; 0
    248e:	e9 81       	ldd	r30, Y+1	; 0x01
    2490:	fa 81       	ldd	r31, Y+2	; 0x02
    2492:	84 8d       	ldd	r24, Z+28	; 0x1c
    2494:	88 2f       	mov	r24, r24
    2496:	90 e0       	ldi	r25, 0x00	; 0
    2498:	bc 01       	movw	r22, r24
    249a:	26 9f       	mul	r18, r22
    249c:	c0 01       	movw	r24, r0
    249e:	27 9f       	mul	r18, r23
    24a0:	90 0d       	add	r25, r0
    24a2:	36 9f       	mul	r19, r22
    24a4:	90 0d       	add	r25, r0
    24a6:	11 24       	eor	r1, r1
    24a8:	84 0f       	add	r24, r20
    24aa:	95 1f       	adc	r25, r21
    24ac:	e9 81       	ldd	r30, Y+1	; 0x01
    24ae:	fa 81       	ldd	r31, Y+2	; 0x02
    24b0:	97 83       	std	Z+7, r25	; 0x07
    24b2:	86 83       	std	Z+6, r24	; 0x06
            pxQueue->cRxLock = queueUNLOCKED;
    24b4:	e9 81       	ldd	r30, Y+1	; 0x01
    24b6:	fa 81       	ldd	r31, Y+2	; 0x02
    24b8:	8f ef       	ldi	r24, 0xFF	; 255
    24ba:	85 8f       	std	Z+29, r24	; 0x1d
            pxQueue->cTxLock = queueUNLOCKED;
    24bc:	e9 81       	ldd	r30, Y+1	; 0x01
    24be:	fa 81       	ldd	r31, Y+2	; 0x02
    24c0:	8f ef       	ldi	r24, 0xFF	; 255
    24c2:	86 8f       	std	Z+30, r24	; 0x1e

            if( xNewQueue == pdFALSE )
    24c4:	8e 81       	ldd	r24, Y+6	; 0x06
    24c6:	88 23       	and	r24, r24
    24c8:	79 f4       	brne	.+30     	; 0x24e8 <xQueueGenericReset+0x126>
                /* If there are tasks blocked waiting to read from the queue, then
                 * the tasks will remain blocked as after this function exits the queue
                 * will still be empty.  If there are tasks blocked waiting to write to
                 * the queue, then one should be unblocked as after this function exits
                 * it will be possible to write to it. */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    24ca:	e9 81       	ldd	r30, Y+1	; 0x01
    24cc:	fa 81       	ldd	r31, Y+2	; 0x02
    24ce:	80 85       	ldd	r24, Z+8	; 0x08
    24d0:	88 23       	and	r24, r24
    24d2:	a1 f0       	breq	.+40     	; 0x24fc <xQueueGenericReset+0x13a>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    24d4:	89 81       	ldd	r24, Y+1	; 0x01
    24d6:	9a 81       	ldd	r25, Y+2	; 0x02
    24d8:	08 96       	adiw	r24, 0x08	; 8
    24da:	0e 94 4e 23 	call	0x469c	; 0x469c <xTaskRemoveFromEventList>
    24de:	88 23       	and	r24, r24
    24e0:	69 f0       	breq	.+26     	; 0x24fc <xQueueGenericReset+0x13a>
                    {
                        queueYIELD_IF_USING_PREEMPTION();
    24e2:	0e 94 72 09 	call	0x12e4	; 0x12e4 <vPortYield>
    24e6:	0a c0       	rjmp	.+20     	; 0x24fc <xQueueGenericReset+0x13a>
                }
            }
            else
            {
                /* Ensure the event queues start in the correct state. */
                vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    24e8:	89 81       	ldd	r24, Y+1	; 0x01
    24ea:	9a 81       	ldd	r25, Y+2	; 0x02
    24ec:	08 96       	adiw	r24, 0x08	; 8
    24ee:	0e 94 ab 10 	call	0x2156	; 0x2156 <vListInitialise>
                vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
    24f2:	89 81       	ldd	r24, Y+1	; 0x01
    24f4:	9a 81       	ldd	r25, Y+2	; 0x02
    24f6:	41 96       	adiw	r24, 0x11	; 17
    24f8:	0e 94 ab 10 	call	0x2156	; 0x2156 <vListInitialise>
            }
        }
        taskEXIT_CRITICAL();
    24fc:	0f 90       	pop	r0
    24fe:	0f be       	out	0x3f, r0	; 63
    2500:	01 c0       	rjmp	.+2      	; 0x2504 <xQueueGenericReset+0x142>
    }
    else
    {
        xReturn = pdFAIL;
    2502:	1b 82       	std	Y+3, r1	; 0x03

    configASSERT( xReturn != pdFAIL );

    /* A value is returned for calling semantic consistency with previous
     * versions. */
    return xReturn;
    2504:	8b 81       	ldd	r24, Y+3	; 0x03
}
    2506:	26 96       	adiw	r28, 0x06	; 6
    2508:	0f b6       	in	r0, 0x3f	; 63
    250a:	f8 94       	cli
    250c:	de bf       	out	0x3e, r29	; 62
    250e:	0f be       	out	0x3f, r0	; 63
    2510:	cd bf       	out	0x3d, r28	; 61
    2512:	cf 91       	pop	r28
    2514:	df 91       	pop	r29
    2516:	08 95       	ret

00002518 <xQueueGenericCreate>:
#if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

    QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength,
                                       const UBaseType_t uxItemSize,
                                       const uint8_t ucQueueType )
    {
    2518:	0f 93       	push	r16
    251a:	1f 93       	push	r17
    251c:	df 93       	push	r29
    251e:	cf 93       	push	r28
    2520:	cd b7       	in	r28, 0x3d	; 61
    2522:	de b7       	in	r29, 0x3e	; 62
    2524:	29 97       	sbiw	r28, 0x09	; 9
    2526:	0f b6       	in	r0, 0x3f	; 63
    2528:	f8 94       	cli
    252a:	de bf       	out	0x3e, r29	; 62
    252c:	0f be       	out	0x3f, r0	; 63
    252e:	cd bf       	out	0x3d, r28	; 61
    2530:	8f 83       	std	Y+7, r24	; 0x07
    2532:	68 87       	std	Y+8, r22	; 0x08
    2534:	49 87       	std	Y+9, r20	; 0x09
        Queue_t * pxNewQueue = NULL;
    2536:	1e 82       	std	Y+6, r1	; 0x06
    2538:	1d 82       	std	Y+5, r1	; 0x05
        size_t xQueueSizeInBytes;
        uint8_t * pucQueueStorage;

        if( ( uxQueueLength > ( UBaseType_t ) 0 ) &&
    253a:	8f 81       	ldd	r24, Y+7	; 0x07
    253c:	88 23       	and	r24, r24
    253e:	09 f4       	brne	.+2      	; 0x2542 <xQueueGenericCreate+0x2a>
    2540:	52 c0       	rjmp	.+164    	; 0x25e6 <xQueueGenericCreate+0xce>
    2542:	8f 81       	ldd	r24, Y+7	; 0x07
    2544:	28 2f       	mov	r18, r24
    2546:	30 e0       	ldi	r19, 0x00	; 0
    2548:	8f ef       	ldi	r24, 0xFF	; 255
    254a:	9f e7       	ldi	r25, 0x7F	; 127
    254c:	b9 01       	movw	r22, r18
    254e:	0e 94 b0 48 	call	0x9160	; 0x9160 <__udivmodhi4>
    2552:	cb 01       	movw	r24, r22
    2554:	9c 01       	movw	r18, r24
    2556:	88 85       	ldd	r24, Y+8	; 0x08
    2558:	88 2f       	mov	r24, r24
    255a:	90 e0       	ldi	r25, 0x00	; 0
    255c:	28 17       	cp	r18, r24
    255e:	39 07       	cpc	r19, r25
    2560:	08 f4       	brcc	.+2      	; 0x2564 <xQueueGenericCreate+0x4c>
    2562:	41 c0       	rjmp	.+130    	; 0x25e6 <xQueueGenericCreate+0xce>
    2564:	8f 81       	ldd	r24, Y+7	; 0x07
    2566:	28 2f       	mov	r18, r24
    2568:	30 e0       	ldi	r19, 0x00	; 0
    256a:	88 85       	ldd	r24, Y+8	; 0x08
    256c:	88 2f       	mov	r24, r24
    256e:	90 e0       	ldi	r25, 0x00	; 0
    2570:	ac 01       	movw	r20, r24
    2572:	24 9f       	mul	r18, r20
    2574:	c0 01       	movw	r24, r0
    2576:	25 9f       	mul	r18, r21
    2578:	90 0d       	add	r25, r0
    257a:	34 9f       	mul	r19, r20
    257c:	90 0d       	add	r25, r0
    257e:	11 24       	eor	r1, r1
    2580:	5f e7       	ldi	r21, 0x7F	; 127
    2582:	81 3e       	cpi	r24, 0xE1	; 225
    2584:	95 07       	cpc	r25, r21
    2586:	78 f5       	brcc	.+94     	; 0x25e6 <xQueueGenericCreate+0xce>
            ( ( SIZE_MAX - sizeof( Queue_t ) ) >= ( uxQueueLength * uxItemSize ) ) )
        {
            /* Allocate enough space to hold the maximum number of items that
             * can be in the queue at any time.  It is valid for uxItemSize to be
             * zero in the case the queue is used as a semaphore. */
            xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    2588:	8f 81       	ldd	r24, Y+7	; 0x07
    258a:	28 2f       	mov	r18, r24
    258c:	30 e0       	ldi	r19, 0x00	; 0
    258e:	88 85       	ldd	r24, Y+8	; 0x08
    2590:	88 2f       	mov	r24, r24
    2592:	90 e0       	ldi	r25, 0x00	; 0
    2594:	ac 01       	movw	r20, r24
    2596:	24 9f       	mul	r18, r20
    2598:	c0 01       	movw	r24, r0
    259a:	25 9f       	mul	r18, r21
    259c:	90 0d       	add	r25, r0
    259e:	34 9f       	mul	r19, r20
    25a0:	90 0d       	add	r25, r0
    25a2:	11 24       	eor	r1, r1
    25a4:	9c 83       	std	Y+4, r25	; 0x04
    25a6:	8b 83       	std	Y+3, r24	; 0x03
             * alignment requirements of the Queue_t structure - which in this case
             * is an int8_t *.  Therefore, whenever the stack alignment requirements
             * are greater than or equal to the pointer to char requirements the cast
             * is safe.  In other cases alignment requirements are not strict (one or
             * two bytes). */
            pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !e9079 see comment above. */
    25a8:	8b 81       	ldd	r24, Y+3	; 0x03
    25aa:	9c 81       	ldd	r25, Y+4	; 0x04
    25ac:	4f 96       	adiw	r24, 0x1f	; 31
    25ae:	0e 94 33 07 	call	0xe66	; 0xe66 <pvPortMalloc>
    25b2:	9e 83       	std	Y+6, r25	; 0x06
    25b4:	8d 83       	std	Y+5, r24	; 0x05

            if( pxNewQueue != NULL )
    25b6:	8d 81       	ldd	r24, Y+5	; 0x05
    25b8:	9e 81       	ldd	r25, Y+6	; 0x06
    25ba:	00 97       	sbiw	r24, 0x00	; 0
    25bc:	a1 f0       	breq	.+40     	; 0x25e6 <xQueueGenericCreate+0xce>
            {
                /* Jump past the queue structure to find the location of the queue
                 * storage area. */
                pucQueueStorage = ( uint8_t * ) pxNewQueue;
    25be:	8d 81       	ldd	r24, Y+5	; 0x05
    25c0:	9e 81       	ldd	r25, Y+6	; 0x06
    25c2:	9a 83       	std	Y+2, r25	; 0x02
    25c4:	89 83       	std	Y+1, r24	; 0x01
                pucQueueStorage += sizeof( Queue_t ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    25c6:	89 81       	ldd	r24, Y+1	; 0x01
    25c8:	9a 81       	ldd	r25, Y+2	; 0x02
    25ca:	4f 96       	adiw	r24, 0x1f	; 31
    25cc:	9a 83       	std	Y+2, r25	; 0x02
    25ce:	89 83       	std	Y+1, r24	; 0x01
                         * deleted. */
                        pxNewQueue->ucStaticallyAllocated = pdFALSE;
                    }
                #endif /* configSUPPORT_STATIC_ALLOCATION */

                prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
    25d0:	29 81       	ldd	r18, Y+1	; 0x01
    25d2:	3a 81       	ldd	r19, Y+2	; 0x02
    25d4:	ed 81       	ldd	r30, Y+5	; 0x05
    25d6:	fe 81       	ldd	r31, Y+6	; 0x06
    25d8:	8f 81       	ldd	r24, Y+7	; 0x07
    25da:	68 85       	ldd	r22, Y+8	; 0x08
    25dc:	a9 01       	movw	r20, r18
    25de:	29 85       	ldd	r18, Y+9	; 0x09
    25e0:	8f 01       	movw	r16, r30
    25e2:	0e 94 00 13 	call	0x2600	; 0x2600 <prvInitialiseNewQueue>
        {
            configASSERT( pxNewQueue );
            mtCOVERAGE_TEST_MARKER();
        }

        return pxNewQueue;
    25e6:	8d 81       	ldd	r24, Y+5	; 0x05
    25e8:	9e 81       	ldd	r25, Y+6	; 0x06
    }
    25ea:	29 96       	adiw	r28, 0x09	; 9
    25ec:	0f b6       	in	r0, 0x3f	; 63
    25ee:	f8 94       	cli
    25f0:	de bf       	out	0x3e, r29	; 62
    25f2:	0f be       	out	0x3f, r0	; 63
    25f4:	cd bf       	out	0x3d, r28	; 61
    25f6:	cf 91       	pop	r28
    25f8:	df 91       	pop	r29
    25fa:	1f 91       	pop	r17
    25fc:	0f 91       	pop	r16
    25fe:	08 95       	ret

00002600 <prvInitialiseNewQueue>:
static void prvInitialiseNewQueue( const UBaseType_t uxQueueLength,
                                   const UBaseType_t uxItemSize,
                                   uint8_t * pucQueueStorage,
                                   const uint8_t ucQueueType,
                                   Queue_t * pxNewQueue )
{
    2600:	0f 93       	push	r16
    2602:	1f 93       	push	r17
    2604:	df 93       	push	r29
    2606:	cf 93       	push	r28
    2608:	cd b7       	in	r28, 0x3d	; 61
    260a:	de b7       	in	r29, 0x3e	; 62
    260c:	27 97       	sbiw	r28, 0x07	; 7
    260e:	0f b6       	in	r0, 0x3f	; 63
    2610:	f8 94       	cli
    2612:	de bf       	out	0x3e, r29	; 62
    2614:	0f be       	out	0x3f, r0	; 63
    2616:	cd bf       	out	0x3d, r28	; 61
    2618:	89 83       	std	Y+1, r24	; 0x01
    261a:	6a 83       	std	Y+2, r22	; 0x02
    261c:	5c 83       	std	Y+4, r21	; 0x04
    261e:	4b 83       	std	Y+3, r20	; 0x03
    2620:	2d 83       	std	Y+5, r18	; 0x05
    2622:	1f 83       	std	Y+7, r17	; 0x07
    2624:	0e 83       	std	Y+6, r16	; 0x06
    /* Remove compiler warnings about unused parameters should
     * configUSE_TRACE_FACILITY not be set to 1. */
    ( void ) ucQueueType;

    if( uxItemSize == ( UBaseType_t ) 0 )
    2626:	8a 81       	ldd	r24, Y+2	; 0x02
    2628:	88 23       	and	r24, r24
    262a:	39 f4       	brne	.+14     	; 0x263a <prvInitialiseNewQueue+0x3a>
    {
        /* No RAM was allocated for the queue storage area, but PC head cannot
         * be set to NULL because NULL is used as a key to say the queue is used as
         * a mutex.  Therefore just set pcHead to point to the queue as a benign
         * value that is known to be within the memory map. */
        pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
    262c:	8e 81       	ldd	r24, Y+6	; 0x06
    262e:	9f 81       	ldd	r25, Y+7	; 0x07
    2630:	ee 81       	ldd	r30, Y+6	; 0x06
    2632:	ff 81       	ldd	r31, Y+7	; 0x07
    2634:	91 83       	std	Z+1, r25	; 0x01
    2636:	80 83       	st	Z, r24
    2638:	06 c0       	rjmp	.+12     	; 0x2646 <prvInitialiseNewQueue+0x46>
    }
    else
    {
        /* Set the head to the start of the queue storage area. */
        pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
    263a:	8b 81       	ldd	r24, Y+3	; 0x03
    263c:	9c 81       	ldd	r25, Y+4	; 0x04
    263e:	ee 81       	ldd	r30, Y+6	; 0x06
    2640:	ff 81       	ldd	r31, Y+7	; 0x07
    2642:	91 83       	std	Z+1, r25	; 0x01
    2644:	80 83       	st	Z, r24
    }

    /* Initialise the queue members as described where the queue type is
     * defined. */
    pxNewQueue->uxLength = uxQueueLength;
    2646:	ee 81       	ldd	r30, Y+6	; 0x06
    2648:	ff 81       	ldd	r31, Y+7	; 0x07
    264a:	89 81       	ldd	r24, Y+1	; 0x01
    264c:	83 8f       	std	Z+27, r24	; 0x1b
    pxNewQueue->uxItemSize = uxItemSize;
    264e:	ee 81       	ldd	r30, Y+6	; 0x06
    2650:	ff 81       	ldd	r31, Y+7	; 0x07
    2652:	8a 81       	ldd	r24, Y+2	; 0x02
    2654:	84 8f       	std	Z+28, r24	; 0x1c
    ( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
    2656:	8e 81       	ldd	r24, Y+6	; 0x06
    2658:	9f 81       	ldd	r25, Y+7	; 0x07
    265a:	61 e0       	ldi	r22, 0x01	; 1
    265c:	0e 94 e1 11 	call	0x23c2	; 0x23c2 <xQueueGenericReset>
            pxNewQueue->pxQueueSetContainer = NULL;
        }
    #endif /* configUSE_QUEUE_SETS */

    traceQUEUE_CREATE( pxNewQueue );
}
    2660:	27 96       	adiw	r28, 0x07	; 7
    2662:	0f b6       	in	r0, 0x3f	; 63
    2664:	f8 94       	cli
    2666:	de bf       	out	0x3e, r29	; 62
    2668:	0f be       	out	0x3f, r0	; 63
    266a:	cd bf       	out	0x3d, r28	; 61
    266c:	cf 91       	pop	r28
    266e:	df 91       	pop	r29
    2670:	1f 91       	pop	r17
    2672:	0f 91       	pop	r16
    2674:	08 95       	ret

00002676 <xQueueGenericSend>:

BaseType_t xQueueGenericSend( QueueHandle_t xQueue,
                              const void * const pvItemToQueue,
                              TickType_t xTicksToWait,
                              const BaseType_t xCopyPosition )
{
    2676:	df 93       	push	r29
    2678:	cf 93       	push	r28
    267a:	cd b7       	in	r28, 0x3d	; 61
    267c:	de b7       	in	r29, 0x3e	; 62
    267e:	2f 97       	sbiw	r28, 0x0f	; 15
    2680:	0f b6       	in	r0, 0x3f	; 63
    2682:	f8 94       	cli
    2684:	de bf       	out	0x3e, r29	; 62
    2686:	0f be       	out	0x3f, r0	; 63
    2688:	cd bf       	out	0x3d, r28	; 61
    268a:	99 87       	std	Y+9, r25	; 0x09
    268c:	88 87       	std	Y+8, r24	; 0x08
    268e:	7b 87       	std	Y+11, r23	; 0x0b
    2690:	6a 87       	std	Y+10, r22	; 0x0a
    2692:	5d 87       	std	Y+13, r21	; 0x0d
    2694:	4c 87       	std	Y+12, r20	; 0x0c
    2696:	2e 87       	std	Y+14, r18	; 0x0e
    BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
    2698:	1c 82       	std	Y+4, r1	; 0x04
    TimeOut_t xTimeOut;
    Queue_t * const pxQueue = xQueue;
    269a:	88 85       	ldd	r24, Y+8	; 0x08
    269c:	99 85       	ldd	r25, Y+9	; 0x09
    269e:	9a 83       	std	Y+2, r25	; 0x02
    26a0:	89 83       	std	Y+1, r24	; 0x01
    /*lint -save -e904 This function relaxes the coding standard somewhat to
     * allow return statements within the function itself.  This is done in the
     * interest of execution time efficiency. */
    for( ; ; )
    {
        taskENTER_CRITICAL();
    26a2:	0f b6       	in	r0, 0x3f	; 63
    26a4:	f8 94       	cli
    26a6:	0f 92       	push	r0
        {
            /* Is there room on the queue now?  The running task must be the
             * highest priority task wanting to access the queue.  If the head item
             * in the queue is to be overwritten then it does not matter if the
             * queue is full. */
            if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    26a8:	e9 81       	ldd	r30, Y+1	; 0x01
    26aa:	fa 81       	ldd	r31, Y+2	; 0x02
    26ac:	92 8d       	ldd	r25, Z+26	; 0x1a
    26ae:	e9 81       	ldd	r30, Y+1	; 0x01
    26b0:	fa 81       	ldd	r31, Y+2	; 0x02
    26b2:	83 8d       	ldd	r24, Z+27	; 0x1b
    26b4:	98 17       	cp	r25, r24
    26b6:	18 f0       	brcs	.+6      	; 0x26be <xQueueGenericSend+0x48>
    26b8:	8e 85       	ldd	r24, Y+14	; 0x0e
    26ba:	82 30       	cpi	r24, 0x02	; 2
    26bc:	11 f5       	brne	.+68     	; 0x2702 <xQueueGenericSend+0x8c>
                            }
                        }
                    }
                #else /* configUSE_QUEUE_SETS */
                    {
                        xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    26be:	89 81       	ldd	r24, Y+1	; 0x01
    26c0:	9a 81       	ldd	r25, Y+2	; 0x02
    26c2:	2a 85       	ldd	r18, Y+10	; 0x0a
    26c4:	3b 85       	ldd	r19, Y+11	; 0x0b
    26c6:	b9 01       	movw	r22, r18
    26c8:	4e 85       	ldd	r20, Y+14	; 0x0e
    26ca:	0e 94 91 17 	call	0x2f22	; 0x2f22 <prvCopyDataToQueue>
    26ce:	8b 83       	std	Y+3, r24	; 0x03

                        /* If there was a task waiting for data to arrive on the
                         * queue then unblock it now. */
                        if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    26d0:	e9 81       	ldd	r30, Y+1	; 0x01
    26d2:	fa 81       	ldd	r31, Y+2	; 0x02
    26d4:	81 89       	ldd	r24, Z+17	; 0x11
    26d6:	88 23       	and	r24, r24
    26d8:	51 f0       	breq	.+20     	; 0x26ee <xQueueGenericSend+0x78>
                        {
                            if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    26da:	89 81       	ldd	r24, Y+1	; 0x01
    26dc:	9a 81       	ldd	r25, Y+2	; 0x02
    26de:	41 96       	adiw	r24, 0x11	; 17
    26e0:	0e 94 4e 23 	call	0x469c	; 0x469c <xTaskRemoveFromEventList>
    26e4:	88 23       	and	r24, r24
    26e6:	41 f0       	breq	.+16     	; 0x26f8 <xQueueGenericSend+0x82>
                            {
                                /* The unblocked task has a priority higher than
                                 * our own so yield immediately.  Yes it is ok to do
                                 * this from within the critical section - the kernel
                                 * takes care of that. */
                                queueYIELD_IF_USING_PREEMPTION();
    26e8:	0e 94 72 09 	call	0x12e4	; 0x12e4 <vPortYield>
    26ec:	05 c0       	rjmp	.+10     	; 0x26f8 <xQueueGenericSend+0x82>
                            else
                            {
                                mtCOVERAGE_TEST_MARKER();
                            }
                        }
                        else if( xYieldRequired != pdFALSE )
    26ee:	8b 81       	ldd	r24, Y+3	; 0x03
    26f0:	88 23       	and	r24, r24
    26f2:	11 f0       	breq	.+4      	; 0x26f8 <xQueueGenericSend+0x82>
                        {
                            /* This path is a special case that will only get
                             * executed if the task was holding multiple mutexes and
                             * the mutexes were given back in an order that is
                             * different to that in which they were taken. */
                            queueYIELD_IF_USING_PREEMPTION();
    26f4:	0e 94 72 09 	call	0x12e4	; 0x12e4 <vPortYield>
                            mtCOVERAGE_TEST_MARKER();
                        }
                    }
                #endif /* configUSE_QUEUE_SETS */

                taskEXIT_CRITICAL();
    26f8:	0f 90       	pop	r0
    26fa:	0f be       	out	0x3f, r0	; 63
                return pdPASS;
    26fc:	81 e0       	ldi	r24, 0x01	; 1
    26fe:	8f 87       	std	Y+15, r24	; 0x0f
    2700:	5c c0       	rjmp	.+184    	; 0x27ba <xQueueGenericSend+0x144>
            }
            else
            {
                if( xTicksToWait == ( TickType_t ) 0 )
    2702:	8c 85       	ldd	r24, Y+12	; 0x0c
    2704:	9d 85       	ldd	r25, Y+13	; 0x0d
    2706:	00 97       	sbiw	r24, 0x00	; 0
    2708:	21 f4       	brne	.+8      	; 0x2712 <xQueueGenericSend+0x9c>
                {
                    /* The queue was full and no block time is specified (or
                     * the block time has expired) so leave now. */
                    taskEXIT_CRITICAL();
    270a:	0f 90       	pop	r0
    270c:	0f be       	out	0x3f, r0	; 63

                    /* Return to the original privilege level before exiting
                     * the function. */
                    traceQUEUE_SEND_FAILED( pxQueue );
                    return errQUEUE_FULL;
    270e:	1f 86       	std	Y+15, r1	; 0x0f
    2710:	54 c0       	rjmp	.+168    	; 0x27ba <xQueueGenericSend+0x144>
                }
                else if( xEntryTimeSet == pdFALSE )
    2712:	8c 81       	ldd	r24, Y+4	; 0x04
    2714:	88 23       	and	r24, r24
    2716:	31 f4       	brne	.+12     	; 0x2724 <xQueueGenericSend+0xae>
                {
                    /* The queue was full and a block time was specified so
                     * configure the timeout structure. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
    2718:	ce 01       	movw	r24, r28
    271a:	05 96       	adiw	r24, 0x05	; 5
    271c:	0e 94 be 25 	call	0x4b7c	; 0x4b7c <vTaskInternalSetTimeOutState>
                    xEntryTimeSet = pdTRUE;
    2720:	81 e0       	ldi	r24, 0x01	; 1
    2722:	8c 83       	std	Y+4, r24	; 0x04
                    /* Entry time was already set. */
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        taskEXIT_CRITICAL();
    2724:	0f 90       	pop	r0
    2726:	0f be       	out	0x3f, r0	; 63

        /* Interrupts and other tasks can send to and receive from the queue
         * now the critical section has been exited. */

        vTaskSuspendAll();
    2728:	0e 94 88 1e 	call	0x3d10	; 0x3d10 <vTaskSuspendAll>
        prvLockQueue( pxQueue );
    272c:	0f b6       	in	r0, 0x3f	; 63
    272e:	f8 94       	cli
    2730:	0f 92       	push	r0
    2732:	e9 81       	ldd	r30, Y+1	; 0x01
    2734:	fa 81       	ldd	r31, Y+2	; 0x02
    2736:	85 8d       	ldd	r24, Z+29	; 0x1d
    2738:	8f 3f       	cpi	r24, 0xFF	; 255
    273a:	19 f4       	brne	.+6      	; 0x2742 <xQueueGenericSend+0xcc>
    273c:	e9 81       	ldd	r30, Y+1	; 0x01
    273e:	fa 81       	ldd	r31, Y+2	; 0x02
    2740:	15 8e       	std	Z+29, r1	; 0x1d
    2742:	e9 81       	ldd	r30, Y+1	; 0x01
    2744:	fa 81       	ldd	r31, Y+2	; 0x02
    2746:	86 8d       	ldd	r24, Z+30	; 0x1e
    2748:	8f 3f       	cpi	r24, 0xFF	; 255
    274a:	19 f4       	brne	.+6      	; 0x2752 <xQueueGenericSend+0xdc>
    274c:	e9 81       	ldd	r30, Y+1	; 0x01
    274e:	fa 81       	ldd	r31, Y+2	; 0x02
    2750:	16 8e       	std	Z+30, r1	; 0x1e
    2752:	0f 90       	pop	r0
    2754:	0f be       	out	0x3f, r0	; 63

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    2756:	ce 01       	movw	r24, r28
    2758:	05 96       	adiw	r24, 0x05	; 5
    275a:	9e 01       	movw	r18, r28
    275c:	24 5f       	subi	r18, 0xF4	; 244
    275e:	3f 4f       	sbci	r19, 0xFF	; 255
    2760:	b9 01       	movw	r22, r18
    2762:	0e 94 d7 25 	call	0x4bae	; 0x4bae <xTaskCheckForTimeOut>
    2766:	88 23       	and	r24, r24
    2768:	09 f5       	brne	.+66     	; 0x27ac <xQueueGenericSend+0x136>
        {
            if( prvIsQueueFull( pxQueue ) != pdFALSE )
    276a:	89 81       	ldd	r24, Y+1	; 0x01
    276c:	9a 81       	ldd	r25, Y+2	; 0x02
    276e:	0e 94 0d 19 	call	0x321a	; 0x321a <prvIsQueueFull>
    2772:	88 23       	and	r24, r24
    2774:	a1 f0       	breq	.+40     	; 0x279e <xQueueGenericSend+0x128>
            {
                traceBLOCKING_ON_QUEUE_SEND( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    2776:	89 81       	ldd	r24, Y+1	; 0x01
    2778:	9a 81       	ldd	r25, Y+2	; 0x02
    277a:	08 96       	adiw	r24, 0x08	; 8
    277c:	2c 85       	ldd	r18, Y+12	; 0x0c
    277e:	3d 85       	ldd	r19, Y+13	; 0x0d
    2780:	b9 01       	movw	r22, r18
    2782:	0e 94 65 22 	call	0x44ca	; 0x44ca <vTaskPlaceOnEventList>
                /* Unlocking the queue means queue events can effect the
                 * event list. It is possible that interrupts occurring now
                 * remove this task from the event list again - but as the
                 * scheduler is suspended the task will go onto the pending
                 * ready list instead of the actual ready list. */
                prvUnlockQueue( pxQueue );
    2786:	89 81       	ldd	r24, Y+1	; 0x01
    2788:	9a 81       	ldd	r25, Y+2	; 0x02
    278a:	0e 94 7e 18 	call	0x30fc	; 0x30fc <prvUnlockQueue>
                /* Resuming the scheduler will move tasks from the pending
                 * ready list into the ready list - so it is feasible that this
                 * task is already in the ready list before it yields - in which
                 * case the yield will not cause a context switch unless there
                 * is also a higher priority task in the pending ready list. */
                if( xTaskResumeAll() == pdFALSE )
    278e:	0e 94 94 1e 	call	0x3d28	; 0x3d28 <xTaskResumeAll>
    2792:	88 23       	and	r24, r24
    2794:	09 f0       	breq	.+2      	; 0x2798 <xQueueGenericSend+0x122>
    2796:	85 cf       	rjmp	.-246    	; 0x26a2 <xQueueGenericSend+0x2c>
                {
                    portYIELD_WITHIN_API();
    2798:	0e 94 72 09 	call	0x12e4	; 0x12e4 <vPortYield>
    279c:	82 cf       	rjmp	.-252    	; 0x26a2 <xQueueGenericSend+0x2c>
                }
            }
            else
            {
                /* Try again. */
                prvUnlockQueue( pxQueue );
    279e:	89 81       	ldd	r24, Y+1	; 0x01
    27a0:	9a 81       	ldd	r25, Y+2	; 0x02
    27a2:	0e 94 7e 18 	call	0x30fc	; 0x30fc <prvUnlockQueue>
                ( void ) xTaskResumeAll();
    27a6:	0e 94 94 1e 	call	0x3d28	; 0x3d28 <xTaskResumeAll>
    27aa:	7b cf       	rjmp	.-266    	; 0x26a2 <xQueueGenericSend+0x2c>
            }
        }
        else
        {
            /* The timeout has expired. */
            prvUnlockQueue( pxQueue );
    27ac:	89 81       	ldd	r24, Y+1	; 0x01
    27ae:	9a 81       	ldd	r25, Y+2	; 0x02
    27b0:	0e 94 7e 18 	call	0x30fc	; 0x30fc <prvUnlockQueue>
            ( void ) xTaskResumeAll();
    27b4:	0e 94 94 1e 	call	0x3d28	; 0x3d28 <xTaskResumeAll>

            traceQUEUE_SEND_FAILED( pxQueue );
            return errQUEUE_FULL;
    27b8:	1f 86       	std	Y+15, r1	; 0x0f
    27ba:	8f 85       	ldd	r24, Y+15	; 0x0f
        }
    } /*lint -restore */
}
    27bc:	2f 96       	adiw	r28, 0x0f	; 15
    27be:	0f b6       	in	r0, 0x3f	; 63
    27c0:	f8 94       	cli
    27c2:	de bf       	out	0x3e, r29	; 62
    27c4:	0f be       	out	0x3f, r0	; 63
    27c6:	cd bf       	out	0x3d, r28	; 61
    27c8:	cf 91       	pop	r28
    27ca:	df 91       	pop	r29
    27cc:	08 95       	ret

000027ce <xQueueGenericSendFromISR>:

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue,
                                     const void * const pvItemToQueue,
                                     BaseType_t * const pxHigherPriorityTaskWoken,
                                     const BaseType_t xCopyPosition )
{
    27ce:	df 93       	push	r29
    27d0:	cf 93       	push	r28
    27d2:	cd b7       	in	r28, 0x3d	; 61
    27d4:	de b7       	in	r29, 0x3e	; 62
    27d6:	2d 97       	sbiw	r28, 0x0d	; 13
    27d8:	0f b6       	in	r0, 0x3f	; 63
    27da:	f8 94       	cli
    27dc:	de bf       	out	0x3e, r29	; 62
    27de:	0f be       	out	0x3f, r0	; 63
    27e0:	cd bf       	out	0x3d, r28	; 61
    27e2:	98 87       	std	Y+8, r25	; 0x08
    27e4:	8f 83       	std	Y+7, r24	; 0x07
    27e6:	7a 87       	std	Y+10, r23	; 0x0a
    27e8:	69 87       	std	Y+9, r22	; 0x09
    27ea:	5c 87       	std	Y+12, r21	; 0x0c
    27ec:	4b 87       	std	Y+11, r20	; 0x0b
    27ee:	2d 87       	std	Y+13, r18	; 0x0d
    BaseType_t xReturn;
    UBaseType_t uxSavedInterruptStatus;
    Queue_t * const pxQueue = xQueue;
    27f0:	8f 81       	ldd	r24, Y+7	; 0x07
    27f2:	98 85       	ldd	r25, Y+8	; 0x08
    27f4:	9c 83       	std	Y+4, r25	; 0x04
    27f6:	8b 83       	std	Y+3, r24	; 0x03
    /* Similar to xQueueGenericSend, except without blocking if there is no room
     * in the queue.  Also don't directly wake a task that was blocked on a queue
     * read, instead return a flag to say whether a context switch is required or
     * not (i.e. has a task with a higher priority than us been woken by this
     * post). */
    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    27f8:	1d 82       	std	Y+5, r1	; 0x05
    {
        if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    27fa:	eb 81       	ldd	r30, Y+3	; 0x03
    27fc:	fc 81       	ldd	r31, Y+4	; 0x04
    27fe:	92 8d       	ldd	r25, Z+26	; 0x1a
    2800:	eb 81       	ldd	r30, Y+3	; 0x03
    2802:	fc 81       	ldd	r31, Y+4	; 0x04
    2804:	83 8d       	ldd	r24, Z+27	; 0x1b
    2806:	98 17       	cp	r25, r24
    2808:	18 f0       	brcs	.+6      	; 0x2810 <xQueueGenericSendFromISR+0x42>
    280a:	8d 85       	ldd	r24, Y+13	; 0x0d
    280c:	82 30       	cpi	r24, 0x02	; 2
    280e:	81 f5       	brne	.+96     	; 0x2870 <xQueueGenericSendFromISR+0xa2>
        {
            const int8_t cTxLock = pxQueue->cTxLock;
    2810:	eb 81       	ldd	r30, Y+3	; 0x03
    2812:	fc 81       	ldd	r31, Y+4	; 0x04
    2814:	86 8d       	ldd	r24, Z+30	; 0x1e
    2816:	8a 83       	std	Y+2, r24	; 0x02
            const UBaseType_t uxPreviousMessagesWaiting = pxQueue->uxMessagesWaiting;
    2818:	eb 81       	ldd	r30, Y+3	; 0x03
    281a:	fc 81       	ldd	r31, Y+4	; 0x04
    281c:	82 8d       	ldd	r24, Z+26	; 0x1a
    281e:	89 83       	std	Y+1, r24	; 0x01
            /* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
             *  semaphore or mutex.  That means prvCopyDataToQueue() cannot result
             *  in a task disinheriting a priority and prvCopyDataToQueue() can be
             *  called here even though the disinherit function does not check if
             *  the scheduler is suspended before accessing the ready lists. */
            ( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    2820:	8b 81       	ldd	r24, Y+3	; 0x03
    2822:	9c 81       	ldd	r25, Y+4	; 0x04
    2824:	29 85       	ldd	r18, Y+9	; 0x09
    2826:	3a 85       	ldd	r19, Y+10	; 0x0a
    2828:	b9 01       	movw	r22, r18
    282a:	4d 85       	ldd	r20, Y+13	; 0x0d
    282c:	0e 94 91 17 	call	0x2f22	; 0x2f22 <prvCopyDataToQueue>

            /* The event list is not altered if the queue is locked.  This will
             * be done when the queue is unlocked later. */
            if( cTxLock == queueUNLOCKED )
    2830:	8a 81       	ldd	r24, Y+2	; 0x02
    2832:	8f 3f       	cpi	r24, 0xFF	; 255
    2834:	a9 f4       	brne	.+42     	; 0x2860 <xQueueGenericSendFromISR+0x92>
                            }
                        }
                    }
                #else /* configUSE_QUEUE_SETS */
                    {
                        if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    2836:	eb 81       	ldd	r30, Y+3	; 0x03
    2838:	fc 81       	ldd	r31, Y+4	; 0x04
    283a:	81 89       	ldd	r24, Z+17	; 0x11
    283c:	88 23       	and	r24, r24
    283e:	a9 f0       	breq	.+42     	; 0x286a <xQueueGenericSendFromISR+0x9c>
                        {
                            if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    2840:	8b 81       	ldd	r24, Y+3	; 0x03
    2842:	9c 81       	ldd	r25, Y+4	; 0x04
    2844:	41 96       	adiw	r24, 0x11	; 17
    2846:	0e 94 4e 23 	call	0x469c	; 0x469c <xTaskRemoveFromEventList>
    284a:	88 23       	and	r24, r24
    284c:	71 f0       	breq	.+28     	; 0x286a <xQueueGenericSendFromISR+0x9c>
                            {
                                /* The task waiting has a higher priority so record that a
                                 * context switch is required. */
                                if( pxHigherPriorityTaskWoken != NULL )
    284e:	8b 85       	ldd	r24, Y+11	; 0x0b
    2850:	9c 85       	ldd	r25, Y+12	; 0x0c
    2852:	00 97       	sbiw	r24, 0x00	; 0
    2854:	51 f0       	breq	.+20     	; 0x286a <xQueueGenericSendFromISR+0x9c>
                                {
                                    *pxHigherPriorityTaskWoken = pdTRUE;
    2856:	eb 85       	ldd	r30, Y+11	; 0x0b
    2858:	fc 85       	ldd	r31, Y+12	; 0x0c
    285a:	81 e0       	ldi	r24, 0x01	; 1
    285c:	80 83       	st	Z, r24
    285e:	05 c0       	rjmp	.+10     	; 0x286a <xQueueGenericSendFromISR+0x9c>
            {
                /* Increment the lock count so the task that unlocks the queue
                 * knows that data was posted while it was locked. */
                configASSERT( cTxLock != queueINT8_MAX );

                pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    2860:	8a 81       	ldd	r24, Y+2	; 0x02
    2862:	8f 5f       	subi	r24, 0xFF	; 255
    2864:	eb 81       	ldd	r30, Y+3	; 0x03
    2866:	fc 81       	ldd	r31, Y+4	; 0x04
    2868:	86 8f       	std	Z+30, r24	; 0x1e
            }

            xReturn = pdPASS;
    286a:	81 e0       	ldi	r24, 0x01	; 1
    286c:	8e 83       	std	Y+6, r24	; 0x06
    286e:	01 c0       	rjmp	.+2      	; 0x2872 <xQueueGenericSendFromISR+0xa4>
        }
        else
        {
            traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
            xReturn = errQUEUE_FULL;
    2870:	1e 82       	std	Y+6, r1	; 0x06
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
    2872:	8e 81       	ldd	r24, Y+6	; 0x06
}
    2874:	2d 96       	adiw	r28, 0x0d	; 13
    2876:	0f b6       	in	r0, 0x3f	; 63
    2878:	f8 94       	cli
    287a:	de bf       	out	0x3e, r29	; 62
    287c:	0f be       	out	0x3f, r0	; 63
    287e:	cd bf       	out	0x3d, r28	; 61
    2880:	cf 91       	pop	r28
    2882:	df 91       	pop	r29
    2884:	08 95       	ret

00002886 <xQueueGiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue,
                              BaseType_t * const pxHigherPriorityTaskWoken )
{
    2886:	df 93       	push	r29
    2888:	cf 93       	push	r28
    288a:	cd b7       	in	r28, 0x3d	; 61
    288c:	de b7       	in	r29, 0x3e	; 62
    288e:	2a 97       	sbiw	r28, 0x0a	; 10
    2890:	0f b6       	in	r0, 0x3f	; 63
    2892:	f8 94       	cli
    2894:	de bf       	out	0x3e, r29	; 62
    2896:	0f be       	out	0x3f, r0	; 63
    2898:	cd bf       	out	0x3d, r28	; 61
    289a:	98 87       	std	Y+8, r25	; 0x08
    289c:	8f 83       	std	Y+7, r24	; 0x07
    289e:	7a 87       	std	Y+10, r23	; 0x0a
    28a0:	69 87       	std	Y+9, r22	; 0x09
    BaseType_t xReturn;
    UBaseType_t uxSavedInterruptStatus;
    Queue_t * const pxQueue = xQueue;
    28a2:	8f 81       	ldd	r24, Y+7	; 0x07
    28a4:	98 85       	ldd	r25, Y+8	; 0x08
    28a6:	9c 83       	std	Y+4, r25	; 0x04
    28a8:	8b 83       	std	Y+3, r24	; 0x03
     * safe API to ensure interrupt entry is as fast and as simple as possible.
     * More information (albeit Cortex-M specific) is provided on the following
     * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    28aa:	1d 82       	std	Y+5, r1	; 0x05
    {
        const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    28ac:	eb 81       	ldd	r30, Y+3	; 0x03
    28ae:	fc 81       	ldd	r31, Y+4	; 0x04
    28b0:	82 8d       	ldd	r24, Z+26	; 0x1a
    28b2:	8a 83       	std	Y+2, r24	; 0x02

        /* When the queue is used to implement a semaphore no data is ever
         * moved through the queue but it is still valid to see if the queue 'has
         * space'. */
        if( uxMessagesWaiting < pxQueue->uxLength )
    28b4:	eb 81       	ldd	r30, Y+3	; 0x03
    28b6:	fc 81       	ldd	r31, Y+4	; 0x04
    28b8:	93 8d       	ldd	r25, Z+27	; 0x1b
    28ba:	8a 81       	ldd	r24, Y+2	; 0x02
    28bc:	89 17       	cp	r24, r25
    28be:	48 f5       	brcc	.+82     	; 0x2912 <xQueueGiveFromISR+0x8c>
        {
            const int8_t cTxLock = pxQueue->cTxLock;
    28c0:	eb 81       	ldd	r30, Y+3	; 0x03
    28c2:	fc 81       	ldd	r31, Y+4	; 0x04
    28c4:	86 8d       	ldd	r24, Z+30	; 0x1e
    28c6:	89 83       	std	Y+1, r24	; 0x01
             * holder - and if there is a mutex holder then the mutex cannot be
             * given from an ISR.  As this is the ISR version of the function it
             * can be assumed there is no mutex holder and no need to determine if
             * priority disinheritance is needed.  Simply increase the count of
             * messages (semaphores) available. */
            pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
    28c8:	8a 81       	ldd	r24, Y+2	; 0x02
    28ca:	8f 5f       	subi	r24, 0xFF	; 255
    28cc:	eb 81       	ldd	r30, Y+3	; 0x03
    28ce:	fc 81       	ldd	r31, Y+4	; 0x04
    28d0:	82 8f       	std	Z+26, r24	; 0x1a

            /* The event list is not altered if the queue is locked.  This will
             * be done when the queue is unlocked later. */
            if( cTxLock == queueUNLOCKED )
    28d2:	89 81       	ldd	r24, Y+1	; 0x01
    28d4:	8f 3f       	cpi	r24, 0xFF	; 255
    28d6:	a9 f4       	brne	.+42     	; 0x2902 <xQueueGiveFromISR+0x7c>
                            }
                        }
                    }
                #else /* configUSE_QUEUE_SETS */
                    {
                        if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    28d8:	eb 81       	ldd	r30, Y+3	; 0x03
    28da:	fc 81       	ldd	r31, Y+4	; 0x04
    28dc:	81 89       	ldd	r24, Z+17	; 0x11
    28de:	88 23       	and	r24, r24
    28e0:	a9 f0       	breq	.+42     	; 0x290c <xQueueGiveFromISR+0x86>
                        {
                            if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    28e2:	8b 81       	ldd	r24, Y+3	; 0x03
    28e4:	9c 81       	ldd	r25, Y+4	; 0x04
    28e6:	41 96       	adiw	r24, 0x11	; 17
    28e8:	0e 94 4e 23 	call	0x469c	; 0x469c <xTaskRemoveFromEventList>
    28ec:	88 23       	and	r24, r24
    28ee:	71 f0       	breq	.+28     	; 0x290c <xQueueGiveFromISR+0x86>
                            {
                                /* The task waiting has a higher priority so record that a
                                 * context switch is required. */
                                if( pxHigherPriorityTaskWoken != NULL )
    28f0:	89 85       	ldd	r24, Y+9	; 0x09
    28f2:	9a 85       	ldd	r25, Y+10	; 0x0a
    28f4:	00 97       	sbiw	r24, 0x00	; 0
    28f6:	51 f0       	breq	.+20     	; 0x290c <xQueueGiveFromISR+0x86>
                                {
                                    *pxHigherPriorityTaskWoken = pdTRUE;
    28f8:	e9 85       	ldd	r30, Y+9	; 0x09
    28fa:	fa 85       	ldd	r31, Y+10	; 0x0a
    28fc:	81 e0       	ldi	r24, 0x01	; 1
    28fe:	80 83       	st	Z, r24
    2900:	05 c0       	rjmp	.+10     	; 0x290c <xQueueGiveFromISR+0x86>
            {
                /* Increment the lock count so the task that unlocks the queue
                 * knows that data was posted while it was locked. */
                configASSERT( cTxLock != queueINT8_MAX );

                pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    2902:	89 81       	ldd	r24, Y+1	; 0x01
    2904:	8f 5f       	subi	r24, 0xFF	; 255
    2906:	eb 81       	ldd	r30, Y+3	; 0x03
    2908:	fc 81       	ldd	r31, Y+4	; 0x04
    290a:	86 8f       	std	Z+30, r24	; 0x1e
            }

            xReturn = pdPASS;
    290c:	81 e0       	ldi	r24, 0x01	; 1
    290e:	8e 83       	std	Y+6, r24	; 0x06
    2910:	01 c0       	rjmp	.+2      	; 0x2914 <xQueueGiveFromISR+0x8e>
        }
        else
        {
            traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
            xReturn = errQUEUE_FULL;
    2912:	1e 82       	std	Y+6, r1	; 0x06
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
    2914:	8e 81       	ldd	r24, Y+6	; 0x06
}
    2916:	2a 96       	adiw	r28, 0x0a	; 10
    2918:	0f b6       	in	r0, 0x3f	; 63
    291a:	f8 94       	cli
    291c:	de bf       	out	0x3e, r29	; 62
    291e:	0f be       	out	0x3f, r0	; 63
    2920:	cd bf       	out	0x3d, r28	; 61
    2922:	cf 91       	pop	r28
    2924:	df 91       	pop	r29
    2926:	08 95       	ret

00002928 <xQueueReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceive( QueueHandle_t xQueue,
                          void * const pvBuffer,
                          TickType_t xTicksToWait )
{
    2928:	df 93       	push	r29
    292a:	cf 93       	push	r28
    292c:	cd b7       	in	r28, 0x3d	; 61
    292e:	de b7       	in	r29, 0x3e	; 62
    2930:	2e 97       	sbiw	r28, 0x0e	; 14
    2932:	0f b6       	in	r0, 0x3f	; 63
    2934:	f8 94       	cli
    2936:	de bf       	out	0x3e, r29	; 62
    2938:	0f be       	out	0x3f, r0	; 63
    293a:	cd bf       	out	0x3d, r28	; 61
    293c:	99 87       	std	Y+9, r25	; 0x09
    293e:	88 87       	std	Y+8, r24	; 0x08
    2940:	7b 87       	std	Y+11, r23	; 0x0b
    2942:	6a 87       	std	Y+10, r22	; 0x0a
    2944:	5d 87       	std	Y+13, r21	; 0x0d
    2946:	4c 87       	std	Y+12, r20	; 0x0c
    BaseType_t xEntryTimeSet = pdFALSE;
    2948:	1c 82       	std	Y+4, r1	; 0x04
    TimeOut_t xTimeOut;
    Queue_t * const pxQueue = xQueue;
    294a:	88 85       	ldd	r24, Y+8	; 0x08
    294c:	99 85       	ldd	r25, Y+9	; 0x09
    294e:	9b 83       	std	Y+3, r25	; 0x03
    2950:	8a 83       	std	Y+2, r24	; 0x02
    /*lint -save -e904  This function relaxes the coding standard somewhat to
     * allow return statements within the function itself.  This is done in the
     * interest of execution time efficiency. */
    for( ; ; )
    {
        taskENTER_CRITICAL();
    2952:	0f b6       	in	r0, 0x3f	; 63
    2954:	f8 94       	cli
    2956:	0f 92       	push	r0
        {
            const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    2958:	ea 81       	ldd	r30, Y+2	; 0x02
    295a:	fb 81       	ldd	r31, Y+3	; 0x03
    295c:	82 8d       	ldd	r24, Z+26	; 0x1a
    295e:	89 83       	std	Y+1, r24	; 0x01

            /* Is there data in the queue now?  To be running the calling task
             * must be the highest priority task wanting to access the queue. */
            if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    2960:	89 81       	ldd	r24, Y+1	; 0x01
    2962:	88 23       	and	r24, r24
    2964:	f9 f0       	breq	.+62     	; 0x29a4 <xQueueReceive+0x7c>
            {
                /* Data available, remove one item. */
                prvCopyDataFromQueue( pxQueue, pvBuffer );
    2966:	8a 81       	ldd	r24, Y+2	; 0x02
    2968:	9b 81       	ldd	r25, Y+3	; 0x03
    296a:	2a 85       	ldd	r18, Y+10	; 0x0a
    296c:	3b 85       	ldd	r19, Y+11	; 0x0b
    296e:	b9 01       	movw	r22, r18
    2970:	0e 94 37 18 	call	0x306e	; 0x306e <prvCopyDataFromQueue>
                traceQUEUE_RECEIVE( pxQueue );
                pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
    2974:	89 81       	ldd	r24, Y+1	; 0x01
    2976:	81 50       	subi	r24, 0x01	; 1
    2978:	ea 81       	ldd	r30, Y+2	; 0x02
    297a:	fb 81       	ldd	r31, Y+3	; 0x03
    297c:	82 8f       	std	Z+26, r24	; 0x1a

                /* There is now space in the queue, were any tasks waiting to
                 * post to the queue?  If so, unblock the highest priority waiting
                 * task. */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    297e:	ea 81       	ldd	r30, Y+2	; 0x02
    2980:	fb 81       	ldd	r31, Y+3	; 0x03
    2982:	80 85       	ldd	r24, Z+8	; 0x08
    2984:	88 23       	and	r24, r24
    2986:	49 f0       	breq	.+18     	; 0x299a <xQueueReceive+0x72>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    2988:	8a 81       	ldd	r24, Y+2	; 0x02
    298a:	9b 81       	ldd	r25, Y+3	; 0x03
    298c:	08 96       	adiw	r24, 0x08	; 8
    298e:	0e 94 4e 23 	call	0x469c	; 0x469c <xTaskRemoveFromEventList>
    2992:	88 23       	and	r24, r24
    2994:	11 f0       	breq	.+4      	; 0x299a <xQueueReceive+0x72>
                    {
                        queueYIELD_IF_USING_PREEMPTION();
    2996:	0e 94 72 09 	call	0x12e4	; 0x12e4 <vPortYield>
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                taskEXIT_CRITICAL();
    299a:	0f 90       	pop	r0
    299c:	0f be       	out	0x3f, r0	; 63
                return pdPASS;
    299e:	81 e0       	ldi	r24, 0x01	; 1
    29a0:	8e 87       	std	Y+14, r24	; 0x0e
    29a2:	63 c0       	rjmp	.+198    	; 0x2a6a <xQueueReceive+0x142>
            }
            else
            {
                if( xTicksToWait == ( TickType_t ) 0 )
    29a4:	8c 85       	ldd	r24, Y+12	; 0x0c
    29a6:	9d 85       	ldd	r25, Y+13	; 0x0d
    29a8:	00 97       	sbiw	r24, 0x00	; 0
    29aa:	21 f4       	brne	.+8      	; 0x29b4 <xQueueReceive+0x8c>
                {
                    /* The queue was empty and no block time is specified (or
                     * the block time has expired) so leave now. */
                    taskEXIT_CRITICAL();
    29ac:	0f 90       	pop	r0
    29ae:	0f be       	out	0x3f, r0	; 63
                    traceQUEUE_RECEIVE_FAILED( pxQueue );
                    return errQUEUE_EMPTY;
    29b0:	1e 86       	std	Y+14, r1	; 0x0e
    29b2:	5b c0       	rjmp	.+182    	; 0x2a6a <xQueueReceive+0x142>
                }
                else if( xEntryTimeSet == pdFALSE )
    29b4:	8c 81       	ldd	r24, Y+4	; 0x04
    29b6:	88 23       	and	r24, r24
    29b8:	31 f4       	brne	.+12     	; 0x29c6 <xQueueReceive+0x9e>
                {
                    /* The queue was empty and a block time was specified so
                     * configure the timeout structure. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
    29ba:	ce 01       	movw	r24, r28
    29bc:	05 96       	adiw	r24, 0x05	; 5
    29be:	0e 94 be 25 	call	0x4b7c	; 0x4b7c <vTaskInternalSetTimeOutState>
                    xEntryTimeSet = pdTRUE;
    29c2:	81 e0       	ldi	r24, 0x01	; 1
    29c4:	8c 83       	std	Y+4, r24	; 0x04
                    /* Entry time was already set. */
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        taskEXIT_CRITICAL();
    29c6:	0f 90       	pop	r0
    29c8:	0f be       	out	0x3f, r0	; 63

        /* Interrupts and other tasks can send to and receive from the queue
         * now the critical section has been exited. */

        vTaskSuspendAll();
    29ca:	0e 94 88 1e 	call	0x3d10	; 0x3d10 <vTaskSuspendAll>
        prvLockQueue( pxQueue );
    29ce:	0f b6       	in	r0, 0x3f	; 63
    29d0:	f8 94       	cli
    29d2:	0f 92       	push	r0
    29d4:	ea 81       	ldd	r30, Y+2	; 0x02
    29d6:	fb 81       	ldd	r31, Y+3	; 0x03
    29d8:	85 8d       	ldd	r24, Z+29	; 0x1d
    29da:	8f 3f       	cpi	r24, 0xFF	; 255
    29dc:	19 f4       	brne	.+6      	; 0x29e4 <xQueueReceive+0xbc>
    29de:	ea 81       	ldd	r30, Y+2	; 0x02
    29e0:	fb 81       	ldd	r31, Y+3	; 0x03
    29e2:	15 8e       	std	Z+29, r1	; 0x1d
    29e4:	ea 81       	ldd	r30, Y+2	; 0x02
    29e6:	fb 81       	ldd	r31, Y+3	; 0x03
    29e8:	86 8d       	ldd	r24, Z+30	; 0x1e
    29ea:	8f 3f       	cpi	r24, 0xFF	; 255
    29ec:	19 f4       	brne	.+6      	; 0x29f4 <xQueueReceive+0xcc>
    29ee:	ea 81       	ldd	r30, Y+2	; 0x02
    29f0:	fb 81       	ldd	r31, Y+3	; 0x03
    29f2:	16 8e       	std	Z+30, r1	; 0x1e
    29f4:	0f 90       	pop	r0
    29f6:	0f be       	out	0x3f, r0	; 63

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    29f8:	ce 01       	movw	r24, r28
    29fa:	05 96       	adiw	r24, 0x05	; 5
    29fc:	9e 01       	movw	r18, r28
    29fe:	24 5f       	subi	r18, 0xF4	; 244
    2a00:	3f 4f       	sbci	r19, 0xFF	; 255
    2a02:	b9 01       	movw	r22, r18
    2a04:	0e 94 d7 25 	call	0x4bae	; 0x4bae <xTaskCheckForTimeOut>
    2a08:	88 23       	and	r24, r24
    2a0a:	09 f5       	brne	.+66     	; 0x2a4e <xQueueReceive+0x126>
        {
            /* The timeout has not expired.  If the queue is still empty place
             * the task on the list of tasks waiting to receive from the queue. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    2a0c:	8a 81       	ldd	r24, Y+2	; 0x02
    2a0e:	9b 81       	ldd	r25, Y+3	; 0x03
    2a10:	0e 94 d1 18 	call	0x31a2	; 0x31a2 <prvIsQueueEmpty>
    2a14:	88 23       	and	r24, r24
    2a16:	a1 f0       	breq	.+40     	; 0x2a40 <xQueueReceive+0x118>
            {
                traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    2a18:	8a 81       	ldd	r24, Y+2	; 0x02
    2a1a:	9b 81       	ldd	r25, Y+3	; 0x03
    2a1c:	41 96       	adiw	r24, 0x11	; 17
    2a1e:	2c 85       	ldd	r18, Y+12	; 0x0c
    2a20:	3d 85       	ldd	r19, Y+13	; 0x0d
    2a22:	b9 01       	movw	r22, r18
    2a24:	0e 94 65 22 	call	0x44ca	; 0x44ca <vTaskPlaceOnEventList>
                prvUnlockQueue( pxQueue );
    2a28:	8a 81       	ldd	r24, Y+2	; 0x02
    2a2a:	9b 81       	ldd	r25, Y+3	; 0x03
    2a2c:	0e 94 7e 18 	call	0x30fc	; 0x30fc <prvUnlockQueue>

                if( xTaskResumeAll() == pdFALSE )
    2a30:	0e 94 94 1e 	call	0x3d28	; 0x3d28 <xTaskResumeAll>
    2a34:	88 23       	and	r24, r24
    2a36:	09 f0       	breq	.+2      	; 0x2a3a <xQueueReceive+0x112>
    2a38:	8c cf       	rjmp	.-232    	; 0x2952 <xQueueReceive+0x2a>
                {
                    portYIELD_WITHIN_API();
    2a3a:	0e 94 72 09 	call	0x12e4	; 0x12e4 <vPortYield>
    2a3e:	89 cf       	rjmp	.-238    	; 0x2952 <xQueueReceive+0x2a>
            }
            else
            {
                /* The queue contains data again.  Loop back to try and read the
                 * data. */
                prvUnlockQueue( pxQueue );
    2a40:	8a 81       	ldd	r24, Y+2	; 0x02
    2a42:	9b 81       	ldd	r25, Y+3	; 0x03
    2a44:	0e 94 7e 18 	call	0x30fc	; 0x30fc <prvUnlockQueue>
                ( void ) xTaskResumeAll();
    2a48:	0e 94 94 1e 	call	0x3d28	; 0x3d28 <xTaskResumeAll>
    2a4c:	82 cf       	rjmp	.-252    	; 0x2952 <xQueueReceive+0x2a>
        }
        else
        {
            /* Timed out.  If there is no data in the queue exit, otherwise loop
             * back and attempt to read the data. */
            prvUnlockQueue( pxQueue );
    2a4e:	8a 81       	ldd	r24, Y+2	; 0x02
    2a50:	9b 81       	ldd	r25, Y+3	; 0x03
    2a52:	0e 94 7e 18 	call	0x30fc	; 0x30fc <prvUnlockQueue>
            ( void ) xTaskResumeAll();
    2a56:	0e 94 94 1e 	call	0x3d28	; 0x3d28 <xTaskResumeAll>

            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    2a5a:	8a 81       	ldd	r24, Y+2	; 0x02
    2a5c:	9b 81       	ldd	r25, Y+3	; 0x03
    2a5e:	0e 94 d1 18 	call	0x31a2	; 0x31a2 <prvIsQueueEmpty>
    2a62:	88 23       	and	r24, r24
    2a64:	09 f4       	brne	.+2      	; 0x2a68 <xQueueReceive+0x140>
    2a66:	75 cf       	rjmp	.-278    	; 0x2952 <xQueueReceive+0x2a>
            {
                traceQUEUE_RECEIVE_FAILED( pxQueue );
                return errQUEUE_EMPTY;
    2a68:	1e 86       	std	Y+14, r1	; 0x0e
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
    } /*lint -restore */
    2a6a:	8e 85       	ldd	r24, Y+14	; 0x0e
}
    2a6c:	2e 96       	adiw	r28, 0x0e	; 14
    2a6e:	0f b6       	in	r0, 0x3f	; 63
    2a70:	f8 94       	cli
    2a72:	de bf       	out	0x3e, r29	; 62
    2a74:	0f be       	out	0x3f, r0	; 63
    2a76:	cd bf       	out	0x3d, r28	; 61
    2a78:	cf 91       	pop	r28
    2a7a:	df 91       	pop	r29
    2a7c:	08 95       	ret

00002a7e <xQueueSemaphoreTake>:
/*-----------------------------------------------------------*/

BaseType_t xQueueSemaphoreTake( QueueHandle_t xQueue,
                                TickType_t xTicksToWait )
{
    2a7e:	df 93       	push	r29
    2a80:	cf 93       	push	r28
    2a82:	cd b7       	in	r28, 0x3d	; 61
    2a84:	de b7       	in	r29, 0x3e	; 62
    2a86:	2c 97       	sbiw	r28, 0x0c	; 12
    2a88:	0f b6       	in	r0, 0x3f	; 63
    2a8a:	f8 94       	cli
    2a8c:	de bf       	out	0x3e, r29	; 62
    2a8e:	0f be       	out	0x3f, r0	; 63
    2a90:	cd bf       	out	0x3d, r28	; 61
    2a92:	99 87       	std	Y+9, r25	; 0x09
    2a94:	88 87       	std	Y+8, r24	; 0x08
    2a96:	7b 87       	std	Y+11, r23	; 0x0b
    2a98:	6a 87       	std	Y+10, r22	; 0x0a
    BaseType_t xEntryTimeSet = pdFALSE;
    2a9a:	1c 82       	std	Y+4, r1	; 0x04
    TimeOut_t xTimeOut;
    Queue_t * const pxQueue = xQueue;
    2a9c:	88 85       	ldd	r24, Y+8	; 0x08
    2a9e:	99 85       	ldd	r25, Y+9	; 0x09
    2aa0:	9b 83       	std	Y+3, r25	; 0x03
    2aa2:	8a 83       	std	Y+2, r24	; 0x02
    /*lint -save -e904 This function relaxes the coding standard somewhat to allow return
     * statements within the function itself.  This is done in the interest
     * of execution time efficiency. */
    for( ; ; )
    {
        taskENTER_CRITICAL();
    2aa4:	0f b6       	in	r0, 0x3f	; 63
    2aa6:	f8 94       	cli
    2aa8:	0f 92       	push	r0
        {
            /* Semaphores are queues with an item size of 0, and where the
             * number of messages in the queue is the semaphore's count value. */
            const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;
    2aaa:	ea 81       	ldd	r30, Y+2	; 0x02
    2aac:	fb 81       	ldd	r31, Y+3	; 0x03
    2aae:	82 8d       	ldd	r24, Z+26	; 0x1a
    2ab0:	89 83       	std	Y+1, r24	; 0x01

            /* Is there data in the queue now?  To be running the calling task
             * must be the highest priority task wanting to access the queue. */
            if( uxSemaphoreCount > ( UBaseType_t ) 0 )
    2ab2:	89 81       	ldd	r24, Y+1	; 0x01
    2ab4:	88 23       	and	r24, r24
    2ab6:	c1 f0       	breq	.+48     	; 0x2ae8 <xQueueSemaphoreTake+0x6a>
            {
                traceQUEUE_RECEIVE( pxQueue );

                /* Semaphores are queues with a data size of zero and where the
                 * messages waiting is the semaphore's count.  Reduce the count. */
                pxQueue->uxMessagesWaiting = uxSemaphoreCount - ( UBaseType_t ) 1;
    2ab8:	89 81       	ldd	r24, Y+1	; 0x01
    2aba:	81 50       	subi	r24, 0x01	; 1
    2abc:	ea 81       	ldd	r30, Y+2	; 0x02
    2abe:	fb 81       	ldd	r31, Y+3	; 0x03
    2ac0:	82 8f       	std	Z+26, r24	; 0x1a
                    }
                #endif /* configUSE_MUTEXES */

                /* Check to see if other tasks are blocked waiting to give the
                 * semaphore, and if so, unblock the highest priority such task. */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    2ac2:	ea 81       	ldd	r30, Y+2	; 0x02
    2ac4:	fb 81       	ldd	r31, Y+3	; 0x03
    2ac6:	80 85       	ldd	r24, Z+8	; 0x08
    2ac8:	88 23       	and	r24, r24
    2aca:	49 f0       	breq	.+18     	; 0x2ade <xQueueSemaphoreTake+0x60>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    2acc:	8a 81       	ldd	r24, Y+2	; 0x02
    2ace:	9b 81       	ldd	r25, Y+3	; 0x03
    2ad0:	08 96       	adiw	r24, 0x08	; 8
    2ad2:	0e 94 4e 23 	call	0x469c	; 0x469c <xTaskRemoveFromEventList>
    2ad6:	88 23       	and	r24, r24
    2ad8:	11 f0       	breq	.+4      	; 0x2ade <xQueueSemaphoreTake+0x60>
                    {
                        queueYIELD_IF_USING_PREEMPTION();
    2ada:	0e 94 72 09 	call	0x12e4	; 0x12e4 <vPortYield>
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                taskEXIT_CRITICAL();
    2ade:	0f 90       	pop	r0
    2ae0:	0f be       	out	0x3f, r0	; 63
                return pdPASS;
    2ae2:	81 e0       	ldi	r24, 0x01	; 1
    2ae4:	8c 87       	std	Y+12, r24	; 0x0c
    2ae6:	63 c0       	rjmp	.+198    	; 0x2bae <xQueueSemaphoreTake+0x130>
            }
            else
            {
                if( xTicksToWait == ( TickType_t ) 0 )
    2ae8:	8a 85       	ldd	r24, Y+10	; 0x0a
    2aea:	9b 85       	ldd	r25, Y+11	; 0x0b
    2aec:	00 97       	sbiw	r24, 0x00	; 0
    2aee:	21 f4       	brne	.+8      	; 0x2af8 <xQueueSemaphoreTake+0x7a>
                        }
                    #endif /* configUSE_MUTEXES */

                    /* The semaphore count was 0 and no block time is specified
                     * (or the block time has expired) so exit now. */
                    taskEXIT_CRITICAL();
    2af0:	0f 90       	pop	r0
    2af2:	0f be       	out	0x3f, r0	; 63
                    traceQUEUE_RECEIVE_FAILED( pxQueue );
                    return errQUEUE_EMPTY;
    2af4:	1c 86       	std	Y+12, r1	; 0x0c
    2af6:	5b c0       	rjmp	.+182    	; 0x2bae <xQueueSemaphoreTake+0x130>
                }
                else if( xEntryTimeSet == pdFALSE )
    2af8:	8c 81       	ldd	r24, Y+4	; 0x04
    2afa:	88 23       	and	r24, r24
    2afc:	31 f4       	brne	.+12     	; 0x2b0a <xQueueSemaphoreTake+0x8c>
                {
                    /* The semaphore count was 0 and a block time was specified
                     * so configure the timeout structure ready to block. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
    2afe:	ce 01       	movw	r24, r28
    2b00:	05 96       	adiw	r24, 0x05	; 5
    2b02:	0e 94 be 25 	call	0x4b7c	; 0x4b7c <vTaskInternalSetTimeOutState>
                    xEntryTimeSet = pdTRUE;
    2b06:	81 e0       	ldi	r24, 0x01	; 1
    2b08:	8c 83       	std	Y+4, r24	; 0x04
                    /* Entry time was already set. */
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        taskEXIT_CRITICAL();
    2b0a:	0f 90       	pop	r0
    2b0c:	0f be       	out	0x3f, r0	; 63

        /* Interrupts and other tasks can give to and take from the semaphore
         * now the critical section has been exited. */

        vTaskSuspendAll();
    2b0e:	0e 94 88 1e 	call	0x3d10	; 0x3d10 <vTaskSuspendAll>
        prvLockQueue( pxQueue );
    2b12:	0f b6       	in	r0, 0x3f	; 63
    2b14:	f8 94       	cli
    2b16:	0f 92       	push	r0
    2b18:	ea 81       	ldd	r30, Y+2	; 0x02
    2b1a:	fb 81       	ldd	r31, Y+3	; 0x03
    2b1c:	85 8d       	ldd	r24, Z+29	; 0x1d
    2b1e:	8f 3f       	cpi	r24, 0xFF	; 255
    2b20:	19 f4       	brne	.+6      	; 0x2b28 <xQueueSemaphoreTake+0xaa>
    2b22:	ea 81       	ldd	r30, Y+2	; 0x02
    2b24:	fb 81       	ldd	r31, Y+3	; 0x03
    2b26:	15 8e       	std	Z+29, r1	; 0x1d
    2b28:	ea 81       	ldd	r30, Y+2	; 0x02
    2b2a:	fb 81       	ldd	r31, Y+3	; 0x03
    2b2c:	86 8d       	ldd	r24, Z+30	; 0x1e
    2b2e:	8f 3f       	cpi	r24, 0xFF	; 255
    2b30:	19 f4       	brne	.+6      	; 0x2b38 <xQueueSemaphoreTake+0xba>
    2b32:	ea 81       	ldd	r30, Y+2	; 0x02
    2b34:	fb 81       	ldd	r31, Y+3	; 0x03
    2b36:	16 8e       	std	Z+30, r1	; 0x1e
    2b38:	0f 90       	pop	r0
    2b3a:	0f be       	out	0x3f, r0	; 63

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    2b3c:	ce 01       	movw	r24, r28
    2b3e:	05 96       	adiw	r24, 0x05	; 5
    2b40:	9e 01       	movw	r18, r28
    2b42:	26 5f       	subi	r18, 0xF6	; 246
    2b44:	3f 4f       	sbci	r19, 0xFF	; 255
    2b46:	b9 01       	movw	r22, r18
    2b48:	0e 94 d7 25 	call	0x4bae	; 0x4bae <xTaskCheckForTimeOut>
    2b4c:	88 23       	and	r24, r24
    2b4e:	09 f5       	brne	.+66     	; 0x2b92 <xQueueSemaphoreTake+0x114>
        {
            /* A block time is specified and not expired.  If the semaphore
             * count is 0 then enter the Blocked state to wait for a semaphore to
             * become available.  As semaphores are implemented with queues the
             * queue being empty is equivalent to the semaphore count being 0. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    2b50:	8a 81       	ldd	r24, Y+2	; 0x02
    2b52:	9b 81       	ldd	r25, Y+3	; 0x03
    2b54:	0e 94 d1 18 	call	0x31a2	; 0x31a2 <prvIsQueueEmpty>
    2b58:	88 23       	and	r24, r24
    2b5a:	a1 f0       	breq	.+40     	; 0x2b84 <xQueueSemaphoreTake+0x106>
                            mtCOVERAGE_TEST_MARKER();
                        }
                    }
                #endif /* if ( configUSE_MUTEXES == 1 ) */

                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    2b5c:	8a 81       	ldd	r24, Y+2	; 0x02
    2b5e:	9b 81       	ldd	r25, Y+3	; 0x03
    2b60:	41 96       	adiw	r24, 0x11	; 17
    2b62:	2a 85       	ldd	r18, Y+10	; 0x0a
    2b64:	3b 85       	ldd	r19, Y+11	; 0x0b
    2b66:	b9 01       	movw	r22, r18
    2b68:	0e 94 65 22 	call	0x44ca	; 0x44ca <vTaskPlaceOnEventList>
                prvUnlockQueue( pxQueue );
    2b6c:	8a 81       	ldd	r24, Y+2	; 0x02
    2b6e:	9b 81       	ldd	r25, Y+3	; 0x03
    2b70:	0e 94 7e 18 	call	0x30fc	; 0x30fc <prvUnlockQueue>

                if( xTaskResumeAll() == pdFALSE )
    2b74:	0e 94 94 1e 	call	0x3d28	; 0x3d28 <xTaskResumeAll>
    2b78:	88 23       	and	r24, r24
    2b7a:	09 f0       	breq	.+2      	; 0x2b7e <xQueueSemaphoreTake+0x100>
    2b7c:	93 cf       	rjmp	.-218    	; 0x2aa4 <xQueueSemaphoreTake+0x26>
                {
                    portYIELD_WITHIN_API();
    2b7e:	0e 94 72 09 	call	0x12e4	; 0x12e4 <vPortYield>
    2b82:	90 cf       	rjmp	.-224    	; 0x2aa4 <xQueueSemaphoreTake+0x26>
            }
            else
            {
                /* There was no timeout and the semaphore count was not 0, so
                 * attempt to take the semaphore again. */
                prvUnlockQueue( pxQueue );
    2b84:	8a 81       	ldd	r24, Y+2	; 0x02
    2b86:	9b 81       	ldd	r25, Y+3	; 0x03
    2b88:	0e 94 7e 18 	call	0x30fc	; 0x30fc <prvUnlockQueue>
                ( void ) xTaskResumeAll();
    2b8c:	0e 94 94 1e 	call	0x3d28	; 0x3d28 <xTaskResumeAll>
    2b90:	89 cf       	rjmp	.-238    	; 0x2aa4 <xQueueSemaphoreTake+0x26>
            }
        }
        else
        {
            /* Timed out. */
            prvUnlockQueue( pxQueue );
    2b92:	8a 81       	ldd	r24, Y+2	; 0x02
    2b94:	9b 81       	ldd	r25, Y+3	; 0x03
    2b96:	0e 94 7e 18 	call	0x30fc	; 0x30fc <prvUnlockQueue>
            ( void ) xTaskResumeAll();
    2b9a:	0e 94 94 1e 	call	0x3d28	; 0x3d28 <xTaskResumeAll>

            /* If the semaphore count is 0 exit now as the timeout has
             * expired.  Otherwise return to attempt to take the semaphore that is
             * known to be available.  As semaphores are implemented by queues the
             * queue being empty is equivalent to the semaphore count being 0. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    2b9e:	8a 81       	ldd	r24, Y+2	; 0x02
    2ba0:	9b 81       	ldd	r25, Y+3	; 0x03
    2ba2:	0e 94 d1 18 	call	0x31a2	; 0x31a2 <prvIsQueueEmpty>
    2ba6:	88 23       	and	r24, r24
    2ba8:	09 f4       	brne	.+2      	; 0x2bac <xQueueSemaphoreTake+0x12e>
    2baa:	7c cf       	rjmp	.-264    	; 0x2aa4 <xQueueSemaphoreTake+0x26>
                        }
                    }
                #endif /* configUSE_MUTEXES */

                traceQUEUE_RECEIVE_FAILED( pxQueue );
                return errQUEUE_EMPTY;
    2bac:	1c 86       	std	Y+12, r1	; 0x0c
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
    } /*lint -restore */
    2bae:	8c 85       	ldd	r24, Y+12	; 0x0c
}
    2bb0:	2c 96       	adiw	r28, 0x0c	; 12
    2bb2:	0f b6       	in	r0, 0x3f	; 63
    2bb4:	f8 94       	cli
    2bb6:	de bf       	out	0x3e, r29	; 62
    2bb8:	0f be       	out	0x3f, r0	; 63
    2bba:	cd bf       	out	0x3d, r28	; 61
    2bbc:	cf 91       	pop	r28
    2bbe:	df 91       	pop	r29
    2bc0:	08 95       	ret

00002bc2 <xQueuePeek>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeek( QueueHandle_t xQueue,
                       void * const pvBuffer,
                       TickType_t xTicksToWait )
{
    2bc2:	df 93       	push	r29
    2bc4:	cf 93       	push	r28
    2bc6:	cd b7       	in	r28, 0x3d	; 61
    2bc8:	de b7       	in	r29, 0x3e	; 62
    2bca:	60 97       	sbiw	r28, 0x10	; 16
    2bcc:	0f b6       	in	r0, 0x3f	; 63
    2bce:	f8 94       	cli
    2bd0:	de bf       	out	0x3e, r29	; 62
    2bd2:	0f be       	out	0x3f, r0	; 63
    2bd4:	cd bf       	out	0x3d, r28	; 61
    2bd6:	9b 87       	std	Y+11, r25	; 0x0b
    2bd8:	8a 87       	std	Y+10, r24	; 0x0a
    2bda:	7d 87       	std	Y+13, r23	; 0x0d
    2bdc:	6c 87       	std	Y+12, r22	; 0x0c
    2bde:	5f 87       	std	Y+15, r21	; 0x0f
    2be0:	4e 87       	std	Y+14, r20	; 0x0e
    BaseType_t xEntryTimeSet = pdFALSE;
    2be2:	1e 82       	std	Y+6, r1	; 0x06
    TimeOut_t xTimeOut;
    int8_t * pcOriginalReadPosition;
    Queue_t * const pxQueue = xQueue;
    2be4:	8a 85       	ldd	r24, Y+10	; 0x0a
    2be6:	9b 85       	ldd	r25, Y+11	; 0x0b
    2be8:	9b 83       	std	Y+3, r25	; 0x03
    2bea:	8a 83       	std	Y+2, r24	; 0x02
    /*lint -save -e904  This function relaxes the coding standard somewhat to
     * allow return statements within the function itself.  This is done in the
     * interest of execution time efficiency. */
    for( ; ; )
    {
        taskENTER_CRITICAL();
    2bec:	0f b6       	in	r0, 0x3f	; 63
    2bee:	f8 94       	cli
    2bf0:	0f 92       	push	r0
        {
            const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    2bf2:	ea 81       	ldd	r30, Y+2	; 0x02
    2bf4:	fb 81       	ldd	r31, Y+3	; 0x03
    2bf6:	82 8d       	ldd	r24, Z+26	; 0x1a
    2bf8:	89 83       	std	Y+1, r24	; 0x01

            /* Is there data in the queue now?  To be running the calling task
             * must be the highest priority task wanting to access the queue. */
            if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    2bfa:	89 81       	ldd	r24, Y+1	; 0x01
    2bfc:	88 23       	and	r24, r24
    2bfe:	31 f1       	breq	.+76     	; 0x2c4c <xQueuePeek+0x8a>
            {
                /* Remember the read position so it can be reset after the data
                 * is read from the queue as this function is only peeking the
                 * data, not removing it. */
                pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
    2c00:	ea 81       	ldd	r30, Y+2	; 0x02
    2c02:	fb 81       	ldd	r31, Y+3	; 0x03
    2c04:	86 81       	ldd	r24, Z+6	; 0x06
    2c06:	97 81       	ldd	r25, Z+7	; 0x07
    2c08:	9d 83       	std	Y+5, r25	; 0x05
    2c0a:	8c 83       	std	Y+4, r24	; 0x04

                prvCopyDataFromQueue( pxQueue, pvBuffer );
    2c0c:	8a 81       	ldd	r24, Y+2	; 0x02
    2c0e:	9b 81       	ldd	r25, Y+3	; 0x03
    2c10:	2c 85       	ldd	r18, Y+12	; 0x0c
    2c12:	3d 85       	ldd	r19, Y+13	; 0x0d
    2c14:	b9 01       	movw	r22, r18
    2c16:	0e 94 37 18 	call	0x306e	; 0x306e <prvCopyDataFromQueue>
                traceQUEUE_PEEK( pxQueue );

                /* The data is not being removed, so reset the read pointer. */
                pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
    2c1a:	ea 81       	ldd	r30, Y+2	; 0x02
    2c1c:	fb 81       	ldd	r31, Y+3	; 0x03
    2c1e:	8c 81       	ldd	r24, Y+4	; 0x04
    2c20:	9d 81       	ldd	r25, Y+5	; 0x05
    2c22:	97 83       	std	Z+7, r25	; 0x07
    2c24:	86 83       	std	Z+6, r24	; 0x06

                /* The data is being left in the queue, so see if there are
                 * any other tasks waiting for the data. */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    2c26:	ea 81       	ldd	r30, Y+2	; 0x02
    2c28:	fb 81       	ldd	r31, Y+3	; 0x03
    2c2a:	81 89       	ldd	r24, Z+17	; 0x11
    2c2c:	88 23       	and	r24, r24
    2c2e:	49 f0       	breq	.+18     	; 0x2c42 <xQueuePeek+0x80>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    2c30:	8a 81       	ldd	r24, Y+2	; 0x02
    2c32:	9b 81       	ldd	r25, Y+3	; 0x03
    2c34:	41 96       	adiw	r24, 0x11	; 17
    2c36:	0e 94 4e 23 	call	0x469c	; 0x469c <xTaskRemoveFromEventList>
    2c3a:	88 23       	and	r24, r24
    2c3c:	11 f0       	breq	.+4      	; 0x2c42 <xQueuePeek+0x80>
                    {
                        /* The task waiting has a higher priority than this task. */
                        queueYIELD_IF_USING_PREEMPTION();
    2c3e:	0e 94 72 09 	call	0x12e4	; 0x12e4 <vPortYield>
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                taskEXIT_CRITICAL();
    2c42:	0f 90       	pop	r0
    2c44:	0f be       	out	0x3f, r0	; 63
                return pdPASS;
    2c46:	81 e0       	ldi	r24, 0x01	; 1
    2c48:	88 8b       	std	Y+16, r24	; 0x10
    2c4a:	63 c0       	rjmp	.+198    	; 0x2d12 <xQueuePeek+0x150>
            }
            else
            {
                if( xTicksToWait == ( TickType_t ) 0 )
    2c4c:	8e 85       	ldd	r24, Y+14	; 0x0e
    2c4e:	9f 85       	ldd	r25, Y+15	; 0x0f
    2c50:	00 97       	sbiw	r24, 0x00	; 0
    2c52:	21 f4       	brne	.+8      	; 0x2c5c <xQueuePeek+0x9a>
                {
                    /* The queue was empty and no block time is specified (or
                     * the block time has expired) so leave now. */
                    taskEXIT_CRITICAL();
    2c54:	0f 90       	pop	r0
    2c56:	0f be       	out	0x3f, r0	; 63
                    traceQUEUE_PEEK_FAILED( pxQueue );
                    return errQUEUE_EMPTY;
    2c58:	18 8a       	std	Y+16, r1	; 0x10
    2c5a:	5b c0       	rjmp	.+182    	; 0x2d12 <xQueuePeek+0x150>
                }
                else if( xEntryTimeSet == pdFALSE )
    2c5c:	8e 81       	ldd	r24, Y+6	; 0x06
    2c5e:	88 23       	and	r24, r24
    2c60:	31 f4       	brne	.+12     	; 0x2c6e <xQueuePeek+0xac>
                {
                    /* The queue was empty and a block time was specified so
                     * configure the timeout structure ready to enter the blocked
                     * state. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
    2c62:	ce 01       	movw	r24, r28
    2c64:	07 96       	adiw	r24, 0x07	; 7
    2c66:	0e 94 be 25 	call	0x4b7c	; 0x4b7c <vTaskInternalSetTimeOutState>
                    xEntryTimeSet = pdTRUE;
    2c6a:	81 e0       	ldi	r24, 0x01	; 1
    2c6c:	8e 83       	std	Y+6, r24	; 0x06
                    /* Entry time was already set. */
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        taskEXIT_CRITICAL();
    2c6e:	0f 90       	pop	r0
    2c70:	0f be       	out	0x3f, r0	; 63

        /* Interrupts and other tasks can send to and receive from the queue
         * now that the critical section has been exited. */

        vTaskSuspendAll();
    2c72:	0e 94 88 1e 	call	0x3d10	; 0x3d10 <vTaskSuspendAll>
        prvLockQueue( pxQueue );
    2c76:	0f b6       	in	r0, 0x3f	; 63
    2c78:	f8 94       	cli
    2c7a:	0f 92       	push	r0
    2c7c:	ea 81       	ldd	r30, Y+2	; 0x02
    2c7e:	fb 81       	ldd	r31, Y+3	; 0x03
    2c80:	85 8d       	ldd	r24, Z+29	; 0x1d
    2c82:	8f 3f       	cpi	r24, 0xFF	; 255
    2c84:	19 f4       	brne	.+6      	; 0x2c8c <xQueuePeek+0xca>
    2c86:	ea 81       	ldd	r30, Y+2	; 0x02
    2c88:	fb 81       	ldd	r31, Y+3	; 0x03
    2c8a:	15 8e       	std	Z+29, r1	; 0x1d
    2c8c:	ea 81       	ldd	r30, Y+2	; 0x02
    2c8e:	fb 81       	ldd	r31, Y+3	; 0x03
    2c90:	86 8d       	ldd	r24, Z+30	; 0x1e
    2c92:	8f 3f       	cpi	r24, 0xFF	; 255
    2c94:	19 f4       	brne	.+6      	; 0x2c9c <xQueuePeek+0xda>
    2c96:	ea 81       	ldd	r30, Y+2	; 0x02
    2c98:	fb 81       	ldd	r31, Y+3	; 0x03
    2c9a:	16 8e       	std	Z+30, r1	; 0x1e
    2c9c:	0f 90       	pop	r0
    2c9e:	0f be       	out	0x3f, r0	; 63

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    2ca0:	ce 01       	movw	r24, r28
    2ca2:	07 96       	adiw	r24, 0x07	; 7
    2ca4:	9e 01       	movw	r18, r28
    2ca6:	22 5f       	subi	r18, 0xF2	; 242
    2ca8:	3f 4f       	sbci	r19, 0xFF	; 255
    2caa:	b9 01       	movw	r22, r18
    2cac:	0e 94 d7 25 	call	0x4bae	; 0x4bae <xTaskCheckForTimeOut>
    2cb0:	88 23       	and	r24, r24
    2cb2:	09 f5       	brne	.+66     	; 0x2cf6 <xQueuePeek+0x134>
        {
            /* Timeout has not expired yet, check to see if there is data in the
            * queue now, and if not enter the Blocked state to wait for data. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    2cb4:	8a 81       	ldd	r24, Y+2	; 0x02
    2cb6:	9b 81       	ldd	r25, Y+3	; 0x03
    2cb8:	0e 94 d1 18 	call	0x31a2	; 0x31a2 <prvIsQueueEmpty>
    2cbc:	88 23       	and	r24, r24
    2cbe:	a1 f0       	breq	.+40     	; 0x2ce8 <xQueuePeek+0x126>
            {
                traceBLOCKING_ON_QUEUE_PEEK( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    2cc0:	8a 81       	ldd	r24, Y+2	; 0x02
    2cc2:	9b 81       	ldd	r25, Y+3	; 0x03
    2cc4:	41 96       	adiw	r24, 0x11	; 17
    2cc6:	2e 85       	ldd	r18, Y+14	; 0x0e
    2cc8:	3f 85       	ldd	r19, Y+15	; 0x0f
    2cca:	b9 01       	movw	r22, r18
    2ccc:	0e 94 65 22 	call	0x44ca	; 0x44ca <vTaskPlaceOnEventList>
                prvUnlockQueue( pxQueue );
    2cd0:	8a 81       	ldd	r24, Y+2	; 0x02
    2cd2:	9b 81       	ldd	r25, Y+3	; 0x03
    2cd4:	0e 94 7e 18 	call	0x30fc	; 0x30fc <prvUnlockQueue>

                if( xTaskResumeAll() == pdFALSE )
    2cd8:	0e 94 94 1e 	call	0x3d28	; 0x3d28 <xTaskResumeAll>
    2cdc:	88 23       	and	r24, r24
    2cde:	09 f0       	breq	.+2      	; 0x2ce2 <xQueuePeek+0x120>
    2ce0:	85 cf       	rjmp	.-246    	; 0x2bec <xQueuePeek+0x2a>
                {
                    portYIELD_WITHIN_API();
    2ce2:	0e 94 72 09 	call	0x12e4	; 0x12e4 <vPortYield>
    2ce6:	82 cf       	rjmp	.-252    	; 0x2bec <xQueuePeek+0x2a>
            }
            else
            {
                /* There is data in the queue now, so don't enter the blocked
                 * state, instead return to try and obtain the data. */
                prvUnlockQueue( pxQueue );
    2ce8:	8a 81       	ldd	r24, Y+2	; 0x02
    2cea:	9b 81       	ldd	r25, Y+3	; 0x03
    2cec:	0e 94 7e 18 	call	0x30fc	; 0x30fc <prvUnlockQueue>
                ( void ) xTaskResumeAll();
    2cf0:	0e 94 94 1e 	call	0x3d28	; 0x3d28 <xTaskResumeAll>
    2cf4:	7b cf       	rjmp	.-266    	; 0x2bec <xQueuePeek+0x2a>
        }
        else
        {
            /* The timeout has expired.  If there is still no data in the queue
             * exit, otherwise go back and try to read the data again. */
            prvUnlockQueue( pxQueue );
    2cf6:	8a 81       	ldd	r24, Y+2	; 0x02
    2cf8:	9b 81       	ldd	r25, Y+3	; 0x03
    2cfa:	0e 94 7e 18 	call	0x30fc	; 0x30fc <prvUnlockQueue>
            ( void ) xTaskResumeAll();
    2cfe:	0e 94 94 1e 	call	0x3d28	; 0x3d28 <xTaskResumeAll>

            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    2d02:	8a 81       	ldd	r24, Y+2	; 0x02
    2d04:	9b 81       	ldd	r25, Y+3	; 0x03
    2d06:	0e 94 d1 18 	call	0x31a2	; 0x31a2 <prvIsQueueEmpty>
    2d0a:	88 23       	and	r24, r24
    2d0c:	09 f4       	brne	.+2      	; 0x2d10 <xQueuePeek+0x14e>
    2d0e:	6e cf       	rjmp	.-292    	; 0x2bec <xQueuePeek+0x2a>
            {
                traceQUEUE_PEEK_FAILED( pxQueue );
                return errQUEUE_EMPTY;
    2d10:	18 8a       	std	Y+16, r1	; 0x10
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
    } /*lint -restore */
    2d12:	88 89       	ldd	r24, Y+16	; 0x10
}
    2d14:	60 96       	adiw	r28, 0x10	; 16
    2d16:	0f b6       	in	r0, 0x3f	; 63
    2d18:	f8 94       	cli
    2d1a:	de bf       	out	0x3e, r29	; 62
    2d1c:	0f be       	out	0x3f, r0	; 63
    2d1e:	cd bf       	out	0x3d, r28	; 61
    2d20:	cf 91       	pop	r28
    2d22:	df 91       	pop	r29
    2d24:	08 95       	ret

00002d26 <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue,
                                 void * const pvBuffer,
                                 BaseType_t * const pxHigherPriorityTaskWoken )
{
    2d26:	df 93       	push	r29
    2d28:	cf 93       	push	r28
    2d2a:	cd b7       	in	r28, 0x3d	; 61
    2d2c:	de b7       	in	r29, 0x3e	; 62
    2d2e:	2c 97       	sbiw	r28, 0x0c	; 12
    2d30:	0f b6       	in	r0, 0x3f	; 63
    2d32:	f8 94       	cli
    2d34:	de bf       	out	0x3e, r29	; 62
    2d36:	0f be       	out	0x3f, r0	; 63
    2d38:	cd bf       	out	0x3d, r28	; 61
    2d3a:	98 87       	std	Y+8, r25	; 0x08
    2d3c:	8f 83       	std	Y+7, r24	; 0x07
    2d3e:	7a 87       	std	Y+10, r23	; 0x0a
    2d40:	69 87       	std	Y+9, r22	; 0x09
    2d42:	5c 87       	std	Y+12, r21	; 0x0c
    2d44:	4b 87       	std	Y+11, r20	; 0x0b
    BaseType_t xReturn;
    UBaseType_t uxSavedInterruptStatus;
    Queue_t * const pxQueue = xQueue;
    2d46:	8f 81       	ldd	r24, Y+7	; 0x07
    2d48:	98 85       	ldd	r25, Y+8	; 0x08
    2d4a:	9c 83       	std	Y+4, r25	; 0x04
    2d4c:	8b 83       	std	Y+3, r24	; 0x03
     * safe API to ensure interrupt entry is as fast and as simple as possible.
     * More information (albeit Cortex-M specific) is provided on the following
     * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    2d4e:	1d 82       	std	Y+5, r1	; 0x05
    {
        const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    2d50:	eb 81       	ldd	r30, Y+3	; 0x03
    2d52:	fc 81       	ldd	r31, Y+4	; 0x04
    2d54:	82 8d       	ldd	r24, Z+26	; 0x1a
    2d56:	8a 83       	std	Y+2, r24	; 0x02

        /* Cannot block in an ISR, so check there is data available. */
        if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    2d58:	8a 81       	ldd	r24, Y+2	; 0x02
    2d5a:	88 23       	and	r24, r24
    2d5c:	81 f1       	breq	.+96     	; 0x2dbe <xQueueReceiveFromISR+0x98>
        {
            const int8_t cRxLock = pxQueue->cRxLock;
    2d5e:	eb 81       	ldd	r30, Y+3	; 0x03
    2d60:	fc 81       	ldd	r31, Y+4	; 0x04
    2d62:	85 8d       	ldd	r24, Z+29	; 0x1d
    2d64:	89 83       	std	Y+1, r24	; 0x01

            traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

            prvCopyDataFromQueue( pxQueue, pvBuffer );
    2d66:	8b 81       	ldd	r24, Y+3	; 0x03
    2d68:	9c 81       	ldd	r25, Y+4	; 0x04
    2d6a:	29 85       	ldd	r18, Y+9	; 0x09
    2d6c:	3a 85       	ldd	r19, Y+10	; 0x0a
    2d6e:	b9 01       	movw	r22, r18
    2d70:	0e 94 37 18 	call	0x306e	; 0x306e <prvCopyDataFromQueue>
            pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
    2d74:	8a 81       	ldd	r24, Y+2	; 0x02
    2d76:	81 50       	subi	r24, 0x01	; 1
    2d78:	eb 81       	ldd	r30, Y+3	; 0x03
    2d7a:	fc 81       	ldd	r31, Y+4	; 0x04
    2d7c:	82 8f       	std	Z+26, r24	; 0x1a

            /* If the queue is locked the event list will not be modified.
             * Instead update the lock count so the task that unlocks the queue
             * will know that an ISR has removed data while the queue was
             * locked. */
            if( cRxLock == queueUNLOCKED )
    2d7e:	89 81       	ldd	r24, Y+1	; 0x01
    2d80:	8f 3f       	cpi	r24, 0xFF	; 255
    2d82:	a9 f4       	brne	.+42     	; 0x2dae <xQueueReceiveFromISR+0x88>
            {
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    2d84:	eb 81       	ldd	r30, Y+3	; 0x03
    2d86:	fc 81       	ldd	r31, Y+4	; 0x04
    2d88:	80 85       	ldd	r24, Z+8	; 0x08
    2d8a:	88 23       	and	r24, r24
    2d8c:	a9 f0       	breq	.+42     	; 0x2db8 <xQueueReceiveFromISR+0x92>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    2d8e:	8b 81       	ldd	r24, Y+3	; 0x03
    2d90:	9c 81       	ldd	r25, Y+4	; 0x04
    2d92:	08 96       	adiw	r24, 0x08	; 8
    2d94:	0e 94 4e 23 	call	0x469c	; 0x469c <xTaskRemoveFromEventList>
    2d98:	88 23       	and	r24, r24
    2d9a:	71 f0       	breq	.+28     	; 0x2db8 <xQueueReceiveFromISR+0x92>
                    {
                        /* The task waiting has a higher priority than us so
                         * force a context switch. */
                        if( pxHigherPriorityTaskWoken != NULL )
    2d9c:	8b 85       	ldd	r24, Y+11	; 0x0b
    2d9e:	9c 85       	ldd	r25, Y+12	; 0x0c
    2da0:	00 97       	sbiw	r24, 0x00	; 0
    2da2:	51 f0       	breq	.+20     	; 0x2db8 <xQueueReceiveFromISR+0x92>
                        {
                            *pxHigherPriorityTaskWoken = pdTRUE;
    2da4:	eb 85       	ldd	r30, Y+11	; 0x0b
    2da6:	fc 85       	ldd	r31, Y+12	; 0x0c
    2da8:	81 e0       	ldi	r24, 0x01	; 1
    2daa:	80 83       	st	Z, r24
    2dac:	05 c0       	rjmp	.+10     	; 0x2db8 <xQueueReceiveFromISR+0x92>
            {
                /* Increment the lock count so the task that unlocks the queue
                 * knows that data was removed while it was locked. */
                configASSERT( cRxLock != queueINT8_MAX );

                pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
    2dae:	89 81       	ldd	r24, Y+1	; 0x01
    2db0:	8f 5f       	subi	r24, 0xFF	; 255
    2db2:	eb 81       	ldd	r30, Y+3	; 0x03
    2db4:	fc 81       	ldd	r31, Y+4	; 0x04
    2db6:	85 8f       	std	Z+29, r24	; 0x1d
            }

            xReturn = pdPASS;
    2db8:	81 e0       	ldi	r24, 0x01	; 1
    2dba:	8e 83       	std	Y+6, r24	; 0x06
    2dbc:	01 c0       	rjmp	.+2      	; 0x2dc0 <xQueueReceiveFromISR+0x9a>
        }
        else
        {
            xReturn = pdFAIL;
    2dbe:	1e 82       	std	Y+6, r1	; 0x06
            traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
    2dc0:	8e 81       	ldd	r24, Y+6	; 0x06
}
    2dc2:	2c 96       	adiw	r28, 0x0c	; 12
    2dc4:	0f b6       	in	r0, 0x3f	; 63
    2dc6:	f8 94       	cli
    2dc8:	de bf       	out	0x3e, r29	; 62
    2dca:	0f be       	out	0x3f, r0	; 63
    2dcc:	cd bf       	out	0x3d, r28	; 61
    2dce:	cf 91       	pop	r28
    2dd0:	df 91       	pop	r29
    2dd2:	08 95       	ret

00002dd4 <xQueuePeekFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,
                              void * const pvBuffer )
{
    2dd4:	df 93       	push	r29
    2dd6:	cf 93       	push	r28
    2dd8:	cd b7       	in	r28, 0x3d	; 61
    2dda:	de b7       	in	r29, 0x3e	; 62
    2ddc:	2a 97       	sbiw	r28, 0x0a	; 10
    2dde:	0f b6       	in	r0, 0x3f	; 63
    2de0:	f8 94       	cli
    2de2:	de bf       	out	0x3e, r29	; 62
    2de4:	0f be       	out	0x3f, r0	; 63
    2de6:	cd bf       	out	0x3d, r28	; 61
    2de8:	98 87       	std	Y+8, r25	; 0x08
    2dea:	8f 83       	std	Y+7, r24	; 0x07
    2dec:	7a 87       	std	Y+10, r23	; 0x0a
    2dee:	69 87       	std	Y+9, r22	; 0x09
    BaseType_t xReturn;
    UBaseType_t uxSavedInterruptStatus;
    int8_t * pcOriginalReadPosition;
    Queue_t * const pxQueue = xQueue;
    2df0:	8f 81       	ldd	r24, Y+7	; 0x07
    2df2:	98 85       	ldd	r25, Y+8	; 0x08
    2df4:	9a 83       	std	Y+2, r25	; 0x02
    2df6:	89 83       	std	Y+1, r24	; 0x01
     * safe API to ensure interrupt entry is as fast and as simple as possible.
     * More information (albeit Cortex-M specific) is provided on the following
     * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    2df8:	1d 82       	std	Y+5, r1	; 0x05
    {
        /* Cannot block in an ISR, so check there is data available. */
        if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    2dfa:	e9 81       	ldd	r30, Y+1	; 0x01
    2dfc:	fa 81       	ldd	r31, Y+2	; 0x02
    2dfe:	82 8d       	ldd	r24, Z+26	; 0x1a
    2e00:	88 23       	and	r24, r24
    2e02:	b1 f0       	breq	.+44     	; 0x2e30 <xQueuePeekFromISR+0x5c>
        {
            traceQUEUE_PEEK_FROM_ISR( pxQueue );

            /* Remember the read position so it can be reset as nothing is
             * actually being removed from the queue. */
            pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
    2e04:	e9 81       	ldd	r30, Y+1	; 0x01
    2e06:	fa 81       	ldd	r31, Y+2	; 0x02
    2e08:	86 81       	ldd	r24, Z+6	; 0x06
    2e0a:	97 81       	ldd	r25, Z+7	; 0x07
    2e0c:	9c 83       	std	Y+4, r25	; 0x04
    2e0e:	8b 83       	std	Y+3, r24	; 0x03
            prvCopyDataFromQueue( pxQueue, pvBuffer );
    2e10:	89 81       	ldd	r24, Y+1	; 0x01
    2e12:	9a 81       	ldd	r25, Y+2	; 0x02
    2e14:	29 85       	ldd	r18, Y+9	; 0x09
    2e16:	3a 85       	ldd	r19, Y+10	; 0x0a
    2e18:	b9 01       	movw	r22, r18
    2e1a:	0e 94 37 18 	call	0x306e	; 0x306e <prvCopyDataFromQueue>
            pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
    2e1e:	e9 81       	ldd	r30, Y+1	; 0x01
    2e20:	fa 81       	ldd	r31, Y+2	; 0x02
    2e22:	8b 81       	ldd	r24, Y+3	; 0x03
    2e24:	9c 81       	ldd	r25, Y+4	; 0x04
    2e26:	97 83       	std	Z+7, r25	; 0x07
    2e28:	86 83       	std	Z+6, r24	; 0x06

            xReturn = pdPASS;
    2e2a:	81 e0       	ldi	r24, 0x01	; 1
    2e2c:	8e 83       	std	Y+6, r24	; 0x06
    2e2e:	01 c0       	rjmp	.+2      	; 0x2e32 <xQueuePeekFromISR+0x5e>
        }
        else
        {
            xReturn = pdFAIL;
    2e30:	1e 82       	std	Y+6, r1	; 0x06
            traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue );
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
    2e32:	8e 81       	ldd	r24, Y+6	; 0x06
}
    2e34:	2a 96       	adiw	r28, 0x0a	; 10
    2e36:	0f b6       	in	r0, 0x3f	; 63
    2e38:	f8 94       	cli
    2e3a:	de bf       	out	0x3e, r29	; 62
    2e3c:	0f be       	out	0x3f, r0	; 63
    2e3e:	cd bf       	out	0x3d, r28	; 61
    2e40:	cf 91       	pop	r28
    2e42:	df 91       	pop	r29
    2e44:	08 95       	ret

00002e46 <uxQueueMessagesWaiting>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue )
{
    2e46:	df 93       	push	r29
    2e48:	cf 93       	push	r28
    2e4a:	00 d0       	rcall	.+0      	; 0x2e4c <uxQueueMessagesWaiting+0x6>
    2e4c:	0f 92       	push	r0
    2e4e:	cd b7       	in	r28, 0x3d	; 61
    2e50:	de b7       	in	r29, 0x3e	; 62
    2e52:	9b 83       	std	Y+3, r25	; 0x03
    2e54:	8a 83       	std	Y+2, r24	; 0x02
    UBaseType_t uxReturn;

    configASSERT( xQueue );

    taskENTER_CRITICAL();
    2e56:	0f b6       	in	r0, 0x3f	; 63
    2e58:	f8 94       	cli
    2e5a:	0f 92       	push	r0
    {
        uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
    2e5c:	ea 81       	ldd	r30, Y+2	; 0x02
    2e5e:	fb 81       	ldd	r31, Y+3	; 0x03
    2e60:	82 8d       	ldd	r24, Z+26	; 0x1a
    2e62:	89 83       	std	Y+1, r24	; 0x01
    }
    taskEXIT_CRITICAL();
    2e64:	0f 90       	pop	r0
    2e66:	0f be       	out	0x3f, r0	; 63

    return uxReturn;
    2e68:	89 81       	ldd	r24, Y+1	; 0x01
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    2e6a:	0f 90       	pop	r0
    2e6c:	0f 90       	pop	r0
    2e6e:	0f 90       	pop	r0
    2e70:	cf 91       	pop	r28
    2e72:	df 91       	pop	r29
    2e74:	08 95       	ret

00002e76 <uxQueueSpacesAvailable>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )
{
    2e76:	df 93       	push	r29
    2e78:	cf 93       	push	r28
    2e7a:	00 d0       	rcall	.+0      	; 0x2e7c <uxQueueSpacesAvailable+0x6>
    2e7c:	00 d0       	rcall	.+0      	; 0x2e7e <uxQueueSpacesAvailable+0x8>
    2e7e:	0f 92       	push	r0
    2e80:	cd b7       	in	r28, 0x3d	; 61
    2e82:	de b7       	in	r29, 0x3e	; 62
    2e84:	9d 83       	std	Y+5, r25	; 0x05
    2e86:	8c 83       	std	Y+4, r24	; 0x04
    UBaseType_t uxReturn;
    Queue_t * const pxQueue = xQueue;
    2e88:	8c 81       	ldd	r24, Y+4	; 0x04
    2e8a:	9d 81       	ldd	r25, Y+5	; 0x05
    2e8c:	9a 83       	std	Y+2, r25	; 0x02
    2e8e:	89 83       	std	Y+1, r24	; 0x01

    configASSERT( pxQueue );

    taskENTER_CRITICAL();
    2e90:	0f b6       	in	r0, 0x3f	; 63
    2e92:	f8 94       	cli
    2e94:	0f 92       	push	r0
    {
        uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
    2e96:	e9 81       	ldd	r30, Y+1	; 0x01
    2e98:	fa 81       	ldd	r31, Y+2	; 0x02
    2e9a:	93 8d       	ldd	r25, Z+27	; 0x1b
    2e9c:	e9 81       	ldd	r30, Y+1	; 0x01
    2e9e:	fa 81       	ldd	r31, Y+2	; 0x02
    2ea0:	82 8d       	ldd	r24, Z+26	; 0x1a
    2ea2:	29 2f       	mov	r18, r25
    2ea4:	28 1b       	sub	r18, r24
    2ea6:	82 2f       	mov	r24, r18
    2ea8:	8b 83       	std	Y+3, r24	; 0x03
    }
    taskEXIT_CRITICAL();
    2eaa:	0f 90       	pop	r0
    2eac:	0f be       	out	0x3f, r0	; 63

    return uxReturn;
    2eae:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    2eb0:	0f 90       	pop	r0
    2eb2:	0f 90       	pop	r0
    2eb4:	0f 90       	pop	r0
    2eb6:	0f 90       	pop	r0
    2eb8:	0f 90       	pop	r0
    2eba:	cf 91       	pop	r28
    2ebc:	df 91       	pop	r29
    2ebe:	08 95       	ret

00002ec0 <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue )
{
    2ec0:	df 93       	push	r29
    2ec2:	cf 93       	push	r28
    2ec4:	00 d0       	rcall	.+0      	; 0x2ec6 <uxQueueMessagesWaitingFromISR+0x6>
    2ec6:	00 d0       	rcall	.+0      	; 0x2ec8 <uxQueueMessagesWaitingFromISR+0x8>
    2ec8:	0f 92       	push	r0
    2eca:	cd b7       	in	r28, 0x3d	; 61
    2ecc:	de b7       	in	r29, 0x3e	; 62
    2ece:	9d 83       	std	Y+5, r25	; 0x05
    2ed0:	8c 83       	std	Y+4, r24	; 0x04
    UBaseType_t uxReturn;
    Queue_t * const pxQueue = xQueue;
    2ed2:	8c 81       	ldd	r24, Y+4	; 0x04
    2ed4:	9d 81       	ldd	r25, Y+5	; 0x05
    2ed6:	9a 83       	std	Y+2, r25	; 0x02
    2ed8:	89 83       	std	Y+1, r24	; 0x01

    configASSERT( pxQueue );
    uxReturn = pxQueue->uxMessagesWaiting;
    2eda:	e9 81       	ldd	r30, Y+1	; 0x01
    2edc:	fa 81       	ldd	r31, Y+2	; 0x02
    2ede:	82 8d       	ldd	r24, Z+26	; 0x1a
    2ee0:	8b 83       	std	Y+3, r24	; 0x03

    return uxReturn;
    2ee2:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    2ee4:	0f 90       	pop	r0
    2ee6:	0f 90       	pop	r0
    2ee8:	0f 90       	pop	r0
    2eea:	0f 90       	pop	r0
    2eec:	0f 90       	pop	r0
    2eee:	cf 91       	pop	r28
    2ef0:	df 91       	pop	r29
    2ef2:	08 95       	ret

00002ef4 <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( QueueHandle_t xQueue )
{
    2ef4:	df 93       	push	r29
    2ef6:	cf 93       	push	r28
    2ef8:	00 d0       	rcall	.+0      	; 0x2efa <vQueueDelete+0x6>
    2efa:	00 d0       	rcall	.+0      	; 0x2efc <vQueueDelete+0x8>
    2efc:	cd b7       	in	r28, 0x3d	; 61
    2efe:	de b7       	in	r29, 0x3e	; 62
    2f00:	9c 83       	std	Y+4, r25	; 0x04
    2f02:	8b 83       	std	Y+3, r24	; 0x03
    Queue_t * const pxQueue = xQueue;
    2f04:	8b 81       	ldd	r24, Y+3	; 0x03
    2f06:	9c 81       	ldd	r25, Y+4	; 0x04
    2f08:	9a 83       	std	Y+2, r25	; 0x02
    2f0a:	89 83       	std	Y+1, r24	; 0x01

    #if ( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
        {
            /* The queue can only have been allocated dynamically - free it
             * again. */
            vPortFree( pxQueue );
    2f0c:	89 81       	ldd	r24, Y+1	; 0x01
    2f0e:	9a 81       	ldd	r25, Y+2	; 0x02
    2f10:	0e 94 8d 07 	call	0xf1a	; 0xf1a <vPortFree>
            /* The queue must have been statically allocated, so is not going to be
             * deleted.  Avoid compiler warnings about the unused parameter. */
            ( void ) pxQueue;
        }
    #endif /* configSUPPORT_DYNAMIC_ALLOCATION */
}
    2f14:	0f 90       	pop	r0
    2f16:	0f 90       	pop	r0
    2f18:	0f 90       	pop	r0
    2f1a:	0f 90       	pop	r0
    2f1c:	cf 91       	pop	r28
    2f1e:	df 91       	pop	r29
    2f20:	08 95       	ret

00002f22 <prvCopyDataToQueue>:
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue,
                                      const void * pvItemToQueue,
                                      const BaseType_t xPosition )
{
    2f22:	df 93       	push	r29
    2f24:	cf 93       	push	r28
    2f26:	cd b7       	in	r28, 0x3d	; 61
    2f28:	de b7       	in	r29, 0x3e	; 62
    2f2a:	27 97       	sbiw	r28, 0x07	; 7
    2f2c:	0f b6       	in	r0, 0x3f	; 63
    2f2e:	f8 94       	cli
    2f30:	de bf       	out	0x3e, r29	; 62
    2f32:	0f be       	out	0x3f, r0	; 63
    2f34:	cd bf       	out	0x3d, r28	; 61
    2f36:	9c 83       	std	Y+4, r25	; 0x04
    2f38:	8b 83       	std	Y+3, r24	; 0x03
    2f3a:	7e 83       	std	Y+6, r23	; 0x06
    2f3c:	6d 83       	std	Y+5, r22	; 0x05
    2f3e:	4f 83       	std	Y+7, r20	; 0x07
    BaseType_t xReturn = pdFALSE;
    2f40:	1a 82       	std	Y+2, r1	; 0x02
    UBaseType_t uxMessagesWaiting;

    /* This function is called from a critical section. */

    uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    2f42:	eb 81       	ldd	r30, Y+3	; 0x03
    2f44:	fc 81       	ldd	r31, Y+4	; 0x04
    2f46:	82 8d       	ldd	r24, Z+26	; 0x1a
    2f48:	89 83       	std	Y+1, r24	; 0x01

    if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
    2f4a:	eb 81       	ldd	r30, Y+3	; 0x03
    2f4c:	fc 81       	ldd	r31, Y+4	; 0x04
    2f4e:	84 8d       	ldd	r24, Z+28	; 0x1c
    2f50:	88 23       	and	r24, r24
    2f52:	09 f4       	brne	.+2      	; 0x2f56 <prvCopyDataToQueue+0x34>
    2f54:	7d c0       	rjmp	.+250    	; 0x3050 <prvCopyDataToQueue+0x12e>
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        #endif /* configUSE_MUTEXES */
    }
    else if( xPosition == queueSEND_TO_BACK )
    2f56:	8f 81       	ldd	r24, Y+7	; 0x07
    2f58:	88 23       	and	r24, r24
    2f5a:	99 f5       	brne	.+102    	; 0x2fc2 <prvCopyDataToQueue+0xa0>
    {
        ( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
    2f5c:	eb 81       	ldd	r30, Y+3	; 0x03
    2f5e:	fc 81       	ldd	r31, Y+4	; 0x04
    2f60:	62 81       	ldd	r22, Z+2	; 0x02
    2f62:	73 81       	ldd	r23, Z+3	; 0x03
    2f64:	eb 81       	ldd	r30, Y+3	; 0x03
    2f66:	fc 81       	ldd	r31, Y+4	; 0x04
    2f68:	84 8d       	ldd	r24, Z+28	; 0x1c
    2f6a:	48 2f       	mov	r20, r24
    2f6c:	50 e0       	ldi	r21, 0x00	; 0
    2f6e:	2d 81       	ldd	r18, Y+5	; 0x05
    2f70:	3e 81       	ldd	r19, Y+6	; 0x06
    2f72:	cb 01       	movw	r24, r22
    2f74:	b9 01       	movw	r22, r18
    2f76:	0e 94 0e 49 	call	0x921c	; 0x921c <memcpy>
        pxQueue->pcWriteTo += pxQueue->uxItemSize;                                                       /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
    2f7a:	eb 81       	ldd	r30, Y+3	; 0x03
    2f7c:	fc 81       	ldd	r31, Y+4	; 0x04
    2f7e:	22 81       	ldd	r18, Z+2	; 0x02
    2f80:	33 81       	ldd	r19, Z+3	; 0x03
    2f82:	eb 81       	ldd	r30, Y+3	; 0x03
    2f84:	fc 81       	ldd	r31, Y+4	; 0x04
    2f86:	84 8d       	ldd	r24, Z+28	; 0x1c
    2f88:	88 2f       	mov	r24, r24
    2f8a:	90 e0       	ldi	r25, 0x00	; 0
    2f8c:	82 0f       	add	r24, r18
    2f8e:	93 1f       	adc	r25, r19
    2f90:	eb 81       	ldd	r30, Y+3	; 0x03
    2f92:	fc 81       	ldd	r31, Y+4	; 0x04
    2f94:	93 83       	std	Z+3, r25	; 0x03
    2f96:	82 83       	std	Z+2, r24	; 0x02

        if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail )                                             /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    2f98:	eb 81       	ldd	r30, Y+3	; 0x03
    2f9a:	fc 81       	ldd	r31, Y+4	; 0x04
    2f9c:	22 81       	ldd	r18, Z+2	; 0x02
    2f9e:	33 81       	ldd	r19, Z+3	; 0x03
    2fa0:	eb 81       	ldd	r30, Y+3	; 0x03
    2fa2:	fc 81       	ldd	r31, Y+4	; 0x04
    2fa4:	84 81       	ldd	r24, Z+4	; 0x04
    2fa6:	95 81       	ldd	r25, Z+5	; 0x05
    2fa8:	28 17       	cp	r18, r24
    2faa:	39 07       	cpc	r19, r25
    2fac:	08 f4       	brcc	.+2      	; 0x2fb0 <prvCopyDataToQueue+0x8e>
    2fae:	50 c0       	rjmp	.+160    	; 0x3050 <prvCopyDataToQueue+0x12e>
        {
            pxQueue->pcWriteTo = pxQueue->pcHead;
    2fb0:	eb 81       	ldd	r30, Y+3	; 0x03
    2fb2:	fc 81       	ldd	r31, Y+4	; 0x04
    2fb4:	80 81       	ld	r24, Z
    2fb6:	91 81       	ldd	r25, Z+1	; 0x01
    2fb8:	eb 81       	ldd	r30, Y+3	; 0x03
    2fba:	fc 81       	ldd	r31, Y+4	; 0x04
    2fbc:	93 83       	std	Z+3, r25	; 0x03
    2fbe:	82 83       	std	Z+2, r24	; 0x02
    2fc0:	47 c0       	rjmp	.+142    	; 0x3050 <prvCopyDataToQueue+0x12e>
            mtCOVERAGE_TEST_MARKER();
        }
    }
    else
    {
        ( void ) memcpy( ( void * ) pxQueue->u.xQueue.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e9087 !e418 MISRA exception as the casts are only redundant for some ports.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes.  Assert checks null pointer only used when length is 0. */
    2fc2:	eb 81       	ldd	r30, Y+3	; 0x03
    2fc4:	fc 81       	ldd	r31, Y+4	; 0x04
    2fc6:	66 81       	ldd	r22, Z+6	; 0x06
    2fc8:	77 81       	ldd	r23, Z+7	; 0x07
    2fca:	eb 81       	ldd	r30, Y+3	; 0x03
    2fcc:	fc 81       	ldd	r31, Y+4	; 0x04
    2fce:	84 8d       	ldd	r24, Z+28	; 0x1c
    2fd0:	48 2f       	mov	r20, r24
    2fd2:	50 e0       	ldi	r21, 0x00	; 0
    2fd4:	2d 81       	ldd	r18, Y+5	; 0x05
    2fd6:	3e 81       	ldd	r19, Y+6	; 0x06
    2fd8:	cb 01       	movw	r24, r22
    2fda:	b9 01       	movw	r22, r18
    2fdc:	0e 94 0e 49 	call	0x921c	; 0x921c <memcpy>
        pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
    2fe0:	eb 81       	ldd	r30, Y+3	; 0x03
    2fe2:	fc 81       	ldd	r31, Y+4	; 0x04
    2fe4:	26 81       	ldd	r18, Z+6	; 0x06
    2fe6:	37 81       	ldd	r19, Z+7	; 0x07
    2fe8:	eb 81       	ldd	r30, Y+3	; 0x03
    2fea:	fc 81       	ldd	r31, Y+4	; 0x04
    2fec:	84 8d       	ldd	r24, Z+28	; 0x1c
    2fee:	88 2f       	mov	r24, r24
    2ff0:	90 e0       	ldi	r25, 0x00	; 0
    2ff2:	90 95       	com	r25
    2ff4:	81 95       	neg	r24
    2ff6:	9f 4f       	sbci	r25, 0xFF	; 255
    2ff8:	82 0f       	add	r24, r18
    2ffa:	93 1f       	adc	r25, r19
    2ffc:	eb 81       	ldd	r30, Y+3	; 0x03
    2ffe:	fc 81       	ldd	r31, Y+4	; 0x04
    3000:	97 83       	std	Z+7, r25	; 0x07
    3002:	86 83       	std	Z+6, r24	; 0x06

        if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    3004:	eb 81       	ldd	r30, Y+3	; 0x03
    3006:	fc 81       	ldd	r31, Y+4	; 0x04
    3008:	26 81       	ldd	r18, Z+6	; 0x06
    300a:	37 81       	ldd	r19, Z+7	; 0x07
    300c:	eb 81       	ldd	r30, Y+3	; 0x03
    300e:	fc 81       	ldd	r31, Y+4	; 0x04
    3010:	80 81       	ld	r24, Z
    3012:	91 81       	ldd	r25, Z+1	; 0x01
    3014:	28 17       	cp	r18, r24
    3016:	39 07       	cpc	r19, r25
    3018:	90 f4       	brcc	.+36     	; 0x303e <prvCopyDataToQueue+0x11c>
        {
            pxQueue->u.xQueue.pcReadFrom = ( pxQueue->u.xQueue.pcTail - pxQueue->uxItemSize );
    301a:	eb 81       	ldd	r30, Y+3	; 0x03
    301c:	fc 81       	ldd	r31, Y+4	; 0x04
    301e:	24 81       	ldd	r18, Z+4	; 0x04
    3020:	35 81       	ldd	r19, Z+5	; 0x05
    3022:	eb 81       	ldd	r30, Y+3	; 0x03
    3024:	fc 81       	ldd	r31, Y+4	; 0x04
    3026:	84 8d       	ldd	r24, Z+28	; 0x1c
    3028:	88 2f       	mov	r24, r24
    302a:	90 e0       	ldi	r25, 0x00	; 0
    302c:	90 95       	com	r25
    302e:	81 95       	neg	r24
    3030:	9f 4f       	sbci	r25, 0xFF	; 255
    3032:	82 0f       	add	r24, r18
    3034:	93 1f       	adc	r25, r19
    3036:	eb 81       	ldd	r30, Y+3	; 0x03
    3038:	fc 81       	ldd	r31, Y+4	; 0x04
    303a:	97 83       	std	Z+7, r25	; 0x07
    303c:	86 83       	std	Z+6, r24	; 0x06
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        if( xPosition == queueOVERWRITE )
    303e:	8f 81       	ldd	r24, Y+7	; 0x07
    3040:	82 30       	cpi	r24, 0x02	; 2
    3042:	31 f4       	brne	.+12     	; 0x3050 <prvCopyDataToQueue+0x12e>
        {
            if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    3044:	89 81       	ldd	r24, Y+1	; 0x01
    3046:	88 23       	and	r24, r24
    3048:	19 f0       	breq	.+6      	; 0x3050 <prvCopyDataToQueue+0x12e>
            {
                /* An item is not being added but overwritten, so subtract
                 * one from the recorded number of items in the queue so when
                 * one is added again below the number of recorded items remains
                 * correct. */
                --uxMessagesWaiting;
    304a:	89 81       	ldd	r24, Y+1	; 0x01
    304c:	81 50       	subi	r24, 0x01	; 1
    304e:	89 83       	std	Y+1, r24	; 0x01
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }

    pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
    3050:	89 81       	ldd	r24, Y+1	; 0x01
    3052:	8f 5f       	subi	r24, 0xFF	; 255
    3054:	eb 81       	ldd	r30, Y+3	; 0x03
    3056:	fc 81       	ldd	r31, Y+4	; 0x04
    3058:	82 8f       	std	Z+26, r24	; 0x1a

    return xReturn;
    305a:	8a 81       	ldd	r24, Y+2	; 0x02
}
    305c:	27 96       	adiw	r28, 0x07	; 7
    305e:	0f b6       	in	r0, 0x3f	; 63
    3060:	f8 94       	cli
    3062:	de bf       	out	0x3e, r29	; 62
    3064:	0f be       	out	0x3f, r0	; 63
    3066:	cd bf       	out	0x3d, r28	; 61
    3068:	cf 91       	pop	r28
    306a:	df 91       	pop	r29
    306c:	08 95       	ret

0000306e <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue,
                                  void * const pvBuffer )
{
    306e:	df 93       	push	r29
    3070:	cf 93       	push	r28
    3072:	00 d0       	rcall	.+0      	; 0x3074 <prvCopyDataFromQueue+0x6>
    3074:	00 d0       	rcall	.+0      	; 0x3076 <prvCopyDataFromQueue+0x8>
    3076:	cd b7       	in	r28, 0x3d	; 61
    3078:	de b7       	in	r29, 0x3e	; 62
    307a:	9a 83       	std	Y+2, r25	; 0x02
    307c:	89 83       	std	Y+1, r24	; 0x01
    307e:	7c 83       	std	Y+4, r23	; 0x04
    3080:	6b 83       	std	Y+3, r22	; 0x03
    if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
    3082:	e9 81       	ldd	r30, Y+1	; 0x01
    3084:	fa 81       	ldd	r31, Y+2	; 0x02
    3086:	84 8d       	ldd	r24, Z+28	; 0x1c
    3088:	88 23       	and	r24, r24
    308a:	89 f1       	breq	.+98     	; 0x30ee <prvCopyDataFromQueue+0x80>
    {
        pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;           /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
    308c:	e9 81       	ldd	r30, Y+1	; 0x01
    308e:	fa 81       	ldd	r31, Y+2	; 0x02
    3090:	26 81       	ldd	r18, Z+6	; 0x06
    3092:	37 81       	ldd	r19, Z+7	; 0x07
    3094:	e9 81       	ldd	r30, Y+1	; 0x01
    3096:	fa 81       	ldd	r31, Y+2	; 0x02
    3098:	84 8d       	ldd	r24, Z+28	; 0x1c
    309a:	88 2f       	mov	r24, r24
    309c:	90 e0       	ldi	r25, 0x00	; 0
    309e:	82 0f       	add	r24, r18
    30a0:	93 1f       	adc	r25, r19
    30a2:	e9 81       	ldd	r30, Y+1	; 0x01
    30a4:	fa 81       	ldd	r31, Y+2	; 0x02
    30a6:	97 83       	std	Z+7, r25	; 0x07
    30a8:	86 83       	std	Z+6, r24	; 0x06

        if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
    30aa:	e9 81       	ldd	r30, Y+1	; 0x01
    30ac:	fa 81       	ldd	r31, Y+2	; 0x02
    30ae:	26 81       	ldd	r18, Z+6	; 0x06
    30b0:	37 81       	ldd	r19, Z+7	; 0x07
    30b2:	e9 81       	ldd	r30, Y+1	; 0x01
    30b4:	fa 81       	ldd	r31, Y+2	; 0x02
    30b6:	84 81       	ldd	r24, Z+4	; 0x04
    30b8:	95 81       	ldd	r25, Z+5	; 0x05
    30ba:	28 17       	cp	r18, r24
    30bc:	39 07       	cpc	r19, r25
    30be:	40 f0       	brcs	.+16     	; 0x30d0 <prvCopyDataFromQueue+0x62>
        {
            pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
    30c0:	e9 81       	ldd	r30, Y+1	; 0x01
    30c2:	fa 81       	ldd	r31, Y+2	; 0x02
    30c4:	80 81       	ld	r24, Z
    30c6:	91 81       	ldd	r25, Z+1	; 0x01
    30c8:	e9 81       	ldd	r30, Y+1	; 0x01
    30ca:	fa 81       	ldd	r31, Y+2	; 0x02
    30cc:	97 83       	std	Z+7, r25	; 0x07
    30ce:	86 83       	std	Z+6, r24	; 0x06
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        ( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
    30d0:	e9 81       	ldd	r30, Y+1	; 0x01
    30d2:	fa 81       	ldd	r31, Y+2	; 0x02
    30d4:	46 81       	ldd	r20, Z+6	; 0x06
    30d6:	57 81       	ldd	r21, Z+7	; 0x07
    30d8:	e9 81       	ldd	r30, Y+1	; 0x01
    30da:	fa 81       	ldd	r31, Y+2	; 0x02
    30dc:	84 8d       	ldd	r24, Z+28	; 0x1c
    30de:	28 2f       	mov	r18, r24
    30e0:	30 e0       	ldi	r19, 0x00	; 0
    30e2:	8b 81       	ldd	r24, Y+3	; 0x03
    30e4:	9c 81       	ldd	r25, Y+4	; 0x04
    30e6:	ba 01       	movw	r22, r20
    30e8:	a9 01       	movw	r20, r18
    30ea:	0e 94 0e 49 	call	0x921c	; 0x921c <memcpy>
    }
}
    30ee:	0f 90       	pop	r0
    30f0:	0f 90       	pop	r0
    30f2:	0f 90       	pop	r0
    30f4:	0f 90       	pop	r0
    30f6:	cf 91       	pop	r28
    30f8:	df 91       	pop	r29
    30fa:	08 95       	ret

000030fc <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
    30fc:	df 93       	push	r29
    30fe:	cf 93       	push	r28
    3100:	00 d0       	rcall	.+0      	; 0x3102 <prvUnlockQueue+0x6>
    3102:	00 d0       	rcall	.+0      	; 0x3104 <prvUnlockQueue+0x8>
    3104:	cd b7       	in	r28, 0x3d	; 61
    3106:	de b7       	in	r29, 0x3e	; 62
    3108:	9c 83       	std	Y+4, r25	; 0x04
    310a:	8b 83       	std	Y+3, r24	; 0x03

    /* The lock counts contains the number of extra data items placed or
     * removed from the queue while the queue was locked.  When a queue is
     * locked items can be added or removed, but the event lists cannot be
     * updated. */
    taskENTER_CRITICAL();
    310c:	0f b6       	in	r0, 0x3f	; 63
    310e:	f8 94       	cli
    3110:	0f 92       	push	r0
    {
        int8_t cTxLock = pxQueue->cTxLock;
    3112:	eb 81       	ldd	r30, Y+3	; 0x03
    3114:	fc 81       	ldd	r31, Y+4	; 0x04
    3116:	86 8d       	ldd	r24, Z+30	; 0x1e
    3118:	8a 83       	std	Y+2, r24	; 0x02
    311a:	11 c0       	rjmp	.+34     	; 0x313e <prvUnlockQueue+0x42>
                }
            #else /* configUSE_QUEUE_SETS */
                {
                    /* Tasks that are removed from the event list will get added to
                     * the pending ready list as the scheduler is still suspended. */
                    if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    311c:	eb 81       	ldd	r30, Y+3	; 0x03
    311e:	fc 81       	ldd	r31, Y+4	; 0x04
    3120:	81 89       	ldd	r24, Z+17	; 0x11
    3122:	88 23       	and	r24, r24
    3124:	79 f0       	breq	.+30     	; 0x3144 <prvUnlockQueue+0x48>
                    {
                        if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    3126:	8b 81       	ldd	r24, Y+3	; 0x03
    3128:	9c 81       	ldd	r25, Y+4	; 0x04
    312a:	41 96       	adiw	r24, 0x11	; 17
    312c:	0e 94 4e 23 	call	0x469c	; 0x469c <xTaskRemoveFromEventList>
    3130:	88 23       	and	r24, r24
    3132:	11 f0       	breq	.+4      	; 0x3138 <prvUnlockQueue+0x3c>
                        {
                            /* The task waiting has a higher priority so record that
                             * a context switch is required. */
                            vTaskMissedYield();
    3134:	0e 94 3e 26 	call	0x4c7c	; 0x4c7c <vTaskMissedYield>
                        break;
                    }
                }
            #endif /* configUSE_QUEUE_SETS */

            --cTxLock;
    3138:	8a 81       	ldd	r24, Y+2	; 0x02
    313a:	81 50       	subi	r24, 0x01	; 1
    313c:	8a 83       	std	Y+2, r24	; 0x02
    taskENTER_CRITICAL();
    {
        int8_t cTxLock = pxQueue->cTxLock;

        /* See if data was added to the queue while it was locked. */
        while( cTxLock > queueLOCKED_UNMODIFIED )
    313e:	8a 81       	ldd	r24, Y+2	; 0x02
    3140:	18 16       	cp	r1, r24
    3142:	64 f3       	brlt	.-40     	; 0x311c <prvUnlockQueue+0x20>
            #endif /* configUSE_QUEUE_SETS */

            --cTxLock;
        }

        pxQueue->cTxLock = queueUNLOCKED;
    3144:	eb 81       	ldd	r30, Y+3	; 0x03
    3146:	fc 81       	ldd	r31, Y+4	; 0x04
    3148:	8f ef       	ldi	r24, 0xFF	; 255
    314a:	86 8f       	std	Z+30, r24	; 0x1e
    }
    taskEXIT_CRITICAL();
    314c:	0f 90       	pop	r0
    314e:	0f be       	out	0x3f, r0	; 63

    /* Do the same for the Rx lock. */
    taskENTER_CRITICAL();
    3150:	0f b6       	in	r0, 0x3f	; 63
    3152:	f8 94       	cli
    3154:	0f 92       	push	r0
    {
        int8_t cRxLock = pxQueue->cRxLock;
    3156:	eb 81       	ldd	r30, Y+3	; 0x03
    3158:	fc 81       	ldd	r31, Y+4	; 0x04
    315a:	85 8d       	ldd	r24, Z+29	; 0x1d
    315c:	89 83       	std	Y+1, r24	; 0x01
    315e:	11 c0       	rjmp	.+34     	; 0x3182 <prvUnlockQueue+0x86>

        while( cRxLock > queueLOCKED_UNMODIFIED )
        {
            if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    3160:	eb 81       	ldd	r30, Y+3	; 0x03
    3162:	fc 81       	ldd	r31, Y+4	; 0x04
    3164:	80 85       	ldd	r24, Z+8	; 0x08
    3166:	88 23       	and	r24, r24
    3168:	79 f0       	breq	.+30     	; 0x3188 <prvUnlockQueue+0x8c>
            {
                if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    316a:	8b 81       	ldd	r24, Y+3	; 0x03
    316c:	9c 81       	ldd	r25, Y+4	; 0x04
    316e:	08 96       	adiw	r24, 0x08	; 8
    3170:	0e 94 4e 23 	call	0x469c	; 0x469c <xTaskRemoveFromEventList>
    3174:	88 23       	and	r24, r24
    3176:	11 f0       	breq	.+4      	; 0x317c <prvUnlockQueue+0x80>
                {
                    vTaskMissedYield();
    3178:	0e 94 3e 26 	call	0x4c7c	; 0x4c7c <vTaskMissedYield>
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                --cRxLock;
    317c:	89 81       	ldd	r24, Y+1	; 0x01
    317e:	81 50       	subi	r24, 0x01	; 1
    3180:	89 83       	std	Y+1, r24	; 0x01
    /* Do the same for the Rx lock. */
    taskENTER_CRITICAL();
    {
        int8_t cRxLock = pxQueue->cRxLock;

        while( cRxLock > queueLOCKED_UNMODIFIED )
    3182:	89 81       	ldd	r24, Y+1	; 0x01
    3184:	18 16       	cp	r1, r24
    3186:	64 f3       	brlt	.-40     	; 0x3160 <prvUnlockQueue+0x64>
            {
                break;
            }
        }

        pxQueue->cRxLock = queueUNLOCKED;
    3188:	eb 81       	ldd	r30, Y+3	; 0x03
    318a:	fc 81       	ldd	r31, Y+4	; 0x04
    318c:	8f ef       	ldi	r24, 0xFF	; 255
    318e:	85 8f       	std	Z+29, r24	; 0x1d
    }
    taskEXIT_CRITICAL();
    3190:	0f 90       	pop	r0
    3192:	0f be       	out	0x3f, r0	; 63
}
    3194:	0f 90       	pop	r0
    3196:	0f 90       	pop	r0
    3198:	0f 90       	pop	r0
    319a:	0f 90       	pop	r0
    319c:	cf 91       	pop	r28
    319e:	df 91       	pop	r29
    31a0:	08 95       	ret

000031a2 <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueEmpty( const Queue_t * pxQueue )
{
    31a2:	df 93       	push	r29
    31a4:	cf 93       	push	r28
    31a6:	00 d0       	rcall	.+0      	; 0x31a8 <prvIsQueueEmpty+0x6>
    31a8:	0f 92       	push	r0
    31aa:	cd b7       	in	r28, 0x3d	; 61
    31ac:	de b7       	in	r29, 0x3e	; 62
    31ae:	9b 83       	std	Y+3, r25	; 0x03
    31b0:	8a 83       	std	Y+2, r24	; 0x02
    BaseType_t xReturn;

    taskENTER_CRITICAL();
    31b2:	0f b6       	in	r0, 0x3f	; 63
    31b4:	f8 94       	cli
    31b6:	0f 92       	push	r0
    {
        if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    31b8:	ea 81       	ldd	r30, Y+2	; 0x02
    31ba:	fb 81       	ldd	r31, Y+3	; 0x03
    31bc:	82 8d       	ldd	r24, Z+26	; 0x1a
    31be:	88 23       	and	r24, r24
    31c0:	19 f4       	brne	.+6      	; 0x31c8 <prvIsQueueEmpty+0x26>
        {
            xReturn = pdTRUE;
    31c2:	81 e0       	ldi	r24, 0x01	; 1
    31c4:	89 83       	std	Y+1, r24	; 0x01
    31c6:	01 c0       	rjmp	.+2      	; 0x31ca <prvIsQueueEmpty+0x28>
        }
        else
        {
            xReturn = pdFALSE;
    31c8:	19 82       	std	Y+1, r1	; 0x01
        }
    }
    taskEXIT_CRITICAL();
    31ca:	0f 90       	pop	r0
    31cc:	0f be       	out	0x3f, r0	; 63

    return xReturn;
    31ce:	89 81       	ldd	r24, Y+1	; 0x01
}
    31d0:	0f 90       	pop	r0
    31d2:	0f 90       	pop	r0
    31d4:	0f 90       	pop	r0
    31d6:	cf 91       	pop	r28
    31d8:	df 91       	pop	r29
    31da:	08 95       	ret

000031dc <xQueueIsQueueEmptyFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )
{
    31dc:	df 93       	push	r29
    31de:	cf 93       	push	r28
    31e0:	00 d0       	rcall	.+0      	; 0x31e2 <xQueueIsQueueEmptyFromISR+0x6>
    31e2:	00 d0       	rcall	.+0      	; 0x31e4 <xQueueIsQueueEmptyFromISR+0x8>
    31e4:	0f 92       	push	r0
    31e6:	cd b7       	in	r28, 0x3d	; 61
    31e8:	de b7       	in	r29, 0x3e	; 62
    31ea:	9d 83       	std	Y+5, r25	; 0x05
    31ec:	8c 83       	std	Y+4, r24	; 0x04
    BaseType_t xReturn;
    Queue_t * const pxQueue = xQueue;
    31ee:	8c 81       	ldd	r24, Y+4	; 0x04
    31f0:	9d 81       	ldd	r25, Y+5	; 0x05
    31f2:	9a 83       	std	Y+2, r25	; 0x02
    31f4:	89 83       	std	Y+1, r24	; 0x01

    configASSERT( pxQueue );

    if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    31f6:	e9 81       	ldd	r30, Y+1	; 0x01
    31f8:	fa 81       	ldd	r31, Y+2	; 0x02
    31fa:	82 8d       	ldd	r24, Z+26	; 0x1a
    31fc:	88 23       	and	r24, r24
    31fe:	19 f4       	brne	.+6      	; 0x3206 <xQueueIsQueueEmptyFromISR+0x2a>
    {
        xReturn = pdTRUE;
    3200:	81 e0       	ldi	r24, 0x01	; 1
    3202:	8b 83       	std	Y+3, r24	; 0x03
    3204:	01 c0       	rjmp	.+2      	; 0x3208 <xQueueIsQueueEmptyFromISR+0x2c>
    }
    else
    {
        xReturn = pdFALSE;
    3206:	1b 82       	std	Y+3, r1	; 0x03
    }

    return xReturn;
    3208:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    320a:	0f 90       	pop	r0
    320c:	0f 90       	pop	r0
    320e:	0f 90       	pop	r0
    3210:	0f 90       	pop	r0
    3212:	0f 90       	pop	r0
    3214:	cf 91       	pop	r28
    3216:	df 91       	pop	r29
    3218:	08 95       	ret

0000321a <prvIsQueueFull>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueFull( const Queue_t * pxQueue )
{
    321a:	df 93       	push	r29
    321c:	cf 93       	push	r28
    321e:	00 d0       	rcall	.+0      	; 0x3220 <prvIsQueueFull+0x6>
    3220:	0f 92       	push	r0
    3222:	cd b7       	in	r28, 0x3d	; 61
    3224:	de b7       	in	r29, 0x3e	; 62
    3226:	9b 83       	std	Y+3, r25	; 0x03
    3228:	8a 83       	std	Y+2, r24	; 0x02
    BaseType_t xReturn;

    taskENTER_CRITICAL();
    322a:	0f b6       	in	r0, 0x3f	; 63
    322c:	f8 94       	cli
    322e:	0f 92       	push	r0
    {
        if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    3230:	ea 81       	ldd	r30, Y+2	; 0x02
    3232:	fb 81       	ldd	r31, Y+3	; 0x03
    3234:	92 8d       	ldd	r25, Z+26	; 0x1a
    3236:	ea 81       	ldd	r30, Y+2	; 0x02
    3238:	fb 81       	ldd	r31, Y+3	; 0x03
    323a:	83 8d       	ldd	r24, Z+27	; 0x1b
    323c:	98 17       	cp	r25, r24
    323e:	19 f4       	brne	.+6      	; 0x3246 <prvIsQueueFull+0x2c>
        {
            xReturn = pdTRUE;
    3240:	81 e0       	ldi	r24, 0x01	; 1
    3242:	89 83       	std	Y+1, r24	; 0x01
    3244:	01 c0       	rjmp	.+2      	; 0x3248 <prvIsQueueFull+0x2e>
        }
        else
        {
            xReturn = pdFALSE;
    3246:	19 82       	std	Y+1, r1	; 0x01
        }
    }
    taskEXIT_CRITICAL();
    3248:	0f 90       	pop	r0
    324a:	0f be       	out	0x3f, r0	; 63

    return xReturn;
    324c:	89 81       	ldd	r24, Y+1	; 0x01
}
    324e:	0f 90       	pop	r0
    3250:	0f 90       	pop	r0
    3252:	0f 90       	pop	r0
    3254:	cf 91       	pop	r28
    3256:	df 91       	pop	r29
    3258:	08 95       	ret

0000325a <xQueueIsQueueFullFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
{
    325a:	df 93       	push	r29
    325c:	cf 93       	push	r28
    325e:	00 d0       	rcall	.+0      	; 0x3260 <xQueueIsQueueFullFromISR+0x6>
    3260:	00 d0       	rcall	.+0      	; 0x3262 <xQueueIsQueueFullFromISR+0x8>
    3262:	0f 92       	push	r0
    3264:	cd b7       	in	r28, 0x3d	; 61
    3266:	de b7       	in	r29, 0x3e	; 62
    3268:	9d 83       	std	Y+5, r25	; 0x05
    326a:	8c 83       	std	Y+4, r24	; 0x04
    BaseType_t xReturn;
    Queue_t * const pxQueue = xQueue;
    326c:	8c 81       	ldd	r24, Y+4	; 0x04
    326e:	9d 81       	ldd	r25, Y+5	; 0x05
    3270:	9a 83       	std	Y+2, r25	; 0x02
    3272:	89 83       	std	Y+1, r24	; 0x01

    configASSERT( pxQueue );

    if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    3274:	e9 81       	ldd	r30, Y+1	; 0x01
    3276:	fa 81       	ldd	r31, Y+2	; 0x02
    3278:	92 8d       	ldd	r25, Z+26	; 0x1a
    327a:	e9 81       	ldd	r30, Y+1	; 0x01
    327c:	fa 81       	ldd	r31, Y+2	; 0x02
    327e:	83 8d       	ldd	r24, Z+27	; 0x1b
    3280:	98 17       	cp	r25, r24
    3282:	19 f4       	brne	.+6      	; 0x328a <xQueueIsQueueFullFromISR+0x30>
    {
        xReturn = pdTRUE;
    3284:	81 e0       	ldi	r24, 0x01	; 1
    3286:	8b 83       	std	Y+3, r24	; 0x03
    3288:	01 c0       	rjmp	.+2      	; 0x328c <xQueueIsQueueFullFromISR+0x32>
    }
    else
    {
        xReturn = pdFALSE;
    328a:	1b 82       	std	Y+3, r1	; 0x03
    }

    return xReturn;
    328c:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    328e:	0f 90       	pop	r0
    3290:	0f 90       	pop	r0
    3292:	0f 90       	pop	r0
    3294:	0f 90       	pop	r0
    3296:	0f 90       	pop	r0
    3298:	cf 91       	pop	r28
    329a:	df 91       	pop	r29
    329c:	08 95       	ret

0000329e <xQueueCRSend>:
#if ( configUSE_CO_ROUTINES == 1 )

    BaseType_t xQueueCRSend( QueueHandle_t xQueue,
                             const void * pvItemToQueue,
                             TickType_t xTicksToWait )
    {
    329e:	df 93       	push	r29
    32a0:	cf 93       	push	r28
    32a2:	cd b7       	in	r28, 0x3d	; 61
    32a4:	de b7       	in	r29, 0x3e	; 62
    32a6:	2a 97       	sbiw	r28, 0x0a	; 10
    32a8:	0f b6       	in	r0, 0x3f	; 63
    32aa:	f8 94       	cli
    32ac:	de bf       	out	0x3e, r29	; 62
    32ae:	0f be       	out	0x3f, r0	; 63
    32b0:	cd bf       	out	0x3d, r28	; 61
    32b2:	9d 83       	std	Y+5, r25	; 0x05
    32b4:	8c 83       	std	Y+4, r24	; 0x04
    32b6:	7f 83       	std	Y+7, r23	; 0x07
    32b8:	6e 83       	std	Y+6, r22	; 0x06
    32ba:	59 87       	std	Y+9, r21	; 0x09
    32bc:	48 87       	std	Y+8, r20	; 0x08
        BaseType_t xReturn;
        Queue_t * const pxQueue = xQueue;
    32be:	8c 81       	ldd	r24, Y+4	; 0x04
    32c0:	9d 81       	ldd	r25, Y+5	; 0x05
    32c2:	9a 83       	std	Y+2, r25	; 0x02
    32c4:	89 83       	std	Y+1, r24	; 0x01

        /* If the queue is already full we may have to block.  A critical section
         * is required to prevent an interrupt removing something from the queue
         * between the check to see if the queue is full and blocking on the queue. */
        portDISABLE_INTERRUPTS();
    32c6:	f8 94       	cli
        {
            if( prvIsQueueFull( pxQueue ) != pdFALSE )
    32c8:	89 81       	ldd	r24, Y+1	; 0x01
    32ca:	9a 81       	ldd	r25, Y+2	; 0x02
    32cc:	0e 94 0d 19 	call	0x321a	; 0x321a <prvIsQueueFull>
    32d0:	88 23       	and	r24, r24
    32d2:	a9 f0       	breq	.+42     	; 0x32fe <xQueueCRSend+0x60>
            {
                /* The queue is full - do we want to block or just leave without
                 * posting? */
                if( xTicksToWait > ( TickType_t ) 0 )
    32d4:	88 85       	ldd	r24, Y+8	; 0x08
    32d6:	99 85       	ldd	r25, Y+9	; 0x09
    32d8:	00 97       	sbiw	r24, 0x00	; 0
    32da:	71 f0       	breq	.+28     	; 0x32f8 <xQueueCRSend+0x5a>
                {
                    /* As this is called from a coroutine we cannot block directly, but
                     * return indicating that we need to block. */
                    vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToSend ) );
    32dc:	89 81       	ldd	r24, Y+1	; 0x01
    32de:	9a 81       	ldd	r25, Y+2	; 0x02
    32e0:	9c 01       	movw	r18, r24
    32e2:	28 5f       	subi	r18, 0xF8	; 248
    32e4:	3f 4f       	sbci	r19, 0xFF	; 255
    32e6:	88 85       	ldd	r24, Y+8	; 0x08
    32e8:	99 85       	ldd	r25, Y+9	; 0x09
    32ea:	b9 01       	movw	r22, r18
    32ec:	0e 94 1b 0b 	call	0x1636	; 0x1636 <vCoRoutineAddToDelayedList>
                    portENABLE_INTERRUPTS();
    32f0:	78 94       	sei
                    return errQUEUE_BLOCKED;
    32f2:	8c ef       	ldi	r24, 0xFC	; 252
    32f4:	8a 87       	std	Y+10, r24	; 0x0a
    32f6:	2a c0       	rjmp	.+84     	; 0x334c <xQueueCRSend+0xae>
                }
                else
                {
                    portENABLE_INTERRUPTS();
    32f8:	78 94       	sei
                    return errQUEUE_FULL;
    32fa:	1a 86       	std	Y+10, r1	; 0x0a
    32fc:	27 c0       	rjmp	.+78     	; 0x334c <xQueueCRSend+0xae>
                }
            }
        }
        portENABLE_INTERRUPTS();
    32fe:	78 94       	sei

        portDISABLE_INTERRUPTS();
    3300:	f8 94       	cli
        {
            if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    3302:	e9 81       	ldd	r30, Y+1	; 0x01
    3304:	fa 81       	ldd	r31, Y+2	; 0x02
    3306:	92 8d       	ldd	r25, Z+26	; 0x1a
    3308:	e9 81       	ldd	r30, Y+1	; 0x01
    330a:	fa 81       	ldd	r31, Y+2	; 0x02
    330c:	83 8d       	ldd	r24, Z+27	; 0x1b
    330e:	98 17       	cp	r25, r24
    3310:	c8 f4       	brcc	.+50     	; 0x3344 <xQueueCRSend+0xa6>
            {
                /* There is room in the queue, copy the data into the queue. */
                prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
    3312:	89 81       	ldd	r24, Y+1	; 0x01
    3314:	9a 81       	ldd	r25, Y+2	; 0x02
    3316:	2e 81       	ldd	r18, Y+6	; 0x06
    3318:	3f 81       	ldd	r19, Y+7	; 0x07
    331a:	b9 01       	movw	r22, r18
    331c:	40 e0       	ldi	r20, 0x00	; 0
    331e:	0e 94 91 17 	call	0x2f22	; 0x2f22 <prvCopyDataToQueue>
                xReturn = pdPASS;
    3322:	81 e0       	ldi	r24, 0x01	; 1
    3324:	8b 83       	std	Y+3, r24	; 0x03

                /* Were any co-routines waiting for data to become available? */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    3326:	e9 81       	ldd	r30, Y+1	; 0x01
    3328:	fa 81       	ldd	r31, Y+2	; 0x02
    332a:	81 89       	ldd	r24, Z+17	; 0x11
    332c:	88 23       	and	r24, r24
    332e:	59 f0       	breq	.+22     	; 0x3346 <xQueueCRSend+0xa8>
                {
                    /* In this instance the co-routine could be placed directly
                     * into the ready list as we are within a critical section.
                     * Instead the same pending ready list mechanism is used as if
                     * the event were caused from within an interrupt. */
                    if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    3330:	89 81       	ldd	r24, Y+1	; 0x01
    3332:	9a 81       	ldd	r25, Y+2	; 0x02
    3334:	41 96       	adiw	r24, 0x11	; 17
    3336:	0e 94 2e 0d 	call	0x1a5c	; 0x1a5c <xCoRoutineRemoveFromEventList>
    333a:	88 23       	and	r24, r24
    333c:	21 f0       	breq	.+8      	; 0x3346 <xQueueCRSend+0xa8>
                    {
                        /* The co-routine waiting has a higher priority so record
                         * that a yield might be appropriate. */
                        xReturn = errQUEUE_YIELD;
    333e:	8b ef       	ldi	r24, 0xFB	; 251
    3340:	8b 83       	std	Y+3, r24	; 0x03
    3342:	01 c0       	rjmp	.+2      	; 0x3346 <xQueueCRSend+0xa8>
                    mtCOVERAGE_TEST_MARKER();
                }
            }
            else
            {
                xReturn = errQUEUE_FULL;
    3344:	1b 82       	std	Y+3, r1	; 0x03
            }
        }
        portENABLE_INTERRUPTS();
    3346:	78 94       	sei

        return xReturn;
    3348:	8b 81       	ldd	r24, Y+3	; 0x03
    334a:	8a 87       	std	Y+10, r24	; 0x0a
    334c:	8a 85       	ldd	r24, Y+10	; 0x0a
    }
    334e:	2a 96       	adiw	r28, 0x0a	; 10
    3350:	0f b6       	in	r0, 0x3f	; 63
    3352:	f8 94       	cli
    3354:	de bf       	out	0x3e, r29	; 62
    3356:	0f be       	out	0x3f, r0	; 63
    3358:	cd bf       	out	0x3d, r28	; 61
    335a:	cf 91       	pop	r28
    335c:	df 91       	pop	r29
    335e:	08 95       	ret

00003360 <xQueueCRReceive>:
#if ( configUSE_CO_ROUTINES == 1 )

    BaseType_t xQueueCRReceive( QueueHandle_t xQueue,
                                void * pvBuffer,
                                TickType_t xTicksToWait )
    {
    3360:	df 93       	push	r29
    3362:	cf 93       	push	r28
    3364:	cd b7       	in	r28, 0x3d	; 61
    3366:	de b7       	in	r29, 0x3e	; 62
    3368:	2a 97       	sbiw	r28, 0x0a	; 10
    336a:	0f b6       	in	r0, 0x3f	; 63
    336c:	f8 94       	cli
    336e:	de bf       	out	0x3e, r29	; 62
    3370:	0f be       	out	0x3f, r0	; 63
    3372:	cd bf       	out	0x3d, r28	; 61
    3374:	9d 83       	std	Y+5, r25	; 0x05
    3376:	8c 83       	std	Y+4, r24	; 0x04
    3378:	7f 83       	std	Y+7, r23	; 0x07
    337a:	6e 83       	std	Y+6, r22	; 0x06
    337c:	59 87       	std	Y+9, r21	; 0x09
    337e:	48 87       	std	Y+8, r20	; 0x08
        BaseType_t xReturn;
        Queue_t * const pxQueue = xQueue;
    3380:	8c 81       	ldd	r24, Y+4	; 0x04
    3382:	9d 81       	ldd	r25, Y+5	; 0x05
    3384:	9a 83       	std	Y+2, r25	; 0x02
    3386:	89 83       	std	Y+1, r24	; 0x01

        /* If the queue is already empty we may have to block.  A critical section
         * is required to prevent an interrupt adding something to the queue
         * between the check to see if the queue is empty and blocking on the queue. */
        portDISABLE_INTERRUPTS();
    3388:	f8 94       	cli
        {
            if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    338a:	e9 81       	ldd	r30, Y+1	; 0x01
    338c:	fa 81       	ldd	r31, Y+2	; 0x02
    338e:	82 8d       	ldd	r24, Z+26	; 0x1a
    3390:	88 23       	and	r24, r24
    3392:	a9 f4       	brne	.+42     	; 0x33be <xQueueCRReceive+0x5e>
            {
                /* There are no messages in the queue, do we want to block or just
                 * leave with nothing? */
                if( xTicksToWait > ( TickType_t ) 0 )
    3394:	88 85       	ldd	r24, Y+8	; 0x08
    3396:	99 85       	ldd	r25, Y+9	; 0x09
    3398:	00 97       	sbiw	r24, 0x00	; 0
    339a:	71 f0       	breq	.+28     	; 0x33b8 <xQueueCRReceive+0x58>
                {
                    /* As this is a co-routine we cannot block directly, but return
                     * indicating that we need to block. */
                    vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToReceive ) );
    339c:	89 81       	ldd	r24, Y+1	; 0x01
    339e:	9a 81       	ldd	r25, Y+2	; 0x02
    33a0:	9c 01       	movw	r18, r24
    33a2:	2f 5e       	subi	r18, 0xEF	; 239
    33a4:	3f 4f       	sbci	r19, 0xFF	; 255
    33a6:	88 85       	ldd	r24, Y+8	; 0x08
    33a8:	99 85       	ldd	r25, Y+9	; 0x09
    33aa:	b9 01       	movw	r22, r18
    33ac:	0e 94 1b 0b 	call	0x1636	; 0x1636 <vCoRoutineAddToDelayedList>
                    portENABLE_INTERRUPTS();
    33b0:	78 94       	sei
                    return errQUEUE_BLOCKED;
    33b2:	8c ef       	ldi	r24, 0xFC	; 252
    33b4:	8a 87       	std	Y+10, r24	; 0x0a
    33b6:	58 c0       	rjmp	.+176    	; 0x3468 <xQueueCRReceive+0x108>
                }
                else
                {
                    portENABLE_INTERRUPTS();
    33b8:	78 94       	sei
                    return errQUEUE_FULL;
    33ba:	1a 86       	std	Y+10, r1	; 0x0a
    33bc:	55 c0       	rjmp	.+170    	; 0x3468 <xQueueCRReceive+0x108>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        portENABLE_INTERRUPTS();
    33be:	78 94       	sei

        portDISABLE_INTERRUPTS();
    33c0:	f8 94       	cli
        {
            if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    33c2:	e9 81       	ldd	r30, Y+1	; 0x01
    33c4:	fa 81       	ldd	r31, Y+2	; 0x02
    33c6:	82 8d       	ldd	r24, Z+26	; 0x1a
    33c8:	88 23       	and	r24, r24
    33ca:	09 f4       	brne	.+2      	; 0x33ce <xQueueCRReceive+0x6e>
    33cc:	49 c0       	rjmp	.+146    	; 0x3460 <xQueueCRReceive+0x100>
            {
                /* Data is available from the queue. */
                pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;
    33ce:	e9 81       	ldd	r30, Y+1	; 0x01
    33d0:	fa 81       	ldd	r31, Y+2	; 0x02
    33d2:	26 81       	ldd	r18, Z+6	; 0x06
    33d4:	37 81       	ldd	r19, Z+7	; 0x07
    33d6:	e9 81       	ldd	r30, Y+1	; 0x01
    33d8:	fa 81       	ldd	r31, Y+2	; 0x02
    33da:	84 8d       	ldd	r24, Z+28	; 0x1c
    33dc:	88 2f       	mov	r24, r24
    33de:	90 e0       	ldi	r25, 0x00	; 0
    33e0:	82 0f       	add	r24, r18
    33e2:	93 1f       	adc	r25, r19
    33e4:	e9 81       	ldd	r30, Y+1	; 0x01
    33e6:	fa 81       	ldd	r31, Y+2	; 0x02
    33e8:	97 83       	std	Z+7, r25	; 0x07
    33ea:	86 83       	std	Z+6, r24	; 0x06

                if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail )
    33ec:	e9 81       	ldd	r30, Y+1	; 0x01
    33ee:	fa 81       	ldd	r31, Y+2	; 0x02
    33f0:	26 81       	ldd	r18, Z+6	; 0x06
    33f2:	37 81       	ldd	r19, Z+7	; 0x07
    33f4:	e9 81       	ldd	r30, Y+1	; 0x01
    33f6:	fa 81       	ldd	r31, Y+2	; 0x02
    33f8:	84 81       	ldd	r24, Z+4	; 0x04
    33fa:	95 81       	ldd	r25, Z+5	; 0x05
    33fc:	28 17       	cp	r18, r24
    33fe:	39 07       	cpc	r19, r25
    3400:	40 f0       	brcs	.+16     	; 0x3412 <xQueueCRReceive+0xb2>
                {
                    pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
    3402:	e9 81       	ldd	r30, Y+1	; 0x01
    3404:	fa 81       	ldd	r31, Y+2	; 0x02
    3406:	80 81       	ld	r24, Z
    3408:	91 81       	ldd	r25, Z+1	; 0x01
    340a:	e9 81       	ldd	r30, Y+1	; 0x01
    340c:	fa 81       	ldd	r31, Y+2	; 0x02
    340e:	97 83       	std	Z+7, r25	; 0x07
    3410:	86 83       	std	Z+6, r24	; 0x06
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                --( pxQueue->uxMessagesWaiting );
    3412:	e9 81       	ldd	r30, Y+1	; 0x01
    3414:	fa 81       	ldd	r31, Y+2	; 0x02
    3416:	82 8d       	ldd	r24, Z+26	; 0x1a
    3418:	81 50       	subi	r24, 0x01	; 1
    341a:	e9 81       	ldd	r30, Y+1	; 0x01
    341c:	fa 81       	ldd	r31, Y+2	; 0x02
    341e:	82 8f       	std	Z+26, r24	; 0x1a
                ( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    3420:	e9 81       	ldd	r30, Y+1	; 0x01
    3422:	fa 81       	ldd	r31, Y+2	; 0x02
    3424:	46 81       	ldd	r20, Z+6	; 0x06
    3426:	57 81       	ldd	r21, Z+7	; 0x07
    3428:	e9 81       	ldd	r30, Y+1	; 0x01
    342a:	fa 81       	ldd	r31, Y+2	; 0x02
    342c:	84 8d       	ldd	r24, Z+28	; 0x1c
    342e:	28 2f       	mov	r18, r24
    3430:	30 e0       	ldi	r19, 0x00	; 0
    3432:	8e 81       	ldd	r24, Y+6	; 0x06
    3434:	9f 81       	ldd	r25, Y+7	; 0x07
    3436:	ba 01       	movw	r22, r20
    3438:	a9 01       	movw	r20, r18
    343a:	0e 94 0e 49 	call	0x921c	; 0x921c <memcpy>

                xReturn = pdPASS;
    343e:	81 e0       	ldi	r24, 0x01	; 1
    3440:	8b 83       	std	Y+3, r24	; 0x03

                /* Were any co-routines waiting for space to become available? */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    3442:	e9 81       	ldd	r30, Y+1	; 0x01
    3444:	fa 81       	ldd	r31, Y+2	; 0x02
    3446:	80 85       	ldd	r24, Z+8	; 0x08
    3448:	88 23       	and	r24, r24
    344a:	59 f0       	breq	.+22     	; 0x3462 <xQueueCRReceive+0x102>
                {
                    /* In this instance the co-routine could be placed directly
                     * into the ready list as we are within a critical section.
                     * Instead the same pending ready list mechanism is used as if
                     * the event were caused from within an interrupt. */
                    if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    344c:	89 81       	ldd	r24, Y+1	; 0x01
    344e:	9a 81       	ldd	r25, Y+2	; 0x02
    3450:	08 96       	adiw	r24, 0x08	; 8
    3452:	0e 94 2e 0d 	call	0x1a5c	; 0x1a5c <xCoRoutineRemoveFromEventList>
    3456:	88 23       	and	r24, r24
    3458:	21 f0       	breq	.+8      	; 0x3462 <xQueueCRReceive+0x102>
                    {
                        xReturn = errQUEUE_YIELD;
    345a:	8b ef       	ldi	r24, 0xFB	; 251
    345c:	8b 83       	std	Y+3, r24	; 0x03
    345e:	01 c0       	rjmp	.+2      	; 0x3462 <xQueueCRReceive+0x102>
                    mtCOVERAGE_TEST_MARKER();
                }
            }
            else
            {
                xReturn = pdFAIL;
    3460:	1b 82       	std	Y+3, r1	; 0x03
            }
        }
        portENABLE_INTERRUPTS();
    3462:	78 94       	sei

        return xReturn;
    3464:	8b 81       	ldd	r24, Y+3	; 0x03
    3466:	8a 87       	std	Y+10, r24	; 0x0a
    3468:	8a 85       	ldd	r24, Y+10	; 0x0a
    }
    346a:	2a 96       	adiw	r28, 0x0a	; 10
    346c:	0f b6       	in	r0, 0x3f	; 63
    346e:	f8 94       	cli
    3470:	de bf       	out	0x3e, r29	; 62
    3472:	0f be       	out	0x3f, r0	; 63
    3474:	cd bf       	out	0x3d, r28	; 61
    3476:	cf 91       	pop	r28
    3478:	df 91       	pop	r29
    347a:	08 95       	ret

0000347c <xQueueCRSendFromISR>:
#if ( configUSE_CO_ROUTINES == 1 )

    BaseType_t xQueueCRSendFromISR( QueueHandle_t xQueue,
                                    const void * pvItemToQueue,
                                    BaseType_t xCoRoutinePreviouslyWoken )
    {
    347c:	df 93       	push	r29
    347e:	cf 93       	push	r28
    3480:	cd b7       	in	r28, 0x3d	; 61
    3482:	de b7       	in	r29, 0x3e	; 62
    3484:	28 97       	sbiw	r28, 0x08	; 8
    3486:	0f b6       	in	r0, 0x3f	; 63
    3488:	f8 94       	cli
    348a:	de bf       	out	0x3e, r29	; 62
    348c:	0f be       	out	0x3f, r0	; 63
    348e:	cd bf       	out	0x3d, r28	; 61
    3490:	9c 83       	std	Y+4, r25	; 0x04
    3492:	8b 83       	std	Y+3, r24	; 0x03
    3494:	7e 83       	std	Y+6, r23	; 0x06
    3496:	6d 83       	std	Y+5, r22	; 0x05
    3498:	4f 83       	std	Y+7, r20	; 0x07
        Queue_t * const pxQueue = xQueue;
    349a:	8b 81       	ldd	r24, Y+3	; 0x03
    349c:	9c 81       	ldd	r25, Y+4	; 0x04
    349e:	9a 83       	std	Y+2, r25	; 0x02
    34a0:	89 83       	std	Y+1, r24	; 0x01

        /* Cannot block within an ISR so if there is no space on the queue then
         * exit without doing anything. */
        if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    34a2:	e9 81       	ldd	r30, Y+1	; 0x01
    34a4:	fa 81       	ldd	r31, Y+2	; 0x02
    34a6:	92 8d       	ldd	r25, Z+26	; 0x1a
    34a8:	e9 81       	ldd	r30, Y+1	; 0x01
    34aa:	fa 81       	ldd	r31, Y+2	; 0x02
    34ac:	83 8d       	ldd	r24, Z+27	; 0x1b
    34ae:	98 17       	cp	r25, r24
    34b0:	d0 f4       	brcc	.+52     	; 0x34e6 <xQueueCRSendFromISR+0x6a>
        {
            prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
    34b2:	89 81       	ldd	r24, Y+1	; 0x01
    34b4:	9a 81       	ldd	r25, Y+2	; 0x02
    34b6:	2d 81       	ldd	r18, Y+5	; 0x05
    34b8:	3e 81       	ldd	r19, Y+6	; 0x06
    34ba:	b9 01       	movw	r22, r18
    34bc:	40 e0       	ldi	r20, 0x00	; 0
    34be:	0e 94 91 17 	call	0x2f22	; 0x2f22 <prvCopyDataToQueue>

            /* We only want to wake one co-routine per ISR, so check that a
             * co-routine has not already been woken. */
            if( xCoRoutinePreviouslyWoken == pdFALSE )
    34c2:	8f 81       	ldd	r24, Y+7	; 0x07
    34c4:	88 23       	and	r24, r24
    34c6:	79 f4       	brne	.+30     	; 0x34e6 <xQueueCRSendFromISR+0x6a>
            {
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    34c8:	e9 81       	ldd	r30, Y+1	; 0x01
    34ca:	fa 81       	ldd	r31, Y+2	; 0x02
    34cc:	81 89       	ldd	r24, Z+17	; 0x11
    34ce:	88 23       	and	r24, r24
    34d0:	51 f0       	breq	.+20     	; 0x34e6 <xQueueCRSendFromISR+0x6a>
                {
                    if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    34d2:	89 81       	ldd	r24, Y+1	; 0x01
    34d4:	9a 81       	ldd	r25, Y+2	; 0x02
    34d6:	41 96       	adiw	r24, 0x11	; 17
    34d8:	0e 94 2e 0d 	call	0x1a5c	; 0x1a5c <xCoRoutineRemoveFromEventList>
    34dc:	88 23       	and	r24, r24
    34de:	19 f0       	breq	.+6      	; 0x34e6 <xQueueCRSendFromISR+0x6a>
                    {
                        return pdTRUE;
    34e0:	81 e0       	ldi	r24, 0x01	; 1
    34e2:	88 87       	std	Y+8, r24	; 0x08
    34e4:	02 c0       	rjmp	.+4      	; 0x34ea <xQueueCRSendFromISR+0x6e>
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        return xCoRoutinePreviouslyWoken;
    34e6:	8f 81       	ldd	r24, Y+7	; 0x07
    34e8:	88 87       	std	Y+8, r24	; 0x08
    34ea:	88 85       	ldd	r24, Y+8	; 0x08
    }
    34ec:	28 96       	adiw	r28, 0x08	; 8
    34ee:	0f b6       	in	r0, 0x3f	; 63
    34f0:	f8 94       	cli
    34f2:	de bf       	out	0x3e, r29	; 62
    34f4:	0f be       	out	0x3f, r0	; 63
    34f6:	cd bf       	out	0x3d, r28	; 61
    34f8:	cf 91       	pop	r28
    34fa:	df 91       	pop	r29
    34fc:	08 95       	ret

000034fe <xQueueCRReceiveFromISR>:
#if ( configUSE_CO_ROUTINES == 1 )

    BaseType_t xQueueCRReceiveFromISR( QueueHandle_t xQueue,
                                       void * pvBuffer,
                                       BaseType_t * pxCoRoutineWoken )
    {
    34fe:	df 93       	push	r29
    3500:	cf 93       	push	r28
    3502:	cd b7       	in	r28, 0x3d	; 61
    3504:	de b7       	in	r29, 0x3e	; 62
    3506:	29 97       	sbiw	r28, 0x09	; 9
    3508:	0f b6       	in	r0, 0x3f	; 63
    350a:	f8 94       	cli
    350c:	de bf       	out	0x3e, r29	; 62
    350e:	0f be       	out	0x3f, r0	; 63
    3510:	cd bf       	out	0x3d, r28	; 61
    3512:	9d 83       	std	Y+5, r25	; 0x05
    3514:	8c 83       	std	Y+4, r24	; 0x04
    3516:	7f 83       	std	Y+7, r23	; 0x07
    3518:	6e 83       	std	Y+6, r22	; 0x06
    351a:	59 87       	std	Y+9, r21	; 0x09
    351c:	48 87       	std	Y+8, r20	; 0x08
        BaseType_t xReturn;
        Queue_t * const pxQueue = xQueue;
    351e:	8c 81       	ldd	r24, Y+4	; 0x04
    3520:	9d 81       	ldd	r25, Y+5	; 0x05
    3522:	9a 83       	std	Y+2, r25	; 0x02
    3524:	89 83       	std	Y+1, r24	; 0x01

        /* We cannot block from an ISR, so check there is data available. If
         * not then just leave without doing anything. */
        if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    3526:	e9 81       	ldd	r30, Y+1	; 0x01
    3528:	fa 81       	ldd	r31, Y+2	; 0x02
    352a:	82 8d       	ldd	r24, Z+26	; 0x1a
    352c:	88 23       	and	r24, r24
    352e:	09 f4       	brne	.+2      	; 0x3532 <xQueueCRReceiveFromISR+0x34>
    3530:	50 c0       	rjmp	.+160    	; 0x35d2 <xQueueCRReceiveFromISR+0xd4>
        {
            /* Copy the data from the queue. */
            pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;
    3532:	e9 81       	ldd	r30, Y+1	; 0x01
    3534:	fa 81       	ldd	r31, Y+2	; 0x02
    3536:	26 81       	ldd	r18, Z+6	; 0x06
    3538:	37 81       	ldd	r19, Z+7	; 0x07
    353a:	e9 81       	ldd	r30, Y+1	; 0x01
    353c:	fa 81       	ldd	r31, Y+2	; 0x02
    353e:	84 8d       	ldd	r24, Z+28	; 0x1c
    3540:	88 2f       	mov	r24, r24
    3542:	90 e0       	ldi	r25, 0x00	; 0
    3544:	82 0f       	add	r24, r18
    3546:	93 1f       	adc	r25, r19
    3548:	e9 81       	ldd	r30, Y+1	; 0x01
    354a:	fa 81       	ldd	r31, Y+2	; 0x02
    354c:	97 83       	std	Z+7, r25	; 0x07
    354e:	86 83       	std	Z+6, r24	; 0x06

            if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail )
    3550:	e9 81       	ldd	r30, Y+1	; 0x01
    3552:	fa 81       	ldd	r31, Y+2	; 0x02
    3554:	26 81       	ldd	r18, Z+6	; 0x06
    3556:	37 81       	ldd	r19, Z+7	; 0x07
    3558:	e9 81       	ldd	r30, Y+1	; 0x01
    355a:	fa 81       	ldd	r31, Y+2	; 0x02
    355c:	84 81       	ldd	r24, Z+4	; 0x04
    355e:	95 81       	ldd	r25, Z+5	; 0x05
    3560:	28 17       	cp	r18, r24
    3562:	39 07       	cpc	r19, r25
    3564:	40 f0       	brcs	.+16     	; 0x3576 <xQueueCRReceiveFromISR+0x78>
            {
                pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
    3566:	e9 81       	ldd	r30, Y+1	; 0x01
    3568:	fa 81       	ldd	r31, Y+2	; 0x02
    356a:	80 81       	ld	r24, Z
    356c:	91 81       	ldd	r25, Z+1	; 0x01
    356e:	e9 81       	ldd	r30, Y+1	; 0x01
    3570:	fa 81       	ldd	r31, Y+2	; 0x02
    3572:	97 83       	std	Z+7, r25	; 0x07
    3574:	86 83       	std	Z+6, r24	; 0x06
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }

            --( pxQueue->uxMessagesWaiting );
    3576:	e9 81       	ldd	r30, Y+1	; 0x01
    3578:	fa 81       	ldd	r31, Y+2	; 0x02
    357a:	82 8d       	ldd	r24, Z+26	; 0x1a
    357c:	81 50       	subi	r24, 0x01	; 1
    357e:	e9 81       	ldd	r30, Y+1	; 0x01
    3580:	fa 81       	ldd	r31, Y+2	; 0x02
    3582:	82 8f       	std	Z+26, r24	; 0x1a
            ( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    3584:	e9 81       	ldd	r30, Y+1	; 0x01
    3586:	fa 81       	ldd	r31, Y+2	; 0x02
    3588:	46 81       	ldd	r20, Z+6	; 0x06
    358a:	57 81       	ldd	r21, Z+7	; 0x07
    358c:	e9 81       	ldd	r30, Y+1	; 0x01
    358e:	fa 81       	ldd	r31, Y+2	; 0x02
    3590:	84 8d       	ldd	r24, Z+28	; 0x1c
    3592:	28 2f       	mov	r18, r24
    3594:	30 e0       	ldi	r19, 0x00	; 0
    3596:	8e 81       	ldd	r24, Y+6	; 0x06
    3598:	9f 81       	ldd	r25, Y+7	; 0x07
    359a:	ba 01       	movw	r22, r20
    359c:	a9 01       	movw	r20, r18
    359e:	0e 94 0e 49 	call	0x921c	; 0x921c <memcpy>

            if( ( *pxCoRoutineWoken ) == pdFALSE )
    35a2:	e8 85       	ldd	r30, Y+8	; 0x08
    35a4:	f9 85       	ldd	r31, Y+9	; 0x09
    35a6:	80 81       	ld	r24, Z
    35a8:	88 23       	and	r24, r24
    35aa:	81 f4       	brne	.+32     	; 0x35cc <xQueueCRReceiveFromISR+0xce>
            {
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    35ac:	e9 81       	ldd	r30, Y+1	; 0x01
    35ae:	fa 81       	ldd	r31, Y+2	; 0x02
    35b0:	80 85       	ldd	r24, Z+8	; 0x08
    35b2:	88 23       	and	r24, r24
    35b4:	59 f0       	breq	.+22     	; 0x35cc <xQueueCRReceiveFromISR+0xce>
                {
                    if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    35b6:	89 81       	ldd	r24, Y+1	; 0x01
    35b8:	9a 81       	ldd	r25, Y+2	; 0x02
    35ba:	08 96       	adiw	r24, 0x08	; 8
    35bc:	0e 94 2e 0d 	call	0x1a5c	; 0x1a5c <xCoRoutineRemoveFromEventList>
    35c0:	88 23       	and	r24, r24
    35c2:	21 f0       	breq	.+8      	; 0x35cc <xQueueCRReceiveFromISR+0xce>
                    {
                        *pxCoRoutineWoken = pdTRUE;
    35c4:	e8 85       	ldd	r30, Y+8	; 0x08
    35c6:	f9 85       	ldd	r31, Y+9	; 0x09
    35c8:	81 e0       	ldi	r24, 0x01	; 1
    35ca:	80 83       	st	Z, r24
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }

            xReturn = pdPASS;
    35cc:	81 e0       	ldi	r24, 0x01	; 1
    35ce:	8b 83       	std	Y+3, r24	; 0x03
    35d0:	01 c0       	rjmp	.+2      	; 0x35d4 <xQueueCRReceiveFromISR+0xd6>
        }
        else
        {
            xReturn = pdFAIL;
    35d2:	1b 82       	std	Y+3, r1	; 0x03
        }

        return xReturn;
    35d4:	8b 81       	ldd	r24, Y+3	; 0x03
    }
    35d6:	29 96       	adiw	r28, 0x09	; 9
    35d8:	0f b6       	in	r0, 0x3f	; 63
    35da:	f8 94       	cli
    35dc:	de bf       	out	0x3e, r29	; 62
    35de:	0f be       	out	0x3f, r0	; 63
    35e0:	cd bf       	out	0x3d, r28	; 61
    35e2:	cf 91       	pop	r28
    35e4:	df 91       	pop	r29
    35e6:	08 95       	ret

000035e8 <vQueueWaitForMessageRestricted>:
#if ( configUSE_TIMERS == 1 )

    void vQueueWaitForMessageRestricted( QueueHandle_t xQueue,
                                         TickType_t xTicksToWait,
                                         const BaseType_t xWaitIndefinitely )
    {
    35e8:	df 93       	push	r29
    35ea:	cf 93       	push	r28
    35ec:	cd b7       	in	r28, 0x3d	; 61
    35ee:	de b7       	in	r29, 0x3e	; 62
    35f0:	27 97       	sbiw	r28, 0x07	; 7
    35f2:	0f b6       	in	r0, 0x3f	; 63
    35f4:	f8 94       	cli
    35f6:	de bf       	out	0x3e, r29	; 62
    35f8:	0f be       	out	0x3f, r0	; 63
    35fa:	cd bf       	out	0x3d, r28	; 61
    35fc:	9c 83       	std	Y+4, r25	; 0x04
    35fe:	8b 83       	std	Y+3, r24	; 0x03
    3600:	7e 83       	std	Y+6, r23	; 0x06
    3602:	6d 83       	std	Y+5, r22	; 0x05
    3604:	4f 83       	std	Y+7, r20	; 0x07
        Queue_t * const pxQueue = xQueue;
    3606:	8b 81       	ldd	r24, Y+3	; 0x03
    3608:	9c 81       	ldd	r25, Y+4	; 0x04
    360a:	9a 83       	std	Y+2, r25	; 0x02
    360c:	89 83       	std	Y+1, r24	; 0x01
         *  will not actually cause the task to block, just place it on a blocked
         *  list.  It will not block until the scheduler is unlocked - at which
         *  time a yield will be performed.  If an item is added to the queue while
         *  the queue is locked, and the calling task blocks on the queue, then the
         *  calling task will be immediately unblocked when the queue is unlocked. */
        prvLockQueue( pxQueue );
    360e:	0f b6       	in	r0, 0x3f	; 63
    3610:	f8 94       	cli
    3612:	0f 92       	push	r0
    3614:	e9 81       	ldd	r30, Y+1	; 0x01
    3616:	fa 81       	ldd	r31, Y+2	; 0x02
    3618:	85 8d       	ldd	r24, Z+29	; 0x1d
    361a:	8f 3f       	cpi	r24, 0xFF	; 255
    361c:	19 f4       	brne	.+6      	; 0x3624 <vQueueWaitForMessageRestricted+0x3c>
    361e:	e9 81       	ldd	r30, Y+1	; 0x01
    3620:	fa 81       	ldd	r31, Y+2	; 0x02
    3622:	15 8e       	std	Z+29, r1	; 0x1d
    3624:	e9 81       	ldd	r30, Y+1	; 0x01
    3626:	fa 81       	ldd	r31, Y+2	; 0x02
    3628:	86 8d       	ldd	r24, Z+30	; 0x1e
    362a:	8f 3f       	cpi	r24, 0xFF	; 255
    362c:	19 f4       	brne	.+6      	; 0x3634 <vQueueWaitForMessageRestricted+0x4c>
    362e:	e9 81       	ldd	r30, Y+1	; 0x01
    3630:	fa 81       	ldd	r31, Y+2	; 0x02
    3632:	16 8e       	std	Z+30, r1	; 0x1e
    3634:	0f 90       	pop	r0
    3636:	0f be       	out	0x3f, r0	; 63

        if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
    3638:	e9 81       	ldd	r30, Y+1	; 0x01
    363a:	fa 81       	ldd	r31, Y+2	; 0x02
    363c:	82 8d       	ldd	r24, Z+26	; 0x1a
    363e:	88 23       	and	r24, r24
    3640:	49 f4       	brne	.+18     	; 0x3654 <vQueueWaitForMessageRestricted+0x6c>
        {
            /* There is nothing in the queue, block for the specified period. */
            vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait, xWaitIndefinitely );
    3642:	89 81       	ldd	r24, Y+1	; 0x01
    3644:	9a 81       	ldd	r25, Y+2	; 0x02
    3646:	41 96       	adiw	r24, 0x11	; 17
    3648:	2d 81       	ldd	r18, Y+5	; 0x05
    364a:	3e 81       	ldd	r19, Y+6	; 0x06
    364c:	b9 01       	movw	r22, r18
    364e:	4f 81       	ldd	r20, Y+7	; 0x07
    3650:	0e 94 ec 22 	call	0x45d8	; 0x45d8 <vTaskPlaceOnEventListRestricted>
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        prvUnlockQueue( pxQueue );
    3654:	89 81       	ldd	r24, Y+1	; 0x01
    3656:	9a 81       	ldd	r25, Y+2	; 0x02
    3658:	0e 94 7e 18 	call	0x30fc	; 0x30fc <prvUnlockQueue>
    }
    365c:	27 96       	adiw	r28, 0x07	; 7
    365e:	0f b6       	in	r0, 0x3f	; 63
    3660:	f8 94       	cli
    3662:	de bf       	out	0x3e, r29	; 62
    3664:	0f be       	out	0x3f, r0	; 63
    3666:	cd bf       	out	0x3d, r28	; 61
    3668:	cf 91       	pop	r28
    366a:	df 91       	pop	r29
    366c:	08 95       	ret

0000366e <xTaskCreate>:
                            const char * const pcName, /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
                            const configSTACK_DEPTH_TYPE usStackDepth,
                            void * const pvParameters,
                            UBaseType_t uxPriority,
                            TaskHandle_t * const pxCreatedTask )
    {
    366e:	8f 92       	push	r8
    3670:	9f 92       	push	r9
    3672:	af 92       	push	r10
    3674:	bf 92       	push	r11
    3676:	cf 92       	push	r12
    3678:	df 92       	push	r13
    367a:	ef 92       	push	r14
    367c:	ff 92       	push	r15
    367e:	0f 93       	push	r16
    3680:	1f 93       	push	r17
    3682:	df 93       	push	r29
    3684:	cf 93       	push	r28
    3686:	cd b7       	in	r28, 0x3d	; 61
    3688:	de b7       	in	r29, 0x3e	; 62
    368a:	60 97       	sbiw	r28, 0x10	; 16
    368c:	0f b6       	in	r0, 0x3f	; 63
    368e:	f8 94       	cli
    3690:	de bf       	out	0x3e, r29	; 62
    3692:	0f be       	out	0x3f, r0	; 63
    3694:	cd bf       	out	0x3d, r28	; 61
    3696:	9f 83       	std	Y+7, r25	; 0x07
    3698:	8e 83       	std	Y+6, r24	; 0x06
    369a:	79 87       	std	Y+9, r23	; 0x09
    369c:	68 87       	std	Y+8, r22	; 0x08
    369e:	5b 87       	std	Y+11, r21	; 0x0b
    36a0:	4a 87       	std	Y+10, r20	; 0x0a
    36a2:	3d 87       	std	Y+13, r19	; 0x0d
    36a4:	2c 87       	std	Y+12, r18	; 0x0c
    36a6:	0e 87       	std	Y+14, r16	; 0x0e
    36a8:	f8 8a       	std	Y+16, r15	; 0x10
    36aa:	ef 86       	std	Y+15, r14	; 0x0f
        #else /* portSTACK_GROWTH */
            {
                StackType_t * pxStack;

                /* Allocate space for the stack used by the task being created. */
                pxStack = pvPortMallocStack( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation is the stack. */
    36ac:	8a 85       	ldd	r24, Y+10	; 0x0a
    36ae:	9b 85       	ldd	r25, Y+11	; 0x0b
    36b0:	0e 94 33 07 	call	0xe66	; 0xe66 <pvPortMalloc>
    36b4:	9a 83       	std	Y+2, r25	; 0x02
    36b6:	89 83       	std	Y+1, r24	; 0x01

                if( pxStack != NULL )
    36b8:	89 81       	ldd	r24, Y+1	; 0x01
    36ba:	9a 81       	ldd	r25, Y+2	; 0x02
    36bc:	00 97       	sbiw	r24, 0x00	; 0
    36be:	b1 f0       	breq	.+44     	; 0x36ec <xTaskCreate+0x7e>
                {
                    /* Allocate space for the TCB. */
                    pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of TCB_t is always a pointer to the task's stack. */
    36c0:	86 e2       	ldi	r24, 0x26	; 38
    36c2:	90 e0       	ldi	r25, 0x00	; 0
    36c4:	0e 94 33 07 	call	0xe66	; 0xe66 <pvPortMalloc>
    36c8:	9d 83       	std	Y+5, r25	; 0x05
    36ca:	8c 83       	std	Y+4, r24	; 0x04

                    if( pxNewTCB != NULL )
    36cc:	8c 81       	ldd	r24, Y+4	; 0x04
    36ce:	9d 81       	ldd	r25, Y+5	; 0x05
    36d0:	00 97       	sbiw	r24, 0x00	; 0
    36d2:	39 f0       	breq	.+14     	; 0x36e2 <xTaskCreate+0x74>
                    {
                        /* Store the stack location in the TCB. */
                        pxNewTCB->pxStack = pxStack;
    36d4:	ec 81       	ldd	r30, Y+4	; 0x04
    36d6:	fd 81       	ldd	r31, Y+5	; 0x05
    36d8:	89 81       	ldd	r24, Y+1	; 0x01
    36da:	9a 81       	ldd	r25, Y+2	; 0x02
    36dc:	90 8f       	std	Z+24, r25	; 0x18
    36de:	87 8b       	std	Z+23, r24	; 0x17
    36e0:	07 c0       	rjmp	.+14     	; 0x36f0 <xTaskCreate+0x82>
                    }
                    else
                    {
                        /* The stack cannot be used as the TCB was not created.  Free
                         * it again. */
                        vPortFreeStack( pxStack );
    36e2:	89 81       	ldd	r24, Y+1	; 0x01
    36e4:	9a 81       	ldd	r25, Y+2	; 0x02
    36e6:	0e 94 8d 07 	call	0xf1a	; 0xf1a <vPortFree>
    36ea:	02 c0       	rjmp	.+4      	; 0x36f0 <xTaskCreate+0x82>
                    }
                }
                else
                {
                    pxNewTCB = NULL;
    36ec:	1d 82       	std	Y+5, r1	; 0x05
    36ee:	1c 82       	std	Y+4, r1	; 0x04
                }
            }
        #endif /* portSTACK_GROWTH */

        if( pxNewTCB != NULL )
    36f0:	8c 81       	ldd	r24, Y+4	; 0x04
    36f2:	9d 81       	ldd	r25, Y+5	; 0x05
    36f4:	00 97       	sbiw	r24, 0x00	; 0
    36f6:	e9 f0       	breq	.+58     	; 0x3732 <xTaskCreate+0xc4>
                     * task was created dynamically in case it is later deleted. */
                    pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
                }
            #endif /* tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE */

            prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
    36f8:	8a 85       	ldd	r24, Y+10	; 0x0a
    36fa:	9b 85       	ldd	r25, Y+11	; 0x0b
    36fc:	9c 01       	movw	r18, r24
    36fe:	40 e0       	ldi	r20, 0x00	; 0
    3700:	50 e0       	ldi	r21, 0x00	; 0
    3702:	8e 81       	ldd	r24, Y+6	; 0x06
    3704:	9f 81       	ldd	r25, Y+7	; 0x07
    3706:	68 85       	ldd	r22, Y+8	; 0x08
    3708:	79 85       	ldd	r23, Y+9	; 0x09
    370a:	ec 85       	ldd	r30, Y+12	; 0x0c
    370c:	fd 85       	ldd	r31, Y+13	; 0x0d
    370e:	af 85       	ldd	r26, Y+15	; 0x0f
    3710:	b8 89       	ldd	r27, Y+16	; 0x10
    3712:	ac 80       	ldd	r10, Y+4	; 0x04
    3714:	bd 80       	ldd	r11, Y+5	; 0x05
    3716:	8f 01       	movw	r16, r30
    3718:	ee 84       	ldd	r14, Y+14	; 0x0e
    371a:	6d 01       	movw	r12, r26
    371c:	88 24       	eor	r8, r8
    371e:	99 24       	eor	r9, r9
    3720:	0e 94 af 1b 	call	0x375e	; 0x375e <prvInitialiseNewTask>
            prvAddNewTaskToReadyList( pxNewTCB );
    3724:	8c 81       	ldd	r24, Y+4	; 0x04
    3726:	9d 81       	ldd	r25, Y+5	; 0x05
    3728:	0e 94 74 1c 	call	0x38e8	; 0x38e8 <prvAddNewTaskToReadyList>
            xReturn = pdPASS;
    372c:	81 e0       	ldi	r24, 0x01	; 1
    372e:	8b 83       	std	Y+3, r24	; 0x03
    3730:	02 c0       	rjmp	.+4      	; 0x3736 <xTaskCreate+0xc8>
        }
        else
        {
            xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    3732:	8f ef       	ldi	r24, 0xFF	; 255
    3734:	8b 83       	std	Y+3, r24	; 0x03
        }

        return xReturn;
    3736:	8b 81       	ldd	r24, Y+3	; 0x03
    }
    3738:	60 96       	adiw	r28, 0x10	; 16
    373a:	0f b6       	in	r0, 0x3f	; 63
    373c:	f8 94       	cli
    373e:	de bf       	out	0x3e, r29	; 62
    3740:	0f be       	out	0x3f, r0	; 63
    3742:	cd bf       	out	0x3d, r28	; 61
    3744:	cf 91       	pop	r28
    3746:	df 91       	pop	r29
    3748:	1f 91       	pop	r17
    374a:	0f 91       	pop	r16
    374c:	ff 90       	pop	r15
    374e:	ef 90       	pop	r14
    3750:	df 90       	pop	r13
    3752:	cf 90       	pop	r12
    3754:	bf 90       	pop	r11
    3756:	af 90       	pop	r10
    3758:	9f 90       	pop	r9
    375a:	8f 90       	pop	r8
    375c:	08 95       	ret

0000375e <prvInitialiseNewTask>:
                                  void * const pvParameters,
                                  UBaseType_t uxPriority,
                                  TaskHandle_t * const pxCreatedTask,
                                  TCB_t * pxNewTCB,
                                  const MemoryRegion_t * const xRegions )
{
    375e:	8f 92       	push	r8
    3760:	9f 92       	push	r9
    3762:	af 92       	push	r10
    3764:	bf 92       	push	r11
    3766:	cf 92       	push	r12
    3768:	df 92       	push	r13
    376a:	ef 92       	push	r14
    376c:	0f 93       	push	r16
    376e:	1f 93       	push	r17
    3770:	df 93       	push	r29
    3772:	cf 93       	push	r28
    3774:	cd b7       	in	r28, 0x3d	; 61
    3776:	de b7       	in	r29, 0x3e	; 62
    3778:	64 97       	sbiw	r28, 0x14	; 20
    377a:	0f b6       	in	r0, 0x3f	; 63
    377c:	f8 94       	cli
    377e:	de bf       	out	0x3e, r29	; 62
    3780:	0f be       	out	0x3f, r0	; 63
    3782:	cd bf       	out	0x3d, r28	; 61
    3784:	9d 83       	std	Y+5, r25	; 0x05
    3786:	8c 83       	std	Y+4, r24	; 0x04
    3788:	7f 83       	std	Y+7, r23	; 0x07
    378a:	6e 83       	std	Y+6, r22	; 0x06
    378c:	28 87       	std	Y+8, r18	; 0x08
    378e:	39 87       	std	Y+9, r19	; 0x09
    3790:	4a 87       	std	Y+10, r20	; 0x0a
    3792:	5b 87       	std	Y+11, r21	; 0x0b
    3794:	1d 87       	std	Y+13, r17	; 0x0d
    3796:	0c 87       	std	Y+12, r16	; 0x0c
    3798:	ee 86       	std	Y+14, r14	; 0x0e
    379a:	d8 8a       	std	Y+16, r13	; 0x10
    379c:	cf 86       	std	Y+15, r12	; 0x0f
    379e:	ba 8a       	std	Y+18, r11	; 0x12
    37a0:	a9 8a       	std	Y+17, r10	; 0x11
    37a2:	9c 8a       	std	Y+20, r9	; 0x14
    37a4:	8b 8a       	std	Y+19, r8	; 0x13
     * grows from high memory to low (as per the 80x86) or vice versa.
     * portSTACK_GROWTH is used to make the result positive or negative as required
     * by the port. */
    #if ( portSTACK_GROWTH < 0 )
        {
            pxTopOfStack = &( pxNewTCB->pxStack[ ulStackDepth - ( uint32_t ) 1 ] );
    37a6:	e9 89       	ldd	r30, Y+17	; 0x11
    37a8:	fa 89       	ldd	r31, Y+18	; 0x12
    37aa:	27 89       	ldd	r18, Z+23	; 0x17
    37ac:	30 8d       	ldd	r19, Z+24	; 0x18
    37ae:	88 85       	ldd	r24, Y+8	; 0x08
    37b0:	99 85       	ldd	r25, Y+9	; 0x09
    37b2:	01 97       	sbiw	r24, 0x01	; 1
    37b4:	82 0f       	add	r24, r18
    37b6:	93 1f       	adc	r25, r19
    37b8:	9b 83       	std	Y+3, r25	; 0x03
    37ba:	8a 83       	std	Y+2, r24	; 0x02
            pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
        }
    #endif /* portSTACK_GROWTH */

    /* Store the task name in the TCB. */
    if( pcName != NULL )
    37bc:	8e 81       	ldd	r24, Y+6	; 0x06
    37be:	9f 81       	ldd	r25, Y+7	; 0x07
    37c0:	00 97       	sbiw	r24, 0x00	; 0
    37c2:	51 f1       	breq	.+84     	; 0x3818 <prvInitialiseNewTask+0xba>
    {
        for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    37c4:	19 82       	std	Y+1, r1	; 0x01
    37c6:	21 c0       	rjmp	.+66     	; 0x380a <prvInitialiseNewTask+0xac>
        {
            pxNewTCB->pcTaskName[ x ] = pcName[ x ];
    37c8:	89 81       	ldd	r24, Y+1	; 0x01
    37ca:	48 2f       	mov	r20, r24
    37cc:	50 e0       	ldi	r21, 0x00	; 0
    37ce:	89 81       	ldd	r24, Y+1	; 0x01
    37d0:	28 2f       	mov	r18, r24
    37d2:	30 e0       	ldi	r19, 0x00	; 0
    37d4:	8e 81       	ldd	r24, Y+6	; 0x06
    37d6:	9f 81       	ldd	r25, Y+7	; 0x07
    37d8:	fc 01       	movw	r30, r24
    37da:	e2 0f       	add	r30, r18
    37dc:	f3 1f       	adc	r31, r19
    37de:	20 81       	ld	r18, Z
    37e0:	89 89       	ldd	r24, Y+17	; 0x11
    37e2:	9a 89       	ldd	r25, Y+18	; 0x12
    37e4:	84 0f       	add	r24, r20
    37e6:	95 1f       	adc	r25, r21
    37e8:	fc 01       	movw	r30, r24
    37ea:	79 96       	adiw	r30, 0x19	; 25
    37ec:	20 83       	st	Z, r18

            /* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
             * configMAX_TASK_NAME_LEN characters just in case the memory after the
             * string is not accessible (extremely unlikely). */
            if( pcName[ x ] == ( char ) 0x00 )
    37ee:	89 81       	ldd	r24, Y+1	; 0x01
    37f0:	28 2f       	mov	r18, r24
    37f2:	30 e0       	ldi	r19, 0x00	; 0
    37f4:	8e 81       	ldd	r24, Y+6	; 0x06
    37f6:	9f 81       	ldd	r25, Y+7	; 0x07
    37f8:	fc 01       	movw	r30, r24
    37fa:	e2 0f       	add	r30, r18
    37fc:	f3 1f       	adc	r31, r19
    37fe:	80 81       	ld	r24, Z
    3800:	88 23       	and	r24, r24
    3802:	31 f0       	breq	.+12     	; 0x3810 <prvInitialiseNewTask+0xb2>
    #endif /* portSTACK_GROWTH */

    /* Store the task name in the TCB. */
    if( pcName != NULL )
    {
        for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    3804:	89 81       	ldd	r24, Y+1	; 0x01
    3806:	8f 5f       	subi	r24, 0xFF	; 255
    3808:	89 83       	std	Y+1, r24	; 0x01
    380a:	89 81       	ldd	r24, Y+1	; 0x01
    380c:	88 30       	cpi	r24, 0x08	; 8
    380e:	e0 f2       	brcs	.-72     	; 0x37c8 <prvInitialiseNewTask+0x6a>
            }
        }

        /* Ensure the name string is terminated in the case that the string length
         * was greater or equal to configMAX_TASK_NAME_LEN. */
        pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
    3810:	e9 89       	ldd	r30, Y+17	; 0x11
    3812:	fa 89       	ldd	r31, Y+18	; 0x12
    3814:	10 a2       	std	Z+32, r1	; 0x20
    3816:	03 c0       	rjmp	.+6      	; 0x381e <prvInitialiseNewTask+0xc0>
    }
    else
    {
        /* The task has not been given a name, so just ensure there is a NULL
         * terminator when it is read out. */
        pxNewTCB->pcTaskName[ 0 ] = 0x00;
    3818:	e9 89       	ldd	r30, Y+17	; 0x11
    381a:	fa 89       	ldd	r31, Y+18	; 0x12
    381c:	11 8e       	std	Z+25, r1	; 0x19
    }

    /* This is used as an array index so must ensure it's not too large. */
    configASSERT( uxPriority < configMAX_PRIORITIES );

    if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
    381e:	8e 85       	ldd	r24, Y+14	; 0x0e
    3820:	84 30       	cpi	r24, 0x04	; 4
    3822:	10 f0       	brcs	.+4      	; 0x3828 <prvInitialiseNewTask+0xca>
    {
        uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
    3824:	83 e0       	ldi	r24, 0x03	; 3
    3826:	8e 87       	std	Y+14, r24	; 0x0e
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    pxNewTCB->uxPriority = uxPriority;
    3828:	e9 89       	ldd	r30, Y+17	; 0x11
    382a:	fa 89       	ldd	r31, Y+18	; 0x12
    382c:	8e 85       	ldd	r24, Y+14	; 0x0e
    382e:	86 8b       	std	Z+22, r24	; 0x16
            pxNewTCB->uxBasePriority = uxPriority;
            pxNewTCB->uxMutexesHeld = 0;
        }
    #endif /* configUSE_MUTEXES */

    vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
    3830:	89 89       	ldd	r24, Y+17	; 0x11
    3832:	9a 89       	ldd	r25, Y+18	; 0x12
    3834:	02 96       	adiw	r24, 0x02	; 2
    3836:	0e 94 d5 10 	call	0x21aa	; 0x21aa <vListInitialiseItem>
    vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
    383a:	89 89       	ldd	r24, Y+17	; 0x11
    383c:	9a 89       	ldd	r25, Y+18	; 0x12
    383e:	0c 96       	adiw	r24, 0x0c	; 12
    3840:	0e 94 d5 10 	call	0x21aa	; 0x21aa <vListInitialiseItem>

    /* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
     * back to  the containing TCB from a generic item in a list. */
    listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
    3844:	e9 89       	ldd	r30, Y+17	; 0x11
    3846:	fa 89       	ldd	r31, Y+18	; 0x12
    3848:	89 89       	ldd	r24, Y+17	; 0x11
    384a:	9a 89       	ldd	r25, Y+18	; 0x12
    384c:	91 87       	std	Z+9, r25	; 0x09
    384e:	80 87       	std	Z+8, r24	; 0x08

    /* Event lists are always in priority order. */
    listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    3850:	8e 85       	ldd	r24, Y+14	; 0x0e
    3852:	28 2f       	mov	r18, r24
    3854:	30 e0       	ldi	r19, 0x00	; 0
    3856:	84 e0       	ldi	r24, 0x04	; 4
    3858:	90 e0       	ldi	r25, 0x00	; 0
    385a:	82 1b       	sub	r24, r18
    385c:	93 0b       	sbc	r25, r19
    385e:	e9 89       	ldd	r30, Y+17	; 0x11
    3860:	fa 89       	ldd	r31, Y+18	; 0x12
    3862:	95 87       	std	Z+13, r25	; 0x0d
    3864:	84 87       	std	Z+12, r24	; 0x0c
    listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
    3866:	e9 89       	ldd	r30, Y+17	; 0x11
    3868:	fa 89       	ldd	r31, Y+18	; 0x12
    386a:	89 89       	ldd	r24, Y+17	; 0x11
    386c:	9a 89       	ldd	r25, Y+18	; 0x12
    386e:	93 8b       	std	Z+19, r25	; 0x13
    3870:	82 8b       	std	Z+18, r24	; 0x12
        }
    #endif

    #if ( configUSE_TASK_NOTIFICATIONS == 1 )
        {
            memset( ( void * ) &( pxNewTCB->ulNotifiedValue[ 0 ] ), 0x00, sizeof( pxNewTCB->ulNotifiedValue ) );
    3872:	89 89       	ldd	r24, Y+17	; 0x11
    3874:	9a 89       	ldd	r25, Y+18	; 0x12
    3876:	81 96       	adiw	r24, 0x21	; 33
    3878:	60 e0       	ldi	r22, 0x00	; 0
    387a:	70 e0       	ldi	r23, 0x00	; 0
    387c:	44 e0       	ldi	r20, 0x04	; 4
    387e:	50 e0       	ldi	r21, 0x00	; 0
    3880:	0e 94 17 49 	call	0x922e	; 0x922e <memset>
            memset( ( void * ) &( pxNewTCB->ucNotifyState[ 0 ] ), 0x00, sizeof( pxNewTCB->ucNotifyState ) );
    3884:	89 89       	ldd	r24, Y+17	; 0x11
    3886:	9a 89       	ldd	r25, Y+18	; 0x12
    3888:	85 96       	adiw	r24, 0x25	; 37
    388a:	60 e0       	ldi	r22, 0x00	; 0
    388c:	70 e0       	ldi	r23, 0x00	; 0
    388e:	41 e0       	ldi	r20, 0x01	; 1
    3890:	50 e0       	ldi	r21, 0x00	; 0
    3892:	0e 94 17 49 	call	0x922e	; 0x922e <memset>
                        }
                    #endif /* portSTACK_GROWTH */
                }
            #else /* portHAS_STACK_OVERFLOW_CHECKING */
                {
                    pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    3896:	8a 81       	ldd	r24, Y+2	; 0x02
    3898:	9b 81       	ldd	r25, Y+3	; 0x03
    389a:	2c 81       	ldd	r18, Y+4	; 0x04
    389c:	3d 81       	ldd	r19, Y+5	; 0x05
    389e:	4c 85       	ldd	r20, Y+12	; 0x0c
    38a0:	5d 85       	ldd	r21, Y+13	; 0x0d
    38a2:	b9 01       	movw	r22, r18
    38a4:	0e 94 b3 07 	call	0xf66	; 0xf66 <pxPortInitialiseStack>
    38a8:	e9 89       	ldd	r30, Y+17	; 0x11
    38aa:	fa 89       	ldd	r31, Y+18	; 0x12
    38ac:	91 83       	std	Z+1, r25	; 0x01
    38ae:	80 83       	st	Z, r24
                }
            #endif /* portHAS_STACK_OVERFLOW_CHECKING */
        }
    #endif /* portUSING_MPU_WRAPPERS */

    if( pxCreatedTask != NULL )
    38b0:	8f 85       	ldd	r24, Y+15	; 0x0f
    38b2:	98 89       	ldd	r25, Y+16	; 0x10
    38b4:	00 97       	sbiw	r24, 0x00	; 0
    38b6:	31 f0       	breq	.+12     	; 0x38c4 <prvInitialiseNewTask+0x166>
    {
        /* Pass the handle out in an anonymous way.  The handle can be used to
         * change the created task's priority, delete the created task, etc.*/
        *pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
    38b8:	ef 85       	ldd	r30, Y+15	; 0x0f
    38ba:	f8 89       	ldd	r31, Y+16	; 0x10
    38bc:	89 89       	ldd	r24, Y+17	; 0x11
    38be:	9a 89       	ldd	r25, Y+18	; 0x12
    38c0:	91 83       	std	Z+1, r25	; 0x01
    38c2:	80 83       	st	Z, r24
    }
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }
}
    38c4:	64 96       	adiw	r28, 0x14	; 20
    38c6:	0f b6       	in	r0, 0x3f	; 63
    38c8:	f8 94       	cli
    38ca:	de bf       	out	0x3e, r29	; 62
    38cc:	0f be       	out	0x3f, r0	; 63
    38ce:	cd bf       	out	0x3d, r28	; 61
    38d0:	cf 91       	pop	r28
    38d2:	df 91       	pop	r29
    38d4:	1f 91       	pop	r17
    38d6:	0f 91       	pop	r16
    38d8:	ef 90       	pop	r14
    38da:	df 90       	pop	r13
    38dc:	cf 90       	pop	r12
    38de:	bf 90       	pop	r11
    38e0:	af 90       	pop	r10
    38e2:	9f 90       	pop	r9
    38e4:	8f 90       	pop	r8
    38e6:	08 95       	ret

000038e8 <prvAddNewTaskToReadyList>:
/*-----------------------------------------------------------*/

static void prvAddNewTaskToReadyList( TCB_t * pxNewTCB )
{
    38e8:	df 93       	push	r29
    38ea:	cf 93       	push	r28
    38ec:	00 d0       	rcall	.+0      	; 0x38ee <prvAddNewTaskToReadyList+0x6>
    38ee:	00 d0       	rcall	.+0      	; 0x38f0 <prvAddNewTaskToReadyList+0x8>
    38f0:	cd b7       	in	r28, 0x3d	; 61
    38f2:	de b7       	in	r29, 0x3e	; 62
    38f4:	9c 83       	std	Y+4, r25	; 0x04
    38f6:	8b 83       	std	Y+3, r24	; 0x03
    /* Ensure interrupts don't access the task lists while the lists are being
     * updated. */
    taskENTER_CRITICAL();
    38f8:	0f b6       	in	r0, 0x3f	; 63
    38fa:	f8 94       	cli
    38fc:	0f 92       	push	r0
    {
        uxCurrentNumberOfTasks++;
    38fe:	80 91 5f 08 	lds	r24, 0x085F
    3902:	8f 5f       	subi	r24, 0xFF	; 255
    3904:	80 93 5f 08 	sts	0x085F, r24

        if( pxCurrentTCB == NULL )
    3908:	80 91 5c 08 	lds	r24, 0x085C
    390c:	90 91 5d 08 	lds	r25, 0x085D
    3910:	00 97       	sbiw	r24, 0x00	; 0
    3912:	69 f4       	brne	.+26     	; 0x392e <prvAddNewTaskToReadyList+0x46>
        {
            /* There are no other tasks, or all the other tasks are in
             * the suspended state - make this the current task. */
            pxCurrentTCB = pxNewTCB;
    3914:	8b 81       	ldd	r24, Y+3	; 0x03
    3916:	9c 81       	ldd	r25, Y+4	; 0x04
    3918:	90 93 5d 08 	sts	0x085D, r25
    391c:	80 93 5c 08 	sts	0x085C, r24

            if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
    3920:	80 91 5f 08 	lds	r24, 0x085F
    3924:	81 30       	cpi	r24, 0x01	; 1
    3926:	b9 f4       	brne	.+46     	; 0x3956 <prvAddNewTaskToReadyList+0x6e>
            {
                /* This is the first task to be created so do the preliminary
                 * initialisation required.  We will not recover if this call
                 * fails, but we will report the failure. */
                prvInitialiseTaskLists();
    3928:	0e 94 58 26 	call	0x4cb0	; 0x4cb0 <prvInitialiseTaskLists>
    392c:	14 c0       	rjmp	.+40     	; 0x3956 <prvAddNewTaskToReadyList+0x6e>
        else
        {
            /* If the scheduler is not already running, make this task the
             * current task if it is the highest priority task to be created
             * so far. */
            if( xSchedulerRunning == pdFALSE )
    392e:	80 91 63 08 	lds	r24, 0x0863
    3932:	88 23       	and	r24, r24
    3934:	81 f4       	brne	.+32     	; 0x3956 <prvAddNewTaskToReadyList+0x6e>
            {
                if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
    3936:	e0 91 5c 08 	lds	r30, 0x085C
    393a:	f0 91 5d 08 	lds	r31, 0x085D
    393e:	96 89       	ldd	r25, Z+22	; 0x16
    3940:	eb 81       	ldd	r30, Y+3	; 0x03
    3942:	fc 81       	ldd	r31, Y+4	; 0x04
    3944:	86 89       	ldd	r24, Z+22	; 0x16
    3946:	89 17       	cp	r24, r25
    3948:	30 f0       	brcs	.+12     	; 0x3956 <prvAddNewTaskToReadyList+0x6e>
                {
                    pxCurrentTCB = pxNewTCB;
    394a:	8b 81       	ldd	r24, Y+3	; 0x03
    394c:	9c 81       	ldd	r25, Y+4	; 0x04
    394e:	90 93 5d 08 	sts	0x085D, r25
    3952:	80 93 5c 08 	sts	0x085C, r24
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }

        uxTaskNumber++;
    3956:	80 91 68 08 	lds	r24, 0x0868
    395a:	8f 5f       	subi	r24, 0xFF	; 255
    395c:	80 93 68 08 	sts	0x0868, r24
                pxNewTCB->uxTCBNumber = uxTaskNumber;
            }
        #endif /* configUSE_TRACE_FACILITY */
        traceTASK_CREATE( pxNewTCB );

        prvAddTaskToReadyList( pxNewTCB );
    3960:	eb 81       	ldd	r30, Y+3	; 0x03
    3962:	fc 81       	ldd	r31, Y+4	; 0x04
    3964:	96 89       	ldd	r25, Z+22	; 0x16
    3966:	80 91 62 08 	lds	r24, 0x0862
    396a:	89 17       	cp	r24, r25
    396c:	28 f4       	brcc	.+10     	; 0x3978 <prvAddNewTaskToReadyList+0x90>
    396e:	eb 81       	ldd	r30, Y+3	; 0x03
    3970:	fc 81       	ldd	r31, Y+4	; 0x04
    3972:	86 89       	ldd	r24, Z+22	; 0x16
    3974:	80 93 62 08 	sts	0x0862, r24
    3978:	eb 81       	ldd	r30, Y+3	; 0x03
    397a:	fc 81       	ldd	r31, Y+4	; 0x04
    397c:	86 89       	ldd	r24, Z+22	; 0x16
    397e:	28 2f       	mov	r18, r24
    3980:	30 e0       	ldi	r19, 0x00	; 0
    3982:	c9 01       	movw	r24, r18
    3984:	88 0f       	add	r24, r24
    3986:	99 1f       	adc	r25, r25
    3988:	88 0f       	add	r24, r24
    398a:	99 1f       	adc	r25, r25
    398c:	88 0f       	add	r24, r24
    398e:	99 1f       	adc	r25, r25
    3990:	82 0f       	add	r24, r18
    3992:	93 1f       	adc	r25, r19
    3994:	fc 01       	movw	r30, r24
    3996:	e2 59       	subi	r30, 0x92	; 146
    3998:	f7 4f       	sbci	r31, 0xF7	; 247
    399a:	81 81       	ldd	r24, Z+1	; 0x01
    399c:	92 81       	ldd	r25, Z+2	; 0x02
    399e:	9a 83       	std	Y+2, r25	; 0x02
    39a0:	89 83       	std	Y+1, r24	; 0x01
    39a2:	eb 81       	ldd	r30, Y+3	; 0x03
    39a4:	fc 81       	ldd	r31, Y+4	; 0x04
    39a6:	89 81       	ldd	r24, Y+1	; 0x01
    39a8:	9a 81       	ldd	r25, Y+2	; 0x02
    39aa:	95 83       	std	Z+5, r25	; 0x05
    39ac:	84 83       	std	Z+4, r24	; 0x04
    39ae:	e9 81       	ldd	r30, Y+1	; 0x01
    39b0:	fa 81       	ldd	r31, Y+2	; 0x02
    39b2:	84 81       	ldd	r24, Z+4	; 0x04
    39b4:	95 81       	ldd	r25, Z+5	; 0x05
    39b6:	eb 81       	ldd	r30, Y+3	; 0x03
    39b8:	fc 81       	ldd	r31, Y+4	; 0x04
    39ba:	97 83       	std	Z+7, r25	; 0x07
    39bc:	86 83       	std	Z+6, r24	; 0x06
    39be:	e9 81       	ldd	r30, Y+1	; 0x01
    39c0:	fa 81       	ldd	r31, Y+2	; 0x02
    39c2:	04 80       	ldd	r0, Z+4	; 0x04
    39c4:	f5 81       	ldd	r31, Z+5	; 0x05
    39c6:	e0 2d       	mov	r30, r0
    39c8:	8b 81       	ldd	r24, Y+3	; 0x03
    39ca:	9c 81       	ldd	r25, Y+4	; 0x04
    39cc:	02 96       	adiw	r24, 0x02	; 2
    39ce:	93 83       	std	Z+3, r25	; 0x03
    39d0:	82 83       	std	Z+2, r24	; 0x02
    39d2:	8b 81       	ldd	r24, Y+3	; 0x03
    39d4:	9c 81       	ldd	r25, Y+4	; 0x04
    39d6:	02 96       	adiw	r24, 0x02	; 2
    39d8:	e9 81       	ldd	r30, Y+1	; 0x01
    39da:	fa 81       	ldd	r31, Y+2	; 0x02
    39dc:	95 83       	std	Z+5, r25	; 0x05
    39de:	84 83       	std	Z+4, r24	; 0x04
    39e0:	eb 81       	ldd	r30, Y+3	; 0x03
    39e2:	fc 81       	ldd	r31, Y+4	; 0x04
    39e4:	86 89       	ldd	r24, Z+22	; 0x16
    39e6:	28 2f       	mov	r18, r24
    39e8:	30 e0       	ldi	r19, 0x00	; 0
    39ea:	c9 01       	movw	r24, r18
    39ec:	88 0f       	add	r24, r24
    39ee:	99 1f       	adc	r25, r25
    39f0:	88 0f       	add	r24, r24
    39f2:	99 1f       	adc	r25, r25
    39f4:	88 0f       	add	r24, r24
    39f6:	99 1f       	adc	r25, r25
    39f8:	82 0f       	add	r24, r18
    39fa:	93 1f       	adc	r25, r19
    39fc:	82 59       	subi	r24, 0x92	; 146
    39fe:	97 4f       	sbci	r25, 0xF7	; 247
    3a00:	eb 81       	ldd	r30, Y+3	; 0x03
    3a02:	fc 81       	ldd	r31, Y+4	; 0x04
    3a04:	93 87       	std	Z+11, r25	; 0x0b
    3a06:	82 87       	std	Z+10, r24	; 0x0a
    3a08:	eb 81       	ldd	r30, Y+3	; 0x03
    3a0a:	fc 81       	ldd	r31, Y+4	; 0x04
    3a0c:	86 89       	ldd	r24, Z+22	; 0x16
    3a0e:	28 2f       	mov	r18, r24
    3a10:	30 e0       	ldi	r19, 0x00	; 0
    3a12:	c9 01       	movw	r24, r18
    3a14:	88 0f       	add	r24, r24
    3a16:	99 1f       	adc	r25, r25
    3a18:	88 0f       	add	r24, r24
    3a1a:	99 1f       	adc	r25, r25
    3a1c:	88 0f       	add	r24, r24
    3a1e:	99 1f       	adc	r25, r25
    3a20:	82 0f       	add	r24, r18
    3a22:	93 1f       	adc	r25, r19
    3a24:	fc 01       	movw	r30, r24
    3a26:	e2 59       	subi	r30, 0x92	; 146
    3a28:	f7 4f       	sbci	r31, 0xF7	; 247
    3a2a:	80 81       	ld	r24, Z
    3a2c:	8f 5f       	subi	r24, 0xFF	; 255
    3a2e:	80 83       	st	Z, r24

        portSETUP_TCB( pxNewTCB );
    }
    taskEXIT_CRITICAL();
    3a30:	0f 90       	pop	r0
    3a32:	0f be       	out	0x3f, r0	; 63

    if( xSchedulerRunning != pdFALSE )
    3a34:	80 91 63 08 	lds	r24, 0x0863
    3a38:	88 23       	and	r24, r24
    3a3a:	61 f0       	breq	.+24     	; 0x3a54 <prvAddNewTaskToReadyList+0x16c>
    {
        /* If the created task is of a higher priority than the current task
         * then it should run now. */
        if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
    3a3c:	e0 91 5c 08 	lds	r30, 0x085C
    3a40:	f0 91 5d 08 	lds	r31, 0x085D
    3a44:	96 89       	ldd	r25, Z+22	; 0x16
    3a46:	eb 81       	ldd	r30, Y+3	; 0x03
    3a48:	fc 81       	ldd	r31, Y+4	; 0x04
    3a4a:	86 89       	ldd	r24, Z+22	; 0x16
    3a4c:	98 17       	cp	r25, r24
    3a4e:	10 f4       	brcc	.+4      	; 0x3a54 <prvAddNewTaskToReadyList+0x16c>
        {
            taskYIELD_IF_USING_PREEMPTION();
    3a50:	0e 94 72 09 	call	0x12e4	; 0x12e4 <vPortYield>
    }
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }
}
    3a54:	0f 90       	pop	r0
    3a56:	0f 90       	pop	r0
    3a58:	0f 90       	pop	r0
    3a5a:	0f 90       	pop	r0
    3a5c:	cf 91       	pop	r28
    3a5e:	df 91       	pop	r29
    3a60:	08 95       	ret

00003a62 <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

    void vTaskDelete( TaskHandle_t xTaskToDelete )
    {
    3a62:	df 93       	push	r29
    3a64:	cf 93       	push	r28
    3a66:	00 d0       	rcall	.+0      	; 0x3a68 <vTaskDelete+0x6>
    3a68:	00 d0       	rcall	.+0      	; 0x3a6a <vTaskDelete+0x8>
    3a6a:	00 d0       	rcall	.+0      	; 0x3a6c <vTaskDelete+0xa>
    3a6c:	cd b7       	in	r28, 0x3d	; 61
    3a6e:	de b7       	in	r29, 0x3e	; 62
    3a70:	9c 83       	std	Y+4, r25	; 0x04
    3a72:	8b 83       	std	Y+3, r24	; 0x03
        TCB_t * pxTCB;

        taskENTER_CRITICAL();
    3a74:	0f b6       	in	r0, 0x3f	; 63
    3a76:	f8 94       	cli
    3a78:	0f 92       	push	r0
        {
            /* If null is passed in here then it is the calling task that is
             * being deleted. */
            pxTCB = prvGetTCBFromHandle( xTaskToDelete );
    3a7a:	8b 81       	ldd	r24, Y+3	; 0x03
    3a7c:	9c 81       	ldd	r25, Y+4	; 0x04
    3a7e:	00 97       	sbiw	r24, 0x00	; 0
    3a80:	39 f4       	brne	.+14     	; 0x3a90 <vTaskDelete+0x2e>
    3a82:	80 91 5c 08 	lds	r24, 0x085C
    3a86:	90 91 5d 08 	lds	r25, 0x085D
    3a8a:	9e 83       	std	Y+6, r25	; 0x06
    3a8c:	8d 83       	std	Y+5, r24	; 0x05
    3a8e:	04 c0       	rjmp	.+8      	; 0x3a98 <vTaskDelete+0x36>
    3a90:	8b 81       	ldd	r24, Y+3	; 0x03
    3a92:	9c 81       	ldd	r25, Y+4	; 0x04
    3a94:	9e 83       	std	Y+6, r25	; 0x06
    3a96:	8d 83       	std	Y+5, r24	; 0x05
    3a98:	8d 81       	ldd	r24, Y+5	; 0x05
    3a9a:	9e 81       	ldd	r25, Y+6	; 0x06
    3a9c:	9a 83       	std	Y+2, r25	; 0x02
    3a9e:	89 83       	std	Y+1, r24	; 0x01

            /* Remove task from the ready/delayed list. */
            if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    3aa0:	89 81       	ldd	r24, Y+1	; 0x01
    3aa2:	9a 81       	ldd	r25, Y+2	; 0x02
    3aa4:	02 96       	adiw	r24, 0x02	; 2
    3aa6:	0e 94 95 11 	call	0x232a	; 0x232a <uxListRemove>
            {
                mtCOVERAGE_TEST_MARKER();
            }

            /* Is the task waiting on an event also? */
            if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    3aaa:	e9 81       	ldd	r30, Y+1	; 0x01
    3aac:	fa 81       	ldd	r31, Y+2	; 0x02
    3aae:	84 89       	ldd	r24, Z+20	; 0x14
    3ab0:	95 89       	ldd	r25, Z+21	; 0x15
    3ab2:	00 97       	sbiw	r24, 0x00	; 0
    3ab4:	29 f0       	breq	.+10     	; 0x3ac0 <vTaskDelete+0x5e>
            {
                ( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    3ab6:	89 81       	ldd	r24, Y+1	; 0x01
    3ab8:	9a 81       	ldd	r25, Y+2	; 0x02
    3aba:	0c 96       	adiw	r24, 0x0c	; 12
    3abc:	0e 94 95 11 	call	0x232a	; 0x232a <uxListRemove>

            /* Increment the uxTaskNumber also so kernel aware debuggers can
             * detect that the task lists need re-generating.  This is done before
             * portPRE_TASK_DELETE_HOOK() as in the Windows port that macro will
             * not return. */
            uxTaskNumber++;
    3ac0:	80 91 68 08 	lds	r24, 0x0868
    3ac4:	8f 5f       	subi	r24, 0xFF	; 255
    3ac6:	80 93 68 08 	sts	0x0868, r24

            if( pxTCB == pxCurrentTCB )
    3aca:	20 91 5c 08 	lds	r18, 0x085C
    3ace:	30 91 5d 08 	lds	r19, 0x085D
    3ad2:	89 81       	ldd	r24, Y+1	; 0x01
    3ad4:	9a 81       	ldd	r25, Y+2	; 0x02
    3ad6:	82 17       	cp	r24, r18
    3ad8:	93 07       	cpc	r25, r19
    3ada:	81 f4       	brne	.+32     	; 0x3afc <vTaskDelete+0x9a>
                /* A task is deleting itself.  This cannot complete within the
                 * task itself, as a context switch to another task is required.
                 * Place the task in the termination list.  The idle task will
                 * check the termination list and free up any memory allocated by
                 * the scheduler for the TCB and stack of the deleted task. */
                vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xStateListItem ) );
    3adc:	89 81       	ldd	r24, Y+1	; 0x01
    3ade:	9a 81       	ldd	r25, Y+2	; 0x02
    3ae0:	9c 01       	movw	r18, r24
    3ae2:	2e 5f       	subi	r18, 0xFE	; 254
    3ae4:	3f 4f       	sbci	r19, 0xFF	; 255
    3ae6:	81 eb       	ldi	r24, 0xB1	; 177
    3ae8:	98 e0       	ldi	r25, 0x08	; 8
    3aea:	b9 01       	movw	r22, r18
    3aec:	0e 94 e5 10 	call	0x21ca	; 0x21ca <vListInsertEnd>

                /* Increment the ucTasksDeleted variable so the idle task knows
                 * there is a task that has been deleted and that it should therefore
                 * check the xTasksWaitingTermination list. */
                ++uxDeletedTasksWaitingCleanUp;
    3af0:	80 91 5e 08 	lds	r24, 0x085E
    3af4:	8f 5f       	subi	r24, 0xFF	; 255
    3af6:	80 93 5e 08 	sts	0x085E, r24
    3afa:	07 c0       	rjmp	.+14     	; 0x3b0a <vTaskDelete+0xa8>
                 * required. */
                portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
            }
            else
            {
                --uxCurrentNumberOfTasks;
    3afc:	80 91 5f 08 	lds	r24, 0x085F
    3b00:	81 50       	subi	r24, 0x01	; 1
    3b02:	80 93 5f 08 	sts	0x085F, r24
                traceTASK_DELETE( pxTCB );

                /* Reset the next expected unblock time in case it referred to
                 * the task that has just been deleted. */
                prvResetNextTaskUnblockTime();
    3b06:	0e 94 da 26 	call	0x4db4	; 0x4db4 <prvResetNextTaskUnblockTime>
            }
        }
        taskEXIT_CRITICAL();
    3b0a:	0f 90       	pop	r0
    3b0c:	0f be       	out	0x3f, r0	; 63

        /* If the task is not deleting itself, call prvDeleteTCB from outside of
         * critical section. If a task deletes itself, prvDeleteTCB is called
         * from prvCheckTasksWaitingTermination which is called from Idle task. */
        if( pxTCB != pxCurrentTCB )
    3b0e:	20 91 5c 08 	lds	r18, 0x085C
    3b12:	30 91 5d 08 	lds	r19, 0x085D
    3b16:	89 81       	ldd	r24, Y+1	; 0x01
    3b18:	9a 81       	ldd	r25, Y+2	; 0x02
    3b1a:	82 17       	cp	r24, r18
    3b1c:	93 07       	cpc	r25, r19
    3b1e:	21 f0       	breq	.+8      	; 0x3b28 <vTaskDelete+0xc6>
        {
            prvDeleteTCB( pxTCB );
    3b20:	89 81       	ldd	r24, Y+1	; 0x01
    3b22:	9a 81       	ldd	r25, Y+2	; 0x02
    3b24:	0e 94 c4 26 	call	0x4d88	; 0x4d88 <prvDeleteTCB>
        }

        /* Force a reschedule if it is the currently running task that has just
         * been deleted. */
        if( xSchedulerRunning != pdFALSE )
    3b28:	80 91 63 08 	lds	r24, 0x0863
    3b2c:	88 23       	and	r24, r24
    3b2e:	59 f0       	breq	.+22     	; 0x3b46 <vTaskDelete+0xe4>
        {
            if( pxTCB == pxCurrentTCB )
    3b30:	20 91 5c 08 	lds	r18, 0x085C
    3b34:	30 91 5d 08 	lds	r19, 0x085D
    3b38:	89 81       	ldd	r24, Y+1	; 0x01
    3b3a:	9a 81       	ldd	r25, Y+2	; 0x02
    3b3c:	82 17       	cp	r24, r18
    3b3e:	93 07       	cpc	r25, r19
    3b40:	11 f4       	brne	.+4      	; 0x3b46 <vTaskDelete+0xe4>
            {
                configASSERT( uxSchedulerSuspended == 0 );
                portYIELD_WITHIN_API();
    3b42:	0e 94 72 09 	call	0x12e4	; 0x12e4 <vPortYield>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
    }
    3b46:	26 96       	adiw	r28, 0x06	; 6
    3b48:	0f b6       	in	r0, 0x3f	; 63
    3b4a:	f8 94       	cli
    3b4c:	de bf       	out	0x3e, r29	; 62
    3b4e:	0f be       	out	0x3f, r0	; 63
    3b50:	cd bf       	out	0x3d, r28	; 61
    3b52:	cf 91       	pop	r28
    3b54:	df 91       	pop	r29
    3b56:	08 95       	ret

00003b58 <xTaskDelayUntil>:

#if ( INCLUDE_xTaskDelayUntil == 1 )

    BaseType_t xTaskDelayUntil( TickType_t * const pxPreviousWakeTime,
                                const TickType_t xTimeIncrement )
    {
    3b58:	df 93       	push	r29
    3b5a:	cf 93       	push	r28
    3b5c:	cd b7       	in	r28, 0x3d	; 61
    3b5e:	de b7       	in	r29, 0x3e	; 62
    3b60:	2a 97       	sbiw	r28, 0x0a	; 10
    3b62:	0f b6       	in	r0, 0x3f	; 63
    3b64:	f8 94       	cli
    3b66:	de bf       	out	0x3e, r29	; 62
    3b68:	0f be       	out	0x3f, r0	; 63
    3b6a:	cd bf       	out	0x3d, r28	; 61
    3b6c:	98 87       	std	Y+8, r25	; 0x08
    3b6e:	8f 83       	std	Y+7, r24	; 0x07
    3b70:	7a 87       	std	Y+10, r23	; 0x0a
    3b72:	69 87       	std	Y+9, r22	; 0x09
        TickType_t xTimeToWake;
        BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
    3b74:	1b 82       	std	Y+3, r1	; 0x03

        configASSERT( pxPreviousWakeTime );
        configASSERT( ( xTimeIncrement > 0U ) );
        configASSERT( uxSchedulerSuspended == 0 );

        vTaskSuspendAll();
    3b76:	0e 94 88 1e 	call	0x3d10	; 0x3d10 <vTaskSuspendAll>
        {
            /* Minor optimisation.  The tick count cannot change in this
             * block. */
            const TickType_t xConstTickCount = xTickCount;
    3b7a:	80 91 60 08 	lds	r24, 0x0860
    3b7e:	90 91 61 08 	lds	r25, 0x0861
    3b82:	9a 83       	std	Y+2, r25	; 0x02
    3b84:	89 83       	std	Y+1, r24	; 0x01

            /* Generate the tick time at which the task wants to wake. */
            xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    3b86:	ef 81       	ldd	r30, Y+7	; 0x07
    3b88:	f8 85       	ldd	r31, Y+8	; 0x08
    3b8a:	20 81       	ld	r18, Z
    3b8c:	31 81       	ldd	r19, Z+1	; 0x01
    3b8e:	89 85       	ldd	r24, Y+9	; 0x09
    3b90:	9a 85       	ldd	r25, Y+10	; 0x0a
    3b92:	82 0f       	add	r24, r18
    3b94:	93 1f       	adc	r25, r19
    3b96:	9e 83       	std	Y+6, r25	; 0x06
    3b98:	8d 83       	std	Y+5, r24	; 0x05

            if( xConstTickCount < *pxPreviousWakeTime )
    3b9a:	ef 81       	ldd	r30, Y+7	; 0x07
    3b9c:	f8 85       	ldd	r31, Y+8	; 0x08
    3b9e:	20 81       	ld	r18, Z
    3ba0:	31 81       	ldd	r19, Z+1	; 0x01
    3ba2:	89 81       	ldd	r24, Y+1	; 0x01
    3ba4:	9a 81       	ldd	r25, Y+2	; 0x02
    3ba6:	82 17       	cp	r24, r18
    3ba8:	93 07       	cpc	r25, r19
    3baa:	98 f4       	brcc	.+38     	; 0x3bd2 <xTaskDelayUntil+0x7a>
                /* The tick count has overflowed since this function was
                 * lasted called.  In this case the only time we should ever
                 * actually delay is if the wake time has also  overflowed,
                 * and the wake time is greater than the tick time.  When this
                 * is the case it is as if neither time had overflowed. */
                if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
    3bac:	ef 81       	ldd	r30, Y+7	; 0x07
    3bae:	f8 85       	ldd	r31, Y+8	; 0x08
    3bb0:	20 81       	ld	r18, Z
    3bb2:	31 81       	ldd	r19, Z+1	; 0x01
    3bb4:	8d 81       	ldd	r24, Y+5	; 0x05
    3bb6:	9e 81       	ldd	r25, Y+6	; 0x06
    3bb8:	82 17       	cp	r24, r18
    3bba:	93 07       	cpc	r25, r19
    3bbc:	e0 f4       	brcc	.+56     	; 0x3bf6 <xTaskDelayUntil+0x9e>
    3bbe:	2d 81       	ldd	r18, Y+5	; 0x05
    3bc0:	3e 81       	ldd	r19, Y+6	; 0x06
    3bc2:	89 81       	ldd	r24, Y+1	; 0x01
    3bc4:	9a 81       	ldd	r25, Y+2	; 0x02
    3bc6:	82 17       	cp	r24, r18
    3bc8:	93 07       	cpc	r25, r19
    3bca:	a8 f4       	brcc	.+42     	; 0x3bf6 <xTaskDelayUntil+0x9e>
                {
                    xShouldDelay = pdTRUE;
    3bcc:	81 e0       	ldi	r24, 0x01	; 1
    3bce:	8b 83       	std	Y+3, r24	; 0x03
    3bd0:	12 c0       	rjmp	.+36     	; 0x3bf6 <xTaskDelayUntil+0x9e>
            else
            {
                /* The tick time has not overflowed.  In this case we will
                 * delay if either the wake time has overflowed, and/or the
                 * tick time is less than the wake time. */
                if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
    3bd2:	ef 81       	ldd	r30, Y+7	; 0x07
    3bd4:	f8 85       	ldd	r31, Y+8	; 0x08
    3bd6:	20 81       	ld	r18, Z
    3bd8:	31 81       	ldd	r19, Z+1	; 0x01
    3bda:	8d 81       	ldd	r24, Y+5	; 0x05
    3bdc:	9e 81       	ldd	r25, Y+6	; 0x06
    3bde:	82 17       	cp	r24, r18
    3be0:	93 07       	cpc	r25, r19
    3be2:	38 f0       	brcs	.+14     	; 0x3bf2 <xTaskDelayUntil+0x9a>
    3be4:	2d 81       	ldd	r18, Y+5	; 0x05
    3be6:	3e 81       	ldd	r19, Y+6	; 0x06
    3be8:	89 81       	ldd	r24, Y+1	; 0x01
    3bea:	9a 81       	ldd	r25, Y+2	; 0x02
    3bec:	82 17       	cp	r24, r18
    3bee:	93 07       	cpc	r25, r19
    3bf0:	10 f4       	brcc	.+4      	; 0x3bf6 <xTaskDelayUntil+0x9e>
                {
                    xShouldDelay = pdTRUE;
    3bf2:	81 e0       	ldi	r24, 0x01	; 1
    3bf4:	8b 83       	std	Y+3, r24	; 0x03
                    mtCOVERAGE_TEST_MARKER();
                }
            }

            /* Update the wake time ready for the next call. */
            *pxPreviousWakeTime = xTimeToWake;
    3bf6:	ef 81       	ldd	r30, Y+7	; 0x07
    3bf8:	f8 85       	ldd	r31, Y+8	; 0x08
    3bfa:	8d 81       	ldd	r24, Y+5	; 0x05
    3bfc:	9e 81       	ldd	r25, Y+6	; 0x06
    3bfe:	91 83       	std	Z+1, r25	; 0x01
    3c00:	80 83       	st	Z, r24

            if( xShouldDelay != pdFALSE )
    3c02:	8b 81       	ldd	r24, Y+3	; 0x03
    3c04:	88 23       	and	r24, r24
    3c06:	49 f0       	breq	.+18     	; 0x3c1a <xTaskDelayUntil+0xc2>
            {
                traceTASK_DELAY_UNTIL( xTimeToWake );

                /* prvAddCurrentTaskToDelayedList() needs the block time, not
                 * the time to wake, so subtract the current tick count. */
                prvAddCurrentTaskToDelayedList( xTimeToWake - xConstTickCount, pdFALSE );
    3c08:	8d 81       	ldd	r24, Y+5	; 0x05
    3c0a:	9e 81       	ldd	r25, Y+6	; 0x06
    3c0c:	29 81       	ldd	r18, Y+1	; 0x01
    3c0e:	3a 81       	ldd	r19, Y+2	; 0x02
    3c10:	82 1b       	sub	r24, r18
    3c12:	93 0b       	sbc	r25, r19
    3c14:	60 e0       	ldi	r22, 0x00	; 0
    3c16:	0e 94 c1 2e 	call	0x5d82	; 0x5d82 <prvAddCurrentTaskToDelayedList>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        xAlreadyYielded = xTaskResumeAll();
    3c1a:	0e 94 94 1e 	call	0x3d28	; 0x3d28 <xTaskResumeAll>
    3c1e:	8c 83       	std	Y+4, r24	; 0x04

        /* Force a reschedule if xTaskResumeAll has not already done so, we may
         * have put ourselves to sleep. */
        if( xAlreadyYielded == pdFALSE )
    3c20:	8c 81       	ldd	r24, Y+4	; 0x04
    3c22:	88 23       	and	r24, r24
    3c24:	11 f4       	brne	.+4      	; 0x3c2a <xTaskDelayUntil+0xd2>
        {
            portYIELD_WITHIN_API();
    3c26:	0e 94 72 09 	call	0x12e4	; 0x12e4 <vPortYield>
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        return xShouldDelay;
    3c2a:	8b 81       	ldd	r24, Y+3	; 0x03
    }
    3c2c:	2a 96       	adiw	r28, 0x0a	; 10
    3c2e:	0f b6       	in	r0, 0x3f	; 63
    3c30:	f8 94       	cli
    3c32:	de bf       	out	0x3e, r29	; 62
    3c34:	0f be       	out	0x3f, r0	; 63
    3c36:	cd bf       	out	0x3d, r28	; 61
    3c38:	cf 91       	pop	r28
    3c3a:	df 91       	pop	r29
    3c3c:	08 95       	ret

00003c3e <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

    void vTaskDelay( const TickType_t xTicksToDelay )
    {
    3c3e:	df 93       	push	r29
    3c40:	cf 93       	push	r28
    3c42:	00 d0       	rcall	.+0      	; 0x3c44 <vTaskDelay+0x6>
    3c44:	0f 92       	push	r0
    3c46:	cd b7       	in	r28, 0x3d	; 61
    3c48:	de b7       	in	r29, 0x3e	; 62
    3c4a:	9b 83       	std	Y+3, r25	; 0x03
    3c4c:	8a 83       	std	Y+2, r24	; 0x02
        BaseType_t xAlreadyYielded = pdFALSE;
    3c4e:	19 82       	std	Y+1, r1	; 0x01

        /* A delay time of zero just forces a reschedule. */
        if( xTicksToDelay > ( TickType_t ) 0U )
    3c50:	8a 81       	ldd	r24, Y+2	; 0x02
    3c52:	9b 81       	ldd	r25, Y+3	; 0x03
    3c54:	00 97       	sbiw	r24, 0x00	; 0
    3c56:	51 f0       	breq	.+20     	; 0x3c6c <vTaskDelay+0x2e>
        {
            configASSERT( uxSchedulerSuspended == 0 );
            vTaskSuspendAll();
    3c58:	0e 94 88 1e 	call	0x3d10	; 0x3d10 <vTaskSuspendAll>
                 * list or removed from the blocked list until the scheduler
                 * is resumed.
                 *
                 * This task cannot be in an event list as it is the currently
                 * executing task. */
                prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
    3c5c:	8a 81       	ldd	r24, Y+2	; 0x02
    3c5e:	9b 81       	ldd	r25, Y+3	; 0x03
    3c60:	60 e0       	ldi	r22, 0x00	; 0
    3c62:	0e 94 c1 2e 	call	0x5d82	; 0x5d82 <prvAddCurrentTaskToDelayedList>
            }
            xAlreadyYielded = xTaskResumeAll();
    3c66:	0e 94 94 1e 	call	0x3d28	; 0x3d28 <xTaskResumeAll>
    3c6a:	89 83       	std	Y+1, r24	; 0x01
            mtCOVERAGE_TEST_MARKER();
        }

        /* Force a reschedule if xTaskResumeAll has not already done so, we may
         * have put ourselves to sleep. */
        if( xAlreadyYielded == pdFALSE )
    3c6c:	89 81       	ldd	r24, Y+1	; 0x01
    3c6e:	88 23       	and	r24, r24
    3c70:	11 f4       	brne	.+4      	; 0x3c76 <vTaskDelay+0x38>
        {
            portYIELD_WITHIN_API();
    3c72:	0e 94 72 09 	call	0x12e4	; 0x12e4 <vPortYield>
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }
    3c76:	0f 90       	pop	r0
    3c78:	0f 90       	pop	r0
    3c7a:	0f 90       	pop	r0
    3c7c:	cf 91       	pop	r28
    3c7e:	df 91       	pop	r29
    3c80:	08 95       	ret

00003c82 <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
    3c82:	ef 92       	push	r14
    3c84:	ff 92       	push	r15
    3c86:	0f 93       	push	r16
    3c88:	df 93       	push	r29
    3c8a:	cf 93       	push	r28
    3c8c:	00 d0       	rcall	.+0      	; 0x3c8e <vTaskStartScheduler+0xc>
    3c8e:	cd b7       	in	r28, 0x3d	; 61
    3c90:	de b7       	in	r29, 0x3e	; 62
            }
        }
    #else /* if ( configSUPPORT_STATIC_ALLOCATION == 1 ) */
        {
            /* The Idle task is being created using dynamically allocated RAM. */
            xReturn = xTaskCreate( prvIdleTask,
    3c92:	88 e4       	ldi	r24, 0x48	; 72
    3c94:	96 e2       	ldi	r25, 0x26	; 38
    3c96:	20 e0       	ldi	r18, 0x00	; 0
    3c98:	31 e0       	ldi	r19, 0x01	; 1
    3c9a:	eb e6       	ldi	r30, 0x6B	; 107
    3c9c:	f8 e0       	ldi	r31, 0x08	; 8
    3c9e:	b9 01       	movw	r22, r18
    3ca0:	45 e5       	ldi	r20, 0x55	; 85
    3ca2:	50 e0       	ldi	r21, 0x00	; 0
    3ca4:	20 e0       	ldi	r18, 0x00	; 0
    3ca6:	30 e0       	ldi	r19, 0x00	; 0
    3ca8:	00 e0       	ldi	r16, 0x00	; 0
    3caa:	7f 01       	movw	r14, r30
    3cac:	0e 94 37 1b 	call	0x366e	; 0x366e <xTaskCreate>
    3cb0:	89 83       	std	Y+1, r24	; 0x01
        }
    #endif /* configSUPPORT_STATIC_ALLOCATION */

    #if ( configUSE_TIMERS == 1 )
        {
            if( xReturn == pdPASS )
    3cb2:	89 81       	ldd	r24, Y+1	; 0x01
    3cb4:	81 30       	cpi	r24, 0x01	; 1
    3cb6:	19 f4       	brne	.+6      	; 0x3cbe <vTaskStartScheduler+0x3c>
            {
                xReturn = xTimerCreateTimerTask();
    3cb8:	0e 94 27 2f 	call	0x5e4e	; 0x5e4e <xTimerCreateTimerTask>
    3cbc:	89 83       	std	Y+1, r24	; 0x01
                mtCOVERAGE_TEST_MARKER();
            }
        }
    #endif /* configUSE_TIMERS */

    if( xReturn == pdPASS )
    3cbe:	89 81       	ldd	r24, Y+1	; 0x01
    3cc0:	81 30       	cpi	r24, 0x01	; 1
    3cc2:	81 f4       	brne	.+32     	; 0x3ce4 <vTaskStartScheduler+0x62>
        /* Interrupts are turned off here, to ensure a tick does not occur
         * before or during the call to xPortStartScheduler().  The stacks of
         * the created tasks contain a status word with interrupts switched on
         * so interrupts will automatically get re-enabled when the first task
         * starts to run. */
        portDISABLE_INTERRUPTS();
    3cc4:	f8 94       	cli
                 * for additional information. */
                _impure_ptr = &( pxCurrentTCB->xNewLib_reent );
            }
        #endif /* configUSE_NEWLIB_REENTRANT */

        xNextTaskUnblockTime = portMAX_DELAY;
    3cc6:	8f ef       	ldi	r24, 0xFF	; 255
    3cc8:	9f ef       	ldi	r25, 0xFF	; 255
    3cca:	90 93 6a 08 	sts	0x086A, r25
    3cce:	80 93 69 08 	sts	0x0869, r24
        xSchedulerRunning = pdTRUE;
    3cd2:	81 e0       	ldi	r24, 0x01	; 1
    3cd4:	80 93 63 08 	sts	0x0863, r24
        xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
    3cd8:	10 92 61 08 	sts	0x0861, r1
    3cdc:	10 92 60 08 	sts	0x0860, r1

        traceTASK_SWITCHED_IN();

        /* Setting up the timer tick is hardware specific and thus in the
         * portable interface. */
        if( xPortStartScheduler() != pdFALSE )
    3ce0:	0e 94 36 09 	call	0x126c	; 0x126c <xPortStartScheduler>
     * meaning xIdleTaskHandle is not used anywhere else. */
    ( void ) xIdleTaskHandle;

    /* OpenOCD makes use of uxTopUsedPriority for thread debugging. Prevent uxTopUsedPriority
     * from getting optimized out as it is no longer used by the kernel. */
    ( void ) uxTopUsedPriority;
    3ce4:	80 91 29 02 	lds	r24, 0x0229
}
    3ce8:	0f 90       	pop	r0
    3cea:	0f 90       	pop	r0
    3cec:	cf 91       	pop	r28
    3cee:	df 91       	pop	r29
    3cf0:	0f 91       	pop	r16
    3cf2:	ff 90       	pop	r15
    3cf4:	ef 90       	pop	r14
    3cf6:	08 95       	ret

00003cf8 <vTaskEndScheduler>:
/*-----------------------------------------------------------*/

void vTaskEndScheduler( void )
{
    3cf8:	df 93       	push	r29
    3cfa:	cf 93       	push	r28
    3cfc:	cd b7       	in	r28, 0x3d	; 61
    3cfe:	de b7       	in	r29, 0x3e	; 62
    /* Stop the scheduler interrupts and call the portable scheduler end
     * routine so the original ISRs can be restored if necessary.  The port
     * layer must ensure interrupts enable  bit is left in the correct state. */
    portDISABLE_INTERRUPTS();
    3d00:	f8 94       	cli
    xSchedulerRunning = pdFALSE;
    3d02:	10 92 63 08 	sts	0x0863, r1
    vPortEndScheduler();
    3d06:	0e 94 6b 09 	call	0x12d6	; 0x12d6 <vPortEndScheduler>
}
    3d0a:	cf 91       	pop	r28
    3d0c:	df 91       	pop	r29
    3d0e:	08 95       	ret

00003d10 <vTaskSuspendAll>:
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
    3d10:	df 93       	push	r29
    3d12:	cf 93       	push	r28
    3d14:	cd b7       	in	r28, 0x3d	; 61
    3d16:	de b7       	in	r29, 0x3e	; 62
     * do not otherwise exhibit real time behaviour. */
    portSOFTWARE_BARRIER();

    /* The scheduler is suspended if uxSchedulerSuspended is non-zero.  An increment
     * is used to allow calls to vTaskSuspendAll() to nest. */
    ++uxSchedulerSuspended;
    3d18:	80 91 6d 08 	lds	r24, 0x086D
    3d1c:	8f 5f       	subi	r24, 0xFF	; 255
    3d1e:	80 93 6d 08 	sts	0x086D, r24

    /* Enforces ordering for ports and optimised compilers that may otherwise place
     * the above increment elsewhere. */
    portMEMORY_BARRIER();
}
    3d22:	cf 91       	pop	r28
    3d24:	df 91       	pop	r29
    3d26:	08 95       	ret

00003d28 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
    3d28:	df 93       	push	r29
    3d2a:	cf 93       	push	r28
    3d2c:	cd b7       	in	r28, 0x3d	; 61
    3d2e:	de b7       	in	r29, 0x3e	; 62
    3d30:	2b 97       	sbiw	r28, 0x0b	; 11
    3d32:	0f b6       	in	r0, 0x3f	; 63
    3d34:	f8 94       	cli
    3d36:	de bf       	out	0x3e, r29	; 62
    3d38:	0f be       	out	0x3f, r0	; 63
    3d3a:	cd bf       	out	0x3d, r28	; 61
    TCB_t * pxTCB = NULL;
    3d3c:	1b 86       	std	Y+11, r1	; 0x0b
    3d3e:	1a 86       	std	Y+10, r1	; 0x0a
    BaseType_t xAlreadyYielded = pdFALSE;
    3d40:	19 86       	std	Y+9, r1	; 0x09
    /* It is possible that an ISR caused a task to be removed from an event
     * list while the scheduler was suspended.  If this was the case then the
     * removed task will have been added to the xPendingReadyList.  Once the
     * scheduler has been resumed it is safe to move all the pending ready
     * tasks from this list into their appropriate ready list. */
    taskENTER_CRITICAL();
    3d42:	0f b6       	in	r0, 0x3f	; 63
    3d44:	f8 94       	cli
    3d46:	0f 92       	push	r0
    {
        --uxSchedulerSuspended;
    3d48:	80 91 6d 08 	lds	r24, 0x086D
    3d4c:	81 50       	subi	r24, 0x01	; 1
    3d4e:	80 93 6d 08 	sts	0x086D, r24

        if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    3d52:	80 91 6d 08 	lds	r24, 0x086D
    3d56:	88 23       	and	r24, r24
    3d58:	09 f0       	breq	.+2      	; 0x3d5c <xTaskResumeAll+0x34>
    3d5a:	2a c1       	rjmp	.+596    	; 0x3fb0 <xTaskResumeAll+0x288>
        {
            if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
    3d5c:	80 91 5f 08 	lds	r24, 0x085F
    3d60:	88 23       	and	r24, r24
    3d62:	09 f4       	brne	.+2      	; 0x3d66 <xTaskResumeAll+0x3e>
    3d64:	25 c1       	rjmp	.+586    	; 0x3fb0 <xTaskResumeAll+0x288>
    3d66:	f3 c0       	rjmp	.+486    	; 0x3f4e <xTaskResumeAll+0x226>
            {
                /* Move any readied tasks from the pending list into the
                 * appropriate ready list. */
                while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
                {
                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    3d68:	e0 91 ad 08 	lds	r30, 0x08AD
    3d6c:	f0 91 ae 08 	lds	r31, 0x08AE
    3d70:	86 81       	ldd	r24, Z+6	; 0x06
    3d72:	97 81       	ldd	r25, Z+7	; 0x07
    3d74:	9b 87       	std	Y+11, r25	; 0x0b
    3d76:	8a 87       	std	Y+10, r24	; 0x0a
                    listREMOVE_ITEM( &( pxTCB->xEventListItem ) );
    3d78:	ea 85       	ldd	r30, Y+10	; 0x0a
    3d7a:	fb 85       	ldd	r31, Y+11	; 0x0b
    3d7c:	84 89       	ldd	r24, Z+20	; 0x14
    3d7e:	95 89       	ldd	r25, Z+21	; 0x15
    3d80:	98 87       	std	Y+8, r25	; 0x08
    3d82:	8f 83       	std	Y+7, r24	; 0x07
    3d84:	ea 85       	ldd	r30, Y+10	; 0x0a
    3d86:	fb 85       	ldd	r31, Y+11	; 0x0b
    3d88:	a6 85       	ldd	r26, Z+14	; 0x0e
    3d8a:	b7 85       	ldd	r27, Z+15	; 0x0f
    3d8c:	ea 85       	ldd	r30, Y+10	; 0x0a
    3d8e:	fb 85       	ldd	r31, Y+11	; 0x0b
    3d90:	80 89       	ldd	r24, Z+16	; 0x10
    3d92:	91 89       	ldd	r25, Z+17	; 0x11
    3d94:	15 96       	adiw	r26, 0x05	; 5
    3d96:	9c 93       	st	X, r25
    3d98:	8e 93       	st	-X, r24
    3d9a:	14 97       	sbiw	r26, 0x04	; 4
    3d9c:	ea 85       	ldd	r30, Y+10	; 0x0a
    3d9e:	fb 85       	ldd	r31, Y+11	; 0x0b
    3da0:	a0 89       	ldd	r26, Z+16	; 0x10
    3da2:	b1 89       	ldd	r27, Z+17	; 0x11
    3da4:	ea 85       	ldd	r30, Y+10	; 0x0a
    3da6:	fb 85       	ldd	r31, Y+11	; 0x0b
    3da8:	86 85       	ldd	r24, Z+14	; 0x0e
    3daa:	97 85       	ldd	r25, Z+15	; 0x0f
    3dac:	13 96       	adiw	r26, 0x03	; 3
    3dae:	9c 93       	st	X, r25
    3db0:	8e 93       	st	-X, r24
    3db2:	12 97       	sbiw	r26, 0x02	; 2
    3db4:	ef 81       	ldd	r30, Y+7	; 0x07
    3db6:	f8 85       	ldd	r31, Y+8	; 0x08
    3db8:	21 81       	ldd	r18, Z+1	; 0x01
    3dba:	32 81       	ldd	r19, Z+2	; 0x02
    3dbc:	8a 85       	ldd	r24, Y+10	; 0x0a
    3dbe:	9b 85       	ldd	r25, Y+11	; 0x0b
    3dc0:	0c 96       	adiw	r24, 0x0c	; 12
    3dc2:	28 17       	cp	r18, r24
    3dc4:	39 07       	cpc	r19, r25
    3dc6:	41 f4       	brne	.+16     	; 0x3dd8 <xTaskResumeAll+0xb0>
    3dc8:	ea 85       	ldd	r30, Y+10	; 0x0a
    3dca:	fb 85       	ldd	r31, Y+11	; 0x0b
    3dcc:	80 89       	ldd	r24, Z+16	; 0x10
    3dce:	91 89       	ldd	r25, Z+17	; 0x11
    3dd0:	ef 81       	ldd	r30, Y+7	; 0x07
    3dd2:	f8 85       	ldd	r31, Y+8	; 0x08
    3dd4:	92 83       	std	Z+2, r25	; 0x02
    3dd6:	81 83       	std	Z+1, r24	; 0x01
    3dd8:	ea 85       	ldd	r30, Y+10	; 0x0a
    3dda:	fb 85       	ldd	r31, Y+11	; 0x0b
    3ddc:	15 8a       	std	Z+21, r1	; 0x15
    3dde:	14 8a       	std	Z+20, r1	; 0x14
    3de0:	ef 81       	ldd	r30, Y+7	; 0x07
    3de2:	f8 85       	ldd	r31, Y+8	; 0x08
    3de4:	80 81       	ld	r24, Z
    3de6:	81 50       	subi	r24, 0x01	; 1
    3de8:	ef 81       	ldd	r30, Y+7	; 0x07
    3dea:	f8 85       	ldd	r31, Y+8	; 0x08
    3dec:	80 83       	st	Z, r24
                    portMEMORY_BARRIER();
                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
    3dee:	ea 85       	ldd	r30, Y+10	; 0x0a
    3df0:	fb 85       	ldd	r31, Y+11	; 0x0b
    3df2:	82 85       	ldd	r24, Z+10	; 0x0a
    3df4:	93 85       	ldd	r25, Z+11	; 0x0b
    3df6:	9e 83       	std	Y+6, r25	; 0x06
    3df8:	8d 83       	std	Y+5, r24	; 0x05
    3dfa:	ea 85       	ldd	r30, Y+10	; 0x0a
    3dfc:	fb 85       	ldd	r31, Y+11	; 0x0b
    3dfe:	a4 81       	ldd	r26, Z+4	; 0x04
    3e00:	b5 81       	ldd	r27, Z+5	; 0x05
    3e02:	ea 85       	ldd	r30, Y+10	; 0x0a
    3e04:	fb 85       	ldd	r31, Y+11	; 0x0b
    3e06:	86 81       	ldd	r24, Z+6	; 0x06
    3e08:	97 81       	ldd	r25, Z+7	; 0x07
    3e0a:	15 96       	adiw	r26, 0x05	; 5
    3e0c:	9c 93       	st	X, r25
    3e0e:	8e 93       	st	-X, r24
    3e10:	14 97       	sbiw	r26, 0x04	; 4
    3e12:	ea 85       	ldd	r30, Y+10	; 0x0a
    3e14:	fb 85       	ldd	r31, Y+11	; 0x0b
    3e16:	a6 81       	ldd	r26, Z+6	; 0x06
    3e18:	b7 81       	ldd	r27, Z+7	; 0x07
    3e1a:	ea 85       	ldd	r30, Y+10	; 0x0a
    3e1c:	fb 85       	ldd	r31, Y+11	; 0x0b
    3e1e:	84 81       	ldd	r24, Z+4	; 0x04
    3e20:	95 81       	ldd	r25, Z+5	; 0x05
    3e22:	13 96       	adiw	r26, 0x03	; 3
    3e24:	9c 93       	st	X, r25
    3e26:	8e 93       	st	-X, r24
    3e28:	12 97       	sbiw	r26, 0x02	; 2
    3e2a:	ed 81       	ldd	r30, Y+5	; 0x05
    3e2c:	fe 81       	ldd	r31, Y+6	; 0x06
    3e2e:	21 81       	ldd	r18, Z+1	; 0x01
    3e30:	32 81       	ldd	r19, Z+2	; 0x02
    3e32:	8a 85       	ldd	r24, Y+10	; 0x0a
    3e34:	9b 85       	ldd	r25, Y+11	; 0x0b
    3e36:	02 96       	adiw	r24, 0x02	; 2
    3e38:	28 17       	cp	r18, r24
    3e3a:	39 07       	cpc	r19, r25
    3e3c:	41 f4       	brne	.+16     	; 0x3e4e <xTaskResumeAll+0x126>
    3e3e:	ea 85       	ldd	r30, Y+10	; 0x0a
    3e40:	fb 85       	ldd	r31, Y+11	; 0x0b
    3e42:	86 81       	ldd	r24, Z+6	; 0x06
    3e44:	97 81       	ldd	r25, Z+7	; 0x07
    3e46:	ed 81       	ldd	r30, Y+5	; 0x05
    3e48:	fe 81       	ldd	r31, Y+6	; 0x06
    3e4a:	92 83       	std	Z+2, r25	; 0x02
    3e4c:	81 83       	std	Z+1, r24	; 0x01
    3e4e:	ea 85       	ldd	r30, Y+10	; 0x0a
    3e50:	fb 85       	ldd	r31, Y+11	; 0x0b
    3e52:	13 86       	std	Z+11, r1	; 0x0b
    3e54:	12 86       	std	Z+10, r1	; 0x0a
    3e56:	ed 81       	ldd	r30, Y+5	; 0x05
    3e58:	fe 81       	ldd	r31, Y+6	; 0x06
    3e5a:	80 81       	ld	r24, Z
    3e5c:	81 50       	subi	r24, 0x01	; 1
    3e5e:	ed 81       	ldd	r30, Y+5	; 0x05
    3e60:	fe 81       	ldd	r31, Y+6	; 0x06
    3e62:	80 83       	st	Z, r24
                    prvAddTaskToReadyList( pxTCB );
    3e64:	ea 85       	ldd	r30, Y+10	; 0x0a
    3e66:	fb 85       	ldd	r31, Y+11	; 0x0b
    3e68:	96 89       	ldd	r25, Z+22	; 0x16
    3e6a:	80 91 62 08 	lds	r24, 0x0862
    3e6e:	89 17       	cp	r24, r25
    3e70:	28 f4       	brcc	.+10     	; 0x3e7c <xTaskResumeAll+0x154>
    3e72:	ea 85       	ldd	r30, Y+10	; 0x0a
    3e74:	fb 85       	ldd	r31, Y+11	; 0x0b
    3e76:	86 89       	ldd	r24, Z+22	; 0x16
    3e78:	80 93 62 08 	sts	0x0862, r24
    3e7c:	ea 85       	ldd	r30, Y+10	; 0x0a
    3e7e:	fb 85       	ldd	r31, Y+11	; 0x0b
    3e80:	86 89       	ldd	r24, Z+22	; 0x16
    3e82:	28 2f       	mov	r18, r24
    3e84:	30 e0       	ldi	r19, 0x00	; 0
    3e86:	c9 01       	movw	r24, r18
    3e88:	88 0f       	add	r24, r24
    3e8a:	99 1f       	adc	r25, r25
    3e8c:	88 0f       	add	r24, r24
    3e8e:	99 1f       	adc	r25, r25
    3e90:	88 0f       	add	r24, r24
    3e92:	99 1f       	adc	r25, r25
    3e94:	82 0f       	add	r24, r18
    3e96:	93 1f       	adc	r25, r19
    3e98:	fc 01       	movw	r30, r24
    3e9a:	e2 59       	subi	r30, 0x92	; 146
    3e9c:	f7 4f       	sbci	r31, 0xF7	; 247
    3e9e:	81 81       	ldd	r24, Z+1	; 0x01
    3ea0:	92 81       	ldd	r25, Z+2	; 0x02
    3ea2:	9c 83       	std	Y+4, r25	; 0x04
    3ea4:	8b 83       	std	Y+3, r24	; 0x03
    3ea6:	ea 85       	ldd	r30, Y+10	; 0x0a
    3ea8:	fb 85       	ldd	r31, Y+11	; 0x0b
    3eaa:	8b 81       	ldd	r24, Y+3	; 0x03
    3eac:	9c 81       	ldd	r25, Y+4	; 0x04
    3eae:	95 83       	std	Z+5, r25	; 0x05
    3eb0:	84 83       	std	Z+4, r24	; 0x04
    3eb2:	eb 81       	ldd	r30, Y+3	; 0x03
    3eb4:	fc 81       	ldd	r31, Y+4	; 0x04
    3eb6:	84 81       	ldd	r24, Z+4	; 0x04
    3eb8:	95 81       	ldd	r25, Z+5	; 0x05
    3eba:	ea 85       	ldd	r30, Y+10	; 0x0a
    3ebc:	fb 85       	ldd	r31, Y+11	; 0x0b
    3ebe:	97 83       	std	Z+7, r25	; 0x07
    3ec0:	86 83       	std	Z+6, r24	; 0x06
    3ec2:	eb 81       	ldd	r30, Y+3	; 0x03
    3ec4:	fc 81       	ldd	r31, Y+4	; 0x04
    3ec6:	04 80       	ldd	r0, Z+4	; 0x04
    3ec8:	f5 81       	ldd	r31, Z+5	; 0x05
    3eca:	e0 2d       	mov	r30, r0
    3ecc:	8a 85       	ldd	r24, Y+10	; 0x0a
    3ece:	9b 85       	ldd	r25, Y+11	; 0x0b
    3ed0:	02 96       	adiw	r24, 0x02	; 2
    3ed2:	93 83       	std	Z+3, r25	; 0x03
    3ed4:	82 83       	std	Z+2, r24	; 0x02
    3ed6:	8a 85       	ldd	r24, Y+10	; 0x0a
    3ed8:	9b 85       	ldd	r25, Y+11	; 0x0b
    3eda:	02 96       	adiw	r24, 0x02	; 2
    3edc:	eb 81       	ldd	r30, Y+3	; 0x03
    3ede:	fc 81       	ldd	r31, Y+4	; 0x04
    3ee0:	95 83       	std	Z+5, r25	; 0x05
    3ee2:	84 83       	std	Z+4, r24	; 0x04
    3ee4:	ea 85       	ldd	r30, Y+10	; 0x0a
    3ee6:	fb 85       	ldd	r31, Y+11	; 0x0b
    3ee8:	86 89       	ldd	r24, Z+22	; 0x16
    3eea:	28 2f       	mov	r18, r24
    3eec:	30 e0       	ldi	r19, 0x00	; 0
    3eee:	c9 01       	movw	r24, r18
    3ef0:	88 0f       	add	r24, r24
    3ef2:	99 1f       	adc	r25, r25
    3ef4:	88 0f       	add	r24, r24
    3ef6:	99 1f       	adc	r25, r25
    3ef8:	88 0f       	add	r24, r24
    3efa:	99 1f       	adc	r25, r25
    3efc:	82 0f       	add	r24, r18
    3efe:	93 1f       	adc	r25, r19
    3f00:	82 59       	subi	r24, 0x92	; 146
    3f02:	97 4f       	sbci	r25, 0xF7	; 247
    3f04:	ea 85       	ldd	r30, Y+10	; 0x0a
    3f06:	fb 85       	ldd	r31, Y+11	; 0x0b
    3f08:	93 87       	std	Z+11, r25	; 0x0b
    3f0a:	82 87       	std	Z+10, r24	; 0x0a
    3f0c:	ea 85       	ldd	r30, Y+10	; 0x0a
    3f0e:	fb 85       	ldd	r31, Y+11	; 0x0b
    3f10:	86 89       	ldd	r24, Z+22	; 0x16
    3f12:	28 2f       	mov	r18, r24
    3f14:	30 e0       	ldi	r19, 0x00	; 0
    3f16:	c9 01       	movw	r24, r18
    3f18:	88 0f       	add	r24, r24
    3f1a:	99 1f       	adc	r25, r25
    3f1c:	88 0f       	add	r24, r24
    3f1e:	99 1f       	adc	r25, r25
    3f20:	88 0f       	add	r24, r24
    3f22:	99 1f       	adc	r25, r25
    3f24:	82 0f       	add	r24, r18
    3f26:	93 1f       	adc	r25, r19
    3f28:	fc 01       	movw	r30, r24
    3f2a:	e2 59       	subi	r30, 0x92	; 146
    3f2c:	f7 4f       	sbci	r31, 0xF7	; 247
    3f2e:	80 81       	ld	r24, Z
    3f30:	8f 5f       	subi	r24, 0xFF	; 255
    3f32:	80 83       	st	Z, r24

                    /* If the moved task has a priority higher than or equal to
                     * the current task then a yield must be performed. */
                    if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    3f34:	ea 85       	ldd	r30, Y+10	; 0x0a
    3f36:	fb 85       	ldd	r31, Y+11	; 0x0b
    3f38:	96 89       	ldd	r25, Z+22	; 0x16
    3f3a:	e0 91 5c 08 	lds	r30, 0x085C
    3f3e:	f0 91 5d 08 	lds	r31, 0x085D
    3f42:	86 89       	ldd	r24, Z+22	; 0x16
    3f44:	98 17       	cp	r25, r24
    3f46:	18 f0       	brcs	.+6      	; 0x3f4e <xTaskResumeAll+0x226>
                    {
                        xYieldPending = pdTRUE;
    3f48:	81 e0       	ldi	r24, 0x01	; 1
    3f4a:	80 93 66 08 	sts	0x0866, r24
        {
            if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
            {
                /* Move any readied tasks from the pending list into the
                 * appropriate ready list. */
                while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
    3f4e:	80 91 a8 08 	lds	r24, 0x08A8
    3f52:	88 23       	and	r24, r24
    3f54:	09 f0       	breq	.+2      	; 0x3f58 <xTaskResumeAll+0x230>
    3f56:	08 cf       	rjmp	.-496    	; 0x3d68 <xTaskResumeAll+0x40>
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }
                }

                if( pxTCB != NULL )
    3f58:	8a 85       	ldd	r24, Y+10	; 0x0a
    3f5a:	9b 85       	ldd	r25, Y+11	; 0x0b
    3f5c:	00 97       	sbiw	r24, 0x00	; 0
    3f5e:	11 f0       	breq	.+4      	; 0x3f64 <xTaskResumeAll+0x23c>
                     * which may have prevented the next unblock time from being
                     * re-calculated, in which case re-calculate it now.  Mainly
                     * important for low power tickless implementations, where
                     * this can prevent an unnecessary exit from low power
                     * state. */
                    prvResetNextTaskUnblockTime();
    3f60:	0e 94 da 26 	call	0x4db4	; 0x4db4 <prvResetNextTaskUnblockTime>
                /* If any ticks occurred while the scheduler was suspended then
                 * they should be processed now.  This ensures the tick count does
                 * not  slip, and that any delayed tasks are resumed at the correct
                 * time. */
                {
                    TickType_t xPendedCounts = xPendedTicks; /* Non-volatile copy. */
    3f64:	80 91 64 08 	lds	r24, 0x0864
    3f68:	90 91 65 08 	lds	r25, 0x0865
    3f6c:	9a 83       	std	Y+2, r25	; 0x02
    3f6e:	89 83       	std	Y+1, r24	; 0x01

                    if( xPendedCounts > ( TickType_t ) 0U )
    3f70:	89 81       	ldd	r24, Y+1	; 0x01
    3f72:	9a 81       	ldd	r25, Y+2	; 0x02
    3f74:	00 97       	sbiw	r24, 0x00	; 0
    3f76:	a1 f0       	breq	.+40     	; 0x3fa0 <xTaskResumeAll+0x278>
                    {
                        do
                        {
                            if( xTaskIncrementTick() != pdFALSE )
    3f78:	0e 94 61 20 	call	0x40c2	; 0x40c2 <xTaskIncrementTick>
    3f7c:	88 23       	and	r24, r24
    3f7e:	19 f0       	breq	.+6      	; 0x3f86 <xTaskResumeAll+0x25e>
                            {
                                xYieldPending = pdTRUE;
    3f80:	81 e0       	ldi	r24, 0x01	; 1
    3f82:	80 93 66 08 	sts	0x0866, r24
                            else
                            {
                                mtCOVERAGE_TEST_MARKER();
                            }

                            --xPendedCounts;
    3f86:	89 81       	ldd	r24, Y+1	; 0x01
    3f88:	9a 81       	ldd	r25, Y+2	; 0x02
    3f8a:	01 97       	sbiw	r24, 0x01	; 1
    3f8c:	9a 83       	std	Y+2, r25	; 0x02
    3f8e:	89 83       	std	Y+1, r24	; 0x01
                        } while( xPendedCounts > ( TickType_t ) 0U );
    3f90:	89 81       	ldd	r24, Y+1	; 0x01
    3f92:	9a 81       	ldd	r25, Y+2	; 0x02
    3f94:	00 97       	sbiw	r24, 0x00	; 0
    3f96:	81 f7       	brne	.-32     	; 0x3f78 <xTaskResumeAll+0x250>

                        xPendedTicks = 0;
    3f98:	10 92 65 08 	sts	0x0865, r1
    3f9c:	10 92 64 08 	sts	0x0864, r1
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }
                }

                if( xYieldPending != pdFALSE )
    3fa0:	80 91 66 08 	lds	r24, 0x0866
    3fa4:	88 23       	and	r24, r24
    3fa6:	21 f0       	breq	.+8      	; 0x3fb0 <xTaskResumeAll+0x288>
                {
                    #if ( configUSE_PREEMPTION != 0 )
                        {
                            xAlreadyYielded = pdTRUE;
    3fa8:	81 e0       	ldi	r24, 0x01	; 1
    3faa:	89 87       	std	Y+9, r24	; 0x09
                        }
                    #endif
                    taskYIELD_IF_USING_PREEMPTION();
    3fac:	0e 94 72 09 	call	0x12e4	; 0x12e4 <vPortYield>
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }
    taskEXIT_CRITICAL();
    3fb0:	0f 90       	pop	r0
    3fb2:	0f be       	out	0x3f, r0	; 63

    return xAlreadyYielded;
    3fb4:	89 85       	ldd	r24, Y+9	; 0x09
}
    3fb6:	2b 96       	adiw	r28, 0x0b	; 11
    3fb8:	0f b6       	in	r0, 0x3f	; 63
    3fba:	f8 94       	cli
    3fbc:	de bf       	out	0x3e, r29	; 62
    3fbe:	0f be       	out	0x3f, r0	; 63
    3fc0:	cd bf       	out	0x3d, r28	; 61
    3fc2:	cf 91       	pop	r28
    3fc4:	df 91       	pop	r29
    3fc6:	08 95       	ret

00003fc8 <xTaskGetTickCount>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCount( void )
{
    3fc8:	df 93       	push	r29
    3fca:	cf 93       	push	r28
    3fcc:	00 d0       	rcall	.+0      	; 0x3fce <xTaskGetTickCount+0x6>
    3fce:	cd b7       	in	r28, 0x3d	; 61
    3fd0:	de b7       	in	r29, 0x3e	; 62
    TickType_t xTicks;

    /* Critical section required if running on a 16 bit processor. */
    portTICK_TYPE_ENTER_CRITICAL();
    3fd2:	0f b6       	in	r0, 0x3f	; 63
    3fd4:	f8 94       	cli
    3fd6:	0f 92       	push	r0
    {
        xTicks = xTickCount;
    3fd8:	80 91 60 08 	lds	r24, 0x0860
    3fdc:	90 91 61 08 	lds	r25, 0x0861
    3fe0:	9a 83       	std	Y+2, r25	; 0x02
    3fe2:	89 83       	std	Y+1, r24	; 0x01
    }
    portTICK_TYPE_EXIT_CRITICAL();
    3fe4:	0f 90       	pop	r0
    3fe6:	0f be       	out	0x3f, r0	; 63

    return xTicks;
    3fe8:	89 81       	ldd	r24, Y+1	; 0x01
    3fea:	9a 81       	ldd	r25, Y+2	; 0x02
}
    3fec:	0f 90       	pop	r0
    3fee:	0f 90       	pop	r0
    3ff0:	cf 91       	pop	r28
    3ff2:	df 91       	pop	r29
    3ff4:	08 95       	ret

00003ff6 <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCountFromISR( void )
{
    3ff6:	df 93       	push	r29
    3ff8:	cf 93       	push	r28
    3ffa:	00 d0       	rcall	.+0      	; 0x3ffc <xTaskGetTickCountFromISR+0x6>
    3ffc:	0f 92       	push	r0
    3ffe:	cd b7       	in	r28, 0x3d	; 61
    4000:	de b7       	in	r29, 0x3e	; 62
     * safe API to ensure interrupt entry is as fast and as simple as possible.
     * More information (albeit Cortex-M specific) is provided on the following
     * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

    uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
    4002:	19 82       	std	Y+1, r1	; 0x01
    {
        xReturn = xTickCount;
    4004:	80 91 60 08 	lds	r24, 0x0860
    4008:	90 91 61 08 	lds	r25, 0x0861
    400c:	9b 83       	std	Y+3, r25	; 0x03
    400e:	8a 83       	std	Y+2, r24	; 0x02
    }
    portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
    4010:	8a 81       	ldd	r24, Y+2	; 0x02
    4012:	9b 81       	ldd	r25, Y+3	; 0x03
}
    4014:	0f 90       	pop	r0
    4016:	0f 90       	pop	r0
    4018:	0f 90       	pop	r0
    401a:	cf 91       	pop	r28
    401c:	df 91       	pop	r29
    401e:	08 95       	ret

00004020 <uxTaskGetNumberOfTasks>:
/*-----------------------------------------------------------*/

UBaseType_t uxTaskGetNumberOfTasks( void )
{
    4020:	df 93       	push	r29
    4022:	cf 93       	push	r28
    4024:	cd b7       	in	r28, 0x3d	; 61
    4026:	de b7       	in	r29, 0x3e	; 62
    /* A critical section is not required because the variables are of type
     * BaseType_t. */
    return uxCurrentNumberOfTasks;
    4028:	80 91 5f 08 	lds	r24, 0x085F
}
    402c:	cf 91       	pop	r28
    402e:	df 91       	pop	r29
    4030:	08 95       	ret

00004032 <pcTaskGetName>:
/*-----------------------------------------------------------*/

char * pcTaskGetName( TaskHandle_t xTaskToQuery ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
    4032:	df 93       	push	r29
    4034:	cf 93       	push	r28
    4036:	00 d0       	rcall	.+0      	; 0x4038 <pcTaskGetName+0x6>
    4038:	00 d0       	rcall	.+0      	; 0x403a <pcTaskGetName+0x8>
    403a:	00 d0       	rcall	.+0      	; 0x403c <pcTaskGetName+0xa>
    403c:	cd b7       	in	r28, 0x3d	; 61
    403e:	de b7       	in	r29, 0x3e	; 62
    4040:	9c 83       	std	Y+4, r25	; 0x04
    4042:	8b 83       	std	Y+3, r24	; 0x03
    TCB_t * pxTCB;

    /* If null is passed in here then the name of the calling task is being
     * queried. */
    pxTCB = prvGetTCBFromHandle( xTaskToQuery );
    4044:	8b 81       	ldd	r24, Y+3	; 0x03
    4046:	9c 81       	ldd	r25, Y+4	; 0x04
    4048:	00 97       	sbiw	r24, 0x00	; 0
    404a:	39 f4       	brne	.+14     	; 0x405a <pcTaskGetName+0x28>
    404c:	80 91 5c 08 	lds	r24, 0x085C
    4050:	90 91 5d 08 	lds	r25, 0x085D
    4054:	9e 83       	std	Y+6, r25	; 0x06
    4056:	8d 83       	std	Y+5, r24	; 0x05
    4058:	04 c0       	rjmp	.+8      	; 0x4062 <pcTaskGetName+0x30>
    405a:	8b 81       	ldd	r24, Y+3	; 0x03
    405c:	9c 81       	ldd	r25, Y+4	; 0x04
    405e:	9e 83       	std	Y+6, r25	; 0x06
    4060:	8d 83       	std	Y+5, r24	; 0x05
    4062:	8d 81       	ldd	r24, Y+5	; 0x05
    4064:	9e 81       	ldd	r25, Y+6	; 0x06
    4066:	9a 83       	std	Y+2, r25	; 0x02
    4068:	89 83       	std	Y+1, r24	; 0x01
    configASSERT( pxTCB );
    return &( pxTCB->pcTaskName[ 0 ] );
    406a:	89 81       	ldd	r24, Y+1	; 0x01
    406c:	9a 81       	ldd	r25, Y+2	; 0x02
    406e:	49 96       	adiw	r24, 0x19	; 25
}
    4070:	26 96       	adiw	r28, 0x06	; 6
    4072:	0f b6       	in	r0, 0x3f	; 63
    4074:	f8 94       	cli
    4076:	de bf       	out	0x3e, r29	; 62
    4078:	0f be       	out	0x3f, r0	; 63
    407a:	cd bf       	out	0x3d, r28	; 61
    407c:	cf 91       	pop	r28
    407e:	df 91       	pop	r29
    4080:	08 95       	ret

00004082 <xTaskCatchUpTicks>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskCatchUpTicks( TickType_t xTicksToCatchUp )
{
    4082:	df 93       	push	r29
    4084:	cf 93       	push	r28
    4086:	00 d0       	rcall	.+0      	; 0x4088 <xTaskCatchUpTicks+0x6>
    4088:	0f 92       	push	r0
    408a:	cd b7       	in	r28, 0x3d	; 61
    408c:	de b7       	in	r29, 0x3e	; 62
    408e:	9b 83       	std	Y+3, r25	; 0x03
    4090:	8a 83       	std	Y+2, r24	; 0x02
     * relies on xPendedTicks being wound down to 0 in xTaskResumeAll(). */
    configASSERT( uxSchedulerSuspended == 0 );

    /* Use xPendedTicks to mimic xTicksToCatchUp number of ticks occurring when
     * the scheduler is suspended so the ticks are executed in xTaskResumeAll(). */
    vTaskSuspendAll();
    4092:	0e 94 88 1e 	call	0x3d10	; 0x3d10 <vTaskSuspendAll>
    xPendedTicks += xTicksToCatchUp;
    4096:	20 91 64 08 	lds	r18, 0x0864
    409a:	30 91 65 08 	lds	r19, 0x0865
    409e:	8a 81       	ldd	r24, Y+2	; 0x02
    40a0:	9b 81       	ldd	r25, Y+3	; 0x03
    40a2:	82 0f       	add	r24, r18
    40a4:	93 1f       	adc	r25, r19
    40a6:	90 93 65 08 	sts	0x0865, r25
    40aa:	80 93 64 08 	sts	0x0864, r24
    xYieldOccurred = xTaskResumeAll();
    40ae:	0e 94 94 1e 	call	0x3d28	; 0x3d28 <xTaskResumeAll>
    40b2:	89 83       	std	Y+1, r24	; 0x01

    return xYieldOccurred;
    40b4:	89 81       	ldd	r24, Y+1	; 0x01
}
    40b6:	0f 90       	pop	r0
    40b8:	0f 90       	pop	r0
    40ba:	0f 90       	pop	r0
    40bc:	cf 91       	pop	r28
    40be:	df 91       	pop	r29
    40c0:	08 95       	ret

000040c2 <xTaskIncrementTick>:

#endif /* INCLUDE_xTaskAbortDelay */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
    40c2:	df 93       	push	r29
    40c4:	cf 93       	push	r28
    40c6:	cd b7       	in	r28, 0x3d	; 61
    40c8:	de b7       	in	r29, 0x3e	; 62
    40ca:	2f 97       	sbiw	r28, 0x0f	; 15
    40cc:	0f b6       	in	r0, 0x3f	; 63
    40ce:	f8 94       	cli
    40d0:	de bf       	out	0x3e, r29	; 62
    40d2:	0f be       	out	0x3f, r0	; 63
    40d4:	cd bf       	out	0x3d, r28	; 61
    TCB_t * pxTCB;
    TickType_t xItemValue;
    BaseType_t xSwitchRequired = pdFALSE;
    40d6:	1b 86       	std	Y+11, r1	; 0x0b
    /* Called by the portable layer each time a tick interrupt occurs.
     * Increments the tick then checks to see if the new tick value will cause any
     * tasks to be unblocked. */
    traceTASK_INCREMENT_TICK( xTickCount );

    if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    40d8:	80 91 6d 08 	lds	r24, 0x086D
    40dc:	88 23       	and	r24, r24
    40de:	09 f0       	breq	.+2      	; 0x40e2 <xTaskIncrementTick+0x20>
    40e0:	74 c1       	rjmp	.+744    	; 0x43ca <xTaskIncrementTick+0x308>
    {
        /* Minor optimisation.  The tick count cannot change in this
         * block. */
        const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
    40e2:	80 91 60 08 	lds	r24, 0x0860
    40e6:	90 91 61 08 	lds	r25, 0x0861
    40ea:	01 96       	adiw	r24, 0x01	; 1
    40ec:	9a 87       	std	Y+10, r25	; 0x0a
    40ee:	89 87       	std	Y+9, r24	; 0x09

        /* Increment the RTOS tick, switching the delayed and overflowed
         * delayed lists if it wraps to 0. */
        xTickCount = xConstTickCount;
    40f0:	89 85       	ldd	r24, Y+9	; 0x09
    40f2:	9a 85       	ldd	r25, Y+10	; 0x0a
    40f4:	90 93 61 08 	sts	0x0861, r25
    40f8:	80 93 60 08 	sts	0x0860, r24

        if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
    40fc:	89 85       	ldd	r24, Y+9	; 0x09
    40fe:	9a 85       	ldd	r25, Y+10	; 0x0a
    4100:	00 97       	sbiw	r24, 0x00	; 0
    4102:	d9 f4       	brne	.+54     	; 0x413a <xTaskIncrementTick+0x78>
        {
            taskSWITCH_DELAYED_LISTS();
    4104:	80 91 a4 08 	lds	r24, 0x08A4
    4108:	90 91 a5 08 	lds	r25, 0x08A5
    410c:	98 87       	std	Y+8, r25	; 0x08
    410e:	8f 83       	std	Y+7, r24	; 0x07
    4110:	80 91 a6 08 	lds	r24, 0x08A6
    4114:	90 91 a7 08 	lds	r25, 0x08A7
    4118:	90 93 a5 08 	sts	0x08A5, r25
    411c:	80 93 a4 08 	sts	0x08A4, r24
    4120:	8f 81       	ldd	r24, Y+7	; 0x07
    4122:	98 85       	ldd	r25, Y+8	; 0x08
    4124:	90 93 a7 08 	sts	0x08A7, r25
    4128:	80 93 a6 08 	sts	0x08A6, r24
    412c:	80 91 67 08 	lds	r24, 0x0867
    4130:	8f 5f       	subi	r24, 0xFF	; 255
    4132:	80 93 67 08 	sts	0x0867, r24
    4136:	0e 94 da 26 	call	0x4db4	; 0x4db4 <prvResetNextTaskUnblockTime>

        /* See if this tick has made a timeout expire.  Tasks are stored in
         * the  queue in the order of their wake time - meaning once one task
         * has been found whose block time has not expired there is no need to
         * look any further down the list. */
        if( xConstTickCount >= xNextTaskUnblockTime )
    413a:	20 91 69 08 	lds	r18, 0x0869
    413e:	30 91 6a 08 	lds	r19, 0x086A
    4142:	89 85       	ldd	r24, Y+9	; 0x09
    4144:	9a 85       	ldd	r25, Y+10	; 0x0a
    4146:	82 17       	cp	r24, r18
    4148:	93 07       	cpc	r25, r19
    414a:	08 f4       	brcc	.+2      	; 0x414e <xTaskIncrementTick+0x8c>
    414c:	1f c1       	rjmp	.+574    	; 0x438c <xTaskIncrementTick+0x2ca>
        {
            for( ; ; )
            {
                if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    414e:	e0 91 a4 08 	lds	r30, 0x08A4
    4152:	f0 91 a5 08 	lds	r31, 0x08A5
    4156:	80 81       	ld	r24, Z
    4158:	88 23       	and	r24, r24
    415a:	39 f4       	brne	.+14     	; 0x416a <xTaskIncrementTick+0xa8>
                    /* The delayed list is empty.  Set xNextTaskUnblockTime
                     * to the maximum possible value so it is extremely
                     * unlikely that the
                     * if( xTickCount >= xNextTaskUnblockTime ) test will pass
                     * next time through. */
                    xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    415c:	8f ef       	ldi	r24, 0xFF	; 255
    415e:	9f ef       	ldi	r25, 0xFF	; 255
    4160:	90 93 6a 08 	sts	0x086A, r25
    4164:	80 93 69 08 	sts	0x0869, r24
    4168:	11 c1       	rjmp	.+546    	; 0x438c <xTaskIncrementTick+0x2ca>
                {
                    /* The delayed list is not empty, get the value of the
                     * item at the head of the delayed list.  This is the time
                     * at which the task at the head of the delayed list must
                     * be removed from the Blocked state. */
                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    416a:	e0 91 a4 08 	lds	r30, 0x08A4
    416e:	f0 91 a5 08 	lds	r31, 0x08A5
    4172:	05 80       	ldd	r0, Z+5	; 0x05
    4174:	f6 81       	ldd	r31, Z+6	; 0x06
    4176:	e0 2d       	mov	r30, r0
    4178:	86 81       	ldd	r24, Z+6	; 0x06
    417a:	97 81       	ldd	r25, Z+7	; 0x07
    417c:	9f 87       	std	Y+15, r25	; 0x0f
    417e:	8e 87       	std	Y+14, r24	; 0x0e
                    xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
    4180:	ee 85       	ldd	r30, Y+14	; 0x0e
    4182:	ff 85       	ldd	r31, Y+15	; 0x0f
    4184:	82 81       	ldd	r24, Z+2	; 0x02
    4186:	93 81       	ldd	r25, Z+3	; 0x03
    4188:	9d 87       	std	Y+13, r25	; 0x0d
    418a:	8c 87       	std	Y+12, r24	; 0x0c

                    if( xConstTickCount < xItemValue )
    418c:	29 85       	ldd	r18, Y+9	; 0x09
    418e:	3a 85       	ldd	r19, Y+10	; 0x0a
    4190:	8c 85       	ldd	r24, Y+12	; 0x0c
    4192:	9d 85       	ldd	r25, Y+13	; 0x0d
    4194:	28 17       	cp	r18, r24
    4196:	39 07       	cpc	r19, r25
    4198:	38 f4       	brcc	.+14     	; 0x41a8 <xTaskIncrementTick+0xe6>
                        /* It is not time to unblock this item yet, but the
                         * item value is the time at which the task at the head
                         * of the blocked list must be removed from the Blocked
                         * state -  so record the item value in
                         * xNextTaskUnblockTime. */
                        xNextTaskUnblockTime = xItemValue;
    419a:	8c 85       	ldd	r24, Y+12	; 0x0c
    419c:	9d 85       	ldd	r25, Y+13	; 0x0d
    419e:	90 93 6a 08 	sts	0x086A, r25
    41a2:	80 93 69 08 	sts	0x0869, r24
    41a6:	f2 c0       	rjmp	.+484    	; 0x438c <xTaskIncrementTick+0x2ca>
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }

                    /* It is time to remove the item from the Blocked state. */
                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
    41a8:	ee 85       	ldd	r30, Y+14	; 0x0e
    41aa:	ff 85       	ldd	r31, Y+15	; 0x0f
    41ac:	82 85       	ldd	r24, Z+10	; 0x0a
    41ae:	93 85       	ldd	r25, Z+11	; 0x0b
    41b0:	9e 83       	std	Y+6, r25	; 0x06
    41b2:	8d 83       	std	Y+5, r24	; 0x05
    41b4:	ee 85       	ldd	r30, Y+14	; 0x0e
    41b6:	ff 85       	ldd	r31, Y+15	; 0x0f
    41b8:	a4 81       	ldd	r26, Z+4	; 0x04
    41ba:	b5 81       	ldd	r27, Z+5	; 0x05
    41bc:	ee 85       	ldd	r30, Y+14	; 0x0e
    41be:	ff 85       	ldd	r31, Y+15	; 0x0f
    41c0:	86 81       	ldd	r24, Z+6	; 0x06
    41c2:	97 81       	ldd	r25, Z+7	; 0x07
    41c4:	15 96       	adiw	r26, 0x05	; 5
    41c6:	9c 93       	st	X, r25
    41c8:	8e 93       	st	-X, r24
    41ca:	14 97       	sbiw	r26, 0x04	; 4
    41cc:	ee 85       	ldd	r30, Y+14	; 0x0e
    41ce:	ff 85       	ldd	r31, Y+15	; 0x0f
    41d0:	a6 81       	ldd	r26, Z+6	; 0x06
    41d2:	b7 81       	ldd	r27, Z+7	; 0x07
    41d4:	ee 85       	ldd	r30, Y+14	; 0x0e
    41d6:	ff 85       	ldd	r31, Y+15	; 0x0f
    41d8:	84 81       	ldd	r24, Z+4	; 0x04
    41da:	95 81       	ldd	r25, Z+5	; 0x05
    41dc:	13 96       	adiw	r26, 0x03	; 3
    41de:	9c 93       	st	X, r25
    41e0:	8e 93       	st	-X, r24
    41e2:	12 97       	sbiw	r26, 0x02	; 2
    41e4:	ed 81       	ldd	r30, Y+5	; 0x05
    41e6:	fe 81       	ldd	r31, Y+6	; 0x06
    41e8:	21 81       	ldd	r18, Z+1	; 0x01
    41ea:	32 81       	ldd	r19, Z+2	; 0x02
    41ec:	8e 85       	ldd	r24, Y+14	; 0x0e
    41ee:	9f 85       	ldd	r25, Y+15	; 0x0f
    41f0:	02 96       	adiw	r24, 0x02	; 2
    41f2:	28 17       	cp	r18, r24
    41f4:	39 07       	cpc	r19, r25
    41f6:	41 f4       	brne	.+16     	; 0x4208 <xTaskIncrementTick+0x146>
    41f8:	ee 85       	ldd	r30, Y+14	; 0x0e
    41fa:	ff 85       	ldd	r31, Y+15	; 0x0f
    41fc:	86 81       	ldd	r24, Z+6	; 0x06
    41fe:	97 81       	ldd	r25, Z+7	; 0x07
    4200:	ed 81       	ldd	r30, Y+5	; 0x05
    4202:	fe 81       	ldd	r31, Y+6	; 0x06
    4204:	92 83       	std	Z+2, r25	; 0x02
    4206:	81 83       	std	Z+1, r24	; 0x01
    4208:	ee 85       	ldd	r30, Y+14	; 0x0e
    420a:	ff 85       	ldd	r31, Y+15	; 0x0f
    420c:	13 86       	std	Z+11, r1	; 0x0b
    420e:	12 86       	std	Z+10, r1	; 0x0a
    4210:	ed 81       	ldd	r30, Y+5	; 0x05
    4212:	fe 81       	ldd	r31, Y+6	; 0x06
    4214:	80 81       	ld	r24, Z
    4216:	81 50       	subi	r24, 0x01	; 1
    4218:	ed 81       	ldd	r30, Y+5	; 0x05
    421a:	fe 81       	ldd	r31, Y+6	; 0x06
    421c:	80 83       	st	Z, r24

                    /* Is the task waiting on an event also?  If so remove
                     * it from the event list. */
                    if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    421e:	ee 85       	ldd	r30, Y+14	; 0x0e
    4220:	ff 85       	ldd	r31, Y+15	; 0x0f
    4222:	84 89       	ldd	r24, Z+20	; 0x14
    4224:	95 89       	ldd	r25, Z+21	; 0x15
    4226:	00 97       	sbiw	r24, 0x00	; 0
    4228:	d9 f1       	breq	.+118    	; 0x42a0 <xTaskIncrementTick+0x1de>
                    {
                        listREMOVE_ITEM( &( pxTCB->xEventListItem ) );
    422a:	ee 85       	ldd	r30, Y+14	; 0x0e
    422c:	ff 85       	ldd	r31, Y+15	; 0x0f
    422e:	84 89       	ldd	r24, Z+20	; 0x14
    4230:	95 89       	ldd	r25, Z+21	; 0x15
    4232:	9c 83       	std	Y+4, r25	; 0x04
    4234:	8b 83       	std	Y+3, r24	; 0x03
    4236:	ee 85       	ldd	r30, Y+14	; 0x0e
    4238:	ff 85       	ldd	r31, Y+15	; 0x0f
    423a:	a6 85       	ldd	r26, Z+14	; 0x0e
    423c:	b7 85       	ldd	r27, Z+15	; 0x0f
    423e:	ee 85       	ldd	r30, Y+14	; 0x0e
    4240:	ff 85       	ldd	r31, Y+15	; 0x0f
    4242:	80 89       	ldd	r24, Z+16	; 0x10
    4244:	91 89       	ldd	r25, Z+17	; 0x11
    4246:	15 96       	adiw	r26, 0x05	; 5
    4248:	9c 93       	st	X, r25
    424a:	8e 93       	st	-X, r24
    424c:	14 97       	sbiw	r26, 0x04	; 4
    424e:	ee 85       	ldd	r30, Y+14	; 0x0e
    4250:	ff 85       	ldd	r31, Y+15	; 0x0f
    4252:	a0 89       	ldd	r26, Z+16	; 0x10
    4254:	b1 89       	ldd	r27, Z+17	; 0x11
    4256:	ee 85       	ldd	r30, Y+14	; 0x0e
    4258:	ff 85       	ldd	r31, Y+15	; 0x0f
    425a:	86 85       	ldd	r24, Z+14	; 0x0e
    425c:	97 85       	ldd	r25, Z+15	; 0x0f
    425e:	13 96       	adiw	r26, 0x03	; 3
    4260:	9c 93       	st	X, r25
    4262:	8e 93       	st	-X, r24
    4264:	12 97       	sbiw	r26, 0x02	; 2
    4266:	eb 81       	ldd	r30, Y+3	; 0x03
    4268:	fc 81       	ldd	r31, Y+4	; 0x04
    426a:	21 81       	ldd	r18, Z+1	; 0x01
    426c:	32 81       	ldd	r19, Z+2	; 0x02
    426e:	8e 85       	ldd	r24, Y+14	; 0x0e
    4270:	9f 85       	ldd	r25, Y+15	; 0x0f
    4272:	0c 96       	adiw	r24, 0x0c	; 12
    4274:	28 17       	cp	r18, r24
    4276:	39 07       	cpc	r19, r25
    4278:	41 f4       	brne	.+16     	; 0x428a <xTaskIncrementTick+0x1c8>
    427a:	ee 85       	ldd	r30, Y+14	; 0x0e
    427c:	ff 85       	ldd	r31, Y+15	; 0x0f
    427e:	80 89       	ldd	r24, Z+16	; 0x10
    4280:	91 89       	ldd	r25, Z+17	; 0x11
    4282:	eb 81       	ldd	r30, Y+3	; 0x03
    4284:	fc 81       	ldd	r31, Y+4	; 0x04
    4286:	92 83       	std	Z+2, r25	; 0x02
    4288:	81 83       	std	Z+1, r24	; 0x01
    428a:	ee 85       	ldd	r30, Y+14	; 0x0e
    428c:	ff 85       	ldd	r31, Y+15	; 0x0f
    428e:	15 8a       	std	Z+21, r1	; 0x15
    4290:	14 8a       	std	Z+20, r1	; 0x14
    4292:	eb 81       	ldd	r30, Y+3	; 0x03
    4294:	fc 81       	ldd	r31, Y+4	; 0x04
    4296:	80 81       	ld	r24, Z
    4298:	81 50       	subi	r24, 0x01	; 1
    429a:	eb 81       	ldd	r30, Y+3	; 0x03
    429c:	fc 81       	ldd	r31, Y+4	; 0x04
    429e:	80 83       	st	Z, r24
                        mtCOVERAGE_TEST_MARKER();
                    }

                    /* Place the unblocked task into the appropriate ready
                     * list. */
                    prvAddTaskToReadyList( pxTCB );
    42a0:	ee 85       	ldd	r30, Y+14	; 0x0e
    42a2:	ff 85       	ldd	r31, Y+15	; 0x0f
    42a4:	96 89       	ldd	r25, Z+22	; 0x16
    42a6:	80 91 62 08 	lds	r24, 0x0862
    42aa:	89 17       	cp	r24, r25
    42ac:	28 f4       	brcc	.+10     	; 0x42b8 <xTaskIncrementTick+0x1f6>
    42ae:	ee 85       	ldd	r30, Y+14	; 0x0e
    42b0:	ff 85       	ldd	r31, Y+15	; 0x0f
    42b2:	86 89       	ldd	r24, Z+22	; 0x16
    42b4:	80 93 62 08 	sts	0x0862, r24
    42b8:	ee 85       	ldd	r30, Y+14	; 0x0e
    42ba:	ff 85       	ldd	r31, Y+15	; 0x0f
    42bc:	86 89       	ldd	r24, Z+22	; 0x16
    42be:	28 2f       	mov	r18, r24
    42c0:	30 e0       	ldi	r19, 0x00	; 0
    42c2:	c9 01       	movw	r24, r18
    42c4:	88 0f       	add	r24, r24
    42c6:	99 1f       	adc	r25, r25
    42c8:	88 0f       	add	r24, r24
    42ca:	99 1f       	adc	r25, r25
    42cc:	88 0f       	add	r24, r24
    42ce:	99 1f       	adc	r25, r25
    42d0:	82 0f       	add	r24, r18
    42d2:	93 1f       	adc	r25, r19
    42d4:	fc 01       	movw	r30, r24
    42d6:	e2 59       	subi	r30, 0x92	; 146
    42d8:	f7 4f       	sbci	r31, 0xF7	; 247
    42da:	81 81       	ldd	r24, Z+1	; 0x01
    42dc:	92 81       	ldd	r25, Z+2	; 0x02
    42de:	9a 83       	std	Y+2, r25	; 0x02
    42e0:	89 83       	std	Y+1, r24	; 0x01
    42e2:	ee 85       	ldd	r30, Y+14	; 0x0e
    42e4:	ff 85       	ldd	r31, Y+15	; 0x0f
    42e6:	89 81       	ldd	r24, Y+1	; 0x01
    42e8:	9a 81       	ldd	r25, Y+2	; 0x02
    42ea:	95 83       	std	Z+5, r25	; 0x05
    42ec:	84 83       	std	Z+4, r24	; 0x04
    42ee:	e9 81       	ldd	r30, Y+1	; 0x01
    42f0:	fa 81       	ldd	r31, Y+2	; 0x02
    42f2:	84 81       	ldd	r24, Z+4	; 0x04
    42f4:	95 81       	ldd	r25, Z+5	; 0x05
    42f6:	ee 85       	ldd	r30, Y+14	; 0x0e
    42f8:	ff 85       	ldd	r31, Y+15	; 0x0f
    42fa:	97 83       	std	Z+7, r25	; 0x07
    42fc:	86 83       	std	Z+6, r24	; 0x06
    42fe:	e9 81       	ldd	r30, Y+1	; 0x01
    4300:	fa 81       	ldd	r31, Y+2	; 0x02
    4302:	04 80       	ldd	r0, Z+4	; 0x04
    4304:	f5 81       	ldd	r31, Z+5	; 0x05
    4306:	e0 2d       	mov	r30, r0
    4308:	8e 85       	ldd	r24, Y+14	; 0x0e
    430a:	9f 85       	ldd	r25, Y+15	; 0x0f
    430c:	02 96       	adiw	r24, 0x02	; 2
    430e:	93 83       	std	Z+3, r25	; 0x03
    4310:	82 83       	std	Z+2, r24	; 0x02
    4312:	8e 85       	ldd	r24, Y+14	; 0x0e
    4314:	9f 85       	ldd	r25, Y+15	; 0x0f
    4316:	02 96       	adiw	r24, 0x02	; 2
    4318:	e9 81       	ldd	r30, Y+1	; 0x01
    431a:	fa 81       	ldd	r31, Y+2	; 0x02
    431c:	95 83       	std	Z+5, r25	; 0x05
    431e:	84 83       	std	Z+4, r24	; 0x04
    4320:	ee 85       	ldd	r30, Y+14	; 0x0e
    4322:	ff 85       	ldd	r31, Y+15	; 0x0f
    4324:	86 89       	ldd	r24, Z+22	; 0x16
    4326:	28 2f       	mov	r18, r24
    4328:	30 e0       	ldi	r19, 0x00	; 0
    432a:	c9 01       	movw	r24, r18
    432c:	88 0f       	add	r24, r24
    432e:	99 1f       	adc	r25, r25
    4330:	88 0f       	add	r24, r24
    4332:	99 1f       	adc	r25, r25
    4334:	88 0f       	add	r24, r24
    4336:	99 1f       	adc	r25, r25
    4338:	82 0f       	add	r24, r18
    433a:	93 1f       	adc	r25, r19
    433c:	82 59       	subi	r24, 0x92	; 146
    433e:	97 4f       	sbci	r25, 0xF7	; 247
    4340:	ee 85       	ldd	r30, Y+14	; 0x0e
    4342:	ff 85       	ldd	r31, Y+15	; 0x0f
    4344:	93 87       	std	Z+11, r25	; 0x0b
    4346:	82 87       	std	Z+10, r24	; 0x0a
    4348:	ee 85       	ldd	r30, Y+14	; 0x0e
    434a:	ff 85       	ldd	r31, Y+15	; 0x0f
    434c:	86 89       	ldd	r24, Z+22	; 0x16
    434e:	28 2f       	mov	r18, r24
    4350:	30 e0       	ldi	r19, 0x00	; 0
    4352:	c9 01       	movw	r24, r18
    4354:	88 0f       	add	r24, r24
    4356:	99 1f       	adc	r25, r25
    4358:	88 0f       	add	r24, r24
    435a:	99 1f       	adc	r25, r25
    435c:	88 0f       	add	r24, r24
    435e:	99 1f       	adc	r25, r25
    4360:	82 0f       	add	r24, r18
    4362:	93 1f       	adc	r25, r19
    4364:	fc 01       	movw	r30, r24
    4366:	e2 59       	subi	r30, 0x92	; 146
    4368:	f7 4f       	sbci	r31, 0xF7	; 247
    436a:	80 81       	ld	r24, Z
    436c:	8f 5f       	subi	r24, 0xFF	; 255
    436e:	80 83       	st	Z, r24
                        {
                            /* Preemption is on, but a context switch should
                             * only be performed if the unblocked task has a
                             * priority that is equal to or higher than the
                             * currently executing task. */
                            if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    4370:	ee 85       	ldd	r30, Y+14	; 0x0e
    4372:	ff 85       	ldd	r31, Y+15	; 0x0f
    4374:	96 89       	ldd	r25, Z+22	; 0x16
    4376:	e0 91 5c 08 	lds	r30, 0x085C
    437a:	f0 91 5d 08 	lds	r31, 0x085D
    437e:	86 89       	ldd	r24, Z+22	; 0x16
    4380:	98 17       	cp	r25, r24
    4382:	08 f4       	brcc	.+2      	; 0x4386 <xTaskIncrementTick+0x2c4>
    4384:	e4 ce       	rjmp	.-568    	; 0x414e <xTaskIncrementTick+0x8c>
                            {
                                xSwitchRequired = pdTRUE;
    4386:	81 e0       	ldi	r24, 0x01	; 1
    4388:	8b 87       	std	Y+11, r24	; 0x0b
    438a:	e1 ce       	rjmp	.-574    	; 0x414e <xTaskIncrementTick+0x8c>
        /* Tasks of equal priority to the currently running task will share
         * processing time (time slice) if preemption is on, and the application
         * writer has not explicitly turned time slicing off. */
        #if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
            {
                if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
    438c:	e0 91 5c 08 	lds	r30, 0x085C
    4390:	f0 91 5d 08 	lds	r31, 0x085D
    4394:	86 89       	ldd	r24, Z+22	; 0x16
    4396:	28 2f       	mov	r18, r24
    4398:	30 e0       	ldi	r19, 0x00	; 0
    439a:	c9 01       	movw	r24, r18
    439c:	88 0f       	add	r24, r24
    439e:	99 1f       	adc	r25, r25
    43a0:	88 0f       	add	r24, r24
    43a2:	99 1f       	adc	r25, r25
    43a4:	88 0f       	add	r24, r24
    43a6:	99 1f       	adc	r25, r25
    43a8:	82 0f       	add	r24, r18
    43aa:	93 1f       	adc	r25, r19
    43ac:	fc 01       	movw	r30, r24
    43ae:	e2 59       	subi	r30, 0x92	; 146
    43b0:	f7 4f       	sbci	r31, 0xF7	; 247
    43b2:	80 81       	ld	r24, Z
    43b4:	82 30       	cpi	r24, 0x02	; 2
    43b6:	10 f0       	brcs	.+4      	; 0x43bc <xTaskIncrementTick+0x2fa>
                {
                    xSwitchRequired = pdTRUE;
    43b8:	81 e0       	ldi	r24, 0x01	; 1
    43ba:	8b 87       	std	Y+11, r24	; 0x0b
            }
        #endif /* configUSE_TICK_HOOK */

        #if ( configUSE_PREEMPTION == 1 )
            {
                if( xYieldPending != pdFALSE )
    43bc:	80 91 66 08 	lds	r24, 0x0866
    43c0:	88 23       	and	r24, r24
    43c2:	61 f0       	breq	.+24     	; 0x43dc <xTaskIncrementTick+0x31a>
                {
                    xSwitchRequired = pdTRUE;
    43c4:	81 e0       	ldi	r24, 0x01	; 1
    43c6:	8b 87       	std	Y+11, r24	; 0x0b
    43c8:	09 c0       	rjmp	.+18     	; 0x43dc <xTaskIncrementTick+0x31a>
            }
        #endif /* configUSE_PREEMPTION */
    }
    else
    {
        ++xPendedTicks;
    43ca:	80 91 64 08 	lds	r24, 0x0864
    43ce:	90 91 65 08 	lds	r25, 0x0865
    43d2:	01 96       	adiw	r24, 0x01	; 1
    43d4:	90 93 65 08 	sts	0x0865, r25
    43d8:	80 93 64 08 	sts	0x0864, r24
                vApplicationTickHook();
            }
        #endif
    }

    return xSwitchRequired;
    43dc:	8b 85       	ldd	r24, Y+11	; 0x0b
}
    43de:	2f 96       	adiw	r28, 0x0f	; 15
    43e0:	0f b6       	in	r0, 0x3f	; 63
    43e2:	f8 94       	cli
    43e4:	de bf       	out	0x3e, r29	; 62
    43e6:	0f be       	out	0x3f, r0	; 63
    43e8:	cd bf       	out	0x3d, r28	; 61
    43ea:	cf 91       	pop	r28
    43ec:	df 91       	pop	r29
    43ee:	08 95       	ret

000043f0 <vTaskSwitchContext>:

#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
    43f0:	df 93       	push	r29
    43f2:	cf 93       	push	r28
    43f4:	00 d0       	rcall	.+0      	; 0x43f6 <vTaskSwitchContext+0x6>
    43f6:	0f 92       	push	r0
    43f8:	cd b7       	in	r28, 0x3d	; 61
    43fa:	de b7       	in	r29, 0x3e	; 62
    if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
    43fc:	80 91 6d 08 	lds	r24, 0x086D
    4400:	88 23       	and	r24, r24
    4402:	21 f0       	breq	.+8      	; 0x440c <vTaskSwitchContext+0x1c>
    {
        /* The scheduler is currently suspended - do not allow a context
         * switch. */
        xYieldPending = pdTRUE;
    4404:	81 e0       	ldi	r24, 0x01	; 1
    4406:	80 93 66 08 	sts	0x0866, r24
    440a:	59 c0       	rjmp	.+178    	; 0x44be <vTaskSwitchContext+0xce>
    }
    else
    {
        xYieldPending = pdFALSE;
    440c:	10 92 66 08 	sts	0x0866, r1
            }
        #endif

        /* Select a new task to run using either the generic C or port
         * optimised asm code. */
        taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    4410:	80 91 62 08 	lds	r24, 0x0862
    4414:	8b 83       	std	Y+3, r24	; 0x03
    4416:	03 c0       	rjmp	.+6      	; 0x441e <vTaskSwitchContext+0x2e>
    4418:	8b 81       	ldd	r24, Y+3	; 0x03
    441a:	81 50       	subi	r24, 0x01	; 1
    441c:	8b 83       	std	Y+3, r24	; 0x03
    441e:	8b 81       	ldd	r24, Y+3	; 0x03
    4420:	28 2f       	mov	r18, r24
    4422:	30 e0       	ldi	r19, 0x00	; 0
    4424:	c9 01       	movw	r24, r18
    4426:	88 0f       	add	r24, r24
    4428:	99 1f       	adc	r25, r25
    442a:	88 0f       	add	r24, r24
    442c:	99 1f       	adc	r25, r25
    442e:	88 0f       	add	r24, r24
    4430:	99 1f       	adc	r25, r25
    4432:	82 0f       	add	r24, r18
    4434:	93 1f       	adc	r25, r19
    4436:	fc 01       	movw	r30, r24
    4438:	e2 59       	subi	r30, 0x92	; 146
    443a:	f7 4f       	sbci	r31, 0xF7	; 247
    443c:	80 81       	ld	r24, Z
    443e:	88 23       	and	r24, r24
    4440:	59 f3       	breq	.-42     	; 0x4418 <vTaskSwitchContext+0x28>
    4442:	8b 81       	ldd	r24, Y+3	; 0x03
    4444:	28 2f       	mov	r18, r24
    4446:	30 e0       	ldi	r19, 0x00	; 0
    4448:	c9 01       	movw	r24, r18
    444a:	88 0f       	add	r24, r24
    444c:	99 1f       	adc	r25, r25
    444e:	88 0f       	add	r24, r24
    4450:	99 1f       	adc	r25, r25
    4452:	88 0f       	add	r24, r24
    4454:	99 1f       	adc	r25, r25
    4456:	82 0f       	add	r24, r18
    4458:	93 1f       	adc	r25, r19
    445a:	82 59       	subi	r24, 0x92	; 146
    445c:	97 4f       	sbci	r25, 0xF7	; 247
    445e:	9a 83       	std	Y+2, r25	; 0x02
    4460:	89 83       	std	Y+1, r24	; 0x01
    4462:	e9 81       	ldd	r30, Y+1	; 0x01
    4464:	fa 81       	ldd	r31, Y+2	; 0x02
    4466:	01 80       	ldd	r0, Z+1	; 0x01
    4468:	f2 81       	ldd	r31, Z+2	; 0x02
    446a:	e0 2d       	mov	r30, r0
    446c:	82 81       	ldd	r24, Z+2	; 0x02
    446e:	93 81       	ldd	r25, Z+3	; 0x03
    4470:	e9 81       	ldd	r30, Y+1	; 0x01
    4472:	fa 81       	ldd	r31, Y+2	; 0x02
    4474:	92 83       	std	Z+2, r25	; 0x02
    4476:	81 83       	std	Z+1, r24	; 0x01
    4478:	e9 81       	ldd	r30, Y+1	; 0x01
    447a:	fa 81       	ldd	r31, Y+2	; 0x02
    447c:	21 81       	ldd	r18, Z+1	; 0x01
    447e:	32 81       	ldd	r19, Z+2	; 0x02
    4480:	89 81       	ldd	r24, Y+1	; 0x01
    4482:	9a 81       	ldd	r25, Y+2	; 0x02
    4484:	03 96       	adiw	r24, 0x03	; 3
    4486:	28 17       	cp	r18, r24
    4488:	39 07       	cpc	r19, r25
    448a:	59 f4       	brne	.+22     	; 0x44a2 <vTaskSwitchContext+0xb2>
    448c:	e9 81       	ldd	r30, Y+1	; 0x01
    448e:	fa 81       	ldd	r31, Y+2	; 0x02
    4490:	01 80       	ldd	r0, Z+1	; 0x01
    4492:	f2 81       	ldd	r31, Z+2	; 0x02
    4494:	e0 2d       	mov	r30, r0
    4496:	82 81       	ldd	r24, Z+2	; 0x02
    4498:	93 81       	ldd	r25, Z+3	; 0x03
    449a:	e9 81       	ldd	r30, Y+1	; 0x01
    449c:	fa 81       	ldd	r31, Y+2	; 0x02
    449e:	92 83       	std	Z+2, r25	; 0x02
    44a0:	81 83       	std	Z+1, r24	; 0x01
    44a2:	e9 81       	ldd	r30, Y+1	; 0x01
    44a4:	fa 81       	ldd	r31, Y+2	; 0x02
    44a6:	01 80       	ldd	r0, Z+1	; 0x01
    44a8:	f2 81       	ldd	r31, Z+2	; 0x02
    44aa:	e0 2d       	mov	r30, r0
    44ac:	86 81       	ldd	r24, Z+6	; 0x06
    44ae:	97 81       	ldd	r25, Z+7	; 0x07
    44b0:	90 93 5d 08 	sts	0x085D, r25
    44b4:	80 93 5c 08 	sts	0x085C, r24
    44b8:	8b 81       	ldd	r24, Y+3	; 0x03
    44ba:	80 93 62 08 	sts	0x0862, r24
                 * for additional information. */
                _impure_ptr = &( pxCurrentTCB->xNewLib_reent );
            }
        #endif /* configUSE_NEWLIB_REENTRANT */
    }
}
    44be:	0f 90       	pop	r0
    44c0:	0f 90       	pop	r0
    44c2:	0f 90       	pop	r0
    44c4:	cf 91       	pop	r28
    44c6:	df 91       	pop	r29
    44c8:	08 95       	ret

000044ca <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList,
                            const TickType_t xTicksToWait )
{
    44ca:	df 93       	push	r29
    44cc:	cf 93       	push	r28
    44ce:	00 d0       	rcall	.+0      	; 0x44d0 <vTaskPlaceOnEventList+0x6>
    44d0:	00 d0       	rcall	.+0      	; 0x44d2 <vTaskPlaceOnEventList+0x8>
    44d2:	cd b7       	in	r28, 0x3d	; 61
    44d4:	de b7       	in	r29, 0x3e	; 62
    44d6:	9a 83       	std	Y+2, r25	; 0x02
    44d8:	89 83       	std	Y+1, r24	; 0x01
    44da:	7c 83       	std	Y+4, r23	; 0x04
    44dc:	6b 83       	std	Y+3, r22	; 0x03
     *      xItemValue = ( configMAX_PRIORITIES - uxPriority )
     * Therefore, the event list is sorted in descending priority order.
     *
     * The queue that contains the event list is locked, preventing
     * simultaneous access from interrupts. */
    vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    44de:	80 91 5c 08 	lds	r24, 0x085C
    44e2:	90 91 5d 08 	lds	r25, 0x085D
    44e6:	9c 01       	movw	r18, r24
    44e8:	24 5f       	subi	r18, 0xF4	; 244
    44ea:	3f 4f       	sbci	r19, 0xFF	; 255
    44ec:	89 81       	ldd	r24, Y+1	; 0x01
    44ee:	9a 81       	ldd	r25, Y+2	; 0x02
    44f0:	b9 01       	movw	r22, r18
    44f2:	0e 94 29 11 	call	0x2252	; 0x2252 <vListInsert>

    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    44f6:	8b 81       	ldd	r24, Y+3	; 0x03
    44f8:	9c 81       	ldd	r25, Y+4	; 0x04
    44fa:	61 e0       	ldi	r22, 0x01	; 1
    44fc:	0e 94 c1 2e 	call	0x5d82	; 0x5d82 <prvAddCurrentTaskToDelayedList>
}
    4500:	0f 90       	pop	r0
    4502:	0f 90       	pop	r0
    4504:	0f 90       	pop	r0
    4506:	0f 90       	pop	r0
    4508:	cf 91       	pop	r28
    450a:	df 91       	pop	r29
    450c:	08 95       	ret

0000450e <vTaskPlaceOnUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnUnorderedEventList( List_t * pxEventList,
                                     const TickType_t xItemValue,
                                     const TickType_t xTicksToWait )
{
    450e:	df 93       	push	r29
    4510:	cf 93       	push	r28
    4512:	cd b7       	in	r28, 0x3d	; 61
    4514:	de b7       	in	r29, 0x3e	; 62
    4516:	28 97       	sbiw	r28, 0x08	; 8
    4518:	0f b6       	in	r0, 0x3f	; 63
    451a:	f8 94       	cli
    451c:	de bf       	out	0x3e, r29	; 62
    451e:	0f be       	out	0x3f, r0	; 63
    4520:	cd bf       	out	0x3d, r28	; 61
    4522:	9c 83       	std	Y+4, r25	; 0x04
    4524:	8b 83       	std	Y+3, r24	; 0x03
    4526:	7e 83       	std	Y+6, r23	; 0x06
    4528:	6d 83       	std	Y+5, r22	; 0x05
    452a:	58 87       	std	Y+8, r21	; 0x08
    452c:	4f 83       	std	Y+7, r20	; 0x07
    configASSERT( uxSchedulerSuspended != 0 );

    /* Store the item value in the event list item.  It is safe to access the
     * event list item here as interrupts won't access the event list item of a
     * task that is not in the Blocked state. */
    listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    452e:	e0 91 5c 08 	lds	r30, 0x085C
    4532:	f0 91 5d 08 	lds	r31, 0x085D
    4536:	8d 81       	ldd	r24, Y+5	; 0x05
    4538:	9e 81       	ldd	r25, Y+6	; 0x06
    453a:	90 68       	ori	r25, 0x80	; 128
    453c:	95 87       	std	Z+13, r25	; 0x0d
    453e:	84 87       	std	Z+12, r24	; 0x0c
    /* Place the event list item of the TCB at the end of the appropriate event
     * list.  It is safe to access the event list here because it is part of an
     * event group implementation - and interrupts don't access event groups
     * directly (instead they access them indirectly by pending function calls to
     * the task level). */
    listINSERT_END( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    4540:	eb 81       	ldd	r30, Y+3	; 0x03
    4542:	fc 81       	ldd	r31, Y+4	; 0x04
    4544:	81 81       	ldd	r24, Z+1	; 0x01
    4546:	92 81       	ldd	r25, Z+2	; 0x02
    4548:	9a 83       	std	Y+2, r25	; 0x02
    454a:	89 83       	std	Y+1, r24	; 0x01
    454c:	e0 91 5c 08 	lds	r30, 0x085C
    4550:	f0 91 5d 08 	lds	r31, 0x085D
    4554:	89 81       	ldd	r24, Y+1	; 0x01
    4556:	9a 81       	ldd	r25, Y+2	; 0x02
    4558:	97 87       	std	Z+15, r25	; 0x0f
    455a:	86 87       	std	Z+14, r24	; 0x0e
    455c:	a0 91 5c 08 	lds	r26, 0x085C
    4560:	b0 91 5d 08 	lds	r27, 0x085D
    4564:	e9 81       	ldd	r30, Y+1	; 0x01
    4566:	fa 81       	ldd	r31, Y+2	; 0x02
    4568:	84 81       	ldd	r24, Z+4	; 0x04
    456a:	95 81       	ldd	r25, Z+5	; 0x05
    456c:	51 96       	adiw	r26, 0x11	; 17
    456e:	9c 93       	st	X, r25
    4570:	8e 93       	st	-X, r24
    4572:	50 97       	sbiw	r26, 0x10	; 16
    4574:	e9 81       	ldd	r30, Y+1	; 0x01
    4576:	fa 81       	ldd	r31, Y+2	; 0x02
    4578:	04 80       	ldd	r0, Z+4	; 0x04
    457a:	f5 81       	ldd	r31, Z+5	; 0x05
    457c:	e0 2d       	mov	r30, r0
    457e:	80 91 5c 08 	lds	r24, 0x085C
    4582:	90 91 5d 08 	lds	r25, 0x085D
    4586:	0c 96       	adiw	r24, 0x0c	; 12
    4588:	93 83       	std	Z+3, r25	; 0x03
    458a:	82 83       	std	Z+2, r24	; 0x02
    458c:	80 91 5c 08 	lds	r24, 0x085C
    4590:	90 91 5d 08 	lds	r25, 0x085D
    4594:	0c 96       	adiw	r24, 0x0c	; 12
    4596:	e9 81       	ldd	r30, Y+1	; 0x01
    4598:	fa 81       	ldd	r31, Y+2	; 0x02
    459a:	95 83       	std	Z+5, r25	; 0x05
    459c:	84 83       	std	Z+4, r24	; 0x04
    459e:	e0 91 5c 08 	lds	r30, 0x085C
    45a2:	f0 91 5d 08 	lds	r31, 0x085D
    45a6:	8b 81       	ldd	r24, Y+3	; 0x03
    45a8:	9c 81       	ldd	r25, Y+4	; 0x04
    45aa:	95 8b       	std	Z+21, r25	; 0x15
    45ac:	84 8b       	std	Z+20, r24	; 0x14
    45ae:	eb 81       	ldd	r30, Y+3	; 0x03
    45b0:	fc 81       	ldd	r31, Y+4	; 0x04
    45b2:	80 81       	ld	r24, Z
    45b4:	8f 5f       	subi	r24, 0xFF	; 255
    45b6:	eb 81       	ldd	r30, Y+3	; 0x03
    45b8:	fc 81       	ldd	r31, Y+4	; 0x04
    45ba:	80 83       	st	Z, r24

    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    45bc:	8f 81       	ldd	r24, Y+7	; 0x07
    45be:	98 85       	ldd	r25, Y+8	; 0x08
    45c0:	61 e0       	ldi	r22, 0x01	; 1
    45c2:	0e 94 c1 2e 	call	0x5d82	; 0x5d82 <prvAddCurrentTaskToDelayedList>
}
    45c6:	28 96       	adiw	r28, 0x08	; 8
    45c8:	0f b6       	in	r0, 0x3f	; 63
    45ca:	f8 94       	cli
    45cc:	de bf       	out	0x3e, r29	; 62
    45ce:	0f be       	out	0x3f, r0	; 63
    45d0:	cd bf       	out	0x3d, r28	; 61
    45d2:	cf 91       	pop	r28
    45d4:	df 91       	pop	r29
    45d6:	08 95       	ret

000045d8 <vTaskPlaceOnEventListRestricted>:
#if ( configUSE_TIMERS == 1 )

    void vTaskPlaceOnEventListRestricted( List_t * const pxEventList,
                                          TickType_t xTicksToWait,
                                          const BaseType_t xWaitIndefinitely )
    {
    45d8:	df 93       	push	r29
    45da:	cf 93       	push	r28
    45dc:	cd b7       	in	r28, 0x3d	; 61
    45de:	de b7       	in	r29, 0x3e	; 62
    45e0:	27 97       	sbiw	r28, 0x07	; 7
    45e2:	0f b6       	in	r0, 0x3f	; 63
    45e4:	f8 94       	cli
    45e6:	de bf       	out	0x3e, r29	; 62
    45e8:	0f be       	out	0x3f, r0	; 63
    45ea:	cd bf       	out	0x3d, r28	; 61
    45ec:	9c 83       	std	Y+4, r25	; 0x04
    45ee:	8b 83       	std	Y+3, r24	; 0x03
    45f0:	7e 83       	std	Y+6, r23	; 0x06
    45f2:	6d 83       	std	Y+5, r22	; 0x05
    45f4:	4f 83       	std	Y+7, r20	; 0x07

        /* Place the event list item of the TCB in the appropriate event list.
         * In this case it is assume that this is the only task that is going to
         * be waiting on this event list, so the faster vListInsertEnd() function
         * can be used in place of vListInsert. */
        listINSERT_END( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    45f6:	eb 81       	ldd	r30, Y+3	; 0x03
    45f8:	fc 81       	ldd	r31, Y+4	; 0x04
    45fa:	81 81       	ldd	r24, Z+1	; 0x01
    45fc:	92 81       	ldd	r25, Z+2	; 0x02
    45fe:	9a 83       	std	Y+2, r25	; 0x02
    4600:	89 83       	std	Y+1, r24	; 0x01
    4602:	e0 91 5c 08 	lds	r30, 0x085C
    4606:	f0 91 5d 08 	lds	r31, 0x085D
    460a:	89 81       	ldd	r24, Y+1	; 0x01
    460c:	9a 81       	ldd	r25, Y+2	; 0x02
    460e:	97 87       	std	Z+15, r25	; 0x0f
    4610:	86 87       	std	Z+14, r24	; 0x0e
    4612:	a0 91 5c 08 	lds	r26, 0x085C
    4616:	b0 91 5d 08 	lds	r27, 0x085D
    461a:	e9 81       	ldd	r30, Y+1	; 0x01
    461c:	fa 81       	ldd	r31, Y+2	; 0x02
    461e:	84 81       	ldd	r24, Z+4	; 0x04
    4620:	95 81       	ldd	r25, Z+5	; 0x05
    4622:	51 96       	adiw	r26, 0x11	; 17
    4624:	9c 93       	st	X, r25
    4626:	8e 93       	st	-X, r24
    4628:	50 97       	sbiw	r26, 0x10	; 16
    462a:	e9 81       	ldd	r30, Y+1	; 0x01
    462c:	fa 81       	ldd	r31, Y+2	; 0x02
    462e:	04 80       	ldd	r0, Z+4	; 0x04
    4630:	f5 81       	ldd	r31, Z+5	; 0x05
    4632:	e0 2d       	mov	r30, r0
    4634:	80 91 5c 08 	lds	r24, 0x085C
    4638:	90 91 5d 08 	lds	r25, 0x085D
    463c:	0c 96       	adiw	r24, 0x0c	; 12
    463e:	93 83       	std	Z+3, r25	; 0x03
    4640:	82 83       	std	Z+2, r24	; 0x02
    4642:	80 91 5c 08 	lds	r24, 0x085C
    4646:	90 91 5d 08 	lds	r25, 0x085D
    464a:	0c 96       	adiw	r24, 0x0c	; 12
    464c:	e9 81       	ldd	r30, Y+1	; 0x01
    464e:	fa 81       	ldd	r31, Y+2	; 0x02
    4650:	95 83       	std	Z+5, r25	; 0x05
    4652:	84 83       	std	Z+4, r24	; 0x04
    4654:	e0 91 5c 08 	lds	r30, 0x085C
    4658:	f0 91 5d 08 	lds	r31, 0x085D
    465c:	8b 81       	ldd	r24, Y+3	; 0x03
    465e:	9c 81       	ldd	r25, Y+4	; 0x04
    4660:	95 8b       	std	Z+21, r25	; 0x15
    4662:	84 8b       	std	Z+20, r24	; 0x14
    4664:	eb 81       	ldd	r30, Y+3	; 0x03
    4666:	fc 81       	ldd	r31, Y+4	; 0x04
    4668:	80 81       	ld	r24, Z
    466a:	8f 5f       	subi	r24, 0xFF	; 255
    466c:	eb 81       	ldd	r30, Y+3	; 0x03
    466e:	fc 81       	ldd	r31, Y+4	; 0x04
    4670:	80 83       	st	Z, r24

        /* If the task should block indefinitely then set the block time to a
         * value that will be recognised as an indefinite delay inside the
         * prvAddCurrentTaskToDelayedList() function. */
        if( xWaitIndefinitely != pdFALSE )
    4672:	8f 81       	ldd	r24, Y+7	; 0x07
    4674:	88 23       	and	r24, r24
    4676:	21 f0       	breq	.+8      	; 0x4680 <vTaskPlaceOnEventListRestricted+0xa8>
        {
            xTicksToWait = portMAX_DELAY;
    4678:	8f ef       	ldi	r24, 0xFF	; 255
    467a:	9f ef       	ldi	r25, 0xFF	; 255
    467c:	9e 83       	std	Y+6, r25	; 0x06
    467e:	8d 83       	std	Y+5, r24	; 0x05
        }

        traceTASK_DELAY_UNTIL( ( xTickCount + xTicksToWait ) );
        prvAddCurrentTaskToDelayedList( xTicksToWait, xWaitIndefinitely );
    4680:	8d 81       	ldd	r24, Y+5	; 0x05
    4682:	9e 81       	ldd	r25, Y+6	; 0x06
    4684:	6f 81       	ldd	r22, Y+7	; 0x07
    4686:	0e 94 c1 2e 	call	0x5d82	; 0x5d82 <prvAddCurrentTaskToDelayedList>
    }
    468a:	27 96       	adiw	r28, 0x07	; 7
    468c:	0f b6       	in	r0, 0x3f	; 63
    468e:	f8 94       	cli
    4690:	de bf       	out	0x3e, r29	; 62
    4692:	0f be       	out	0x3f, r0	; 63
    4694:	cd bf       	out	0x3d, r28	; 61
    4696:	cf 91       	pop	r28
    4698:	df 91       	pop	r29
    469a:	08 95       	ret

0000469c <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
    469c:	df 93       	push	r29
    469e:	cf 93       	push	r28
    46a0:	cd b7       	in	r28, 0x3d	; 61
    46a2:	de b7       	in	r29, 0x3e	; 62
    46a4:	2d 97       	sbiw	r28, 0x0d	; 13
    46a6:	0f b6       	in	r0, 0x3f	; 63
    46a8:	f8 94       	cli
    46aa:	de bf       	out	0x3e, r29	; 62
    46ac:	0f be       	out	0x3f, r0	; 63
    46ae:	cd bf       	out	0x3d, r28	; 61
    46b0:	9d 87       	std	Y+13, r25	; 0x0d
    46b2:	8c 87       	std	Y+12, r24	; 0x0c
     * get called - the lock count on the queue will get modified instead.  This
     * means exclusive access to the event list is guaranteed here.
     *
     * This function assumes that a check has already been made to ensure that
     * pxEventList is not empty. */
    pxUnblockedTCB = listGET_OWNER_OF_HEAD_ENTRY( pxEventList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    46b4:	ec 85       	ldd	r30, Y+12	; 0x0c
    46b6:	fd 85       	ldd	r31, Y+13	; 0x0d
    46b8:	05 80       	ldd	r0, Z+5	; 0x05
    46ba:	f6 81       	ldd	r31, Z+6	; 0x06
    46bc:	e0 2d       	mov	r30, r0
    46be:	86 81       	ldd	r24, Z+6	; 0x06
    46c0:	97 81       	ldd	r25, Z+7	; 0x07
    46c2:	9b 87       	std	Y+11, r25	; 0x0b
    46c4:	8a 87       	std	Y+10, r24	; 0x0a
    configASSERT( pxUnblockedTCB );
    listREMOVE_ITEM( &( pxUnblockedTCB->xEventListItem ) );
    46c6:	ea 85       	ldd	r30, Y+10	; 0x0a
    46c8:	fb 85       	ldd	r31, Y+11	; 0x0b
    46ca:	84 89       	ldd	r24, Z+20	; 0x14
    46cc:	95 89       	ldd	r25, Z+21	; 0x15
    46ce:	98 87       	std	Y+8, r25	; 0x08
    46d0:	8f 83       	std	Y+7, r24	; 0x07
    46d2:	ea 85       	ldd	r30, Y+10	; 0x0a
    46d4:	fb 85       	ldd	r31, Y+11	; 0x0b
    46d6:	a6 85       	ldd	r26, Z+14	; 0x0e
    46d8:	b7 85       	ldd	r27, Z+15	; 0x0f
    46da:	ea 85       	ldd	r30, Y+10	; 0x0a
    46dc:	fb 85       	ldd	r31, Y+11	; 0x0b
    46de:	80 89       	ldd	r24, Z+16	; 0x10
    46e0:	91 89       	ldd	r25, Z+17	; 0x11
    46e2:	15 96       	adiw	r26, 0x05	; 5
    46e4:	9c 93       	st	X, r25
    46e6:	8e 93       	st	-X, r24
    46e8:	14 97       	sbiw	r26, 0x04	; 4
    46ea:	ea 85       	ldd	r30, Y+10	; 0x0a
    46ec:	fb 85       	ldd	r31, Y+11	; 0x0b
    46ee:	a0 89       	ldd	r26, Z+16	; 0x10
    46f0:	b1 89       	ldd	r27, Z+17	; 0x11
    46f2:	ea 85       	ldd	r30, Y+10	; 0x0a
    46f4:	fb 85       	ldd	r31, Y+11	; 0x0b
    46f6:	86 85       	ldd	r24, Z+14	; 0x0e
    46f8:	97 85       	ldd	r25, Z+15	; 0x0f
    46fa:	13 96       	adiw	r26, 0x03	; 3
    46fc:	9c 93       	st	X, r25
    46fe:	8e 93       	st	-X, r24
    4700:	12 97       	sbiw	r26, 0x02	; 2
    4702:	ef 81       	ldd	r30, Y+7	; 0x07
    4704:	f8 85       	ldd	r31, Y+8	; 0x08
    4706:	21 81       	ldd	r18, Z+1	; 0x01
    4708:	32 81       	ldd	r19, Z+2	; 0x02
    470a:	8a 85       	ldd	r24, Y+10	; 0x0a
    470c:	9b 85       	ldd	r25, Y+11	; 0x0b
    470e:	0c 96       	adiw	r24, 0x0c	; 12
    4710:	28 17       	cp	r18, r24
    4712:	39 07       	cpc	r19, r25
    4714:	41 f4       	brne	.+16     	; 0x4726 <xTaskRemoveFromEventList+0x8a>
    4716:	ea 85       	ldd	r30, Y+10	; 0x0a
    4718:	fb 85       	ldd	r31, Y+11	; 0x0b
    471a:	80 89       	ldd	r24, Z+16	; 0x10
    471c:	91 89       	ldd	r25, Z+17	; 0x11
    471e:	ef 81       	ldd	r30, Y+7	; 0x07
    4720:	f8 85       	ldd	r31, Y+8	; 0x08
    4722:	92 83       	std	Z+2, r25	; 0x02
    4724:	81 83       	std	Z+1, r24	; 0x01
    4726:	ea 85       	ldd	r30, Y+10	; 0x0a
    4728:	fb 85       	ldd	r31, Y+11	; 0x0b
    472a:	15 8a       	std	Z+21, r1	; 0x15
    472c:	14 8a       	std	Z+20, r1	; 0x14
    472e:	ef 81       	ldd	r30, Y+7	; 0x07
    4730:	f8 85       	ldd	r31, Y+8	; 0x08
    4732:	80 81       	ld	r24, Z
    4734:	81 50       	subi	r24, 0x01	; 1
    4736:	ef 81       	ldd	r30, Y+7	; 0x07
    4738:	f8 85       	ldd	r31, Y+8	; 0x08
    473a:	80 83       	st	Z, r24

    if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    473c:	80 91 6d 08 	lds	r24, 0x086D
    4740:	88 23       	and	r24, r24
    4742:	09 f0       	breq	.+2      	; 0x4746 <xTaskRemoveFromEventList+0xaa>
    4744:	a4 c0       	rjmp	.+328    	; 0x488e <xTaskRemoveFromEventList+0x1f2>
    {
        listREMOVE_ITEM( &( pxUnblockedTCB->xStateListItem ) );
    4746:	ea 85       	ldd	r30, Y+10	; 0x0a
    4748:	fb 85       	ldd	r31, Y+11	; 0x0b
    474a:	82 85       	ldd	r24, Z+10	; 0x0a
    474c:	93 85       	ldd	r25, Z+11	; 0x0b
    474e:	9e 83       	std	Y+6, r25	; 0x06
    4750:	8d 83       	std	Y+5, r24	; 0x05
    4752:	ea 85       	ldd	r30, Y+10	; 0x0a
    4754:	fb 85       	ldd	r31, Y+11	; 0x0b
    4756:	a4 81       	ldd	r26, Z+4	; 0x04
    4758:	b5 81       	ldd	r27, Z+5	; 0x05
    475a:	ea 85       	ldd	r30, Y+10	; 0x0a
    475c:	fb 85       	ldd	r31, Y+11	; 0x0b
    475e:	86 81       	ldd	r24, Z+6	; 0x06
    4760:	97 81       	ldd	r25, Z+7	; 0x07
    4762:	15 96       	adiw	r26, 0x05	; 5
    4764:	9c 93       	st	X, r25
    4766:	8e 93       	st	-X, r24
    4768:	14 97       	sbiw	r26, 0x04	; 4
    476a:	ea 85       	ldd	r30, Y+10	; 0x0a
    476c:	fb 85       	ldd	r31, Y+11	; 0x0b
    476e:	a6 81       	ldd	r26, Z+6	; 0x06
    4770:	b7 81       	ldd	r27, Z+7	; 0x07
    4772:	ea 85       	ldd	r30, Y+10	; 0x0a
    4774:	fb 85       	ldd	r31, Y+11	; 0x0b
    4776:	84 81       	ldd	r24, Z+4	; 0x04
    4778:	95 81       	ldd	r25, Z+5	; 0x05
    477a:	13 96       	adiw	r26, 0x03	; 3
    477c:	9c 93       	st	X, r25
    477e:	8e 93       	st	-X, r24
    4780:	12 97       	sbiw	r26, 0x02	; 2
    4782:	ed 81       	ldd	r30, Y+5	; 0x05
    4784:	fe 81       	ldd	r31, Y+6	; 0x06
    4786:	21 81       	ldd	r18, Z+1	; 0x01
    4788:	32 81       	ldd	r19, Z+2	; 0x02
    478a:	8a 85       	ldd	r24, Y+10	; 0x0a
    478c:	9b 85       	ldd	r25, Y+11	; 0x0b
    478e:	02 96       	adiw	r24, 0x02	; 2
    4790:	28 17       	cp	r18, r24
    4792:	39 07       	cpc	r19, r25
    4794:	41 f4       	brne	.+16     	; 0x47a6 <xTaskRemoveFromEventList+0x10a>
    4796:	ea 85       	ldd	r30, Y+10	; 0x0a
    4798:	fb 85       	ldd	r31, Y+11	; 0x0b
    479a:	86 81       	ldd	r24, Z+6	; 0x06
    479c:	97 81       	ldd	r25, Z+7	; 0x07
    479e:	ed 81       	ldd	r30, Y+5	; 0x05
    47a0:	fe 81       	ldd	r31, Y+6	; 0x06
    47a2:	92 83       	std	Z+2, r25	; 0x02
    47a4:	81 83       	std	Z+1, r24	; 0x01
    47a6:	ea 85       	ldd	r30, Y+10	; 0x0a
    47a8:	fb 85       	ldd	r31, Y+11	; 0x0b
    47aa:	13 86       	std	Z+11, r1	; 0x0b
    47ac:	12 86       	std	Z+10, r1	; 0x0a
    47ae:	ed 81       	ldd	r30, Y+5	; 0x05
    47b0:	fe 81       	ldd	r31, Y+6	; 0x06
    47b2:	80 81       	ld	r24, Z
    47b4:	81 50       	subi	r24, 0x01	; 1
    47b6:	ed 81       	ldd	r30, Y+5	; 0x05
    47b8:	fe 81       	ldd	r31, Y+6	; 0x06
    47ba:	80 83       	st	Z, r24
        prvAddTaskToReadyList( pxUnblockedTCB );
    47bc:	ea 85       	ldd	r30, Y+10	; 0x0a
    47be:	fb 85       	ldd	r31, Y+11	; 0x0b
    47c0:	96 89       	ldd	r25, Z+22	; 0x16
    47c2:	80 91 62 08 	lds	r24, 0x0862
    47c6:	89 17       	cp	r24, r25
    47c8:	28 f4       	brcc	.+10     	; 0x47d4 <xTaskRemoveFromEventList+0x138>
    47ca:	ea 85       	ldd	r30, Y+10	; 0x0a
    47cc:	fb 85       	ldd	r31, Y+11	; 0x0b
    47ce:	86 89       	ldd	r24, Z+22	; 0x16
    47d0:	80 93 62 08 	sts	0x0862, r24
    47d4:	ea 85       	ldd	r30, Y+10	; 0x0a
    47d6:	fb 85       	ldd	r31, Y+11	; 0x0b
    47d8:	86 89       	ldd	r24, Z+22	; 0x16
    47da:	28 2f       	mov	r18, r24
    47dc:	30 e0       	ldi	r19, 0x00	; 0
    47de:	c9 01       	movw	r24, r18
    47e0:	88 0f       	add	r24, r24
    47e2:	99 1f       	adc	r25, r25
    47e4:	88 0f       	add	r24, r24
    47e6:	99 1f       	adc	r25, r25
    47e8:	88 0f       	add	r24, r24
    47ea:	99 1f       	adc	r25, r25
    47ec:	82 0f       	add	r24, r18
    47ee:	93 1f       	adc	r25, r19
    47f0:	fc 01       	movw	r30, r24
    47f2:	e2 59       	subi	r30, 0x92	; 146
    47f4:	f7 4f       	sbci	r31, 0xF7	; 247
    47f6:	81 81       	ldd	r24, Z+1	; 0x01
    47f8:	92 81       	ldd	r25, Z+2	; 0x02
    47fa:	9c 83       	std	Y+4, r25	; 0x04
    47fc:	8b 83       	std	Y+3, r24	; 0x03
    47fe:	ea 85       	ldd	r30, Y+10	; 0x0a
    4800:	fb 85       	ldd	r31, Y+11	; 0x0b
    4802:	8b 81       	ldd	r24, Y+3	; 0x03
    4804:	9c 81       	ldd	r25, Y+4	; 0x04
    4806:	95 83       	std	Z+5, r25	; 0x05
    4808:	84 83       	std	Z+4, r24	; 0x04
    480a:	eb 81       	ldd	r30, Y+3	; 0x03
    480c:	fc 81       	ldd	r31, Y+4	; 0x04
    480e:	84 81       	ldd	r24, Z+4	; 0x04
    4810:	95 81       	ldd	r25, Z+5	; 0x05
    4812:	ea 85       	ldd	r30, Y+10	; 0x0a
    4814:	fb 85       	ldd	r31, Y+11	; 0x0b
    4816:	97 83       	std	Z+7, r25	; 0x07
    4818:	86 83       	std	Z+6, r24	; 0x06
    481a:	eb 81       	ldd	r30, Y+3	; 0x03
    481c:	fc 81       	ldd	r31, Y+4	; 0x04
    481e:	04 80       	ldd	r0, Z+4	; 0x04
    4820:	f5 81       	ldd	r31, Z+5	; 0x05
    4822:	e0 2d       	mov	r30, r0
    4824:	8a 85       	ldd	r24, Y+10	; 0x0a
    4826:	9b 85       	ldd	r25, Y+11	; 0x0b
    4828:	02 96       	adiw	r24, 0x02	; 2
    482a:	93 83       	std	Z+3, r25	; 0x03
    482c:	82 83       	std	Z+2, r24	; 0x02
    482e:	8a 85       	ldd	r24, Y+10	; 0x0a
    4830:	9b 85       	ldd	r25, Y+11	; 0x0b
    4832:	02 96       	adiw	r24, 0x02	; 2
    4834:	eb 81       	ldd	r30, Y+3	; 0x03
    4836:	fc 81       	ldd	r31, Y+4	; 0x04
    4838:	95 83       	std	Z+5, r25	; 0x05
    483a:	84 83       	std	Z+4, r24	; 0x04
    483c:	ea 85       	ldd	r30, Y+10	; 0x0a
    483e:	fb 85       	ldd	r31, Y+11	; 0x0b
    4840:	86 89       	ldd	r24, Z+22	; 0x16
    4842:	28 2f       	mov	r18, r24
    4844:	30 e0       	ldi	r19, 0x00	; 0
    4846:	c9 01       	movw	r24, r18
    4848:	88 0f       	add	r24, r24
    484a:	99 1f       	adc	r25, r25
    484c:	88 0f       	add	r24, r24
    484e:	99 1f       	adc	r25, r25
    4850:	88 0f       	add	r24, r24
    4852:	99 1f       	adc	r25, r25
    4854:	82 0f       	add	r24, r18
    4856:	93 1f       	adc	r25, r19
    4858:	82 59       	subi	r24, 0x92	; 146
    485a:	97 4f       	sbci	r25, 0xF7	; 247
    485c:	ea 85       	ldd	r30, Y+10	; 0x0a
    485e:	fb 85       	ldd	r31, Y+11	; 0x0b
    4860:	93 87       	std	Z+11, r25	; 0x0b
    4862:	82 87       	std	Z+10, r24	; 0x0a
    4864:	ea 85       	ldd	r30, Y+10	; 0x0a
    4866:	fb 85       	ldd	r31, Y+11	; 0x0b
    4868:	86 89       	ldd	r24, Z+22	; 0x16
    486a:	28 2f       	mov	r18, r24
    486c:	30 e0       	ldi	r19, 0x00	; 0
    486e:	c9 01       	movw	r24, r18
    4870:	88 0f       	add	r24, r24
    4872:	99 1f       	adc	r25, r25
    4874:	88 0f       	add	r24, r24
    4876:	99 1f       	adc	r25, r25
    4878:	88 0f       	add	r24, r24
    487a:	99 1f       	adc	r25, r25
    487c:	82 0f       	add	r24, r18
    487e:	93 1f       	adc	r25, r19
    4880:	fc 01       	movw	r30, r24
    4882:	e2 59       	subi	r30, 0x92	; 146
    4884:	f7 4f       	sbci	r31, 0xF7	; 247
    4886:	80 81       	ld	r24, Z
    4888:	8f 5f       	subi	r24, 0xFF	; 255
    488a:	80 83       	st	Z, r24
    488c:	30 c0       	rjmp	.+96     	; 0x48ee <xTaskRemoveFromEventList+0x252>
    }
    else
    {
        /* The delayed and ready lists cannot be accessed, so hold this task
         * pending until the scheduler is resumed. */
        listINSERT_END( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    488e:	80 91 a9 08 	lds	r24, 0x08A9
    4892:	90 91 aa 08 	lds	r25, 0x08AA
    4896:	9a 83       	std	Y+2, r25	; 0x02
    4898:	89 83       	std	Y+1, r24	; 0x01
    489a:	ea 85       	ldd	r30, Y+10	; 0x0a
    489c:	fb 85       	ldd	r31, Y+11	; 0x0b
    489e:	89 81       	ldd	r24, Y+1	; 0x01
    48a0:	9a 81       	ldd	r25, Y+2	; 0x02
    48a2:	97 87       	std	Z+15, r25	; 0x0f
    48a4:	86 87       	std	Z+14, r24	; 0x0e
    48a6:	e9 81       	ldd	r30, Y+1	; 0x01
    48a8:	fa 81       	ldd	r31, Y+2	; 0x02
    48aa:	84 81       	ldd	r24, Z+4	; 0x04
    48ac:	95 81       	ldd	r25, Z+5	; 0x05
    48ae:	ea 85       	ldd	r30, Y+10	; 0x0a
    48b0:	fb 85       	ldd	r31, Y+11	; 0x0b
    48b2:	91 8b       	std	Z+17, r25	; 0x11
    48b4:	80 8b       	std	Z+16, r24	; 0x10
    48b6:	e9 81       	ldd	r30, Y+1	; 0x01
    48b8:	fa 81       	ldd	r31, Y+2	; 0x02
    48ba:	04 80       	ldd	r0, Z+4	; 0x04
    48bc:	f5 81       	ldd	r31, Z+5	; 0x05
    48be:	e0 2d       	mov	r30, r0
    48c0:	8a 85       	ldd	r24, Y+10	; 0x0a
    48c2:	9b 85       	ldd	r25, Y+11	; 0x0b
    48c4:	0c 96       	adiw	r24, 0x0c	; 12
    48c6:	93 83       	std	Z+3, r25	; 0x03
    48c8:	82 83       	std	Z+2, r24	; 0x02
    48ca:	8a 85       	ldd	r24, Y+10	; 0x0a
    48cc:	9b 85       	ldd	r25, Y+11	; 0x0b
    48ce:	0c 96       	adiw	r24, 0x0c	; 12
    48d0:	e9 81       	ldd	r30, Y+1	; 0x01
    48d2:	fa 81       	ldd	r31, Y+2	; 0x02
    48d4:	95 83       	std	Z+5, r25	; 0x05
    48d6:	84 83       	std	Z+4, r24	; 0x04
    48d8:	ea 85       	ldd	r30, Y+10	; 0x0a
    48da:	fb 85       	ldd	r31, Y+11	; 0x0b
    48dc:	88 ea       	ldi	r24, 0xA8	; 168
    48de:	98 e0       	ldi	r25, 0x08	; 8
    48e0:	95 8b       	std	Z+21, r25	; 0x15
    48e2:	84 8b       	std	Z+20, r24	; 0x14
    48e4:	80 91 a8 08 	lds	r24, 0x08A8
    48e8:	8f 5f       	subi	r24, 0xFF	; 255
    48ea:	80 93 a8 08 	sts	0x08A8, r24
    }

    if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    48ee:	ea 85       	ldd	r30, Y+10	; 0x0a
    48f0:	fb 85       	ldd	r31, Y+11	; 0x0b
    48f2:	96 89       	ldd	r25, Z+22	; 0x16
    48f4:	e0 91 5c 08 	lds	r30, 0x085C
    48f8:	f0 91 5d 08 	lds	r31, 0x085D
    48fc:	86 89       	ldd	r24, Z+22	; 0x16
    48fe:	89 17       	cp	r24, r25
    4900:	30 f4       	brcc	.+12     	; 0x490e <xTaskRemoveFromEventList+0x272>
    {
        /* Return true if the task removed from the event list has a higher
         * priority than the calling task.  This allows the calling task to know if
         * it should force a context switch now. */
        xReturn = pdTRUE;
    4902:	81 e0       	ldi	r24, 0x01	; 1
    4904:	89 87       	std	Y+9, r24	; 0x09

        /* Mark that a yield is pending in case the user is not using the
         * "xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
        xYieldPending = pdTRUE;
    4906:	81 e0       	ldi	r24, 0x01	; 1
    4908:	80 93 66 08 	sts	0x0866, r24
    490c:	01 c0       	rjmp	.+2      	; 0x4910 <xTaskRemoveFromEventList+0x274>
    }
    else
    {
        xReturn = pdFALSE;
    490e:	19 86       	std	Y+9, r1	; 0x09
    }

    return xReturn;
    4910:	89 85       	ldd	r24, Y+9	; 0x09
}
    4912:	2d 96       	adiw	r28, 0x0d	; 13
    4914:	0f b6       	in	r0, 0x3f	; 63
    4916:	f8 94       	cli
    4918:	de bf       	out	0x3e, r29	; 62
    491a:	0f be       	out	0x3f, r0	; 63
    491c:	cd bf       	out	0x3d, r28	; 61
    491e:	cf 91       	pop	r28
    4920:	df 91       	pop	r29
    4922:	08 95       	ret

00004924 <vTaskRemoveFromUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem,
                                        const TickType_t xItemValue )
{
    4924:	df 93       	push	r29
    4926:	cf 93       	push	r28
    4928:	cd b7       	in	r28, 0x3d	; 61
    492a:	de b7       	in	r29, 0x3e	; 62
    492c:	2c 97       	sbiw	r28, 0x0c	; 12
    492e:	0f b6       	in	r0, 0x3f	; 63
    4930:	f8 94       	cli
    4932:	de bf       	out	0x3e, r29	; 62
    4934:	0f be       	out	0x3f, r0	; 63
    4936:	cd bf       	out	0x3d, r28	; 61
    4938:	9a 87       	std	Y+10, r25	; 0x0a
    493a:	89 87       	std	Y+9, r24	; 0x09
    493c:	7c 87       	std	Y+12, r23	; 0x0c
    493e:	6b 87       	std	Y+11, r22	; 0x0b
    /* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
     * the event flags implementation. */
    configASSERT( uxSchedulerSuspended != pdFALSE );

    /* Store the new item value in the event list. */
    listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    4940:	8b 85       	ldd	r24, Y+11	; 0x0b
    4942:	9c 85       	ldd	r25, Y+12	; 0x0c
    4944:	90 68       	ori	r25, 0x80	; 128
    4946:	e9 85       	ldd	r30, Y+9	; 0x09
    4948:	fa 85       	ldd	r31, Y+10	; 0x0a
    494a:	91 83       	std	Z+1, r25	; 0x01
    494c:	80 83       	st	Z, r24

    /* Remove the event list form the event flag.  Interrupts do not access
     * event flags. */
    pxUnblockedTCB = listGET_LIST_ITEM_OWNER( pxEventListItem ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    494e:	e9 85       	ldd	r30, Y+9	; 0x09
    4950:	fa 85       	ldd	r31, Y+10	; 0x0a
    4952:	86 81       	ldd	r24, Z+6	; 0x06
    4954:	97 81       	ldd	r25, Z+7	; 0x07
    4956:	98 87       	std	Y+8, r25	; 0x08
    4958:	8f 83       	std	Y+7, r24	; 0x07
    configASSERT( pxUnblockedTCB );
    listREMOVE_ITEM( pxEventListItem );
    495a:	e9 85       	ldd	r30, Y+9	; 0x09
    495c:	fa 85       	ldd	r31, Y+10	; 0x0a
    495e:	80 85       	ldd	r24, Z+8	; 0x08
    4960:	91 85       	ldd	r25, Z+9	; 0x09
    4962:	9e 83       	std	Y+6, r25	; 0x06
    4964:	8d 83       	std	Y+5, r24	; 0x05
    4966:	e9 85       	ldd	r30, Y+9	; 0x09
    4968:	fa 85       	ldd	r31, Y+10	; 0x0a
    496a:	a2 81       	ldd	r26, Z+2	; 0x02
    496c:	b3 81       	ldd	r27, Z+3	; 0x03
    496e:	e9 85       	ldd	r30, Y+9	; 0x09
    4970:	fa 85       	ldd	r31, Y+10	; 0x0a
    4972:	84 81       	ldd	r24, Z+4	; 0x04
    4974:	95 81       	ldd	r25, Z+5	; 0x05
    4976:	15 96       	adiw	r26, 0x05	; 5
    4978:	9c 93       	st	X, r25
    497a:	8e 93       	st	-X, r24
    497c:	14 97       	sbiw	r26, 0x04	; 4
    497e:	e9 85       	ldd	r30, Y+9	; 0x09
    4980:	fa 85       	ldd	r31, Y+10	; 0x0a
    4982:	a4 81       	ldd	r26, Z+4	; 0x04
    4984:	b5 81       	ldd	r27, Z+5	; 0x05
    4986:	e9 85       	ldd	r30, Y+9	; 0x09
    4988:	fa 85       	ldd	r31, Y+10	; 0x0a
    498a:	82 81       	ldd	r24, Z+2	; 0x02
    498c:	93 81       	ldd	r25, Z+3	; 0x03
    498e:	13 96       	adiw	r26, 0x03	; 3
    4990:	9c 93       	st	X, r25
    4992:	8e 93       	st	-X, r24
    4994:	12 97       	sbiw	r26, 0x02	; 2
    4996:	ed 81       	ldd	r30, Y+5	; 0x05
    4998:	fe 81       	ldd	r31, Y+6	; 0x06
    499a:	21 81       	ldd	r18, Z+1	; 0x01
    499c:	32 81       	ldd	r19, Z+2	; 0x02
    499e:	89 85       	ldd	r24, Y+9	; 0x09
    49a0:	9a 85       	ldd	r25, Y+10	; 0x0a
    49a2:	28 17       	cp	r18, r24
    49a4:	39 07       	cpc	r19, r25
    49a6:	41 f4       	brne	.+16     	; 0x49b8 <vTaskRemoveFromUnorderedEventList+0x94>
    49a8:	e9 85       	ldd	r30, Y+9	; 0x09
    49aa:	fa 85       	ldd	r31, Y+10	; 0x0a
    49ac:	84 81       	ldd	r24, Z+4	; 0x04
    49ae:	95 81       	ldd	r25, Z+5	; 0x05
    49b0:	ed 81       	ldd	r30, Y+5	; 0x05
    49b2:	fe 81       	ldd	r31, Y+6	; 0x06
    49b4:	92 83       	std	Z+2, r25	; 0x02
    49b6:	81 83       	std	Z+1, r24	; 0x01
    49b8:	e9 85       	ldd	r30, Y+9	; 0x09
    49ba:	fa 85       	ldd	r31, Y+10	; 0x0a
    49bc:	11 86       	std	Z+9, r1	; 0x09
    49be:	10 86       	std	Z+8, r1	; 0x08
    49c0:	ed 81       	ldd	r30, Y+5	; 0x05
    49c2:	fe 81       	ldd	r31, Y+6	; 0x06
    49c4:	80 81       	ld	r24, Z
    49c6:	81 50       	subi	r24, 0x01	; 1
    49c8:	ed 81       	ldd	r30, Y+5	; 0x05
    49ca:	fe 81       	ldd	r31, Y+6	; 0x06
    49cc:	80 83       	st	Z, r24
    #endif

    /* Remove the task from the delayed list and add it to the ready list.  The
     * scheduler is suspended so interrupts will not be accessing the ready
     * lists. */
    listREMOVE_ITEM( &( pxUnblockedTCB->xStateListItem ) );
    49ce:	ef 81       	ldd	r30, Y+7	; 0x07
    49d0:	f8 85       	ldd	r31, Y+8	; 0x08
    49d2:	82 85       	ldd	r24, Z+10	; 0x0a
    49d4:	93 85       	ldd	r25, Z+11	; 0x0b
    49d6:	9c 83       	std	Y+4, r25	; 0x04
    49d8:	8b 83       	std	Y+3, r24	; 0x03
    49da:	ef 81       	ldd	r30, Y+7	; 0x07
    49dc:	f8 85       	ldd	r31, Y+8	; 0x08
    49de:	a4 81       	ldd	r26, Z+4	; 0x04
    49e0:	b5 81       	ldd	r27, Z+5	; 0x05
    49e2:	ef 81       	ldd	r30, Y+7	; 0x07
    49e4:	f8 85       	ldd	r31, Y+8	; 0x08
    49e6:	86 81       	ldd	r24, Z+6	; 0x06
    49e8:	97 81       	ldd	r25, Z+7	; 0x07
    49ea:	15 96       	adiw	r26, 0x05	; 5
    49ec:	9c 93       	st	X, r25
    49ee:	8e 93       	st	-X, r24
    49f0:	14 97       	sbiw	r26, 0x04	; 4
    49f2:	ef 81       	ldd	r30, Y+7	; 0x07
    49f4:	f8 85       	ldd	r31, Y+8	; 0x08
    49f6:	a6 81       	ldd	r26, Z+6	; 0x06
    49f8:	b7 81       	ldd	r27, Z+7	; 0x07
    49fa:	ef 81       	ldd	r30, Y+7	; 0x07
    49fc:	f8 85       	ldd	r31, Y+8	; 0x08
    49fe:	84 81       	ldd	r24, Z+4	; 0x04
    4a00:	95 81       	ldd	r25, Z+5	; 0x05
    4a02:	13 96       	adiw	r26, 0x03	; 3
    4a04:	9c 93       	st	X, r25
    4a06:	8e 93       	st	-X, r24
    4a08:	12 97       	sbiw	r26, 0x02	; 2
    4a0a:	eb 81       	ldd	r30, Y+3	; 0x03
    4a0c:	fc 81       	ldd	r31, Y+4	; 0x04
    4a0e:	21 81       	ldd	r18, Z+1	; 0x01
    4a10:	32 81       	ldd	r19, Z+2	; 0x02
    4a12:	8f 81       	ldd	r24, Y+7	; 0x07
    4a14:	98 85       	ldd	r25, Y+8	; 0x08
    4a16:	02 96       	adiw	r24, 0x02	; 2
    4a18:	28 17       	cp	r18, r24
    4a1a:	39 07       	cpc	r19, r25
    4a1c:	41 f4       	brne	.+16     	; 0x4a2e <vTaskRemoveFromUnorderedEventList+0x10a>
    4a1e:	ef 81       	ldd	r30, Y+7	; 0x07
    4a20:	f8 85       	ldd	r31, Y+8	; 0x08
    4a22:	86 81       	ldd	r24, Z+6	; 0x06
    4a24:	97 81       	ldd	r25, Z+7	; 0x07
    4a26:	eb 81       	ldd	r30, Y+3	; 0x03
    4a28:	fc 81       	ldd	r31, Y+4	; 0x04
    4a2a:	92 83       	std	Z+2, r25	; 0x02
    4a2c:	81 83       	std	Z+1, r24	; 0x01
    4a2e:	ef 81       	ldd	r30, Y+7	; 0x07
    4a30:	f8 85       	ldd	r31, Y+8	; 0x08
    4a32:	13 86       	std	Z+11, r1	; 0x0b
    4a34:	12 86       	std	Z+10, r1	; 0x0a
    4a36:	eb 81       	ldd	r30, Y+3	; 0x03
    4a38:	fc 81       	ldd	r31, Y+4	; 0x04
    4a3a:	80 81       	ld	r24, Z
    4a3c:	81 50       	subi	r24, 0x01	; 1
    4a3e:	eb 81       	ldd	r30, Y+3	; 0x03
    4a40:	fc 81       	ldd	r31, Y+4	; 0x04
    4a42:	80 83       	st	Z, r24
    prvAddTaskToReadyList( pxUnblockedTCB );
    4a44:	ef 81       	ldd	r30, Y+7	; 0x07
    4a46:	f8 85       	ldd	r31, Y+8	; 0x08
    4a48:	96 89       	ldd	r25, Z+22	; 0x16
    4a4a:	80 91 62 08 	lds	r24, 0x0862
    4a4e:	89 17       	cp	r24, r25
    4a50:	28 f4       	brcc	.+10     	; 0x4a5c <vTaskRemoveFromUnorderedEventList+0x138>
    4a52:	ef 81       	ldd	r30, Y+7	; 0x07
    4a54:	f8 85       	ldd	r31, Y+8	; 0x08
    4a56:	86 89       	ldd	r24, Z+22	; 0x16
    4a58:	80 93 62 08 	sts	0x0862, r24
    4a5c:	ef 81       	ldd	r30, Y+7	; 0x07
    4a5e:	f8 85       	ldd	r31, Y+8	; 0x08
    4a60:	86 89       	ldd	r24, Z+22	; 0x16
    4a62:	28 2f       	mov	r18, r24
    4a64:	30 e0       	ldi	r19, 0x00	; 0
    4a66:	c9 01       	movw	r24, r18
    4a68:	88 0f       	add	r24, r24
    4a6a:	99 1f       	adc	r25, r25
    4a6c:	88 0f       	add	r24, r24
    4a6e:	99 1f       	adc	r25, r25
    4a70:	88 0f       	add	r24, r24
    4a72:	99 1f       	adc	r25, r25
    4a74:	82 0f       	add	r24, r18
    4a76:	93 1f       	adc	r25, r19
    4a78:	fc 01       	movw	r30, r24
    4a7a:	e2 59       	subi	r30, 0x92	; 146
    4a7c:	f7 4f       	sbci	r31, 0xF7	; 247
    4a7e:	81 81       	ldd	r24, Z+1	; 0x01
    4a80:	92 81       	ldd	r25, Z+2	; 0x02
    4a82:	9a 83       	std	Y+2, r25	; 0x02
    4a84:	89 83       	std	Y+1, r24	; 0x01
    4a86:	ef 81       	ldd	r30, Y+7	; 0x07
    4a88:	f8 85       	ldd	r31, Y+8	; 0x08
    4a8a:	89 81       	ldd	r24, Y+1	; 0x01
    4a8c:	9a 81       	ldd	r25, Y+2	; 0x02
    4a8e:	95 83       	std	Z+5, r25	; 0x05
    4a90:	84 83       	std	Z+4, r24	; 0x04
    4a92:	e9 81       	ldd	r30, Y+1	; 0x01
    4a94:	fa 81       	ldd	r31, Y+2	; 0x02
    4a96:	84 81       	ldd	r24, Z+4	; 0x04
    4a98:	95 81       	ldd	r25, Z+5	; 0x05
    4a9a:	ef 81       	ldd	r30, Y+7	; 0x07
    4a9c:	f8 85       	ldd	r31, Y+8	; 0x08
    4a9e:	97 83       	std	Z+7, r25	; 0x07
    4aa0:	86 83       	std	Z+6, r24	; 0x06
    4aa2:	e9 81       	ldd	r30, Y+1	; 0x01
    4aa4:	fa 81       	ldd	r31, Y+2	; 0x02
    4aa6:	04 80       	ldd	r0, Z+4	; 0x04
    4aa8:	f5 81       	ldd	r31, Z+5	; 0x05
    4aaa:	e0 2d       	mov	r30, r0
    4aac:	8f 81       	ldd	r24, Y+7	; 0x07
    4aae:	98 85       	ldd	r25, Y+8	; 0x08
    4ab0:	02 96       	adiw	r24, 0x02	; 2
    4ab2:	93 83       	std	Z+3, r25	; 0x03
    4ab4:	82 83       	std	Z+2, r24	; 0x02
    4ab6:	8f 81       	ldd	r24, Y+7	; 0x07
    4ab8:	98 85       	ldd	r25, Y+8	; 0x08
    4aba:	02 96       	adiw	r24, 0x02	; 2
    4abc:	e9 81       	ldd	r30, Y+1	; 0x01
    4abe:	fa 81       	ldd	r31, Y+2	; 0x02
    4ac0:	95 83       	std	Z+5, r25	; 0x05
    4ac2:	84 83       	std	Z+4, r24	; 0x04
    4ac4:	ef 81       	ldd	r30, Y+7	; 0x07
    4ac6:	f8 85       	ldd	r31, Y+8	; 0x08
    4ac8:	86 89       	ldd	r24, Z+22	; 0x16
    4aca:	28 2f       	mov	r18, r24
    4acc:	30 e0       	ldi	r19, 0x00	; 0
    4ace:	c9 01       	movw	r24, r18
    4ad0:	88 0f       	add	r24, r24
    4ad2:	99 1f       	adc	r25, r25
    4ad4:	88 0f       	add	r24, r24
    4ad6:	99 1f       	adc	r25, r25
    4ad8:	88 0f       	add	r24, r24
    4ada:	99 1f       	adc	r25, r25
    4adc:	82 0f       	add	r24, r18
    4ade:	93 1f       	adc	r25, r19
    4ae0:	82 59       	subi	r24, 0x92	; 146
    4ae2:	97 4f       	sbci	r25, 0xF7	; 247
    4ae4:	ef 81       	ldd	r30, Y+7	; 0x07
    4ae6:	f8 85       	ldd	r31, Y+8	; 0x08
    4ae8:	93 87       	std	Z+11, r25	; 0x0b
    4aea:	82 87       	std	Z+10, r24	; 0x0a
    4aec:	ef 81       	ldd	r30, Y+7	; 0x07
    4aee:	f8 85       	ldd	r31, Y+8	; 0x08
    4af0:	86 89       	ldd	r24, Z+22	; 0x16
    4af2:	28 2f       	mov	r18, r24
    4af4:	30 e0       	ldi	r19, 0x00	; 0
    4af6:	c9 01       	movw	r24, r18
    4af8:	88 0f       	add	r24, r24
    4afa:	99 1f       	adc	r25, r25
    4afc:	88 0f       	add	r24, r24
    4afe:	99 1f       	adc	r25, r25
    4b00:	88 0f       	add	r24, r24
    4b02:	99 1f       	adc	r25, r25
    4b04:	82 0f       	add	r24, r18
    4b06:	93 1f       	adc	r25, r19
    4b08:	fc 01       	movw	r30, r24
    4b0a:	e2 59       	subi	r30, 0x92	; 146
    4b0c:	f7 4f       	sbci	r31, 0xF7	; 247
    4b0e:	80 81       	ld	r24, Z
    4b10:	8f 5f       	subi	r24, 0xFF	; 255
    4b12:	80 83       	st	Z, r24

    if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    4b14:	ef 81       	ldd	r30, Y+7	; 0x07
    4b16:	f8 85       	ldd	r31, Y+8	; 0x08
    4b18:	96 89       	ldd	r25, Z+22	; 0x16
    4b1a:	e0 91 5c 08 	lds	r30, 0x085C
    4b1e:	f0 91 5d 08 	lds	r31, 0x085D
    4b22:	86 89       	ldd	r24, Z+22	; 0x16
    4b24:	89 17       	cp	r24, r25
    4b26:	18 f4       	brcc	.+6      	; 0x4b2e <vTaskRemoveFromUnorderedEventList+0x20a>
    {
        /* The unblocked task has a priority above that of the calling task, so
         * a context switch is required.  This function is called with the
         * scheduler suspended so xYieldPending is set so the context switch
         * occurs immediately that the scheduler is resumed (unsuspended). */
        xYieldPending = pdTRUE;
    4b28:	81 e0       	ldi	r24, 0x01	; 1
    4b2a:	80 93 66 08 	sts	0x0866, r24
    }
}
    4b2e:	2c 96       	adiw	r28, 0x0c	; 12
    4b30:	0f b6       	in	r0, 0x3f	; 63
    4b32:	f8 94       	cli
    4b34:	de bf       	out	0x3e, r29	; 62
    4b36:	0f be       	out	0x3f, r0	; 63
    4b38:	cd bf       	out	0x3d, r28	; 61
    4b3a:	cf 91       	pop	r28
    4b3c:	df 91       	pop	r29
    4b3e:	08 95       	ret

00004b40 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    4b40:	df 93       	push	r29
    4b42:	cf 93       	push	r28
    4b44:	00 d0       	rcall	.+0      	; 0x4b46 <vTaskSetTimeOutState+0x6>
    4b46:	cd b7       	in	r28, 0x3d	; 61
    4b48:	de b7       	in	r29, 0x3e	; 62
    4b4a:	9a 83       	std	Y+2, r25	; 0x02
    4b4c:	89 83       	std	Y+1, r24	; 0x01
    configASSERT( pxTimeOut );
    taskENTER_CRITICAL();
    4b4e:	0f b6       	in	r0, 0x3f	; 63
    4b50:	f8 94       	cli
    4b52:	0f 92       	push	r0
    {
        pxTimeOut->xOverflowCount = xNumOfOverflows;
    4b54:	80 91 67 08 	lds	r24, 0x0867
    4b58:	e9 81       	ldd	r30, Y+1	; 0x01
    4b5a:	fa 81       	ldd	r31, Y+2	; 0x02
    4b5c:	80 83       	st	Z, r24
        pxTimeOut->xTimeOnEntering = xTickCount;
    4b5e:	80 91 60 08 	lds	r24, 0x0860
    4b62:	90 91 61 08 	lds	r25, 0x0861
    4b66:	e9 81       	ldd	r30, Y+1	; 0x01
    4b68:	fa 81       	ldd	r31, Y+2	; 0x02
    4b6a:	92 83       	std	Z+2, r25	; 0x02
    4b6c:	81 83       	std	Z+1, r24	; 0x01
    }
    taskEXIT_CRITICAL();
    4b6e:	0f 90       	pop	r0
    4b70:	0f be       	out	0x3f, r0	; 63
}
    4b72:	0f 90       	pop	r0
    4b74:	0f 90       	pop	r0
    4b76:	cf 91       	pop	r28
    4b78:	df 91       	pop	r29
    4b7a:	08 95       	ret

00004b7c <vTaskInternalSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    4b7c:	df 93       	push	r29
    4b7e:	cf 93       	push	r28
    4b80:	00 d0       	rcall	.+0      	; 0x4b82 <vTaskInternalSetTimeOutState+0x6>
    4b82:	cd b7       	in	r28, 0x3d	; 61
    4b84:	de b7       	in	r29, 0x3e	; 62
    4b86:	9a 83       	std	Y+2, r25	; 0x02
    4b88:	89 83       	std	Y+1, r24	; 0x01
    /* For internal use only as it does not use a critical section. */
    pxTimeOut->xOverflowCount = xNumOfOverflows;
    4b8a:	80 91 67 08 	lds	r24, 0x0867
    4b8e:	e9 81       	ldd	r30, Y+1	; 0x01
    4b90:	fa 81       	ldd	r31, Y+2	; 0x02
    4b92:	80 83       	st	Z, r24
    pxTimeOut->xTimeOnEntering = xTickCount;
    4b94:	80 91 60 08 	lds	r24, 0x0860
    4b98:	90 91 61 08 	lds	r25, 0x0861
    4b9c:	e9 81       	ldd	r30, Y+1	; 0x01
    4b9e:	fa 81       	ldd	r31, Y+2	; 0x02
    4ba0:	92 83       	std	Z+2, r25	; 0x02
    4ba2:	81 83       	std	Z+1, r24	; 0x01
}
    4ba4:	0f 90       	pop	r0
    4ba6:	0f 90       	pop	r0
    4ba8:	cf 91       	pop	r28
    4baa:	df 91       	pop	r29
    4bac:	08 95       	ret

00004bae <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut,
                                 TickType_t * const pxTicksToWait )
{
    4bae:	df 93       	push	r29
    4bb0:	cf 93       	push	r28
    4bb2:	cd b7       	in	r28, 0x3d	; 61
    4bb4:	de b7       	in	r29, 0x3e	; 62
    4bb6:	29 97       	sbiw	r28, 0x09	; 9
    4bb8:	0f b6       	in	r0, 0x3f	; 63
    4bba:	f8 94       	cli
    4bbc:	de bf       	out	0x3e, r29	; 62
    4bbe:	0f be       	out	0x3f, r0	; 63
    4bc0:	cd bf       	out	0x3d, r28	; 61
    4bc2:	9f 83       	std	Y+7, r25	; 0x07
    4bc4:	8e 83       	std	Y+6, r24	; 0x06
    4bc6:	79 87       	std	Y+9, r23	; 0x09
    4bc8:	68 87       	std	Y+8, r22	; 0x08
    BaseType_t xReturn;

    configASSERT( pxTimeOut );
    configASSERT( pxTicksToWait );

    taskENTER_CRITICAL();
    4bca:	0f b6       	in	r0, 0x3f	; 63
    4bcc:	f8 94       	cli
    4bce:	0f 92       	push	r0
    {
        /* Minor optimisation.  The tick count cannot change in this block. */
        const TickType_t xConstTickCount = xTickCount;
    4bd0:	80 91 60 08 	lds	r24, 0x0860
    4bd4:	90 91 61 08 	lds	r25, 0x0861
    4bd8:	9c 83       	std	Y+4, r25	; 0x04
    4bda:	8b 83       	std	Y+3, r24	; 0x03
        const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
    4bdc:	ee 81       	ldd	r30, Y+6	; 0x06
    4bde:	ff 81       	ldd	r31, Y+7	; 0x07
    4be0:	21 81       	ldd	r18, Z+1	; 0x01
    4be2:	32 81       	ldd	r19, Z+2	; 0x02
    4be4:	8b 81       	ldd	r24, Y+3	; 0x03
    4be6:	9c 81       	ldd	r25, Y+4	; 0x04
    4be8:	82 1b       	sub	r24, r18
    4bea:	93 0b       	sbc	r25, r19
    4bec:	9a 83       	std	Y+2, r25	; 0x02
    4bee:	89 83       	std	Y+1, r24	; 0x01
                xReturn = pdFALSE;
            }
            else
        #endif

        if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
    4bf0:	ee 81       	ldd	r30, Y+6	; 0x06
    4bf2:	ff 81       	ldd	r31, Y+7	; 0x07
    4bf4:	90 81       	ld	r25, Z
    4bf6:	80 91 67 08 	lds	r24, 0x0867
    4bfa:	98 17       	cp	r25, r24
    4bfc:	81 f0       	breq	.+32     	; 0x4c1e <xTaskCheckForTimeOut+0x70>
    4bfe:	ee 81       	ldd	r30, Y+6	; 0x06
    4c00:	ff 81       	ldd	r31, Y+7	; 0x07
    4c02:	21 81       	ldd	r18, Z+1	; 0x01
    4c04:	32 81       	ldd	r19, Z+2	; 0x02
    4c06:	8b 81       	ldd	r24, Y+3	; 0x03
    4c08:	9c 81       	ldd	r25, Y+4	; 0x04
    4c0a:	82 17       	cp	r24, r18
    4c0c:	93 07       	cpc	r25, r19
    4c0e:	38 f0       	brcs	.+14     	; 0x4c1e <xTaskCheckForTimeOut+0x70>
            /* The tick count is greater than the time at which
             * vTaskSetTimeout() was called, but has also overflowed since
             * vTaskSetTimeOut() was called.  It must have wrapped all the way
             * around and gone past again. This passed since vTaskSetTimeout()
             * was called. */
            xReturn = pdTRUE;
    4c10:	81 e0       	ldi	r24, 0x01	; 1
    4c12:	8d 83       	std	Y+5, r24	; 0x05
            *pxTicksToWait = ( TickType_t ) 0;
    4c14:	e8 85       	ldd	r30, Y+8	; 0x08
    4c16:	f9 85       	ldd	r31, Y+9	; 0x09
    4c18:	11 82       	std	Z+1, r1	; 0x01
    4c1a:	10 82       	st	Z, r1
    4c1c:	23 c0       	rjmp	.+70     	; 0x4c64 <xTaskCheckForTimeOut+0xb6>
        }
        else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
    4c1e:	e8 85       	ldd	r30, Y+8	; 0x08
    4c20:	f9 85       	ldd	r31, Y+9	; 0x09
    4c22:	20 81       	ld	r18, Z
    4c24:	31 81       	ldd	r19, Z+1	; 0x01
    4c26:	89 81       	ldd	r24, Y+1	; 0x01
    4c28:	9a 81       	ldd	r25, Y+2	; 0x02
    4c2a:	82 17       	cp	r24, r18
    4c2c:	93 07       	cpc	r25, r19
    4c2e:	a0 f4       	brcc	.+40     	; 0x4c58 <xTaskCheckForTimeOut+0xaa>
        {
            /* Not a genuine timeout. Adjust parameters for time remaining. */
            *pxTicksToWait -= xElapsedTime;
    4c30:	e8 85       	ldd	r30, Y+8	; 0x08
    4c32:	f9 85       	ldd	r31, Y+9	; 0x09
    4c34:	20 81       	ld	r18, Z
    4c36:	31 81       	ldd	r19, Z+1	; 0x01
    4c38:	89 81       	ldd	r24, Y+1	; 0x01
    4c3a:	9a 81       	ldd	r25, Y+2	; 0x02
    4c3c:	a9 01       	movw	r20, r18
    4c3e:	48 1b       	sub	r20, r24
    4c40:	59 0b       	sbc	r21, r25
    4c42:	ca 01       	movw	r24, r20
    4c44:	e8 85       	ldd	r30, Y+8	; 0x08
    4c46:	f9 85       	ldd	r31, Y+9	; 0x09
    4c48:	91 83       	std	Z+1, r25	; 0x01
    4c4a:	80 83       	st	Z, r24
            vTaskInternalSetTimeOutState( pxTimeOut );
    4c4c:	8e 81       	ldd	r24, Y+6	; 0x06
    4c4e:	9f 81       	ldd	r25, Y+7	; 0x07
    4c50:	0e 94 be 25 	call	0x4b7c	; 0x4b7c <vTaskInternalSetTimeOutState>
            xReturn = pdFALSE;
    4c54:	1d 82       	std	Y+5, r1	; 0x05
    4c56:	06 c0       	rjmp	.+12     	; 0x4c64 <xTaskCheckForTimeOut+0xb6>
        }
        else
        {
            *pxTicksToWait = ( TickType_t ) 0;
    4c58:	e8 85       	ldd	r30, Y+8	; 0x08
    4c5a:	f9 85       	ldd	r31, Y+9	; 0x09
    4c5c:	11 82       	std	Z+1, r1	; 0x01
    4c5e:	10 82       	st	Z, r1
            xReturn = pdTRUE;
    4c60:	81 e0       	ldi	r24, 0x01	; 1
    4c62:	8d 83       	std	Y+5, r24	; 0x05
        }
    }
    taskEXIT_CRITICAL();
    4c64:	0f 90       	pop	r0
    4c66:	0f be       	out	0x3f, r0	; 63

    return xReturn;
    4c68:	8d 81       	ldd	r24, Y+5	; 0x05
}
    4c6a:	29 96       	adiw	r28, 0x09	; 9
    4c6c:	0f b6       	in	r0, 0x3f	; 63
    4c6e:	f8 94       	cli
    4c70:	de bf       	out	0x3e, r29	; 62
    4c72:	0f be       	out	0x3f, r0	; 63
    4c74:	cd bf       	out	0x3d, r28	; 61
    4c76:	cf 91       	pop	r28
    4c78:	df 91       	pop	r29
    4c7a:	08 95       	ret

00004c7c <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
    4c7c:	df 93       	push	r29
    4c7e:	cf 93       	push	r28
    4c80:	cd b7       	in	r28, 0x3d	; 61
    4c82:	de b7       	in	r29, 0x3e	; 62
    xYieldPending = pdTRUE;
    4c84:	81 e0       	ldi	r24, 0x01	; 1
    4c86:	80 93 66 08 	sts	0x0866, r24
}
    4c8a:	cf 91       	pop	r28
    4c8c:	df 91       	pop	r29
    4c8e:	08 95       	ret

00004c90 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
    4c90:	df 93       	push	r29
    4c92:	cf 93       	push	r28
    4c94:	00 d0       	rcall	.+0      	; 0x4c96 <prvIdleTask+0x6>
    4c96:	cd b7       	in	r28, 0x3d	; 61
    4c98:	de b7       	in	r29, 0x3e	; 62
    4c9a:	9a 83       	std	Y+2, r25	; 0x02
    4c9c:	89 83       	std	Y+1, r24	; 0x01

    for( ; ; )
    {
        /* See if any tasks have deleted themselves - if so then the idle task
         * is responsible for freeing the deleted task's TCB and stack. */
        prvCheckTasksWaitingTermination();
    4c9e:	0e 94 95 26 	call	0x4d2a	; 0x4d2a <prvCheckTasksWaitingTermination>
                 *
                 * A critical region is not required here as we are just reading from
                 * the list, and an occasional incorrect value will not matter.  If
                 * the ready list at the idle priority contains more than one task
                 * then a task other than the idle task is ready to execute. */
                if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
    4ca2:	80 91 6e 08 	lds	r24, 0x086E
    4ca6:	82 30       	cpi	r24, 0x02	; 2
    4ca8:	d0 f3       	brcs	.-12     	; 0x4c9e <prvIdleTask+0xe>
                {
                    taskYIELD();
    4caa:	0e 94 72 09 	call	0x12e4	; 0x12e4 <vPortYield>
    4cae:	f7 cf       	rjmp	.-18     	; 0x4c9e <prvIdleTask+0xe>

00004cb0 <prvInitialiseTaskLists>:

#endif /* portUSING_MPU_WRAPPERS */
/*-----------------------------------------------------------*/

static void prvInitialiseTaskLists( void )
{
    4cb0:	df 93       	push	r29
    4cb2:	cf 93       	push	r28
    4cb4:	0f 92       	push	r0
    4cb6:	cd b7       	in	r28, 0x3d	; 61
    4cb8:	de b7       	in	r29, 0x3e	; 62
    UBaseType_t uxPriority;

    for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    4cba:	19 82       	std	Y+1, r1	; 0x01
    4cbc:	13 c0       	rjmp	.+38     	; 0x4ce4 <prvInitialiseTaskLists+0x34>
    {
        vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
    4cbe:	89 81       	ldd	r24, Y+1	; 0x01
    4cc0:	28 2f       	mov	r18, r24
    4cc2:	30 e0       	ldi	r19, 0x00	; 0
    4cc4:	c9 01       	movw	r24, r18
    4cc6:	88 0f       	add	r24, r24
    4cc8:	99 1f       	adc	r25, r25
    4cca:	88 0f       	add	r24, r24
    4ccc:	99 1f       	adc	r25, r25
    4cce:	88 0f       	add	r24, r24
    4cd0:	99 1f       	adc	r25, r25
    4cd2:	82 0f       	add	r24, r18
    4cd4:	93 1f       	adc	r25, r19
    4cd6:	82 59       	subi	r24, 0x92	; 146
    4cd8:	97 4f       	sbci	r25, 0xF7	; 247
    4cda:	0e 94 ab 10 	call	0x2156	; 0x2156 <vListInitialise>

static void prvInitialiseTaskLists( void )
{
    UBaseType_t uxPriority;

    for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    4cde:	89 81       	ldd	r24, Y+1	; 0x01
    4ce0:	8f 5f       	subi	r24, 0xFF	; 255
    4ce2:	89 83       	std	Y+1, r24	; 0x01
    4ce4:	89 81       	ldd	r24, Y+1	; 0x01
    4ce6:	84 30       	cpi	r24, 0x04	; 4
    4ce8:	50 f3       	brcs	.-44     	; 0x4cbe <prvInitialiseTaskLists+0xe>
    {
        vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
    }

    vListInitialise( &xDelayedTaskList1 );
    4cea:	82 e9       	ldi	r24, 0x92	; 146
    4cec:	98 e0       	ldi	r25, 0x08	; 8
    4cee:	0e 94 ab 10 	call	0x2156	; 0x2156 <vListInitialise>
    vListInitialise( &xDelayedTaskList2 );
    4cf2:	8b e9       	ldi	r24, 0x9B	; 155
    4cf4:	98 e0       	ldi	r25, 0x08	; 8
    4cf6:	0e 94 ab 10 	call	0x2156	; 0x2156 <vListInitialise>
    vListInitialise( &xPendingReadyList );
    4cfa:	88 ea       	ldi	r24, 0xA8	; 168
    4cfc:	98 e0       	ldi	r25, 0x08	; 8
    4cfe:	0e 94 ab 10 	call	0x2156	; 0x2156 <vListInitialise>

    #if ( INCLUDE_vTaskDelete == 1 )
        {
            vListInitialise( &xTasksWaitingTermination );
    4d02:	81 eb       	ldi	r24, 0xB1	; 177
    4d04:	98 e0       	ldi	r25, 0x08	; 8
    4d06:	0e 94 ab 10 	call	0x2156	; 0x2156 <vListInitialise>
        }
    #endif /* INCLUDE_vTaskSuspend */

    /* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
     * using list2. */
    pxDelayedTaskList = &xDelayedTaskList1;
    4d0a:	82 e9       	ldi	r24, 0x92	; 146
    4d0c:	98 e0       	ldi	r25, 0x08	; 8
    4d0e:	90 93 a5 08 	sts	0x08A5, r25
    4d12:	80 93 a4 08 	sts	0x08A4, r24
    pxOverflowDelayedTaskList = &xDelayedTaskList2;
    4d16:	8b e9       	ldi	r24, 0x9B	; 155
    4d18:	98 e0       	ldi	r25, 0x08	; 8
    4d1a:	90 93 a7 08 	sts	0x08A7, r25
    4d1e:	80 93 a6 08 	sts	0x08A6, r24
}
    4d22:	0f 90       	pop	r0
    4d24:	cf 91       	pop	r28
    4d26:	df 91       	pop	r29
    4d28:	08 95       	ret

00004d2a <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
    4d2a:	df 93       	push	r29
    4d2c:	cf 93       	push	r28
    4d2e:	00 d0       	rcall	.+0      	; 0x4d30 <prvCheckTasksWaitingTermination+0x6>
    4d30:	cd b7       	in	r28, 0x3d	; 61
    4d32:	de b7       	in	r29, 0x3e	; 62
    4d34:	20 c0       	rjmp	.+64     	; 0x4d76 <prvCheckTasksWaitingTermination+0x4c>

            /* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
             * being called too often in the idle task. */
            while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
            {
                taskENTER_CRITICAL();
    4d36:	0f b6       	in	r0, 0x3f	; 63
    4d38:	f8 94       	cli
    4d3a:	0f 92       	push	r0
                {
                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    4d3c:	e0 91 b6 08 	lds	r30, 0x08B6
    4d40:	f0 91 b7 08 	lds	r31, 0x08B7
    4d44:	86 81       	ldd	r24, Z+6	; 0x06
    4d46:	97 81       	ldd	r25, Z+7	; 0x07
    4d48:	9a 83       	std	Y+2, r25	; 0x02
    4d4a:	89 83       	std	Y+1, r24	; 0x01
                    ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    4d4c:	89 81       	ldd	r24, Y+1	; 0x01
    4d4e:	9a 81       	ldd	r25, Y+2	; 0x02
    4d50:	02 96       	adiw	r24, 0x02	; 2
    4d52:	0e 94 95 11 	call	0x232a	; 0x232a <uxListRemove>
                    --uxCurrentNumberOfTasks;
    4d56:	80 91 5f 08 	lds	r24, 0x085F
    4d5a:	81 50       	subi	r24, 0x01	; 1
    4d5c:	80 93 5f 08 	sts	0x085F, r24
                    --uxDeletedTasksWaitingCleanUp;
    4d60:	80 91 5e 08 	lds	r24, 0x085E
    4d64:	81 50       	subi	r24, 0x01	; 1
    4d66:	80 93 5e 08 	sts	0x085E, r24
                }
                taskEXIT_CRITICAL();
    4d6a:	0f 90       	pop	r0
    4d6c:	0f be       	out	0x3f, r0	; 63

                prvDeleteTCB( pxTCB );
    4d6e:	89 81       	ldd	r24, Y+1	; 0x01
    4d70:	9a 81       	ldd	r25, Y+2	; 0x02
    4d72:	0e 94 c4 26 	call	0x4d88	; 0x4d88 <prvDeleteTCB>
        {
            TCB_t * pxTCB;

            /* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
             * being called too often in the idle task. */
            while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
    4d76:	80 91 5e 08 	lds	r24, 0x085E
    4d7a:	88 23       	and	r24, r24
    4d7c:	e1 f6       	brne	.-72     	; 0x4d36 <prvCheckTasksWaitingTermination+0xc>

                prvDeleteTCB( pxTCB );
            }
        }
    #endif /* INCLUDE_vTaskDelete */
}
    4d7e:	0f 90       	pop	r0
    4d80:	0f 90       	pop	r0
    4d82:	cf 91       	pop	r28
    4d84:	df 91       	pop	r29
    4d86:	08 95       	ret

00004d88 <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

    static void prvDeleteTCB( TCB_t * pxTCB )
    {
    4d88:	df 93       	push	r29
    4d8a:	cf 93       	push	r28
    4d8c:	00 d0       	rcall	.+0      	; 0x4d8e <prvDeleteTCB+0x6>
    4d8e:	cd b7       	in	r28, 0x3d	; 61
    4d90:	de b7       	in	r29, 0x3e	; 62
    4d92:	9a 83       	std	Y+2, r25	; 0x02
    4d94:	89 83       	std	Y+1, r24	; 0x01

        #if ( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
            {
                /* The task can only have been allocated dynamically - free both
                 * the stack and TCB. */
                vPortFreeStack( pxTCB->pxStack );
    4d96:	e9 81       	ldd	r30, Y+1	; 0x01
    4d98:	fa 81       	ldd	r31, Y+2	; 0x02
    4d9a:	87 89       	ldd	r24, Z+23	; 0x17
    4d9c:	90 8d       	ldd	r25, Z+24	; 0x18
    4d9e:	0e 94 8d 07 	call	0xf1a	; 0xf1a <vPortFree>
                vPortFree( pxTCB );
    4da2:	89 81       	ldd	r24, Y+1	; 0x01
    4da4:	9a 81       	ldd	r25, Y+2	; 0x02
    4da6:	0e 94 8d 07 	call	0xf1a	; 0xf1a <vPortFree>
                    configASSERT( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB );
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        #endif /* configSUPPORT_DYNAMIC_ALLOCATION */
    }
    4daa:	0f 90       	pop	r0
    4dac:	0f 90       	pop	r0
    4dae:	cf 91       	pop	r28
    4db0:	df 91       	pop	r29
    4db2:	08 95       	ret

00004db4 <prvResetNextTaskUnblockTime>:

#endif /* INCLUDE_vTaskDelete */
/*-----------------------------------------------------------*/

static void prvResetNextTaskUnblockTime( void )
{
    4db4:	df 93       	push	r29
    4db6:	cf 93       	push	r28
    4db8:	cd b7       	in	r28, 0x3d	; 61
    4dba:	de b7       	in	r29, 0x3e	; 62
    if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    4dbc:	e0 91 a4 08 	lds	r30, 0x08A4
    4dc0:	f0 91 a5 08 	lds	r31, 0x08A5
    4dc4:	80 81       	ld	r24, Z
    4dc6:	88 23       	and	r24, r24
    4dc8:	39 f4       	brne	.+14     	; 0x4dd8 <prvResetNextTaskUnblockTime+0x24>
    {
        /* The new current delayed list is empty.  Set xNextTaskUnblockTime to
         * the maximum possible value so it is  extremely unlikely that the
         * if( xTickCount >= xNextTaskUnblockTime ) test will pass until
         * there is an item in the delayed list. */
        xNextTaskUnblockTime = portMAX_DELAY;
    4dca:	8f ef       	ldi	r24, 0xFF	; 255
    4dcc:	9f ef       	ldi	r25, 0xFF	; 255
    4dce:	90 93 6a 08 	sts	0x086A, r25
    4dd2:	80 93 69 08 	sts	0x0869, r24
    4dd6:	0d c0       	rjmp	.+26     	; 0x4df2 <prvResetNextTaskUnblockTime+0x3e>
    {
        /* The new current delayed list is not empty, get the value of
         * the item at the head of the delayed list.  This is the time at
         * which the task at the head of the delayed list should be removed
         * from the Blocked state. */
        xNextTaskUnblockTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxDelayedTaskList );
    4dd8:	e0 91 a4 08 	lds	r30, 0x08A4
    4ddc:	f0 91 a5 08 	lds	r31, 0x08A5
    4de0:	05 80       	ldd	r0, Z+5	; 0x05
    4de2:	f6 81       	ldd	r31, Z+6	; 0x06
    4de4:	e0 2d       	mov	r30, r0
    4de6:	80 81       	ld	r24, Z
    4de8:	91 81       	ldd	r25, Z+1	; 0x01
    4dea:	90 93 6a 08 	sts	0x086A, r25
    4dee:	80 93 69 08 	sts	0x0869, r24
    }
}
    4df2:	cf 91       	pop	r28
    4df4:	df 91       	pop	r29
    4df6:	08 95       	ret

00004df8 <xTaskGetSchedulerState>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )

    BaseType_t xTaskGetSchedulerState( void )
    {
    4df8:	df 93       	push	r29
    4dfa:	cf 93       	push	r28
    4dfc:	0f 92       	push	r0
    4dfe:	cd b7       	in	r28, 0x3d	; 61
    4e00:	de b7       	in	r29, 0x3e	; 62
        BaseType_t xReturn;

        if( xSchedulerRunning == pdFALSE )
    4e02:	80 91 63 08 	lds	r24, 0x0863
    4e06:	88 23       	and	r24, r24
    4e08:	19 f4       	brne	.+6      	; 0x4e10 <xTaskGetSchedulerState+0x18>
        {
            xReturn = taskSCHEDULER_NOT_STARTED;
    4e0a:	81 e0       	ldi	r24, 0x01	; 1
    4e0c:	89 83       	std	Y+1, r24	; 0x01
    4e0e:	08 c0       	rjmp	.+16     	; 0x4e20 <xTaskGetSchedulerState+0x28>
        }
        else
        {
            if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    4e10:	80 91 6d 08 	lds	r24, 0x086D
    4e14:	88 23       	and	r24, r24
    4e16:	19 f4       	brne	.+6      	; 0x4e1e <xTaskGetSchedulerState+0x26>
            {
                xReturn = taskSCHEDULER_RUNNING;
    4e18:	82 e0       	ldi	r24, 0x02	; 2
    4e1a:	89 83       	std	Y+1, r24	; 0x01
    4e1c:	01 c0       	rjmp	.+2      	; 0x4e20 <xTaskGetSchedulerState+0x28>
            }
            else
            {
                xReturn = taskSCHEDULER_SUSPENDED;
    4e1e:	19 82       	std	Y+1, r1	; 0x01
            }
        }

        return xReturn;
    4e20:	89 81       	ldd	r24, Y+1	; 0x01
    }
    4e22:	0f 90       	pop	r0
    4e24:	cf 91       	pop	r28
    4e26:	df 91       	pop	r29
    4e28:	08 95       	ret

00004e2a <uxTaskResetEventItemValue>:

#endif /* ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

TickType_t uxTaskResetEventItemValue( void )
{
    4e2a:	df 93       	push	r29
    4e2c:	cf 93       	push	r28
    4e2e:	00 d0       	rcall	.+0      	; 0x4e30 <uxTaskResetEventItemValue+0x6>
    4e30:	cd b7       	in	r28, 0x3d	; 61
    4e32:	de b7       	in	r29, 0x3e	; 62
    TickType_t uxReturn;

    uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
    4e34:	e0 91 5c 08 	lds	r30, 0x085C
    4e38:	f0 91 5d 08 	lds	r31, 0x085D
    4e3c:	84 85       	ldd	r24, Z+12	; 0x0c
    4e3e:	95 85       	ldd	r25, Z+13	; 0x0d
    4e40:	9a 83       	std	Y+2, r25	; 0x02
    4e42:	89 83       	std	Y+1, r24	; 0x01

    /* Reset the event list item to its normal value - so it can be used with
     * queues and semaphores. */
    listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    4e44:	a0 91 5c 08 	lds	r26, 0x085C
    4e48:	b0 91 5d 08 	lds	r27, 0x085D
    4e4c:	e0 91 5c 08 	lds	r30, 0x085C
    4e50:	f0 91 5d 08 	lds	r31, 0x085D
    4e54:	86 89       	ldd	r24, Z+22	; 0x16
    4e56:	28 2f       	mov	r18, r24
    4e58:	30 e0       	ldi	r19, 0x00	; 0
    4e5a:	84 e0       	ldi	r24, 0x04	; 4
    4e5c:	90 e0       	ldi	r25, 0x00	; 0
    4e5e:	82 1b       	sub	r24, r18
    4e60:	93 0b       	sbc	r25, r19
    4e62:	1d 96       	adiw	r26, 0x0d	; 13
    4e64:	9c 93       	st	X, r25
    4e66:	8e 93       	st	-X, r24
    4e68:	1c 97       	sbiw	r26, 0x0c	; 12

    return uxReturn;
    4e6a:	89 81       	ldd	r24, Y+1	; 0x01
    4e6c:	9a 81       	ldd	r25, Y+2	; 0x02
}
    4e6e:	0f 90       	pop	r0
    4e70:	0f 90       	pop	r0
    4e72:	cf 91       	pop	r28
    4e74:	df 91       	pop	r29
    4e76:	08 95       	ret

00004e78 <ulTaskGenericNotifyTake>:
#if ( configUSE_TASK_NOTIFICATIONS == 1 )

    uint32_t ulTaskGenericNotifyTake( UBaseType_t uxIndexToWait,
                                      BaseType_t xClearCountOnExit,
                                      TickType_t xTicksToWait )
    {
    4e78:	df 93       	push	r29
    4e7a:	cf 93       	push	r28
    4e7c:	cd b7       	in	r28, 0x3d	; 61
    4e7e:	de b7       	in	r29, 0x3e	; 62
    4e80:	28 97       	sbiw	r28, 0x08	; 8
    4e82:	0f b6       	in	r0, 0x3f	; 63
    4e84:	f8 94       	cli
    4e86:	de bf       	out	0x3e, r29	; 62
    4e88:	0f be       	out	0x3f, r0	; 63
    4e8a:	cd bf       	out	0x3d, r28	; 61
    4e8c:	8d 83       	std	Y+5, r24	; 0x05
    4e8e:	6e 83       	std	Y+6, r22	; 0x06
    4e90:	58 87       	std	Y+8, r21	; 0x08
    4e92:	4f 83       	std	Y+7, r20	; 0x07
        uint32_t ulReturn;

        configASSERT( uxIndexToWait < configTASK_NOTIFICATION_ARRAY_ENTRIES );

        taskENTER_CRITICAL();
    4e94:	0f b6       	in	r0, 0x3f	; 63
    4e96:	f8 94       	cli
    4e98:	0f 92       	push	r0
        {
            /* Only block if the notification count is not already non-zero. */
            if( pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] == 0UL )
    4e9a:	20 91 5c 08 	lds	r18, 0x085C
    4e9e:	30 91 5d 08 	lds	r19, 0x085D
    4ea2:	8d 81       	ldd	r24, Y+5	; 0x05
    4ea4:	88 2f       	mov	r24, r24
    4ea6:	90 e0       	ldi	r25, 0x00	; 0
    4ea8:	88 0f       	add	r24, r24
    4eaa:	99 1f       	adc	r25, r25
    4eac:	88 0f       	add	r24, r24
    4eae:	99 1f       	adc	r25, r25
    4eb0:	82 0f       	add	r24, r18
    4eb2:	93 1f       	adc	r25, r19
    4eb4:	fc 01       	movw	r30, r24
    4eb6:	b1 96       	adiw	r30, 0x21	; 33
    4eb8:	80 81       	ld	r24, Z
    4eba:	91 81       	ldd	r25, Z+1	; 0x01
    4ebc:	a2 81       	ldd	r26, Z+2	; 0x02
    4ebe:	b3 81       	ldd	r27, Z+3	; 0x03
    4ec0:	00 97       	sbiw	r24, 0x00	; 0
    4ec2:	a1 05       	cpc	r26, r1
    4ec4:	b1 05       	cpc	r27, r1
    4ec6:	c1 f4       	brne	.+48     	; 0x4ef8 <ulTaskGenericNotifyTake+0x80>
            {
                /* Mark this task as waiting for a notification. */
                pxCurrentTCB->ucNotifyState[ uxIndexToWait ] = taskWAITING_NOTIFICATION;
    4ec8:	20 91 5c 08 	lds	r18, 0x085C
    4ecc:	30 91 5d 08 	lds	r19, 0x085D
    4ed0:	8d 81       	ldd	r24, Y+5	; 0x05
    4ed2:	88 2f       	mov	r24, r24
    4ed4:	90 e0       	ldi	r25, 0x00	; 0
    4ed6:	82 0f       	add	r24, r18
    4ed8:	93 1f       	adc	r25, r19
    4eda:	fc 01       	movw	r30, r24
    4edc:	b5 96       	adiw	r30, 0x25	; 37
    4ede:	81 e0       	ldi	r24, 0x01	; 1
    4ee0:	80 83       	st	Z, r24

                if( xTicksToWait > ( TickType_t ) 0 )
    4ee2:	8f 81       	ldd	r24, Y+7	; 0x07
    4ee4:	98 85       	ldd	r25, Y+8	; 0x08
    4ee6:	00 97       	sbiw	r24, 0x00	; 0
    4ee8:	39 f0       	breq	.+14     	; 0x4ef8 <ulTaskGenericNotifyTake+0x80>
                {
                    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    4eea:	8f 81       	ldd	r24, Y+7	; 0x07
    4eec:	98 85       	ldd	r25, Y+8	; 0x08
    4eee:	61 e0       	ldi	r22, 0x01	; 1
    4ef0:	0e 94 c1 2e 	call	0x5d82	; 0x5d82 <prvAddCurrentTaskToDelayedList>

                    /* All ports are written to allow a yield in a critical
                     * section (some will yield immediately, others wait until the
                     * critical section exits) - but it is not something that
                     * application code should ever do. */
                    portYIELD_WITHIN_API();
    4ef4:	0e 94 72 09 	call	0x12e4	; 0x12e4 <vPortYield>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        taskEXIT_CRITICAL();
    4ef8:	0f 90       	pop	r0
    4efa:	0f be       	out	0x3f, r0	; 63

        taskENTER_CRITICAL();
    4efc:	0f b6       	in	r0, 0x3f	; 63
    4efe:	f8 94       	cli
    4f00:	0f 92       	push	r0
        {
            traceTASK_NOTIFY_TAKE( uxIndexToWait );
            ulReturn = pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ];
    4f02:	20 91 5c 08 	lds	r18, 0x085C
    4f06:	30 91 5d 08 	lds	r19, 0x085D
    4f0a:	8d 81       	ldd	r24, Y+5	; 0x05
    4f0c:	88 2f       	mov	r24, r24
    4f0e:	90 e0       	ldi	r25, 0x00	; 0
    4f10:	88 0f       	add	r24, r24
    4f12:	99 1f       	adc	r25, r25
    4f14:	88 0f       	add	r24, r24
    4f16:	99 1f       	adc	r25, r25
    4f18:	82 0f       	add	r24, r18
    4f1a:	93 1f       	adc	r25, r19
    4f1c:	fc 01       	movw	r30, r24
    4f1e:	b1 96       	adiw	r30, 0x21	; 33
    4f20:	80 81       	ld	r24, Z
    4f22:	91 81       	ldd	r25, Z+1	; 0x01
    4f24:	a2 81       	ldd	r26, Z+2	; 0x02
    4f26:	b3 81       	ldd	r27, Z+3	; 0x03
    4f28:	89 83       	std	Y+1, r24	; 0x01
    4f2a:	9a 83       	std	Y+2, r25	; 0x02
    4f2c:	ab 83       	std	Y+3, r26	; 0x03
    4f2e:	bc 83       	std	Y+4, r27	; 0x04

            if( ulReturn != 0UL )
    4f30:	89 81       	ldd	r24, Y+1	; 0x01
    4f32:	9a 81       	ldd	r25, Y+2	; 0x02
    4f34:	ab 81       	ldd	r26, Y+3	; 0x03
    4f36:	bc 81       	ldd	r27, Y+4	; 0x04
    4f38:	00 97       	sbiw	r24, 0x00	; 0
    4f3a:	a1 05       	cpc	r26, r1
    4f3c:	b1 05       	cpc	r27, r1
    4f3e:	a9 f1       	breq	.+106    	; 0x4faa <ulTaskGenericNotifyTake+0x132>
            {
                if( xClearCountOnExit != pdFALSE )
    4f40:	8e 81       	ldd	r24, Y+6	; 0x06
    4f42:	88 23       	and	r24, r24
    4f44:	a1 f0       	breq	.+40     	; 0x4f6e <ulTaskGenericNotifyTake+0xf6>
                {
                    pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] = 0UL;
    4f46:	20 91 5c 08 	lds	r18, 0x085C
    4f4a:	30 91 5d 08 	lds	r19, 0x085D
    4f4e:	8d 81       	ldd	r24, Y+5	; 0x05
    4f50:	88 2f       	mov	r24, r24
    4f52:	90 e0       	ldi	r25, 0x00	; 0
    4f54:	88 0f       	add	r24, r24
    4f56:	99 1f       	adc	r25, r25
    4f58:	88 0f       	add	r24, r24
    4f5a:	99 1f       	adc	r25, r25
    4f5c:	82 0f       	add	r24, r18
    4f5e:	93 1f       	adc	r25, r19
    4f60:	fc 01       	movw	r30, r24
    4f62:	b1 96       	adiw	r30, 0x21	; 33
    4f64:	10 82       	st	Z, r1
    4f66:	11 82       	std	Z+1, r1	; 0x01
    4f68:	12 82       	std	Z+2, r1	; 0x02
    4f6a:	13 82       	std	Z+3, r1	; 0x03
    4f6c:	1e c0       	rjmp	.+60     	; 0x4faa <ulTaskGenericNotifyTake+0x132>
                }
                else
                {
                    pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] = ulReturn - ( uint32_t ) 1;
    4f6e:	e0 91 5c 08 	lds	r30, 0x085C
    4f72:	f0 91 5d 08 	lds	r31, 0x085D
    4f76:	8d 81       	ldd	r24, Y+5	; 0x05
    4f78:	68 2f       	mov	r22, r24
    4f7a:	70 e0       	ldi	r23, 0x00	; 0
    4f7c:	89 81       	ldd	r24, Y+1	; 0x01
    4f7e:	9a 81       	ldd	r25, Y+2	; 0x02
    4f80:	ab 81       	ldd	r26, Y+3	; 0x03
    4f82:	bc 81       	ldd	r27, Y+4	; 0x04
    4f84:	9c 01       	movw	r18, r24
    4f86:	ad 01       	movw	r20, r26
    4f88:	21 50       	subi	r18, 0x01	; 1
    4f8a:	30 40       	sbci	r19, 0x00	; 0
    4f8c:	40 40       	sbci	r20, 0x00	; 0
    4f8e:	50 40       	sbci	r21, 0x00	; 0
    4f90:	cb 01       	movw	r24, r22
    4f92:	88 0f       	add	r24, r24
    4f94:	99 1f       	adc	r25, r25
    4f96:	88 0f       	add	r24, r24
    4f98:	99 1f       	adc	r25, r25
    4f9a:	8e 0f       	add	r24, r30
    4f9c:	9f 1f       	adc	r25, r31
    4f9e:	fc 01       	movw	r30, r24
    4fa0:	b1 96       	adiw	r30, 0x21	; 33
    4fa2:	20 83       	st	Z, r18
    4fa4:	31 83       	std	Z+1, r19	; 0x01
    4fa6:	42 83       	std	Z+2, r20	; 0x02
    4fa8:	53 83       	std	Z+3, r21	; 0x03
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }

            pxCurrentTCB->ucNotifyState[ uxIndexToWait ] = taskNOT_WAITING_NOTIFICATION;
    4faa:	20 91 5c 08 	lds	r18, 0x085C
    4fae:	30 91 5d 08 	lds	r19, 0x085D
    4fb2:	8d 81       	ldd	r24, Y+5	; 0x05
    4fb4:	88 2f       	mov	r24, r24
    4fb6:	90 e0       	ldi	r25, 0x00	; 0
    4fb8:	82 0f       	add	r24, r18
    4fba:	93 1f       	adc	r25, r19
    4fbc:	fc 01       	movw	r30, r24
    4fbe:	b5 96       	adiw	r30, 0x25	; 37
    4fc0:	10 82       	st	Z, r1
        }
        taskEXIT_CRITICAL();
    4fc2:	0f 90       	pop	r0
    4fc4:	0f be       	out	0x3f, r0	; 63

        return ulReturn;
    4fc6:	89 81       	ldd	r24, Y+1	; 0x01
    4fc8:	9a 81       	ldd	r25, Y+2	; 0x02
    4fca:	ab 81       	ldd	r26, Y+3	; 0x03
    4fcc:	bc 81       	ldd	r27, Y+4	; 0x04
    }
    4fce:	bc 01       	movw	r22, r24
    4fd0:	cd 01       	movw	r24, r26
    4fd2:	28 96       	adiw	r28, 0x08	; 8
    4fd4:	0f b6       	in	r0, 0x3f	; 63
    4fd6:	f8 94       	cli
    4fd8:	de bf       	out	0x3e, r29	; 62
    4fda:	0f be       	out	0x3f, r0	; 63
    4fdc:	cd bf       	out	0x3d, r28	; 61
    4fde:	cf 91       	pop	r28
    4fe0:	df 91       	pop	r29
    4fe2:	08 95       	ret

00004fe4 <xTaskGenericNotifyWait>:
    BaseType_t xTaskGenericNotifyWait( UBaseType_t uxIndexToWait,
                                       uint32_t ulBitsToClearOnEntry,
                                       uint32_t ulBitsToClearOnExit,
                                       uint32_t * pulNotificationValue,
                                       TickType_t xTicksToWait )
    {
    4fe4:	cf 92       	push	r12
    4fe6:	df 92       	push	r13
    4fe8:	ef 92       	push	r14
    4fea:	ff 92       	push	r15
    4fec:	0f 93       	push	r16
    4fee:	1f 93       	push	r17
    4ff0:	df 93       	push	r29
    4ff2:	cf 93       	push	r28
    4ff4:	cd b7       	in	r28, 0x3d	; 61
    4ff6:	de b7       	in	r29, 0x3e	; 62
    4ff8:	2e 97       	sbiw	r28, 0x0e	; 14
    4ffa:	0f b6       	in	r0, 0x3f	; 63
    4ffc:	f8 94       	cli
    4ffe:	de bf       	out	0x3e, r29	; 62
    5000:	0f be       	out	0x3f, r0	; 63
    5002:	cd bf       	out	0x3d, r28	; 61
    5004:	8a 83       	std	Y+2, r24	; 0x02
    5006:	4b 83       	std	Y+3, r20	; 0x03
    5008:	5c 83       	std	Y+4, r21	; 0x04
    500a:	6d 83       	std	Y+5, r22	; 0x05
    500c:	7e 83       	std	Y+6, r23	; 0x06
    500e:	0f 83       	std	Y+7, r16	; 0x07
    5010:	18 87       	std	Y+8, r17	; 0x08
    5012:	29 87       	std	Y+9, r18	; 0x09
    5014:	3a 87       	std	Y+10, r19	; 0x0a
    5016:	fc 86       	std	Y+12, r15	; 0x0c
    5018:	eb 86       	std	Y+11, r14	; 0x0b
    501a:	de 86       	std	Y+14, r13	; 0x0e
    501c:	cd 86       	std	Y+13, r12	; 0x0d
        BaseType_t xReturn;

        configASSERT( uxIndexToWait < configTASK_NOTIFICATION_ARRAY_ENTRIES );

        taskENTER_CRITICAL();
    501e:	0f b6       	in	r0, 0x3f	; 63
    5020:	f8 94       	cli
    5022:	0f 92       	push	r0
        {
            /* Only block if a notification is not already pending. */
            if( pxCurrentTCB->ucNotifyState[ uxIndexToWait ] != taskNOTIFICATION_RECEIVED )
    5024:	20 91 5c 08 	lds	r18, 0x085C
    5028:	30 91 5d 08 	lds	r19, 0x085D
    502c:	8a 81       	ldd	r24, Y+2	; 0x02
    502e:	88 2f       	mov	r24, r24
    5030:	90 e0       	ldi	r25, 0x00	; 0
    5032:	82 0f       	add	r24, r18
    5034:	93 1f       	adc	r25, r19
    5036:	fc 01       	movw	r30, r24
    5038:	b5 96       	adiw	r30, 0x25	; 37
    503a:	80 81       	ld	r24, Z
    503c:	82 30       	cpi	r24, 0x02	; 2
    503e:	09 f4       	brne	.+2      	; 0x5042 <xTaskGenericNotifyWait+0x5e>
    5040:	47 c0       	rjmp	.+142    	; 0x50d0 <xTaskGenericNotifyWait+0xec>
            {
                /* Clear bits in the task's notification value as bits may get
                 * set  by the notifying task or interrupt.  This can be used to
                 * clear the value to zero. */
                pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] &= ~ulBitsToClearOnEntry;
    5042:	60 91 5c 08 	lds	r22, 0x085C
    5046:	70 91 5d 08 	lds	r23, 0x085D
    504a:	8a 81       	ldd	r24, Y+2	; 0x02
    504c:	08 2f       	mov	r16, r24
    504e:	10 e0       	ldi	r17, 0x00	; 0
    5050:	8a 81       	ldd	r24, Y+2	; 0x02
    5052:	88 2f       	mov	r24, r24
    5054:	90 e0       	ldi	r25, 0x00	; 0
    5056:	88 0f       	add	r24, r24
    5058:	99 1f       	adc	r25, r25
    505a:	88 0f       	add	r24, r24
    505c:	99 1f       	adc	r25, r25
    505e:	86 0f       	add	r24, r22
    5060:	97 1f       	adc	r25, r23
    5062:	fc 01       	movw	r30, r24
    5064:	b1 96       	adiw	r30, 0x21	; 33
    5066:	20 81       	ld	r18, Z
    5068:	31 81       	ldd	r19, Z+1	; 0x01
    506a:	42 81       	ldd	r20, Z+2	; 0x02
    506c:	53 81       	ldd	r21, Z+3	; 0x03
    506e:	8b 81       	ldd	r24, Y+3	; 0x03
    5070:	9c 81       	ldd	r25, Y+4	; 0x04
    5072:	ad 81       	ldd	r26, Y+5	; 0x05
    5074:	be 81       	ldd	r27, Y+6	; 0x06
    5076:	80 95       	com	r24
    5078:	90 95       	com	r25
    507a:	a0 95       	com	r26
    507c:	b0 95       	com	r27
    507e:	28 23       	and	r18, r24
    5080:	39 23       	and	r19, r25
    5082:	4a 23       	and	r20, r26
    5084:	5b 23       	and	r21, r27
    5086:	c8 01       	movw	r24, r16
    5088:	88 0f       	add	r24, r24
    508a:	99 1f       	adc	r25, r25
    508c:	88 0f       	add	r24, r24
    508e:	99 1f       	adc	r25, r25
    5090:	86 0f       	add	r24, r22
    5092:	97 1f       	adc	r25, r23
    5094:	fc 01       	movw	r30, r24
    5096:	b1 96       	adiw	r30, 0x21	; 33
    5098:	20 83       	st	Z, r18
    509a:	31 83       	std	Z+1, r19	; 0x01
    509c:	42 83       	std	Z+2, r20	; 0x02
    509e:	53 83       	std	Z+3, r21	; 0x03

                /* Mark this task as waiting for a notification. */
                pxCurrentTCB->ucNotifyState[ uxIndexToWait ] = taskWAITING_NOTIFICATION;
    50a0:	20 91 5c 08 	lds	r18, 0x085C
    50a4:	30 91 5d 08 	lds	r19, 0x085D
    50a8:	8a 81       	ldd	r24, Y+2	; 0x02
    50aa:	88 2f       	mov	r24, r24
    50ac:	90 e0       	ldi	r25, 0x00	; 0
    50ae:	82 0f       	add	r24, r18
    50b0:	93 1f       	adc	r25, r19
    50b2:	fc 01       	movw	r30, r24
    50b4:	b5 96       	adiw	r30, 0x25	; 37
    50b6:	81 e0       	ldi	r24, 0x01	; 1
    50b8:	80 83       	st	Z, r24

                if( xTicksToWait > ( TickType_t ) 0 )
    50ba:	8d 85       	ldd	r24, Y+13	; 0x0d
    50bc:	9e 85       	ldd	r25, Y+14	; 0x0e
    50be:	00 97       	sbiw	r24, 0x00	; 0
    50c0:	39 f0       	breq	.+14     	; 0x50d0 <xTaskGenericNotifyWait+0xec>
                {
                    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    50c2:	8d 85       	ldd	r24, Y+13	; 0x0d
    50c4:	9e 85       	ldd	r25, Y+14	; 0x0e
    50c6:	61 e0       	ldi	r22, 0x01	; 1
    50c8:	0e 94 c1 2e 	call	0x5d82	; 0x5d82 <prvAddCurrentTaskToDelayedList>

                    /* All ports are written to allow a yield in a critical
                     * section (some will yield immediately, others wait until the
                     * critical section exits) - but it is not something that
                     * application code should ever do. */
                    portYIELD_WITHIN_API();
    50cc:	0e 94 72 09 	call	0x12e4	; 0x12e4 <vPortYield>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        taskEXIT_CRITICAL();
    50d0:	0f 90       	pop	r0
    50d2:	0f be       	out	0x3f, r0	; 63

        taskENTER_CRITICAL();
    50d4:	0f b6       	in	r0, 0x3f	; 63
    50d6:	f8 94       	cli
    50d8:	0f 92       	push	r0
        {
            traceTASK_NOTIFY_WAIT( uxIndexToWait );

            if( pulNotificationValue != NULL )
    50da:	8b 85       	ldd	r24, Y+11	; 0x0b
    50dc:	9c 85       	ldd	r25, Y+12	; 0x0c
    50de:	00 97       	sbiw	r24, 0x00	; 0
    50e0:	c9 f0       	breq	.+50     	; 0x5114 <xTaskGenericNotifyWait+0x130>
            {
                /* Output the current notification value, which may or may not
                 * have changed. */
                *pulNotificationValue = pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ];
    50e2:	20 91 5c 08 	lds	r18, 0x085C
    50e6:	30 91 5d 08 	lds	r19, 0x085D
    50ea:	8a 81       	ldd	r24, Y+2	; 0x02
    50ec:	88 2f       	mov	r24, r24
    50ee:	90 e0       	ldi	r25, 0x00	; 0
    50f0:	88 0f       	add	r24, r24
    50f2:	99 1f       	adc	r25, r25
    50f4:	88 0f       	add	r24, r24
    50f6:	99 1f       	adc	r25, r25
    50f8:	82 0f       	add	r24, r18
    50fa:	93 1f       	adc	r25, r19
    50fc:	fc 01       	movw	r30, r24
    50fe:	b1 96       	adiw	r30, 0x21	; 33
    5100:	80 81       	ld	r24, Z
    5102:	91 81       	ldd	r25, Z+1	; 0x01
    5104:	a2 81       	ldd	r26, Z+2	; 0x02
    5106:	b3 81       	ldd	r27, Z+3	; 0x03
    5108:	eb 85       	ldd	r30, Y+11	; 0x0b
    510a:	fc 85       	ldd	r31, Y+12	; 0x0c
    510c:	80 83       	st	Z, r24
    510e:	91 83       	std	Z+1, r25	; 0x01
    5110:	a2 83       	std	Z+2, r26	; 0x02
    5112:	b3 83       	std	Z+3, r27	; 0x03

            /* If ucNotifyValue is set then either the task never entered the
             * blocked state (because a notification was already pending) or the
             * task unblocked because of a notification.  Otherwise the task
             * unblocked because of a timeout. */
            if( pxCurrentTCB->ucNotifyState[ uxIndexToWait ] != taskNOTIFICATION_RECEIVED )
    5114:	20 91 5c 08 	lds	r18, 0x085C
    5118:	30 91 5d 08 	lds	r19, 0x085D
    511c:	8a 81       	ldd	r24, Y+2	; 0x02
    511e:	88 2f       	mov	r24, r24
    5120:	90 e0       	ldi	r25, 0x00	; 0
    5122:	82 0f       	add	r24, r18
    5124:	93 1f       	adc	r25, r19
    5126:	fc 01       	movw	r30, r24
    5128:	b5 96       	adiw	r30, 0x25	; 37
    512a:	80 81       	ld	r24, Z
    512c:	82 30       	cpi	r24, 0x02	; 2
    512e:	11 f0       	breq	.+4      	; 0x5134 <xTaskGenericNotifyWait+0x150>
            {
                /* A notification was not received. */
                xReturn = pdFALSE;
    5130:	19 82       	std	Y+1, r1	; 0x01
    5132:	31 c0       	rjmp	.+98     	; 0x5196 <xTaskGenericNotifyWait+0x1b2>
            }
            else
            {
                /* A notification was already pending or a notification was
                 * received while the task was waiting. */
                pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] &= ~ulBitsToClearOnExit;
    5134:	60 91 5c 08 	lds	r22, 0x085C
    5138:	70 91 5d 08 	lds	r23, 0x085D
    513c:	8a 81       	ldd	r24, Y+2	; 0x02
    513e:	08 2f       	mov	r16, r24
    5140:	10 e0       	ldi	r17, 0x00	; 0
    5142:	8a 81       	ldd	r24, Y+2	; 0x02
    5144:	88 2f       	mov	r24, r24
    5146:	90 e0       	ldi	r25, 0x00	; 0
    5148:	88 0f       	add	r24, r24
    514a:	99 1f       	adc	r25, r25
    514c:	88 0f       	add	r24, r24
    514e:	99 1f       	adc	r25, r25
    5150:	86 0f       	add	r24, r22
    5152:	97 1f       	adc	r25, r23
    5154:	fc 01       	movw	r30, r24
    5156:	b1 96       	adiw	r30, 0x21	; 33
    5158:	20 81       	ld	r18, Z
    515a:	31 81       	ldd	r19, Z+1	; 0x01
    515c:	42 81       	ldd	r20, Z+2	; 0x02
    515e:	53 81       	ldd	r21, Z+3	; 0x03
    5160:	8f 81       	ldd	r24, Y+7	; 0x07
    5162:	98 85       	ldd	r25, Y+8	; 0x08
    5164:	a9 85       	ldd	r26, Y+9	; 0x09
    5166:	ba 85       	ldd	r27, Y+10	; 0x0a
    5168:	80 95       	com	r24
    516a:	90 95       	com	r25
    516c:	a0 95       	com	r26
    516e:	b0 95       	com	r27
    5170:	28 23       	and	r18, r24
    5172:	39 23       	and	r19, r25
    5174:	4a 23       	and	r20, r26
    5176:	5b 23       	and	r21, r27
    5178:	c8 01       	movw	r24, r16
    517a:	88 0f       	add	r24, r24
    517c:	99 1f       	adc	r25, r25
    517e:	88 0f       	add	r24, r24
    5180:	99 1f       	adc	r25, r25
    5182:	86 0f       	add	r24, r22
    5184:	97 1f       	adc	r25, r23
    5186:	fc 01       	movw	r30, r24
    5188:	b1 96       	adiw	r30, 0x21	; 33
    518a:	20 83       	st	Z, r18
    518c:	31 83       	std	Z+1, r19	; 0x01
    518e:	42 83       	std	Z+2, r20	; 0x02
    5190:	53 83       	std	Z+3, r21	; 0x03
                xReturn = pdTRUE;
    5192:	81 e0       	ldi	r24, 0x01	; 1
    5194:	89 83       	std	Y+1, r24	; 0x01
            }

            pxCurrentTCB->ucNotifyState[ uxIndexToWait ] = taskNOT_WAITING_NOTIFICATION;
    5196:	20 91 5c 08 	lds	r18, 0x085C
    519a:	30 91 5d 08 	lds	r19, 0x085D
    519e:	8a 81       	ldd	r24, Y+2	; 0x02
    51a0:	88 2f       	mov	r24, r24
    51a2:	90 e0       	ldi	r25, 0x00	; 0
    51a4:	82 0f       	add	r24, r18
    51a6:	93 1f       	adc	r25, r19
    51a8:	fc 01       	movw	r30, r24
    51aa:	b5 96       	adiw	r30, 0x25	; 37
    51ac:	10 82       	st	Z, r1
        }
        taskEXIT_CRITICAL();
    51ae:	0f 90       	pop	r0
    51b0:	0f be       	out	0x3f, r0	; 63

        return xReturn;
    51b2:	89 81       	ldd	r24, Y+1	; 0x01
    }
    51b4:	2e 96       	adiw	r28, 0x0e	; 14
    51b6:	0f b6       	in	r0, 0x3f	; 63
    51b8:	f8 94       	cli
    51ba:	de bf       	out	0x3e, r29	; 62
    51bc:	0f be       	out	0x3f, r0	; 63
    51be:	cd bf       	out	0x3d, r28	; 61
    51c0:	cf 91       	pop	r28
    51c2:	df 91       	pop	r29
    51c4:	1f 91       	pop	r17
    51c6:	0f 91       	pop	r16
    51c8:	ff 90       	pop	r15
    51ca:	ef 90       	pop	r14
    51cc:	df 90       	pop	r13
    51ce:	cf 90       	pop	r12
    51d0:	08 95       	ret

000051d2 <xTaskGenericNotify>:
    BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify,
                                   UBaseType_t uxIndexToNotify,
                                   uint32_t ulValue,
                                   eNotifyAction eAction,
                                   uint32_t * pulPreviousNotificationValue )
    {
    51d2:	ef 92       	push	r14
    51d4:	ff 92       	push	r15
    51d6:	0f 93       	push	r16
    51d8:	1f 93       	push	r17
    51da:	df 93       	push	r29
    51dc:	cf 93       	push	r28
    51de:	cd b7       	in	r28, 0x3d	; 61
    51e0:	de b7       	in	r29, 0x3e	; 62
    51e2:	64 97       	sbiw	r28, 0x14	; 20
    51e4:	0f b6       	in	r0, 0x3f	; 63
    51e6:	f8 94       	cli
    51e8:	de bf       	out	0x3e, r29	; 62
    51ea:	0f be       	out	0x3f, r0	; 63
    51ec:	cd bf       	out	0x3d, r28	; 61
    51ee:	9a 87       	std	Y+10, r25	; 0x0a
    51f0:	89 87       	std	Y+9, r24	; 0x09
    51f2:	6b 87       	std	Y+11, r22	; 0x0b
    51f4:	2c 87       	std	Y+12, r18	; 0x0c
    51f6:	3d 87       	std	Y+13, r19	; 0x0d
    51f8:	4e 87       	std	Y+14, r20	; 0x0e
    51fa:	5f 87       	std	Y+15, r21	; 0x0f
    51fc:	08 8b       	std	Y+16, r16	; 0x10
    51fe:	fa 8a       	std	Y+18, r15	; 0x12
    5200:	e9 8a       	std	Y+17, r14	; 0x11
        TCB_t * pxTCB;
        BaseType_t xReturn = pdPASS;
    5202:	81 e0       	ldi	r24, 0x01	; 1
    5204:	8e 83       	std	Y+6, r24	; 0x06
        uint8_t ucOriginalNotifyState;

        configASSERT( uxIndexToNotify < configTASK_NOTIFICATION_ARRAY_ENTRIES );
        configASSERT( xTaskToNotify );
        pxTCB = xTaskToNotify;
    5206:	89 85       	ldd	r24, Y+9	; 0x09
    5208:	9a 85       	ldd	r25, Y+10	; 0x0a
    520a:	98 87       	std	Y+8, r25	; 0x08
    520c:	8f 83       	std	Y+7, r24	; 0x07

        taskENTER_CRITICAL();
    520e:	0f b6       	in	r0, 0x3f	; 63
    5210:	f8 94       	cli
    5212:	0f 92       	push	r0
        {
            if( pulPreviousNotificationValue != NULL )
    5214:	89 89       	ldd	r24, Y+17	; 0x11
    5216:	9a 89       	ldd	r25, Y+18	; 0x12
    5218:	00 97       	sbiw	r24, 0x00	; 0
    521a:	b9 f0       	breq	.+46     	; 0x524a <xTaskGenericNotify+0x78>
            {
                *pulPreviousNotificationValue = pxTCB->ulNotifiedValue[ uxIndexToNotify ];
    521c:	8b 85       	ldd	r24, Y+11	; 0x0b
    521e:	88 2f       	mov	r24, r24
    5220:	90 e0       	ldi	r25, 0x00	; 0
    5222:	2f 81       	ldd	r18, Y+7	; 0x07
    5224:	38 85       	ldd	r19, Y+8	; 0x08
    5226:	88 0f       	add	r24, r24
    5228:	99 1f       	adc	r25, r25
    522a:	88 0f       	add	r24, r24
    522c:	99 1f       	adc	r25, r25
    522e:	82 0f       	add	r24, r18
    5230:	93 1f       	adc	r25, r19
    5232:	fc 01       	movw	r30, r24
    5234:	b1 96       	adiw	r30, 0x21	; 33
    5236:	80 81       	ld	r24, Z
    5238:	91 81       	ldd	r25, Z+1	; 0x01
    523a:	a2 81       	ldd	r26, Z+2	; 0x02
    523c:	b3 81       	ldd	r27, Z+3	; 0x03
    523e:	e9 89       	ldd	r30, Y+17	; 0x11
    5240:	fa 89       	ldd	r31, Y+18	; 0x12
    5242:	80 83       	st	Z, r24
    5244:	91 83       	std	Z+1, r25	; 0x01
    5246:	a2 83       	std	Z+2, r26	; 0x02
    5248:	b3 83       	std	Z+3, r27	; 0x03
            }

            ucOriginalNotifyState = pxTCB->ucNotifyState[ uxIndexToNotify ];
    524a:	8b 85       	ldd	r24, Y+11	; 0x0b
    524c:	28 2f       	mov	r18, r24
    524e:	30 e0       	ldi	r19, 0x00	; 0
    5250:	8f 81       	ldd	r24, Y+7	; 0x07
    5252:	98 85       	ldd	r25, Y+8	; 0x08
    5254:	82 0f       	add	r24, r18
    5256:	93 1f       	adc	r25, r19
    5258:	fc 01       	movw	r30, r24
    525a:	b5 96       	adiw	r30, 0x25	; 37
    525c:	80 81       	ld	r24, Z
    525e:	8d 83       	std	Y+5, r24	; 0x05

            pxTCB->ucNotifyState[ uxIndexToNotify ] = taskNOTIFICATION_RECEIVED;
    5260:	8b 85       	ldd	r24, Y+11	; 0x0b
    5262:	28 2f       	mov	r18, r24
    5264:	30 e0       	ldi	r19, 0x00	; 0
    5266:	8f 81       	ldd	r24, Y+7	; 0x07
    5268:	98 85       	ldd	r25, Y+8	; 0x08
    526a:	82 0f       	add	r24, r18
    526c:	93 1f       	adc	r25, r19
    526e:	fc 01       	movw	r30, r24
    5270:	b5 96       	adiw	r30, 0x25	; 37
    5272:	82 e0       	ldi	r24, 0x02	; 2
    5274:	80 83       	st	Z, r24

            switch( eAction )
    5276:	88 89       	ldd	r24, Y+16	; 0x10
    5278:	28 2f       	mov	r18, r24
    527a:	30 e0       	ldi	r19, 0x00	; 0
    527c:	3c 8b       	std	Y+20, r19	; 0x14
    527e:	2b 8b       	std	Y+19, r18	; 0x13
    5280:	8b 89       	ldd	r24, Y+19	; 0x13
    5282:	9c 89       	ldd	r25, Y+20	; 0x14
    5284:	82 30       	cpi	r24, 0x02	; 2
    5286:	91 05       	cpc	r25, r1
    5288:	09 f4       	brne	.+2      	; 0x528c <xTaskGenericNotify+0xba>
    528a:	46 c0       	rjmp	.+140    	; 0x5318 <xTaskGenericNotify+0x146>
    528c:	2b 89       	ldd	r18, Y+19	; 0x13
    528e:	3c 89       	ldd	r19, Y+20	; 0x14
    5290:	23 30       	cpi	r18, 0x03	; 3
    5292:	31 05       	cpc	r19, r1
    5294:	34 f4       	brge	.+12     	; 0x52a2 <xTaskGenericNotify+0xd0>
    5296:	8b 89       	ldd	r24, Y+19	; 0x13
    5298:	9c 89       	ldd	r25, Y+20	; 0x14
    529a:	81 30       	cpi	r24, 0x01	; 1
    529c:	91 05       	cpc	r25, r1
    529e:	71 f0       	breq	.+28     	; 0x52bc <xTaskGenericNotify+0xea>
    52a0:	93 c0       	rjmp	.+294    	; 0x53c8 <xTaskGenericNotify+0x1f6>
    52a2:	2b 89       	ldd	r18, Y+19	; 0x13
    52a4:	3c 89       	ldd	r19, Y+20	; 0x14
    52a6:	23 30       	cpi	r18, 0x03	; 3
    52a8:	31 05       	cpc	r19, r1
    52aa:	09 f4       	brne	.+2      	; 0x52ae <xTaskGenericNotify+0xdc>
    52ac:	5d c0       	rjmp	.+186    	; 0x5368 <xTaskGenericNotify+0x196>
    52ae:	8b 89       	ldd	r24, Y+19	; 0x13
    52b0:	9c 89       	ldd	r25, Y+20	; 0x14
    52b2:	84 30       	cpi	r24, 0x04	; 4
    52b4:	91 05       	cpc	r25, r1
    52b6:	09 f4       	brne	.+2      	; 0x52ba <xTaskGenericNotify+0xe8>
    52b8:	6d c0       	rjmp	.+218    	; 0x5394 <xTaskGenericNotify+0x1c2>
    52ba:	86 c0       	rjmp	.+268    	; 0x53c8 <xTaskGenericNotify+0x1f6>
            {
                case eSetBits:
                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] |= ulValue;
    52bc:	8b 85       	ldd	r24, Y+11	; 0x0b
    52be:	08 2f       	mov	r16, r24
    52c0:	10 e0       	ldi	r17, 0x00	; 0
    52c2:	8b 85       	ldd	r24, Y+11	; 0x0b
    52c4:	88 2f       	mov	r24, r24
    52c6:	90 e0       	ldi	r25, 0x00	; 0
    52c8:	2f 81       	ldd	r18, Y+7	; 0x07
    52ca:	38 85       	ldd	r19, Y+8	; 0x08
    52cc:	88 0f       	add	r24, r24
    52ce:	99 1f       	adc	r25, r25
    52d0:	88 0f       	add	r24, r24
    52d2:	99 1f       	adc	r25, r25
    52d4:	82 0f       	add	r24, r18
    52d6:	93 1f       	adc	r25, r19
    52d8:	fc 01       	movw	r30, r24
    52da:	b1 96       	adiw	r30, 0x21	; 33
    52dc:	20 81       	ld	r18, Z
    52de:	31 81       	ldd	r19, Z+1	; 0x01
    52e0:	42 81       	ldd	r20, Z+2	; 0x02
    52e2:	53 81       	ldd	r21, Z+3	; 0x03
    52e4:	8c 85       	ldd	r24, Y+12	; 0x0c
    52e6:	9d 85       	ldd	r25, Y+13	; 0x0d
    52e8:	ae 85       	ldd	r26, Y+14	; 0x0e
    52ea:	bf 85       	ldd	r27, Y+15	; 0x0f
    52ec:	ba 01       	movw	r22, r20
    52ee:	a9 01       	movw	r20, r18
    52f0:	48 2b       	or	r20, r24
    52f2:	59 2b       	or	r21, r25
    52f4:	6a 2b       	or	r22, r26
    52f6:	7b 2b       	or	r23, r27
    52f8:	2f 81       	ldd	r18, Y+7	; 0x07
    52fa:	38 85       	ldd	r19, Y+8	; 0x08
    52fc:	c8 01       	movw	r24, r16
    52fe:	88 0f       	add	r24, r24
    5300:	99 1f       	adc	r25, r25
    5302:	88 0f       	add	r24, r24
    5304:	99 1f       	adc	r25, r25
    5306:	82 0f       	add	r24, r18
    5308:	93 1f       	adc	r25, r19
    530a:	fc 01       	movw	r30, r24
    530c:	b1 96       	adiw	r30, 0x21	; 33
    530e:	40 83       	st	Z, r20
    5310:	51 83       	std	Z+1, r21	; 0x01
    5312:	62 83       	std	Z+2, r22	; 0x02
    5314:	73 83       	std	Z+3, r23	; 0x03
    5316:	58 c0       	rjmp	.+176    	; 0x53c8 <xTaskGenericNotify+0x1f6>
                    break;

                case eIncrement:
                    ( pxTCB->ulNotifiedValue[ uxIndexToNotify ] )++;
    5318:	8b 85       	ldd	r24, Y+11	; 0x0b
    531a:	08 2f       	mov	r16, r24
    531c:	10 e0       	ldi	r17, 0x00	; 0
    531e:	2f 81       	ldd	r18, Y+7	; 0x07
    5320:	38 85       	ldd	r19, Y+8	; 0x08
    5322:	c8 01       	movw	r24, r16
    5324:	88 0f       	add	r24, r24
    5326:	99 1f       	adc	r25, r25
    5328:	88 0f       	add	r24, r24
    532a:	99 1f       	adc	r25, r25
    532c:	82 0f       	add	r24, r18
    532e:	93 1f       	adc	r25, r19
    5330:	fc 01       	movw	r30, r24
    5332:	b1 96       	adiw	r30, 0x21	; 33
    5334:	80 81       	ld	r24, Z
    5336:	91 81       	ldd	r25, Z+1	; 0x01
    5338:	a2 81       	ldd	r26, Z+2	; 0x02
    533a:	b3 81       	ldd	r27, Z+3	; 0x03
    533c:	ac 01       	movw	r20, r24
    533e:	bd 01       	movw	r22, r26
    5340:	4f 5f       	subi	r20, 0xFF	; 255
    5342:	5f 4f       	sbci	r21, 0xFF	; 255
    5344:	6f 4f       	sbci	r22, 0xFF	; 255
    5346:	7f 4f       	sbci	r23, 0xFF	; 255
    5348:	2f 81       	ldd	r18, Y+7	; 0x07
    534a:	38 85       	ldd	r19, Y+8	; 0x08
    534c:	c8 01       	movw	r24, r16
    534e:	88 0f       	add	r24, r24
    5350:	99 1f       	adc	r25, r25
    5352:	88 0f       	add	r24, r24
    5354:	99 1f       	adc	r25, r25
    5356:	82 0f       	add	r24, r18
    5358:	93 1f       	adc	r25, r19
    535a:	fc 01       	movw	r30, r24
    535c:	b1 96       	adiw	r30, 0x21	; 33
    535e:	40 83       	st	Z, r20
    5360:	51 83       	std	Z+1, r21	; 0x01
    5362:	62 83       	std	Z+2, r22	; 0x02
    5364:	73 83       	std	Z+3, r23	; 0x03
    5366:	30 c0       	rjmp	.+96     	; 0x53c8 <xTaskGenericNotify+0x1f6>
                    break;

                case eSetValueWithOverwrite:
                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
    5368:	8b 85       	ldd	r24, Y+11	; 0x0b
    536a:	88 2f       	mov	r24, r24
    536c:	90 e0       	ldi	r25, 0x00	; 0
    536e:	2f 81       	ldd	r18, Y+7	; 0x07
    5370:	38 85       	ldd	r19, Y+8	; 0x08
    5372:	88 0f       	add	r24, r24
    5374:	99 1f       	adc	r25, r25
    5376:	88 0f       	add	r24, r24
    5378:	99 1f       	adc	r25, r25
    537a:	82 0f       	add	r24, r18
    537c:	93 1f       	adc	r25, r19
    537e:	fc 01       	movw	r30, r24
    5380:	b1 96       	adiw	r30, 0x21	; 33
    5382:	8c 85       	ldd	r24, Y+12	; 0x0c
    5384:	9d 85       	ldd	r25, Y+13	; 0x0d
    5386:	ae 85       	ldd	r26, Y+14	; 0x0e
    5388:	bf 85       	ldd	r27, Y+15	; 0x0f
    538a:	80 83       	st	Z, r24
    538c:	91 83       	std	Z+1, r25	; 0x01
    538e:	a2 83       	std	Z+2, r26	; 0x02
    5390:	b3 83       	std	Z+3, r27	; 0x03
    5392:	1a c0       	rjmp	.+52     	; 0x53c8 <xTaskGenericNotify+0x1f6>
                    break;

                case eSetValueWithoutOverwrite:

                    if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    5394:	8d 81       	ldd	r24, Y+5	; 0x05
    5396:	82 30       	cpi	r24, 0x02	; 2
    5398:	b1 f0       	breq	.+44     	; 0x53c6 <xTaskGenericNotify+0x1f4>
                    {
                        pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
    539a:	8b 85       	ldd	r24, Y+11	; 0x0b
    539c:	88 2f       	mov	r24, r24
    539e:	90 e0       	ldi	r25, 0x00	; 0
    53a0:	2f 81       	ldd	r18, Y+7	; 0x07
    53a2:	38 85       	ldd	r19, Y+8	; 0x08
    53a4:	88 0f       	add	r24, r24
    53a6:	99 1f       	adc	r25, r25
    53a8:	88 0f       	add	r24, r24
    53aa:	99 1f       	adc	r25, r25
    53ac:	82 0f       	add	r24, r18
    53ae:	93 1f       	adc	r25, r19
    53b0:	fc 01       	movw	r30, r24
    53b2:	b1 96       	adiw	r30, 0x21	; 33
    53b4:	8c 85       	ldd	r24, Y+12	; 0x0c
    53b6:	9d 85       	ldd	r25, Y+13	; 0x0d
    53b8:	ae 85       	ldd	r26, Y+14	; 0x0e
    53ba:	bf 85       	ldd	r27, Y+15	; 0x0f
    53bc:	80 83       	st	Z, r24
    53be:	91 83       	std	Z+1, r25	; 0x01
    53c0:	a2 83       	std	Z+2, r26	; 0x02
    53c2:	b3 83       	std	Z+3, r27	; 0x03
    53c4:	01 c0       	rjmp	.+2      	; 0x53c8 <xTaskGenericNotify+0x1f6>
                    }
                    else
                    {
                        /* The value could not be written to the task. */
                        xReturn = pdFAIL;
    53c6:	1e 82       	std	Y+6, r1	; 0x06

            traceTASK_NOTIFY( uxIndexToNotify );

            /* If the task is in the blocked state specifically to wait for a
             * notification then unblock it now. */
            if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    53c8:	8d 81       	ldd	r24, Y+5	; 0x05
    53ca:	81 30       	cpi	r24, 0x01	; 1
    53cc:	09 f0       	breq	.+2      	; 0x53d0 <xTaskGenericNotify+0x1fe>
    53ce:	af c0       	rjmp	.+350    	; 0x552e <xTaskGenericNotify+0x35c>
            {
                listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
    53d0:	ef 81       	ldd	r30, Y+7	; 0x07
    53d2:	f8 85       	ldd	r31, Y+8	; 0x08
    53d4:	82 85       	ldd	r24, Z+10	; 0x0a
    53d6:	93 85       	ldd	r25, Z+11	; 0x0b
    53d8:	9c 83       	std	Y+4, r25	; 0x04
    53da:	8b 83       	std	Y+3, r24	; 0x03
    53dc:	ef 81       	ldd	r30, Y+7	; 0x07
    53de:	f8 85       	ldd	r31, Y+8	; 0x08
    53e0:	a4 81       	ldd	r26, Z+4	; 0x04
    53e2:	b5 81       	ldd	r27, Z+5	; 0x05
    53e4:	ef 81       	ldd	r30, Y+7	; 0x07
    53e6:	f8 85       	ldd	r31, Y+8	; 0x08
    53e8:	86 81       	ldd	r24, Z+6	; 0x06
    53ea:	97 81       	ldd	r25, Z+7	; 0x07
    53ec:	15 96       	adiw	r26, 0x05	; 5
    53ee:	9c 93       	st	X, r25
    53f0:	8e 93       	st	-X, r24
    53f2:	14 97       	sbiw	r26, 0x04	; 4
    53f4:	ef 81       	ldd	r30, Y+7	; 0x07
    53f6:	f8 85       	ldd	r31, Y+8	; 0x08
    53f8:	a6 81       	ldd	r26, Z+6	; 0x06
    53fa:	b7 81       	ldd	r27, Z+7	; 0x07
    53fc:	ef 81       	ldd	r30, Y+7	; 0x07
    53fe:	f8 85       	ldd	r31, Y+8	; 0x08
    5400:	84 81       	ldd	r24, Z+4	; 0x04
    5402:	95 81       	ldd	r25, Z+5	; 0x05
    5404:	13 96       	adiw	r26, 0x03	; 3
    5406:	9c 93       	st	X, r25
    5408:	8e 93       	st	-X, r24
    540a:	12 97       	sbiw	r26, 0x02	; 2
    540c:	eb 81       	ldd	r30, Y+3	; 0x03
    540e:	fc 81       	ldd	r31, Y+4	; 0x04
    5410:	21 81       	ldd	r18, Z+1	; 0x01
    5412:	32 81       	ldd	r19, Z+2	; 0x02
    5414:	8f 81       	ldd	r24, Y+7	; 0x07
    5416:	98 85       	ldd	r25, Y+8	; 0x08
    5418:	02 96       	adiw	r24, 0x02	; 2
    541a:	28 17       	cp	r18, r24
    541c:	39 07       	cpc	r19, r25
    541e:	41 f4       	brne	.+16     	; 0x5430 <xTaskGenericNotify+0x25e>
    5420:	ef 81       	ldd	r30, Y+7	; 0x07
    5422:	f8 85       	ldd	r31, Y+8	; 0x08
    5424:	86 81       	ldd	r24, Z+6	; 0x06
    5426:	97 81       	ldd	r25, Z+7	; 0x07
    5428:	eb 81       	ldd	r30, Y+3	; 0x03
    542a:	fc 81       	ldd	r31, Y+4	; 0x04
    542c:	92 83       	std	Z+2, r25	; 0x02
    542e:	81 83       	std	Z+1, r24	; 0x01
    5430:	ef 81       	ldd	r30, Y+7	; 0x07
    5432:	f8 85       	ldd	r31, Y+8	; 0x08
    5434:	13 86       	std	Z+11, r1	; 0x0b
    5436:	12 86       	std	Z+10, r1	; 0x0a
    5438:	eb 81       	ldd	r30, Y+3	; 0x03
    543a:	fc 81       	ldd	r31, Y+4	; 0x04
    543c:	80 81       	ld	r24, Z
    543e:	81 50       	subi	r24, 0x01	; 1
    5440:	eb 81       	ldd	r30, Y+3	; 0x03
    5442:	fc 81       	ldd	r31, Y+4	; 0x04
    5444:	80 83       	st	Z, r24
                prvAddTaskToReadyList( pxTCB );
    5446:	ef 81       	ldd	r30, Y+7	; 0x07
    5448:	f8 85       	ldd	r31, Y+8	; 0x08
    544a:	96 89       	ldd	r25, Z+22	; 0x16
    544c:	80 91 62 08 	lds	r24, 0x0862
    5450:	89 17       	cp	r24, r25
    5452:	28 f4       	brcc	.+10     	; 0x545e <xTaskGenericNotify+0x28c>
    5454:	ef 81       	ldd	r30, Y+7	; 0x07
    5456:	f8 85       	ldd	r31, Y+8	; 0x08
    5458:	86 89       	ldd	r24, Z+22	; 0x16
    545a:	80 93 62 08 	sts	0x0862, r24
    545e:	ef 81       	ldd	r30, Y+7	; 0x07
    5460:	f8 85       	ldd	r31, Y+8	; 0x08
    5462:	86 89       	ldd	r24, Z+22	; 0x16
    5464:	28 2f       	mov	r18, r24
    5466:	30 e0       	ldi	r19, 0x00	; 0
    5468:	c9 01       	movw	r24, r18
    546a:	88 0f       	add	r24, r24
    546c:	99 1f       	adc	r25, r25
    546e:	88 0f       	add	r24, r24
    5470:	99 1f       	adc	r25, r25
    5472:	88 0f       	add	r24, r24
    5474:	99 1f       	adc	r25, r25
    5476:	82 0f       	add	r24, r18
    5478:	93 1f       	adc	r25, r19
    547a:	fc 01       	movw	r30, r24
    547c:	e2 59       	subi	r30, 0x92	; 146
    547e:	f7 4f       	sbci	r31, 0xF7	; 247
    5480:	81 81       	ldd	r24, Z+1	; 0x01
    5482:	92 81       	ldd	r25, Z+2	; 0x02
    5484:	9a 83       	std	Y+2, r25	; 0x02
    5486:	89 83       	std	Y+1, r24	; 0x01
    5488:	ef 81       	ldd	r30, Y+7	; 0x07
    548a:	f8 85       	ldd	r31, Y+8	; 0x08
    548c:	89 81       	ldd	r24, Y+1	; 0x01
    548e:	9a 81       	ldd	r25, Y+2	; 0x02
    5490:	95 83       	std	Z+5, r25	; 0x05
    5492:	84 83       	std	Z+4, r24	; 0x04
    5494:	e9 81       	ldd	r30, Y+1	; 0x01
    5496:	fa 81       	ldd	r31, Y+2	; 0x02
    5498:	84 81       	ldd	r24, Z+4	; 0x04
    549a:	95 81       	ldd	r25, Z+5	; 0x05
    549c:	ef 81       	ldd	r30, Y+7	; 0x07
    549e:	f8 85       	ldd	r31, Y+8	; 0x08
    54a0:	97 83       	std	Z+7, r25	; 0x07
    54a2:	86 83       	std	Z+6, r24	; 0x06
    54a4:	e9 81       	ldd	r30, Y+1	; 0x01
    54a6:	fa 81       	ldd	r31, Y+2	; 0x02
    54a8:	04 80       	ldd	r0, Z+4	; 0x04
    54aa:	f5 81       	ldd	r31, Z+5	; 0x05
    54ac:	e0 2d       	mov	r30, r0
    54ae:	8f 81       	ldd	r24, Y+7	; 0x07
    54b0:	98 85       	ldd	r25, Y+8	; 0x08
    54b2:	02 96       	adiw	r24, 0x02	; 2
    54b4:	93 83       	std	Z+3, r25	; 0x03
    54b6:	82 83       	std	Z+2, r24	; 0x02
    54b8:	8f 81       	ldd	r24, Y+7	; 0x07
    54ba:	98 85       	ldd	r25, Y+8	; 0x08
    54bc:	02 96       	adiw	r24, 0x02	; 2
    54be:	e9 81       	ldd	r30, Y+1	; 0x01
    54c0:	fa 81       	ldd	r31, Y+2	; 0x02
    54c2:	95 83       	std	Z+5, r25	; 0x05
    54c4:	84 83       	std	Z+4, r24	; 0x04
    54c6:	ef 81       	ldd	r30, Y+7	; 0x07
    54c8:	f8 85       	ldd	r31, Y+8	; 0x08
    54ca:	86 89       	ldd	r24, Z+22	; 0x16
    54cc:	28 2f       	mov	r18, r24
    54ce:	30 e0       	ldi	r19, 0x00	; 0
    54d0:	c9 01       	movw	r24, r18
    54d2:	88 0f       	add	r24, r24
    54d4:	99 1f       	adc	r25, r25
    54d6:	88 0f       	add	r24, r24
    54d8:	99 1f       	adc	r25, r25
    54da:	88 0f       	add	r24, r24
    54dc:	99 1f       	adc	r25, r25
    54de:	82 0f       	add	r24, r18
    54e0:	93 1f       	adc	r25, r19
    54e2:	82 59       	subi	r24, 0x92	; 146
    54e4:	97 4f       	sbci	r25, 0xF7	; 247
    54e6:	ef 81       	ldd	r30, Y+7	; 0x07
    54e8:	f8 85       	ldd	r31, Y+8	; 0x08
    54ea:	93 87       	std	Z+11, r25	; 0x0b
    54ec:	82 87       	std	Z+10, r24	; 0x0a
    54ee:	ef 81       	ldd	r30, Y+7	; 0x07
    54f0:	f8 85       	ldd	r31, Y+8	; 0x08
    54f2:	86 89       	ldd	r24, Z+22	; 0x16
    54f4:	28 2f       	mov	r18, r24
    54f6:	30 e0       	ldi	r19, 0x00	; 0
    54f8:	c9 01       	movw	r24, r18
    54fa:	88 0f       	add	r24, r24
    54fc:	99 1f       	adc	r25, r25
    54fe:	88 0f       	add	r24, r24
    5500:	99 1f       	adc	r25, r25
    5502:	88 0f       	add	r24, r24
    5504:	99 1f       	adc	r25, r25
    5506:	82 0f       	add	r24, r18
    5508:	93 1f       	adc	r25, r19
    550a:	fc 01       	movw	r30, r24
    550c:	e2 59       	subi	r30, 0x92	; 146
    550e:	f7 4f       	sbci	r31, 0xF7	; 247
    5510:	80 81       	ld	r24, Z
    5512:	8f 5f       	subi	r24, 0xFF	; 255
    5514:	80 83       	st	Z, r24
                         * earliest possible time. */
                        prvResetNextTaskUnblockTime();
                    }
                #endif

                if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    5516:	ef 81       	ldd	r30, Y+7	; 0x07
    5518:	f8 85       	ldd	r31, Y+8	; 0x08
    551a:	96 89       	ldd	r25, Z+22	; 0x16
    551c:	e0 91 5c 08 	lds	r30, 0x085C
    5520:	f0 91 5d 08 	lds	r31, 0x085D
    5524:	86 89       	ldd	r24, Z+22	; 0x16
    5526:	89 17       	cp	r24, r25
    5528:	10 f4       	brcc	.+4      	; 0x552e <xTaskGenericNotify+0x35c>
                {
                    /* The notified task has a priority above the currently
                     * executing task so a yield is required. */
                    taskYIELD_IF_USING_PREEMPTION();
    552a:	0e 94 72 09 	call	0x12e4	; 0x12e4 <vPortYield>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        taskEXIT_CRITICAL();
    552e:	0f 90       	pop	r0
    5530:	0f be       	out	0x3f, r0	; 63

        return xReturn;
    5532:	8e 81       	ldd	r24, Y+6	; 0x06
    }
    5534:	64 96       	adiw	r28, 0x14	; 20
    5536:	0f b6       	in	r0, 0x3f	; 63
    5538:	f8 94       	cli
    553a:	de bf       	out	0x3e, r29	; 62
    553c:	0f be       	out	0x3f, r0	; 63
    553e:	cd bf       	out	0x3d, r28	; 61
    5540:	cf 91       	pop	r28
    5542:	df 91       	pop	r29
    5544:	1f 91       	pop	r17
    5546:	0f 91       	pop	r16
    5548:	ff 90       	pop	r15
    554a:	ef 90       	pop	r14
    554c:	08 95       	ret

0000554e <xTaskGenericNotifyFromISR>:
                                          UBaseType_t uxIndexToNotify,
                                          uint32_t ulValue,
                                          eNotifyAction eAction,
                                          uint32_t * pulPreviousNotificationValue,
                                          BaseType_t * pxHigherPriorityTaskWoken )
    {
    554e:	cf 92       	push	r12
    5550:	df 92       	push	r13
    5552:	ef 92       	push	r14
    5554:	ff 92       	push	r15
    5556:	0f 93       	push	r16
    5558:	1f 93       	push	r17
    555a:	df 93       	push	r29
    555c:	cf 93       	push	r28
    555e:	cd b7       	in	r28, 0x3d	; 61
    5560:	de b7       	in	r29, 0x3e	; 62
    5562:	69 97       	sbiw	r28, 0x19	; 25
    5564:	0f b6       	in	r0, 0x3f	; 63
    5566:	f8 94       	cli
    5568:	de bf       	out	0x3e, r29	; 62
    556a:	0f be       	out	0x3f, r0	; 63
    556c:	cd bf       	out	0x3d, r28	; 61
    556e:	9d 87       	std	Y+13, r25	; 0x0d
    5570:	8c 87       	std	Y+12, r24	; 0x0c
    5572:	6e 87       	std	Y+14, r22	; 0x0e
    5574:	2f 87       	std	Y+15, r18	; 0x0f
    5576:	38 8b       	std	Y+16, r19	; 0x10
    5578:	49 8b       	std	Y+17, r20	; 0x11
    557a:	5a 8b       	std	Y+18, r21	; 0x12
    557c:	0b 8b       	std	Y+19, r16	; 0x13
    557e:	fd 8a       	std	Y+21, r15	; 0x15
    5580:	ec 8a       	std	Y+20, r14	; 0x14
    5582:	df 8a       	std	Y+23, r13	; 0x17
    5584:	ce 8a       	std	Y+22, r12	; 0x16
        TCB_t * pxTCB;
        uint8_t ucOriginalNotifyState;
        BaseType_t xReturn = pdPASS;
    5586:	81 e0       	ldi	r24, 0x01	; 1
    5588:	88 87       	std	Y+8, r24	; 0x08
         * simple as possible.  More information (albeit Cortex-M specific) is
         * provided on the following link:
         * https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
        portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

        pxTCB = xTaskToNotify;
    558a:	8c 85       	ldd	r24, Y+12	; 0x0c
    558c:	9d 85       	ldd	r25, Y+13	; 0x0d
    558e:	9b 87       	std	Y+11, r25	; 0x0b
    5590:	8a 87       	std	Y+10, r24	; 0x0a

        uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    5592:	1f 82       	std	Y+7, r1	; 0x07
        {
            if( pulPreviousNotificationValue != NULL )
    5594:	8c 89       	ldd	r24, Y+20	; 0x14
    5596:	9d 89       	ldd	r25, Y+21	; 0x15
    5598:	00 97       	sbiw	r24, 0x00	; 0
    559a:	b9 f0       	breq	.+46     	; 0x55ca <xTaskGenericNotifyFromISR+0x7c>
            {
                *pulPreviousNotificationValue = pxTCB->ulNotifiedValue[ uxIndexToNotify ];
    559c:	8e 85       	ldd	r24, Y+14	; 0x0e
    559e:	88 2f       	mov	r24, r24
    55a0:	90 e0       	ldi	r25, 0x00	; 0
    55a2:	2a 85       	ldd	r18, Y+10	; 0x0a
    55a4:	3b 85       	ldd	r19, Y+11	; 0x0b
    55a6:	88 0f       	add	r24, r24
    55a8:	99 1f       	adc	r25, r25
    55aa:	88 0f       	add	r24, r24
    55ac:	99 1f       	adc	r25, r25
    55ae:	82 0f       	add	r24, r18
    55b0:	93 1f       	adc	r25, r19
    55b2:	fc 01       	movw	r30, r24
    55b4:	b1 96       	adiw	r30, 0x21	; 33
    55b6:	80 81       	ld	r24, Z
    55b8:	91 81       	ldd	r25, Z+1	; 0x01
    55ba:	a2 81       	ldd	r26, Z+2	; 0x02
    55bc:	b3 81       	ldd	r27, Z+3	; 0x03
    55be:	ec 89       	ldd	r30, Y+20	; 0x14
    55c0:	fd 89       	ldd	r31, Y+21	; 0x15
    55c2:	80 83       	st	Z, r24
    55c4:	91 83       	std	Z+1, r25	; 0x01
    55c6:	a2 83       	std	Z+2, r26	; 0x02
    55c8:	b3 83       	std	Z+3, r27	; 0x03
            }

            ucOriginalNotifyState = pxTCB->ucNotifyState[ uxIndexToNotify ];
    55ca:	8e 85       	ldd	r24, Y+14	; 0x0e
    55cc:	28 2f       	mov	r18, r24
    55ce:	30 e0       	ldi	r19, 0x00	; 0
    55d0:	8a 85       	ldd	r24, Y+10	; 0x0a
    55d2:	9b 85       	ldd	r25, Y+11	; 0x0b
    55d4:	82 0f       	add	r24, r18
    55d6:	93 1f       	adc	r25, r19
    55d8:	fc 01       	movw	r30, r24
    55da:	b5 96       	adiw	r30, 0x25	; 37
    55dc:	80 81       	ld	r24, Z
    55de:	89 87       	std	Y+9, r24	; 0x09
            pxTCB->ucNotifyState[ uxIndexToNotify ] = taskNOTIFICATION_RECEIVED;
    55e0:	8e 85       	ldd	r24, Y+14	; 0x0e
    55e2:	28 2f       	mov	r18, r24
    55e4:	30 e0       	ldi	r19, 0x00	; 0
    55e6:	8a 85       	ldd	r24, Y+10	; 0x0a
    55e8:	9b 85       	ldd	r25, Y+11	; 0x0b
    55ea:	82 0f       	add	r24, r18
    55ec:	93 1f       	adc	r25, r19
    55ee:	fc 01       	movw	r30, r24
    55f0:	b5 96       	adiw	r30, 0x25	; 37
    55f2:	82 e0       	ldi	r24, 0x02	; 2
    55f4:	80 83       	st	Z, r24

            switch( eAction )
    55f6:	8b 89       	ldd	r24, Y+19	; 0x13
    55f8:	28 2f       	mov	r18, r24
    55fa:	30 e0       	ldi	r19, 0x00	; 0
    55fc:	39 8f       	std	Y+25, r19	; 0x19
    55fe:	28 8f       	std	Y+24, r18	; 0x18
    5600:	88 8d       	ldd	r24, Y+24	; 0x18
    5602:	99 8d       	ldd	r25, Y+25	; 0x19
    5604:	82 30       	cpi	r24, 0x02	; 2
    5606:	91 05       	cpc	r25, r1
    5608:	09 f4       	brne	.+2      	; 0x560c <xTaskGenericNotifyFromISR+0xbe>
    560a:	46 c0       	rjmp	.+140    	; 0x5698 <xTaskGenericNotifyFromISR+0x14a>
    560c:	28 8d       	ldd	r18, Y+24	; 0x18
    560e:	39 8d       	ldd	r19, Y+25	; 0x19
    5610:	23 30       	cpi	r18, 0x03	; 3
    5612:	31 05       	cpc	r19, r1
    5614:	34 f4       	brge	.+12     	; 0x5622 <xTaskGenericNotifyFromISR+0xd4>
    5616:	88 8d       	ldd	r24, Y+24	; 0x18
    5618:	99 8d       	ldd	r25, Y+25	; 0x19
    561a:	81 30       	cpi	r24, 0x01	; 1
    561c:	91 05       	cpc	r25, r1
    561e:	71 f0       	breq	.+28     	; 0x563c <xTaskGenericNotifyFromISR+0xee>
    5620:	93 c0       	rjmp	.+294    	; 0x5748 <xTaskGenericNotifyFromISR+0x1fa>
    5622:	28 8d       	ldd	r18, Y+24	; 0x18
    5624:	39 8d       	ldd	r19, Y+25	; 0x19
    5626:	23 30       	cpi	r18, 0x03	; 3
    5628:	31 05       	cpc	r19, r1
    562a:	09 f4       	brne	.+2      	; 0x562e <xTaskGenericNotifyFromISR+0xe0>
    562c:	5d c0       	rjmp	.+186    	; 0x56e8 <xTaskGenericNotifyFromISR+0x19a>
    562e:	88 8d       	ldd	r24, Y+24	; 0x18
    5630:	99 8d       	ldd	r25, Y+25	; 0x19
    5632:	84 30       	cpi	r24, 0x04	; 4
    5634:	91 05       	cpc	r25, r1
    5636:	09 f4       	brne	.+2      	; 0x563a <xTaskGenericNotifyFromISR+0xec>
    5638:	6d c0       	rjmp	.+218    	; 0x5714 <xTaskGenericNotifyFromISR+0x1c6>
    563a:	86 c0       	rjmp	.+268    	; 0x5748 <xTaskGenericNotifyFromISR+0x1fa>
            {
                case eSetBits:
                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] |= ulValue;
    563c:	8e 85       	ldd	r24, Y+14	; 0x0e
    563e:	08 2f       	mov	r16, r24
    5640:	10 e0       	ldi	r17, 0x00	; 0
    5642:	8e 85       	ldd	r24, Y+14	; 0x0e
    5644:	88 2f       	mov	r24, r24
    5646:	90 e0       	ldi	r25, 0x00	; 0
    5648:	2a 85       	ldd	r18, Y+10	; 0x0a
    564a:	3b 85       	ldd	r19, Y+11	; 0x0b
    564c:	88 0f       	add	r24, r24
    564e:	99 1f       	adc	r25, r25
    5650:	88 0f       	add	r24, r24
    5652:	99 1f       	adc	r25, r25
    5654:	82 0f       	add	r24, r18
    5656:	93 1f       	adc	r25, r19
    5658:	fc 01       	movw	r30, r24
    565a:	b1 96       	adiw	r30, 0x21	; 33
    565c:	20 81       	ld	r18, Z
    565e:	31 81       	ldd	r19, Z+1	; 0x01
    5660:	42 81       	ldd	r20, Z+2	; 0x02
    5662:	53 81       	ldd	r21, Z+3	; 0x03
    5664:	8f 85       	ldd	r24, Y+15	; 0x0f
    5666:	98 89       	ldd	r25, Y+16	; 0x10
    5668:	a9 89       	ldd	r26, Y+17	; 0x11
    566a:	ba 89       	ldd	r27, Y+18	; 0x12
    566c:	ba 01       	movw	r22, r20
    566e:	a9 01       	movw	r20, r18
    5670:	48 2b       	or	r20, r24
    5672:	59 2b       	or	r21, r25
    5674:	6a 2b       	or	r22, r26
    5676:	7b 2b       	or	r23, r27
    5678:	2a 85       	ldd	r18, Y+10	; 0x0a
    567a:	3b 85       	ldd	r19, Y+11	; 0x0b
    567c:	c8 01       	movw	r24, r16
    567e:	88 0f       	add	r24, r24
    5680:	99 1f       	adc	r25, r25
    5682:	88 0f       	add	r24, r24
    5684:	99 1f       	adc	r25, r25
    5686:	82 0f       	add	r24, r18
    5688:	93 1f       	adc	r25, r19
    568a:	fc 01       	movw	r30, r24
    568c:	b1 96       	adiw	r30, 0x21	; 33
    568e:	40 83       	st	Z, r20
    5690:	51 83       	std	Z+1, r21	; 0x01
    5692:	62 83       	std	Z+2, r22	; 0x02
    5694:	73 83       	std	Z+3, r23	; 0x03
    5696:	58 c0       	rjmp	.+176    	; 0x5748 <xTaskGenericNotifyFromISR+0x1fa>
                    break;

                case eIncrement:
                    ( pxTCB->ulNotifiedValue[ uxIndexToNotify ] )++;
    5698:	8e 85       	ldd	r24, Y+14	; 0x0e
    569a:	08 2f       	mov	r16, r24
    569c:	10 e0       	ldi	r17, 0x00	; 0
    569e:	2a 85       	ldd	r18, Y+10	; 0x0a
    56a0:	3b 85       	ldd	r19, Y+11	; 0x0b
    56a2:	c8 01       	movw	r24, r16
    56a4:	88 0f       	add	r24, r24
    56a6:	99 1f       	adc	r25, r25
    56a8:	88 0f       	add	r24, r24
    56aa:	99 1f       	adc	r25, r25
    56ac:	82 0f       	add	r24, r18
    56ae:	93 1f       	adc	r25, r19
    56b0:	fc 01       	movw	r30, r24
    56b2:	b1 96       	adiw	r30, 0x21	; 33
    56b4:	80 81       	ld	r24, Z
    56b6:	91 81       	ldd	r25, Z+1	; 0x01
    56b8:	a2 81       	ldd	r26, Z+2	; 0x02
    56ba:	b3 81       	ldd	r27, Z+3	; 0x03
    56bc:	ac 01       	movw	r20, r24
    56be:	bd 01       	movw	r22, r26
    56c0:	4f 5f       	subi	r20, 0xFF	; 255
    56c2:	5f 4f       	sbci	r21, 0xFF	; 255
    56c4:	6f 4f       	sbci	r22, 0xFF	; 255
    56c6:	7f 4f       	sbci	r23, 0xFF	; 255
    56c8:	2a 85       	ldd	r18, Y+10	; 0x0a
    56ca:	3b 85       	ldd	r19, Y+11	; 0x0b
    56cc:	c8 01       	movw	r24, r16
    56ce:	88 0f       	add	r24, r24
    56d0:	99 1f       	adc	r25, r25
    56d2:	88 0f       	add	r24, r24
    56d4:	99 1f       	adc	r25, r25
    56d6:	82 0f       	add	r24, r18
    56d8:	93 1f       	adc	r25, r19
    56da:	fc 01       	movw	r30, r24
    56dc:	b1 96       	adiw	r30, 0x21	; 33
    56de:	40 83       	st	Z, r20
    56e0:	51 83       	std	Z+1, r21	; 0x01
    56e2:	62 83       	std	Z+2, r22	; 0x02
    56e4:	73 83       	std	Z+3, r23	; 0x03
    56e6:	30 c0       	rjmp	.+96     	; 0x5748 <xTaskGenericNotifyFromISR+0x1fa>
                    break;

                case eSetValueWithOverwrite:
                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
    56e8:	8e 85       	ldd	r24, Y+14	; 0x0e
    56ea:	88 2f       	mov	r24, r24
    56ec:	90 e0       	ldi	r25, 0x00	; 0
    56ee:	2a 85       	ldd	r18, Y+10	; 0x0a
    56f0:	3b 85       	ldd	r19, Y+11	; 0x0b
    56f2:	88 0f       	add	r24, r24
    56f4:	99 1f       	adc	r25, r25
    56f6:	88 0f       	add	r24, r24
    56f8:	99 1f       	adc	r25, r25
    56fa:	82 0f       	add	r24, r18
    56fc:	93 1f       	adc	r25, r19
    56fe:	fc 01       	movw	r30, r24
    5700:	b1 96       	adiw	r30, 0x21	; 33
    5702:	8f 85       	ldd	r24, Y+15	; 0x0f
    5704:	98 89       	ldd	r25, Y+16	; 0x10
    5706:	a9 89       	ldd	r26, Y+17	; 0x11
    5708:	ba 89       	ldd	r27, Y+18	; 0x12
    570a:	80 83       	st	Z, r24
    570c:	91 83       	std	Z+1, r25	; 0x01
    570e:	a2 83       	std	Z+2, r26	; 0x02
    5710:	b3 83       	std	Z+3, r27	; 0x03
    5712:	1a c0       	rjmp	.+52     	; 0x5748 <xTaskGenericNotifyFromISR+0x1fa>
                    break;

                case eSetValueWithoutOverwrite:

                    if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    5714:	89 85       	ldd	r24, Y+9	; 0x09
    5716:	82 30       	cpi	r24, 0x02	; 2
    5718:	b1 f0       	breq	.+44     	; 0x5746 <xTaskGenericNotifyFromISR+0x1f8>
                    {
                        pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
    571a:	8e 85       	ldd	r24, Y+14	; 0x0e
    571c:	88 2f       	mov	r24, r24
    571e:	90 e0       	ldi	r25, 0x00	; 0
    5720:	2a 85       	ldd	r18, Y+10	; 0x0a
    5722:	3b 85       	ldd	r19, Y+11	; 0x0b
    5724:	88 0f       	add	r24, r24
    5726:	99 1f       	adc	r25, r25
    5728:	88 0f       	add	r24, r24
    572a:	99 1f       	adc	r25, r25
    572c:	82 0f       	add	r24, r18
    572e:	93 1f       	adc	r25, r19
    5730:	fc 01       	movw	r30, r24
    5732:	b1 96       	adiw	r30, 0x21	; 33
    5734:	8f 85       	ldd	r24, Y+15	; 0x0f
    5736:	98 89       	ldd	r25, Y+16	; 0x10
    5738:	a9 89       	ldd	r26, Y+17	; 0x11
    573a:	ba 89       	ldd	r27, Y+18	; 0x12
    573c:	80 83       	st	Z, r24
    573e:	91 83       	std	Z+1, r25	; 0x01
    5740:	a2 83       	std	Z+2, r26	; 0x02
    5742:	b3 83       	std	Z+3, r27	; 0x03
    5744:	01 c0       	rjmp	.+2      	; 0x5748 <xTaskGenericNotifyFromISR+0x1fa>
                    }
                    else
                    {
                        /* The value could not be written to the task. */
                        xReturn = pdFAIL;
    5746:	18 86       	std	Y+8, r1	; 0x08

            traceTASK_NOTIFY_FROM_ISR( uxIndexToNotify );

            /* If the task is in the blocked state specifically to wait for a
             * notification then unblock it now. */
            if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    5748:	89 85       	ldd	r24, Y+9	; 0x09
    574a:	81 30       	cpi	r24, 0x01	; 1
    574c:	09 f0       	breq	.+2      	; 0x5750 <xTaskGenericNotifyFromISR+0x202>
    574e:	ee c0       	rjmp	.+476    	; 0x592c <xTaskGenericNotifyFromISR+0x3de>
            {
                /* The task should not have been on an event list. */
                configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

                if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    5750:	80 91 6d 08 	lds	r24, 0x086D
    5754:	88 23       	and	r24, r24
    5756:	09 f0       	breq	.+2      	; 0x575a <xTaskGenericNotifyFromISR+0x20c>
    5758:	a4 c0       	rjmp	.+328    	; 0x58a2 <xTaskGenericNotifyFromISR+0x354>
                {
                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
    575a:	ea 85       	ldd	r30, Y+10	; 0x0a
    575c:	fb 85       	ldd	r31, Y+11	; 0x0b
    575e:	82 85       	ldd	r24, Z+10	; 0x0a
    5760:	93 85       	ldd	r25, Z+11	; 0x0b
    5762:	9e 83       	std	Y+6, r25	; 0x06
    5764:	8d 83       	std	Y+5, r24	; 0x05
    5766:	ea 85       	ldd	r30, Y+10	; 0x0a
    5768:	fb 85       	ldd	r31, Y+11	; 0x0b
    576a:	a4 81       	ldd	r26, Z+4	; 0x04
    576c:	b5 81       	ldd	r27, Z+5	; 0x05
    576e:	ea 85       	ldd	r30, Y+10	; 0x0a
    5770:	fb 85       	ldd	r31, Y+11	; 0x0b
    5772:	86 81       	ldd	r24, Z+6	; 0x06
    5774:	97 81       	ldd	r25, Z+7	; 0x07
    5776:	15 96       	adiw	r26, 0x05	; 5
    5778:	9c 93       	st	X, r25
    577a:	8e 93       	st	-X, r24
    577c:	14 97       	sbiw	r26, 0x04	; 4
    577e:	ea 85       	ldd	r30, Y+10	; 0x0a
    5780:	fb 85       	ldd	r31, Y+11	; 0x0b
    5782:	a6 81       	ldd	r26, Z+6	; 0x06
    5784:	b7 81       	ldd	r27, Z+7	; 0x07
    5786:	ea 85       	ldd	r30, Y+10	; 0x0a
    5788:	fb 85       	ldd	r31, Y+11	; 0x0b
    578a:	84 81       	ldd	r24, Z+4	; 0x04
    578c:	95 81       	ldd	r25, Z+5	; 0x05
    578e:	13 96       	adiw	r26, 0x03	; 3
    5790:	9c 93       	st	X, r25
    5792:	8e 93       	st	-X, r24
    5794:	12 97       	sbiw	r26, 0x02	; 2
    5796:	ed 81       	ldd	r30, Y+5	; 0x05
    5798:	fe 81       	ldd	r31, Y+6	; 0x06
    579a:	21 81       	ldd	r18, Z+1	; 0x01
    579c:	32 81       	ldd	r19, Z+2	; 0x02
    579e:	8a 85       	ldd	r24, Y+10	; 0x0a
    57a0:	9b 85       	ldd	r25, Y+11	; 0x0b
    57a2:	02 96       	adiw	r24, 0x02	; 2
    57a4:	28 17       	cp	r18, r24
    57a6:	39 07       	cpc	r19, r25
    57a8:	41 f4       	brne	.+16     	; 0x57ba <xTaskGenericNotifyFromISR+0x26c>
    57aa:	ea 85       	ldd	r30, Y+10	; 0x0a
    57ac:	fb 85       	ldd	r31, Y+11	; 0x0b
    57ae:	86 81       	ldd	r24, Z+6	; 0x06
    57b0:	97 81       	ldd	r25, Z+7	; 0x07
    57b2:	ed 81       	ldd	r30, Y+5	; 0x05
    57b4:	fe 81       	ldd	r31, Y+6	; 0x06
    57b6:	92 83       	std	Z+2, r25	; 0x02
    57b8:	81 83       	std	Z+1, r24	; 0x01
    57ba:	ea 85       	ldd	r30, Y+10	; 0x0a
    57bc:	fb 85       	ldd	r31, Y+11	; 0x0b
    57be:	13 86       	std	Z+11, r1	; 0x0b
    57c0:	12 86       	std	Z+10, r1	; 0x0a
    57c2:	ed 81       	ldd	r30, Y+5	; 0x05
    57c4:	fe 81       	ldd	r31, Y+6	; 0x06
    57c6:	80 81       	ld	r24, Z
    57c8:	81 50       	subi	r24, 0x01	; 1
    57ca:	ed 81       	ldd	r30, Y+5	; 0x05
    57cc:	fe 81       	ldd	r31, Y+6	; 0x06
    57ce:	80 83       	st	Z, r24
                    prvAddTaskToReadyList( pxTCB );
    57d0:	ea 85       	ldd	r30, Y+10	; 0x0a
    57d2:	fb 85       	ldd	r31, Y+11	; 0x0b
    57d4:	96 89       	ldd	r25, Z+22	; 0x16
    57d6:	80 91 62 08 	lds	r24, 0x0862
    57da:	89 17       	cp	r24, r25
    57dc:	28 f4       	brcc	.+10     	; 0x57e8 <xTaskGenericNotifyFromISR+0x29a>
    57de:	ea 85       	ldd	r30, Y+10	; 0x0a
    57e0:	fb 85       	ldd	r31, Y+11	; 0x0b
    57e2:	86 89       	ldd	r24, Z+22	; 0x16
    57e4:	80 93 62 08 	sts	0x0862, r24
    57e8:	ea 85       	ldd	r30, Y+10	; 0x0a
    57ea:	fb 85       	ldd	r31, Y+11	; 0x0b
    57ec:	86 89       	ldd	r24, Z+22	; 0x16
    57ee:	28 2f       	mov	r18, r24
    57f0:	30 e0       	ldi	r19, 0x00	; 0
    57f2:	c9 01       	movw	r24, r18
    57f4:	88 0f       	add	r24, r24
    57f6:	99 1f       	adc	r25, r25
    57f8:	88 0f       	add	r24, r24
    57fa:	99 1f       	adc	r25, r25
    57fc:	88 0f       	add	r24, r24
    57fe:	99 1f       	adc	r25, r25
    5800:	82 0f       	add	r24, r18
    5802:	93 1f       	adc	r25, r19
    5804:	fc 01       	movw	r30, r24
    5806:	e2 59       	subi	r30, 0x92	; 146
    5808:	f7 4f       	sbci	r31, 0xF7	; 247
    580a:	81 81       	ldd	r24, Z+1	; 0x01
    580c:	92 81       	ldd	r25, Z+2	; 0x02
    580e:	9c 83       	std	Y+4, r25	; 0x04
    5810:	8b 83       	std	Y+3, r24	; 0x03
    5812:	ea 85       	ldd	r30, Y+10	; 0x0a
    5814:	fb 85       	ldd	r31, Y+11	; 0x0b
    5816:	8b 81       	ldd	r24, Y+3	; 0x03
    5818:	9c 81       	ldd	r25, Y+4	; 0x04
    581a:	95 83       	std	Z+5, r25	; 0x05
    581c:	84 83       	std	Z+4, r24	; 0x04
    581e:	eb 81       	ldd	r30, Y+3	; 0x03
    5820:	fc 81       	ldd	r31, Y+4	; 0x04
    5822:	84 81       	ldd	r24, Z+4	; 0x04
    5824:	95 81       	ldd	r25, Z+5	; 0x05
    5826:	ea 85       	ldd	r30, Y+10	; 0x0a
    5828:	fb 85       	ldd	r31, Y+11	; 0x0b
    582a:	97 83       	std	Z+7, r25	; 0x07
    582c:	86 83       	std	Z+6, r24	; 0x06
    582e:	eb 81       	ldd	r30, Y+3	; 0x03
    5830:	fc 81       	ldd	r31, Y+4	; 0x04
    5832:	04 80       	ldd	r0, Z+4	; 0x04
    5834:	f5 81       	ldd	r31, Z+5	; 0x05
    5836:	e0 2d       	mov	r30, r0
    5838:	8a 85       	ldd	r24, Y+10	; 0x0a
    583a:	9b 85       	ldd	r25, Y+11	; 0x0b
    583c:	02 96       	adiw	r24, 0x02	; 2
    583e:	93 83       	std	Z+3, r25	; 0x03
    5840:	82 83       	std	Z+2, r24	; 0x02
    5842:	8a 85       	ldd	r24, Y+10	; 0x0a
    5844:	9b 85       	ldd	r25, Y+11	; 0x0b
    5846:	02 96       	adiw	r24, 0x02	; 2
    5848:	eb 81       	ldd	r30, Y+3	; 0x03
    584a:	fc 81       	ldd	r31, Y+4	; 0x04
    584c:	95 83       	std	Z+5, r25	; 0x05
    584e:	84 83       	std	Z+4, r24	; 0x04
    5850:	ea 85       	ldd	r30, Y+10	; 0x0a
    5852:	fb 85       	ldd	r31, Y+11	; 0x0b
    5854:	86 89       	ldd	r24, Z+22	; 0x16
    5856:	28 2f       	mov	r18, r24
    5858:	30 e0       	ldi	r19, 0x00	; 0
    585a:	c9 01       	movw	r24, r18
    585c:	88 0f       	add	r24, r24
    585e:	99 1f       	adc	r25, r25
    5860:	88 0f       	add	r24, r24
    5862:	99 1f       	adc	r25, r25
    5864:	88 0f       	add	r24, r24
    5866:	99 1f       	adc	r25, r25
    5868:	82 0f       	add	r24, r18
    586a:	93 1f       	adc	r25, r19
    586c:	82 59       	subi	r24, 0x92	; 146
    586e:	97 4f       	sbci	r25, 0xF7	; 247
    5870:	ea 85       	ldd	r30, Y+10	; 0x0a
    5872:	fb 85       	ldd	r31, Y+11	; 0x0b
    5874:	93 87       	std	Z+11, r25	; 0x0b
    5876:	82 87       	std	Z+10, r24	; 0x0a
    5878:	ea 85       	ldd	r30, Y+10	; 0x0a
    587a:	fb 85       	ldd	r31, Y+11	; 0x0b
    587c:	86 89       	ldd	r24, Z+22	; 0x16
    587e:	28 2f       	mov	r18, r24
    5880:	30 e0       	ldi	r19, 0x00	; 0
    5882:	c9 01       	movw	r24, r18
    5884:	88 0f       	add	r24, r24
    5886:	99 1f       	adc	r25, r25
    5888:	88 0f       	add	r24, r24
    588a:	99 1f       	adc	r25, r25
    588c:	88 0f       	add	r24, r24
    588e:	99 1f       	adc	r25, r25
    5890:	82 0f       	add	r24, r18
    5892:	93 1f       	adc	r25, r19
    5894:	fc 01       	movw	r30, r24
    5896:	e2 59       	subi	r30, 0x92	; 146
    5898:	f7 4f       	sbci	r31, 0xF7	; 247
    589a:	80 81       	ld	r24, Z
    589c:	8f 5f       	subi	r24, 0xFF	; 255
    589e:	80 83       	st	Z, r24
    58a0:	30 c0       	rjmp	.+96     	; 0x5902 <xTaskGenericNotifyFromISR+0x3b4>
                }
                else
                {
                    /* The delayed and ready lists cannot be accessed, so hold
                     * this task pending until the scheduler is resumed. */
                    listINSERT_END( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    58a2:	80 91 a9 08 	lds	r24, 0x08A9
    58a6:	90 91 aa 08 	lds	r25, 0x08AA
    58aa:	9a 83       	std	Y+2, r25	; 0x02
    58ac:	89 83       	std	Y+1, r24	; 0x01
    58ae:	ea 85       	ldd	r30, Y+10	; 0x0a
    58b0:	fb 85       	ldd	r31, Y+11	; 0x0b
    58b2:	89 81       	ldd	r24, Y+1	; 0x01
    58b4:	9a 81       	ldd	r25, Y+2	; 0x02
    58b6:	97 87       	std	Z+15, r25	; 0x0f
    58b8:	86 87       	std	Z+14, r24	; 0x0e
    58ba:	e9 81       	ldd	r30, Y+1	; 0x01
    58bc:	fa 81       	ldd	r31, Y+2	; 0x02
    58be:	84 81       	ldd	r24, Z+4	; 0x04
    58c0:	95 81       	ldd	r25, Z+5	; 0x05
    58c2:	ea 85       	ldd	r30, Y+10	; 0x0a
    58c4:	fb 85       	ldd	r31, Y+11	; 0x0b
    58c6:	91 8b       	std	Z+17, r25	; 0x11
    58c8:	80 8b       	std	Z+16, r24	; 0x10
    58ca:	e9 81       	ldd	r30, Y+1	; 0x01
    58cc:	fa 81       	ldd	r31, Y+2	; 0x02
    58ce:	04 80       	ldd	r0, Z+4	; 0x04
    58d0:	f5 81       	ldd	r31, Z+5	; 0x05
    58d2:	e0 2d       	mov	r30, r0
    58d4:	8a 85       	ldd	r24, Y+10	; 0x0a
    58d6:	9b 85       	ldd	r25, Y+11	; 0x0b
    58d8:	0c 96       	adiw	r24, 0x0c	; 12
    58da:	93 83       	std	Z+3, r25	; 0x03
    58dc:	82 83       	std	Z+2, r24	; 0x02
    58de:	8a 85       	ldd	r24, Y+10	; 0x0a
    58e0:	9b 85       	ldd	r25, Y+11	; 0x0b
    58e2:	0c 96       	adiw	r24, 0x0c	; 12
    58e4:	e9 81       	ldd	r30, Y+1	; 0x01
    58e6:	fa 81       	ldd	r31, Y+2	; 0x02
    58e8:	95 83       	std	Z+5, r25	; 0x05
    58ea:	84 83       	std	Z+4, r24	; 0x04
    58ec:	ea 85       	ldd	r30, Y+10	; 0x0a
    58ee:	fb 85       	ldd	r31, Y+11	; 0x0b
    58f0:	88 ea       	ldi	r24, 0xA8	; 168
    58f2:	98 e0       	ldi	r25, 0x08	; 8
    58f4:	95 8b       	std	Z+21, r25	; 0x15
    58f6:	84 8b       	std	Z+20, r24	; 0x14
    58f8:	80 91 a8 08 	lds	r24, 0x08A8
    58fc:	8f 5f       	subi	r24, 0xFF	; 255
    58fe:	80 93 a8 08 	sts	0x08A8, r24
                }

                if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    5902:	ea 85       	ldd	r30, Y+10	; 0x0a
    5904:	fb 85       	ldd	r31, Y+11	; 0x0b
    5906:	96 89       	ldd	r25, Z+22	; 0x16
    5908:	e0 91 5c 08 	lds	r30, 0x085C
    590c:	f0 91 5d 08 	lds	r31, 0x085D
    5910:	86 89       	ldd	r24, Z+22	; 0x16
    5912:	89 17       	cp	r24, r25
    5914:	58 f4       	brcc	.+22     	; 0x592c <xTaskGenericNotifyFromISR+0x3de>
                {
                    /* The notified task has a priority above the currently
                     * executing task so a yield is required. */
                    if( pxHigherPriorityTaskWoken != NULL )
    5916:	8e 89       	ldd	r24, Y+22	; 0x16
    5918:	9f 89       	ldd	r25, Y+23	; 0x17
    591a:	00 97       	sbiw	r24, 0x00	; 0
    591c:	21 f0       	breq	.+8      	; 0x5926 <xTaskGenericNotifyFromISR+0x3d8>
                    {
                        *pxHigherPriorityTaskWoken = pdTRUE;
    591e:	ee 89       	ldd	r30, Y+22	; 0x16
    5920:	ff 89       	ldd	r31, Y+23	; 0x17
    5922:	81 e0       	ldi	r24, 0x01	; 1
    5924:	80 83       	st	Z, r24
                    }

                    /* Mark that a yield is pending in case the user is not
                     * using the "xHigherPriorityTaskWoken" parameter to an ISR
                     * safe FreeRTOS function. */
                    xYieldPending = pdTRUE;
    5926:	81 e0       	ldi	r24, 0x01	; 1
    5928:	80 93 66 08 	sts	0x0866, r24
                }
            }
        }
        portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

        return xReturn;
    592c:	88 85       	ldd	r24, Y+8	; 0x08
    }
    592e:	69 96       	adiw	r28, 0x19	; 25
    5930:	0f b6       	in	r0, 0x3f	; 63
    5932:	f8 94       	cli
    5934:	de bf       	out	0x3e, r29	; 62
    5936:	0f be       	out	0x3f, r0	; 63
    5938:	cd bf       	out	0x3d, r28	; 61
    593a:	cf 91       	pop	r28
    593c:	df 91       	pop	r29
    593e:	1f 91       	pop	r17
    5940:	0f 91       	pop	r16
    5942:	ff 90       	pop	r15
    5944:	ef 90       	pop	r14
    5946:	df 90       	pop	r13
    5948:	cf 90       	pop	r12
    594a:	08 95       	ret

0000594c <vTaskGenericNotifyGiveFromISR>:
#if ( configUSE_TASK_NOTIFICATIONS == 1 )

    void vTaskGenericNotifyGiveFromISR( TaskHandle_t xTaskToNotify,
                                        UBaseType_t uxIndexToNotify,
                                        BaseType_t * pxHigherPriorityTaskWoken )
    {
    594c:	0f 93       	push	r16
    594e:	1f 93       	push	r17
    5950:	df 93       	push	r29
    5952:	cf 93       	push	r28
    5954:	cd b7       	in	r28, 0x3d	; 61
    5956:	de b7       	in	r29, 0x3e	; 62
    5958:	2f 97       	sbiw	r28, 0x0f	; 15
    595a:	0f b6       	in	r0, 0x3f	; 63
    595c:	f8 94       	cli
    595e:	de bf       	out	0x3e, r29	; 62
    5960:	0f be       	out	0x3f, r0	; 63
    5962:	cd bf       	out	0x3d, r28	; 61
    5964:	9c 87       	std	Y+12, r25	; 0x0c
    5966:	8b 87       	std	Y+11, r24	; 0x0b
    5968:	6d 87       	std	Y+13, r22	; 0x0d
    596a:	5f 87       	std	Y+15, r21	; 0x0f
    596c:	4e 87       	std	Y+14, r20	; 0x0e
         * simple as possible.  More information (albeit Cortex-M specific) is
         * provided on the following link:
         * https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
        portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

        pxTCB = xTaskToNotify;
    596e:	8b 85       	ldd	r24, Y+11	; 0x0b
    5970:	9c 85       	ldd	r25, Y+12	; 0x0c
    5972:	9a 87       	std	Y+10, r25	; 0x0a
    5974:	89 87       	std	Y+9, r24	; 0x09

        uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    5976:	1f 82       	std	Y+7, r1	; 0x07
        {
            ucOriginalNotifyState = pxTCB->ucNotifyState[ uxIndexToNotify ];
    5978:	8d 85       	ldd	r24, Y+13	; 0x0d
    597a:	28 2f       	mov	r18, r24
    597c:	30 e0       	ldi	r19, 0x00	; 0
    597e:	89 85       	ldd	r24, Y+9	; 0x09
    5980:	9a 85       	ldd	r25, Y+10	; 0x0a
    5982:	82 0f       	add	r24, r18
    5984:	93 1f       	adc	r25, r19
    5986:	fc 01       	movw	r30, r24
    5988:	b5 96       	adiw	r30, 0x25	; 37
    598a:	80 81       	ld	r24, Z
    598c:	88 87       	std	Y+8, r24	; 0x08
            pxTCB->ucNotifyState[ uxIndexToNotify ] = taskNOTIFICATION_RECEIVED;
    598e:	8d 85       	ldd	r24, Y+13	; 0x0d
    5990:	28 2f       	mov	r18, r24
    5992:	30 e0       	ldi	r19, 0x00	; 0
    5994:	89 85       	ldd	r24, Y+9	; 0x09
    5996:	9a 85       	ldd	r25, Y+10	; 0x0a
    5998:	82 0f       	add	r24, r18
    599a:	93 1f       	adc	r25, r19
    599c:	fc 01       	movw	r30, r24
    599e:	b5 96       	adiw	r30, 0x25	; 37
    59a0:	82 e0       	ldi	r24, 0x02	; 2
    59a2:	80 83       	st	Z, r24

            /* 'Giving' is equivalent to incrementing a count in a counting
             * semaphore. */
            ( pxTCB->ulNotifiedValue[ uxIndexToNotify ] )++;
    59a4:	8d 85       	ldd	r24, Y+13	; 0x0d
    59a6:	08 2f       	mov	r16, r24
    59a8:	10 e0       	ldi	r17, 0x00	; 0
    59aa:	29 85       	ldd	r18, Y+9	; 0x09
    59ac:	3a 85       	ldd	r19, Y+10	; 0x0a
    59ae:	c8 01       	movw	r24, r16
    59b0:	88 0f       	add	r24, r24
    59b2:	99 1f       	adc	r25, r25
    59b4:	88 0f       	add	r24, r24
    59b6:	99 1f       	adc	r25, r25
    59b8:	82 0f       	add	r24, r18
    59ba:	93 1f       	adc	r25, r19
    59bc:	fc 01       	movw	r30, r24
    59be:	b1 96       	adiw	r30, 0x21	; 33
    59c0:	80 81       	ld	r24, Z
    59c2:	91 81       	ldd	r25, Z+1	; 0x01
    59c4:	a2 81       	ldd	r26, Z+2	; 0x02
    59c6:	b3 81       	ldd	r27, Z+3	; 0x03
    59c8:	ac 01       	movw	r20, r24
    59ca:	bd 01       	movw	r22, r26
    59cc:	4f 5f       	subi	r20, 0xFF	; 255
    59ce:	5f 4f       	sbci	r21, 0xFF	; 255
    59d0:	6f 4f       	sbci	r22, 0xFF	; 255
    59d2:	7f 4f       	sbci	r23, 0xFF	; 255
    59d4:	29 85       	ldd	r18, Y+9	; 0x09
    59d6:	3a 85       	ldd	r19, Y+10	; 0x0a
    59d8:	c8 01       	movw	r24, r16
    59da:	88 0f       	add	r24, r24
    59dc:	99 1f       	adc	r25, r25
    59de:	88 0f       	add	r24, r24
    59e0:	99 1f       	adc	r25, r25
    59e2:	82 0f       	add	r24, r18
    59e4:	93 1f       	adc	r25, r19
    59e6:	fc 01       	movw	r30, r24
    59e8:	b1 96       	adiw	r30, 0x21	; 33
    59ea:	40 83       	st	Z, r20
    59ec:	51 83       	std	Z+1, r21	; 0x01
    59ee:	62 83       	std	Z+2, r22	; 0x02
    59f0:	73 83       	std	Z+3, r23	; 0x03

            traceTASK_NOTIFY_GIVE_FROM_ISR( uxIndexToNotify );

            /* If the task is in the blocked state specifically to wait for a
             * notification then unblock it now. */
            if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    59f2:	88 85       	ldd	r24, Y+8	; 0x08
    59f4:	81 30       	cpi	r24, 0x01	; 1
    59f6:	09 f0       	breq	.+2      	; 0x59fa <vTaskGenericNotifyGiveFromISR+0xae>
    59f8:	ee c0       	rjmp	.+476    	; 0x5bd6 <vTaskGenericNotifyGiveFromISR+0x28a>
            {
                /* The task should not have been on an event list. */
                configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

                if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    59fa:	80 91 6d 08 	lds	r24, 0x086D
    59fe:	88 23       	and	r24, r24
    5a00:	09 f0       	breq	.+2      	; 0x5a04 <vTaskGenericNotifyGiveFromISR+0xb8>
    5a02:	a4 c0       	rjmp	.+328    	; 0x5b4c <vTaskGenericNotifyGiveFromISR+0x200>
                {
                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
    5a04:	e9 85       	ldd	r30, Y+9	; 0x09
    5a06:	fa 85       	ldd	r31, Y+10	; 0x0a
    5a08:	82 85       	ldd	r24, Z+10	; 0x0a
    5a0a:	93 85       	ldd	r25, Z+11	; 0x0b
    5a0c:	9e 83       	std	Y+6, r25	; 0x06
    5a0e:	8d 83       	std	Y+5, r24	; 0x05
    5a10:	e9 85       	ldd	r30, Y+9	; 0x09
    5a12:	fa 85       	ldd	r31, Y+10	; 0x0a
    5a14:	a4 81       	ldd	r26, Z+4	; 0x04
    5a16:	b5 81       	ldd	r27, Z+5	; 0x05
    5a18:	e9 85       	ldd	r30, Y+9	; 0x09
    5a1a:	fa 85       	ldd	r31, Y+10	; 0x0a
    5a1c:	86 81       	ldd	r24, Z+6	; 0x06
    5a1e:	97 81       	ldd	r25, Z+7	; 0x07
    5a20:	15 96       	adiw	r26, 0x05	; 5
    5a22:	9c 93       	st	X, r25
    5a24:	8e 93       	st	-X, r24
    5a26:	14 97       	sbiw	r26, 0x04	; 4
    5a28:	e9 85       	ldd	r30, Y+9	; 0x09
    5a2a:	fa 85       	ldd	r31, Y+10	; 0x0a
    5a2c:	a6 81       	ldd	r26, Z+6	; 0x06
    5a2e:	b7 81       	ldd	r27, Z+7	; 0x07
    5a30:	e9 85       	ldd	r30, Y+9	; 0x09
    5a32:	fa 85       	ldd	r31, Y+10	; 0x0a
    5a34:	84 81       	ldd	r24, Z+4	; 0x04
    5a36:	95 81       	ldd	r25, Z+5	; 0x05
    5a38:	13 96       	adiw	r26, 0x03	; 3
    5a3a:	9c 93       	st	X, r25
    5a3c:	8e 93       	st	-X, r24
    5a3e:	12 97       	sbiw	r26, 0x02	; 2
    5a40:	ed 81       	ldd	r30, Y+5	; 0x05
    5a42:	fe 81       	ldd	r31, Y+6	; 0x06
    5a44:	21 81       	ldd	r18, Z+1	; 0x01
    5a46:	32 81       	ldd	r19, Z+2	; 0x02
    5a48:	89 85       	ldd	r24, Y+9	; 0x09
    5a4a:	9a 85       	ldd	r25, Y+10	; 0x0a
    5a4c:	02 96       	adiw	r24, 0x02	; 2
    5a4e:	28 17       	cp	r18, r24
    5a50:	39 07       	cpc	r19, r25
    5a52:	41 f4       	brne	.+16     	; 0x5a64 <vTaskGenericNotifyGiveFromISR+0x118>
    5a54:	e9 85       	ldd	r30, Y+9	; 0x09
    5a56:	fa 85       	ldd	r31, Y+10	; 0x0a
    5a58:	86 81       	ldd	r24, Z+6	; 0x06
    5a5a:	97 81       	ldd	r25, Z+7	; 0x07
    5a5c:	ed 81       	ldd	r30, Y+5	; 0x05
    5a5e:	fe 81       	ldd	r31, Y+6	; 0x06
    5a60:	92 83       	std	Z+2, r25	; 0x02
    5a62:	81 83       	std	Z+1, r24	; 0x01
    5a64:	e9 85       	ldd	r30, Y+9	; 0x09
    5a66:	fa 85       	ldd	r31, Y+10	; 0x0a
    5a68:	13 86       	std	Z+11, r1	; 0x0b
    5a6a:	12 86       	std	Z+10, r1	; 0x0a
    5a6c:	ed 81       	ldd	r30, Y+5	; 0x05
    5a6e:	fe 81       	ldd	r31, Y+6	; 0x06
    5a70:	80 81       	ld	r24, Z
    5a72:	81 50       	subi	r24, 0x01	; 1
    5a74:	ed 81       	ldd	r30, Y+5	; 0x05
    5a76:	fe 81       	ldd	r31, Y+6	; 0x06
    5a78:	80 83       	st	Z, r24
                    prvAddTaskToReadyList( pxTCB );
    5a7a:	e9 85       	ldd	r30, Y+9	; 0x09
    5a7c:	fa 85       	ldd	r31, Y+10	; 0x0a
    5a7e:	96 89       	ldd	r25, Z+22	; 0x16
    5a80:	80 91 62 08 	lds	r24, 0x0862
    5a84:	89 17       	cp	r24, r25
    5a86:	28 f4       	brcc	.+10     	; 0x5a92 <vTaskGenericNotifyGiveFromISR+0x146>
    5a88:	e9 85       	ldd	r30, Y+9	; 0x09
    5a8a:	fa 85       	ldd	r31, Y+10	; 0x0a
    5a8c:	86 89       	ldd	r24, Z+22	; 0x16
    5a8e:	80 93 62 08 	sts	0x0862, r24
    5a92:	e9 85       	ldd	r30, Y+9	; 0x09
    5a94:	fa 85       	ldd	r31, Y+10	; 0x0a
    5a96:	86 89       	ldd	r24, Z+22	; 0x16
    5a98:	28 2f       	mov	r18, r24
    5a9a:	30 e0       	ldi	r19, 0x00	; 0
    5a9c:	c9 01       	movw	r24, r18
    5a9e:	88 0f       	add	r24, r24
    5aa0:	99 1f       	adc	r25, r25
    5aa2:	88 0f       	add	r24, r24
    5aa4:	99 1f       	adc	r25, r25
    5aa6:	88 0f       	add	r24, r24
    5aa8:	99 1f       	adc	r25, r25
    5aaa:	82 0f       	add	r24, r18
    5aac:	93 1f       	adc	r25, r19
    5aae:	fc 01       	movw	r30, r24
    5ab0:	e2 59       	subi	r30, 0x92	; 146
    5ab2:	f7 4f       	sbci	r31, 0xF7	; 247
    5ab4:	81 81       	ldd	r24, Z+1	; 0x01
    5ab6:	92 81       	ldd	r25, Z+2	; 0x02
    5ab8:	9c 83       	std	Y+4, r25	; 0x04
    5aba:	8b 83       	std	Y+3, r24	; 0x03
    5abc:	e9 85       	ldd	r30, Y+9	; 0x09
    5abe:	fa 85       	ldd	r31, Y+10	; 0x0a
    5ac0:	8b 81       	ldd	r24, Y+3	; 0x03
    5ac2:	9c 81       	ldd	r25, Y+4	; 0x04
    5ac4:	95 83       	std	Z+5, r25	; 0x05
    5ac6:	84 83       	std	Z+4, r24	; 0x04
    5ac8:	eb 81       	ldd	r30, Y+3	; 0x03
    5aca:	fc 81       	ldd	r31, Y+4	; 0x04
    5acc:	84 81       	ldd	r24, Z+4	; 0x04
    5ace:	95 81       	ldd	r25, Z+5	; 0x05
    5ad0:	e9 85       	ldd	r30, Y+9	; 0x09
    5ad2:	fa 85       	ldd	r31, Y+10	; 0x0a
    5ad4:	97 83       	std	Z+7, r25	; 0x07
    5ad6:	86 83       	std	Z+6, r24	; 0x06
    5ad8:	eb 81       	ldd	r30, Y+3	; 0x03
    5ada:	fc 81       	ldd	r31, Y+4	; 0x04
    5adc:	04 80       	ldd	r0, Z+4	; 0x04
    5ade:	f5 81       	ldd	r31, Z+5	; 0x05
    5ae0:	e0 2d       	mov	r30, r0
    5ae2:	89 85       	ldd	r24, Y+9	; 0x09
    5ae4:	9a 85       	ldd	r25, Y+10	; 0x0a
    5ae6:	02 96       	adiw	r24, 0x02	; 2
    5ae8:	93 83       	std	Z+3, r25	; 0x03
    5aea:	82 83       	std	Z+2, r24	; 0x02
    5aec:	89 85       	ldd	r24, Y+9	; 0x09
    5aee:	9a 85       	ldd	r25, Y+10	; 0x0a
    5af0:	02 96       	adiw	r24, 0x02	; 2
    5af2:	eb 81       	ldd	r30, Y+3	; 0x03
    5af4:	fc 81       	ldd	r31, Y+4	; 0x04
    5af6:	95 83       	std	Z+5, r25	; 0x05
    5af8:	84 83       	std	Z+4, r24	; 0x04
    5afa:	e9 85       	ldd	r30, Y+9	; 0x09
    5afc:	fa 85       	ldd	r31, Y+10	; 0x0a
    5afe:	86 89       	ldd	r24, Z+22	; 0x16
    5b00:	28 2f       	mov	r18, r24
    5b02:	30 e0       	ldi	r19, 0x00	; 0
    5b04:	c9 01       	movw	r24, r18
    5b06:	88 0f       	add	r24, r24
    5b08:	99 1f       	adc	r25, r25
    5b0a:	88 0f       	add	r24, r24
    5b0c:	99 1f       	adc	r25, r25
    5b0e:	88 0f       	add	r24, r24
    5b10:	99 1f       	adc	r25, r25
    5b12:	82 0f       	add	r24, r18
    5b14:	93 1f       	adc	r25, r19
    5b16:	82 59       	subi	r24, 0x92	; 146
    5b18:	97 4f       	sbci	r25, 0xF7	; 247
    5b1a:	e9 85       	ldd	r30, Y+9	; 0x09
    5b1c:	fa 85       	ldd	r31, Y+10	; 0x0a
    5b1e:	93 87       	std	Z+11, r25	; 0x0b
    5b20:	82 87       	std	Z+10, r24	; 0x0a
    5b22:	e9 85       	ldd	r30, Y+9	; 0x09
    5b24:	fa 85       	ldd	r31, Y+10	; 0x0a
    5b26:	86 89       	ldd	r24, Z+22	; 0x16
    5b28:	28 2f       	mov	r18, r24
    5b2a:	30 e0       	ldi	r19, 0x00	; 0
    5b2c:	c9 01       	movw	r24, r18
    5b2e:	88 0f       	add	r24, r24
    5b30:	99 1f       	adc	r25, r25
    5b32:	88 0f       	add	r24, r24
    5b34:	99 1f       	adc	r25, r25
    5b36:	88 0f       	add	r24, r24
    5b38:	99 1f       	adc	r25, r25
    5b3a:	82 0f       	add	r24, r18
    5b3c:	93 1f       	adc	r25, r19
    5b3e:	fc 01       	movw	r30, r24
    5b40:	e2 59       	subi	r30, 0x92	; 146
    5b42:	f7 4f       	sbci	r31, 0xF7	; 247
    5b44:	80 81       	ld	r24, Z
    5b46:	8f 5f       	subi	r24, 0xFF	; 255
    5b48:	80 83       	st	Z, r24
    5b4a:	30 c0       	rjmp	.+96     	; 0x5bac <vTaskGenericNotifyGiveFromISR+0x260>
                }
                else
                {
                    /* The delayed and ready lists cannot be accessed, so hold
                     * this task pending until the scheduler is resumed. */
                    listINSERT_END( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    5b4c:	80 91 a9 08 	lds	r24, 0x08A9
    5b50:	90 91 aa 08 	lds	r25, 0x08AA
    5b54:	9a 83       	std	Y+2, r25	; 0x02
    5b56:	89 83       	std	Y+1, r24	; 0x01
    5b58:	e9 85       	ldd	r30, Y+9	; 0x09
    5b5a:	fa 85       	ldd	r31, Y+10	; 0x0a
    5b5c:	89 81       	ldd	r24, Y+1	; 0x01
    5b5e:	9a 81       	ldd	r25, Y+2	; 0x02
    5b60:	97 87       	std	Z+15, r25	; 0x0f
    5b62:	86 87       	std	Z+14, r24	; 0x0e
    5b64:	e9 81       	ldd	r30, Y+1	; 0x01
    5b66:	fa 81       	ldd	r31, Y+2	; 0x02
    5b68:	84 81       	ldd	r24, Z+4	; 0x04
    5b6a:	95 81       	ldd	r25, Z+5	; 0x05
    5b6c:	e9 85       	ldd	r30, Y+9	; 0x09
    5b6e:	fa 85       	ldd	r31, Y+10	; 0x0a
    5b70:	91 8b       	std	Z+17, r25	; 0x11
    5b72:	80 8b       	std	Z+16, r24	; 0x10
    5b74:	e9 81       	ldd	r30, Y+1	; 0x01
    5b76:	fa 81       	ldd	r31, Y+2	; 0x02
    5b78:	04 80       	ldd	r0, Z+4	; 0x04
    5b7a:	f5 81       	ldd	r31, Z+5	; 0x05
    5b7c:	e0 2d       	mov	r30, r0
    5b7e:	89 85       	ldd	r24, Y+9	; 0x09
    5b80:	9a 85       	ldd	r25, Y+10	; 0x0a
    5b82:	0c 96       	adiw	r24, 0x0c	; 12
    5b84:	93 83       	std	Z+3, r25	; 0x03
    5b86:	82 83       	std	Z+2, r24	; 0x02
    5b88:	89 85       	ldd	r24, Y+9	; 0x09
    5b8a:	9a 85       	ldd	r25, Y+10	; 0x0a
    5b8c:	0c 96       	adiw	r24, 0x0c	; 12
    5b8e:	e9 81       	ldd	r30, Y+1	; 0x01
    5b90:	fa 81       	ldd	r31, Y+2	; 0x02
    5b92:	95 83       	std	Z+5, r25	; 0x05
    5b94:	84 83       	std	Z+4, r24	; 0x04
    5b96:	e9 85       	ldd	r30, Y+9	; 0x09
    5b98:	fa 85       	ldd	r31, Y+10	; 0x0a
    5b9a:	88 ea       	ldi	r24, 0xA8	; 168
    5b9c:	98 e0       	ldi	r25, 0x08	; 8
    5b9e:	95 8b       	std	Z+21, r25	; 0x15
    5ba0:	84 8b       	std	Z+20, r24	; 0x14
    5ba2:	80 91 a8 08 	lds	r24, 0x08A8
    5ba6:	8f 5f       	subi	r24, 0xFF	; 255
    5ba8:	80 93 a8 08 	sts	0x08A8, r24
                }

                if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    5bac:	e9 85       	ldd	r30, Y+9	; 0x09
    5bae:	fa 85       	ldd	r31, Y+10	; 0x0a
    5bb0:	96 89       	ldd	r25, Z+22	; 0x16
    5bb2:	e0 91 5c 08 	lds	r30, 0x085C
    5bb6:	f0 91 5d 08 	lds	r31, 0x085D
    5bba:	86 89       	ldd	r24, Z+22	; 0x16
    5bbc:	89 17       	cp	r24, r25
    5bbe:	58 f4       	brcc	.+22     	; 0x5bd6 <vTaskGenericNotifyGiveFromISR+0x28a>
                {
                    /* The notified task has a priority above the currently
                     * executing task so a yield is required. */
                    if( pxHigherPriorityTaskWoken != NULL )
    5bc0:	8e 85       	ldd	r24, Y+14	; 0x0e
    5bc2:	9f 85       	ldd	r25, Y+15	; 0x0f
    5bc4:	00 97       	sbiw	r24, 0x00	; 0
    5bc6:	21 f0       	breq	.+8      	; 0x5bd0 <vTaskGenericNotifyGiveFromISR+0x284>
                    {
                        *pxHigherPriorityTaskWoken = pdTRUE;
    5bc8:	ee 85       	ldd	r30, Y+14	; 0x0e
    5bca:	ff 85       	ldd	r31, Y+15	; 0x0f
    5bcc:	81 e0       	ldi	r24, 0x01	; 1
    5bce:	80 83       	st	Z, r24
                    }

                    /* Mark that a yield is pending in case the user is not
                     * using the "xHigherPriorityTaskWoken" parameter in an ISR
                     * safe FreeRTOS function. */
                    xYieldPending = pdTRUE;
    5bd0:	81 e0       	ldi	r24, 0x01	; 1
    5bd2:	80 93 66 08 	sts	0x0866, r24
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
    }
    5bd6:	2f 96       	adiw	r28, 0x0f	; 15
    5bd8:	0f b6       	in	r0, 0x3f	; 63
    5bda:	f8 94       	cli
    5bdc:	de bf       	out	0x3e, r29	; 62
    5bde:	0f be       	out	0x3f, r0	; 63
    5be0:	cd bf       	out	0x3d, r28	; 61
    5be2:	cf 91       	pop	r28
    5be4:	df 91       	pop	r29
    5be6:	1f 91       	pop	r17
    5be8:	0f 91       	pop	r16
    5bea:	08 95       	ret

00005bec <xTaskGenericNotifyStateClear>:

#if ( configUSE_TASK_NOTIFICATIONS == 1 )

    BaseType_t xTaskGenericNotifyStateClear( TaskHandle_t xTask,
                                             UBaseType_t uxIndexToClear )
    {
    5bec:	df 93       	push	r29
    5bee:	cf 93       	push	r28
    5bf0:	cd b7       	in	r28, 0x3d	; 61
    5bf2:	de b7       	in	r29, 0x3e	; 62
    5bf4:	28 97       	sbiw	r28, 0x08	; 8
    5bf6:	0f b6       	in	r0, 0x3f	; 63
    5bf8:	f8 94       	cli
    5bfa:	de bf       	out	0x3e, r29	; 62
    5bfc:	0f be       	out	0x3f, r0	; 63
    5bfe:	cd bf       	out	0x3d, r28	; 61
    5c00:	9d 83       	std	Y+5, r25	; 0x05
    5c02:	8c 83       	std	Y+4, r24	; 0x04
    5c04:	6e 83       	std	Y+6, r22	; 0x06

        configASSERT( uxIndexToClear < configTASK_NOTIFICATION_ARRAY_ENTRIES );

        /* If null is passed in here then it is the calling task that is having
         * its notification state cleared. */
        pxTCB = prvGetTCBFromHandle( xTask );
    5c06:	8c 81       	ldd	r24, Y+4	; 0x04
    5c08:	9d 81       	ldd	r25, Y+5	; 0x05
    5c0a:	00 97       	sbiw	r24, 0x00	; 0
    5c0c:	39 f4       	brne	.+14     	; 0x5c1c <xTaskGenericNotifyStateClear+0x30>
    5c0e:	80 91 5c 08 	lds	r24, 0x085C
    5c12:	90 91 5d 08 	lds	r25, 0x085D
    5c16:	98 87       	std	Y+8, r25	; 0x08
    5c18:	8f 83       	std	Y+7, r24	; 0x07
    5c1a:	04 c0       	rjmp	.+8      	; 0x5c24 <xTaskGenericNotifyStateClear+0x38>
    5c1c:	8c 81       	ldd	r24, Y+4	; 0x04
    5c1e:	9d 81       	ldd	r25, Y+5	; 0x05
    5c20:	98 87       	std	Y+8, r25	; 0x08
    5c22:	8f 83       	std	Y+7, r24	; 0x07
    5c24:	8f 81       	ldd	r24, Y+7	; 0x07
    5c26:	98 85       	ldd	r25, Y+8	; 0x08
    5c28:	9b 83       	std	Y+3, r25	; 0x03
    5c2a:	8a 83       	std	Y+2, r24	; 0x02

        taskENTER_CRITICAL();
    5c2c:	0f b6       	in	r0, 0x3f	; 63
    5c2e:	f8 94       	cli
    5c30:	0f 92       	push	r0
        {
            if( pxTCB->ucNotifyState[ uxIndexToClear ] == taskNOTIFICATION_RECEIVED )
    5c32:	8e 81       	ldd	r24, Y+6	; 0x06
    5c34:	28 2f       	mov	r18, r24
    5c36:	30 e0       	ldi	r19, 0x00	; 0
    5c38:	8a 81       	ldd	r24, Y+2	; 0x02
    5c3a:	9b 81       	ldd	r25, Y+3	; 0x03
    5c3c:	82 0f       	add	r24, r18
    5c3e:	93 1f       	adc	r25, r19
    5c40:	fc 01       	movw	r30, r24
    5c42:	b5 96       	adiw	r30, 0x25	; 37
    5c44:	80 81       	ld	r24, Z
    5c46:	82 30       	cpi	r24, 0x02	; 2
    5c48:	69 f4       	brne	.+26     	; 0x5c64 <xTaskGenericNotifyStateClear+0x78>
            {
                pxTCB->ucNotifyState[ uxIndexToClear ] = taskNOT_WAITING_NOTIFICATION;
    5c4a:	8e 81       	ldd	r24, Y+6	; 0x06
    5c4c:	28 2f       	mov	r18, r24
    5c4e:	30 e0       	ldi	r19, 0x00	; 0
    5c50:	8a 81       	ldd	r24, Y+2	; 0x02
    5c52:	9b 81       	ldd	r25, Y+3	; 0x03
    5c54:	82 0f       	add	r24, r18
    5c56:	93 1f       	adc	r25, r19
    5c58:	fc 01       	movw	r30, r24
    5c5a:	b5 96       	adiw	r30, 0x25	; 37
    5c5c:	10 82       	st	Z, r1
                xReturn = pdPASS;
    5c5e:	81 e0       	ldi	r24, 0x01	; 1
    5c60:	89 83       	std	Y+1, r24	; 0x01
    5c62:	01 c0       	rjmp	.+2      	; 0x5c66 <xTaskGenericNotifyStateClear+0x7a>
            }
            else
            {
                xReturn = pdFAIL;
    5c64:	19 82       	std	Y+1, r1	; 0x01
            }
        }
        taskEXIT_CRITICAL();
    5c66:	0f 90       	pop	r0
    5c68:	0f be       	out	0x3f, r0	; 63

        return xReturn;
    5c6a:	89 81       	ldd	r24, Y+1	; 0x01
    }
    5c6c:	28 96       	adiw	r28, 0x08	; 8
    5c6e:	0f b6       	in	r0, 0x3f	; 63
    5c70:	f8 94       	cli
    5c72:	de bf       	out	0x3e, r29	; 62
    5c74:	0f be       	out	0x3f, r0	; 63
    5c76:	cd bf       	out	0x3d, r28	; 61
    5c78:	cf 91       	pop	r28
    5c7a:	df 91       	pop	r29
    5c7c:	08 95       	ret

00005c7e <ulTaskGenericNotifyValueClear>:
#if ( configUSE_TASK_NOTIFICATIONS == 1 )

    uint32_t ulTaskGenericNotifyValueClear( TaskHandle_t xTask,
                                            UBaseType_t uxIndexToClear,
                                            uint32_t ulBitsToClear )
    {
    5c7e:	0f 93       	push	r16
    5c80:	1f 93       	push	r17
    5c82:	df 93       	push	r29
    5c84:	cf 93       	push	r28
    5c86:	cd b7       	in	r28, 0x3d	; 61
    5c88:	de b7       	in	r29, 0x3e	; 62
    5c8a:	2f 97       	sbiw	r28, 0x0f	; 15
    5c8c:	0f b6       	in	r0, 0x3f	; 63
    5c8e:	f8 94       	cli
    5c90:	de bf       	out	0x3e, r29	; 62
    5c92:	0f be       	out	0x3f, r0	; 63
    5c94:	cd bf       	out	0x3d, r28	; 61
    5c96:	98 87       	std	Y+8, r25	; 0x08
    5c98:	8f 83       	std	Y+7, r24	; 0x07
    5c9a:	69 87       	std	Y+9, r22	; 0x09
    5c9c:	2a 87       	std	Y+10, r18	; 0x0a
    5c9e:	3b 87       	std	Y+11, r19	; 0x0b
    5ca0:	4c 87       	std	Y+12, r20	; 0x0c
    5ca2:	5d 87       	std	Y+13, r21	; 0x0d
        TCB_t * pxTCB;
        uint32_t ulReturn;

        /* If null is passed in here then it is the calling task that is having
         * its notification state cleared. */
        pxTCB = prvGetTCBFromHandle( xTask );
    5ca4:	8f 81       	ldd	r24, Y+7	; 0x07
    5ca6:	98 85       	ldd	r25, Y+8	; 0x08
    5ca8:	00 97       	sbiw	r24, 0x00	; 0
    5caa:	39 f4       	brne	.+14     	; 0x5cba <ulTaskGenericNotifyValueClear+0x3c>
    5cac:	80 91 5c 08 	lds	r24, 0x085C
    5cb0:	90 91 5d 08 	lds	r25, 0x085D
    5cb4:	9f 87       	std	Y+15, r25	; 0x0f
    5cb6:	8e 87       	std	Y+14, r24	; 0x0e
    5cb8:	04 c0       	rjmp	.+8      	; 0x5cc2 <ulTaskGenericNotifyValueClear+0x44>
    5cba:	8f 81       	ldd	r24, Y+7	; 0x07
    5cbc:	98 85       	ldd	r25, Y+8	; 0x08
    5cbe:	9f 87       	std	Y+15, r25	; 0x0f
    5cc0:	8e 87       	std	Y+14, r24	; 0x0e
    5cc2:	8e 85       	ldd	r24, Y+14	; 0x0e
    5cc4:	9f 85       	ldd	r25, Y+15	; 0x0f
    5cc6:	9e 83       	std	Y+6, r25	; 0x06
    5cc8:	8d 83       	std	Y+5, r24	; 0x05

        taskENTER_CRITICAL();
    5cca:	0f b6       	in	r0, 0x3f	; 63
    5ccc:	f8 94       	cli
    5cce:	0f 92       	push	r0
        {
            /* Return the notification as it was before the bits were cleared,
             * then clear the bit mask. */
            ulReturn = pxTCB->ulNotifiedValue[ uxIndexToClear ];
    5cd0:	89 85       	ldd	r24, Y+9	; 0x09
    5cd2:	88 2f       	mov	r24, r24
    5cd4:	90 e0       	ldi	r25, 0x00	; 0
    5cd6:	2d 81       	ldd	r18, Y+5	; 0x05
    5cd8:	3e 81       	ldd	r19, Y+6	; 0x06
    5cda:	88 0f       	add	r24, r24
    5cdc:	99 1f       	adc	r25, r25
    5cde:	88 0f       	add	r24, r24
    5ce0:	99 1f       	adc	r25, r25
    5ce2:	82 0f       	add	r24, r18
    5ce4:	93 1f       	adc	r25, r19
    5ce6:	fc 01       	movw	r30, r24
    5ce8:	b1 96       	adiw	r30, 0x21	; 33
    5cea:	80 81       	ld	r24, Z
    5cec:	91 81       	ldd	r25, Z+1	; 0x01
    5cee:	a2 81       	ldd	r26, Z+2	; 0x02
    5cf0:	b3 81       	ldd	r27, Z+3	; 0x03
    5cf2:	89 83       	std	Y+1, r24	; 0x01
    5cf4:	9a 83       	std	Y+2, r25	; 0x02
    5cf6:	ab 83       	std	Y+3, r26	; 0x03
    5cf8:	bc 83       	std	Y+4, r27	; 0x04
            pxTCB->ulNotifiedValue[ uxIndexToClear ] &= ~ulBitsToClear;
    5cfa:	89 85       	ldd	r24, Y+9	; 0x09
    5cfc:	08 2f       	mov	r16, r24
    5cfe:	10 e0       	ldi	r17, 0x00	; 0
    5d00:	89 85       	ldd	r24, Y+9	; 0x09
    5d02:	88 2f       	mov	r24, r24
    5d04:	90 e0       	ldi	r25, 0x00	; 0
    5d06:	2d 81       	ldd	r18, Y+5	; 0x05
    5d08:	3e 81       	ldd	r19, Y+6	; 0x06
    5d0a:	88 0f       	add	r24, r24
    5d0c:	99 1f       	adc	r25, r25
    5d0e:	88 0f       	add	r24, r24
    5d10:	99 1f       	adc	r25, r25
    5d12:	82 0f       	add	r24, r18
    5d14:	93 1f       	adc	r25, r19
    5d16:	fc 01       	movw	r30, r24
    5d18:	b1 96       	adiw	r30, 0x21	; 33
    5d1a:	20 81       	ld	r18, Z
    5d1c:	31 81       	ldd	r19, Z+1	; 0x01
    5d1e:	42 81       	ldd	r20, Z+2	; 0x02
    5d20:	53 81       	ldd	r21, Z+3	; 0x03
    5d22:	8a 85       	ldd	r24, Y+10	; 0x0a
    5d24:	9b 85       	ldd	r25, Y+11	; 0x0b
    5d26:	ac 85       	ldd	r26, Y+12	; 0x0c
    5d28:	bd 85       	ldd	r27, Y+13	; 0x0d
    5d2a:	80 95       	com	r24
    5d2c:	90 95       	com	r25
    5d2e:	a0 95       	com	r26
    5d30:	b0 95       	com	r27
    5d32:	ba 01       	movw	r22, r20
    5d34:	a9 01       	movw	r20, r18
    5d36:	48 23       	and	r20, r24
    5d38:	59 23       	and	r21, r25
    5d3a:	6a 23       	and	r22, r26
    5d3c:	7b 23       	and	r23, r27
    5d3e:	2d 81       	ldd	r18, Y+5	; 0x05
    5d40:	3e 81       	ldd	r19, Y+6	; 0x06
    5d42:	c8 01       	movw	r24, r16
    5d44:	88 0f       	add	r24, r24
    5d46:	99 1f       	adc	r25, r25
    5d48:	88 0f       	add	r24, r24
    5d4a:	99 1f       	adc	r25, r25
    5d4c:	82 0f       	add	r24, r18
    5d4e:	93 1f       	adc	r25, r19
    5d50:	fc 01       	movw	r30, r24
    5d52:	b1 96       	adiw	r30, 0x21	; 33
    5d54:	40 83       	st	Z, r20
    5d56:	51 83       	std	Z+1, r21	; 0x01
    5d58:	62 83       	std	Z+2, r22	; 0x02
    5d5a:	73 83       	std	Z+3, r23	; 0x03
        }
        taskEXIT_CRITICAL();
    5d5c:	0f 90       	pop	r0
    5d5e:	0f be       	out	0x3f, r0	; 63

        return ulReturn;
    5d60:	89 81       	ldd	r24, Y+1	; 0x01
    5d62:	9a 81       	ldd	r25, Y+2	; 0x02
    5d64:	ab 81       	ldd	r26, Y+3	; 0x03
    5d66:	bc 81       	ldd	r27, Y+4	; 0x04
    }
    5d68:	bc 01       	movw	r22, r24
    5d6a:	cd 01       	movw	r24, r26
    5d6c:	2f 96       	adiw	r28, 0x0f	; 15
    5d6e:	0f b6       	in	r0, 0x3f	; 63
    5d70:	f8 94       	cli
    5d72:	de bf       	out	0x3e, r29	; 62
    5d74:	0f be       	out	0x3f, r0	; 63
    5d76:	cd bf       	out	0x3d, r28	; 61
    5d78:	cf 91       	pop	r28
    5d7a:	df 91       	pop	r29
    5d7c:	1f 91       	pop	r17
    5d7e:	0f 91       	pop	r16
    5d80:	08 95       	ret

00005d82 <prvAddCurrentTaskToDelayedList>:
#endif /* if ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( INCLUDE_xTaskGetIdleTaskHandle == 1 ) ) */
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait,
                                            const BaseType_t xCanBlockIndefinitely )
{
    5d82:	df 93       	push	r29
    5d84:	cf 93       	push	r28
    5d86:	cd b7       	in	r28, 0x3d	; 61
    5d88:	de b7       	in	r29, 0x3e	; 62
    5d8a:	27 97       	sbiw	r28, 0x07	; 7
    5d8c:	0f b6       	in	r0, 0x3f	; 63
    5d8e:	f8 94       	cli
    5d90:	de bf       	out	0x3e, r29	; 62
    5d92:	0f be       	out	0x3f, r0	; 63
    5d94:	cd bf       	out	0x3d, r28	; 61
    5d96:	9e 83       	std	Y+6, r25	; 0x06
    5d98:	8d 83       	std	Y+5, r24	; 0x05
    5d9a:	6f 83       	std	Y+7, r22	; 0x07
    TickType_t xTimeToWake;
    const TickType_t xConstTickCount = xTickCount;
    5d9c:	80 91 60 08 	lds	r24, 0x0860
    5da0:	90 91 61 08 	lds	r25, 0x0861
    5da4:	9a 83       	std	Y+2, r25	; 0x02
    5da6:	89 83       	std	Y+1, r24	; 0x01
        }
    #endif

    /* Remove the task from the ready list before adding it to the blocked list
     * as the same list item is used for both lists. */
    if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    5da8:	80 91 5c 08 	lds	r24, 0x085C
    5dac:	90 91 5d 08 	lds	r25, 0x085D
    5db0:	02 96       	adiw	r24, 0x02	; 2
    5db2:	0e 94 95 11 	call	0x232a	; 0x232a <uxListRemove>
    #else /* INCLUDE_vTaskSuspend */
        {
            /* Calculate the time at which the task should be woken if the event
             * does not occur.  This may overflow but this doesn't matter, the kernel
             * will manage it correctly. */
            xTimeToWake = xConstTickCount + xTicksToWait;
    5db6:	29 81       	ldd	r18, Y+1	; 0x01
    5db8:	3a 81       	ldd	r19, Y+2	; 0x02
    5dba:	8d 81       	ldd	r24, Y+5	; 0x05
    5dbc:	9e 81       	ldd	r25, Y+6	; 0x06
    5dbe:	82 0f       	add	r24, r18
    5dc0:	93 1f       	adc	r25, r19
    5dc2:	9c 83       	std	Y+4, r25	; 0x04
    5dc4:	8b 83       	std	Y+3, r24	; 0x03

            /* The list item will be inserted in wake time order. */
            listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
    5dc6:	e0 91 5c 08 	lds	r30, 0x085C
    5dca:	f0 91 5d 08 	lds	r31, 0x085D
    5dce:	8b 81       	ldd	r24, Y+3	; 0x03
    5dd0:	9c 81       	ldd	r25, Y+4	; 0x04
    5dd2:	93 83       	std	Z+3, r25	; 0x03
    5dd4:	82 83       	std	Z+2, r24	; 0x02

            if( xTimeToWake < xConstTickCount )
    5dd6:	2b 81       	ldd	r18, Y+3	; 0x03
    5dd8:	3c 81       	ldd	r19, Y+4	; 0x04
    5dda:	89 81       	ldd	r24, Y+1	; 0x01
    5ddc:	9a 81       	ldd	r25, Y+2	; 0x02
    5dde:	28 17       	cp	r18, r24
    5de0:	39 07       	cpc	r19, r25
    5de2:	70 f4       	brcc	.+28     	; 0x5e00 <prvAddCurrentTaskToDelayedList+0x7e>
            {
                /* Wake time has overflowed.  Place this item in the overflow list. */
                vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    5de4:	80 91 a6 08 	lds	r24, 0x08A6
    5de8:	90 91 a7 08 	lds	r25, 0x08A7
    5dec:	20 91 5c 08 	lds	r18, 0x085C
    5df0:	30 91 5d 08 	lds	r19, 0x085D
    5df4:	2e 5f       	subi	r18, 0xFE	; 254
    5df6:	3f 4f       	sbci	r19, 0xFF	; 255
    5df8:	b9 01       	movw	r22, r18
    5dfa:	0e 94 29 11 	call	0x2252	; 0x2252 <vListInsert>
    5dfe:	1e c0       	rjmp	.+60     	; 0x5e3c <prvAddCurrentTaskToDelayedList+0xba>
            }
            else
            {
                /* The wake time has not overflowed, so the current block list is used. */
                vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    5e00:	40 91 a4 08 	lds	r20, 0x08A4
    5e04:	50 91 a5 08 	lds	r21, 0x08A5
    5e08:	80 91 5c 08 	lds	r24, 0x085C
    5e0c:	90 91 5d 08 	lds	r25, 0x085D
    5e10:	9c 01       	movw	r18, r24
    5e12:	2e 5f       	subi	r18, 0xFE	; 254
    5e14:	3f 4f       	sbci	r19, 0xFF	; 255
    5e16:	ca 01       	movw	r24, r20
    5e18:	b9 01       	movw	r22, r18
    5e1a:	0e 94 29 11 	call	0x2252	; 0x2252 <vListInsert>

                /* If the task entering the blocked state was placed at the head of the
                 * list of blocked tasks then xNextTaskUnblockTime needs to be updated
                 * too. */
                if( xTimeToWake < xNextTaskUnblockTime )
    5e1e:	20 91 69 08 	lds	r18, 0x0869
    5e22:	30 91 6a 08 	lds	r19, 0x086A
    5e26:	8b 81       	ldd	r24, Y+3	; 0x03
    5e28:	9c 81       	ldd	r25, Y+4	; 0x04
    5e2a:	82 17       	cp	r24, r18
    5e2c:	93 07       	cpc	r25, r19
    5e2e:	30 f4       	brcc	.+12     	; 0x5e3c <prvAddCurrentTaskToDelayedList+0xba>
                {
                    xNextTaskUnblockTime = xTimeToWake;
    5e30:	8b 81       	ldd	r24, Y+3	; 0x03
    5e32:	9c 81       	ldd	r25, Y+4	; 0x04
    5e34:	90 93 6a 08 	sts	0x086A, r25
    5e38:	80 93 69 08 	sts	0x0869, r24

            /* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
            ( void ) xCanBlockIndefinitely;
        }
    #endif /* INCLUDE_vTaskSuspend */
}
    5e3c:	27 96       	adiw	r28, 0x07	; 7
    5e3e:	0f b6       	in	r0, 0x3f	; 63
    5e40:	f8 94       	cli
    5e42:	de bf       	out	0x3e, r29	; 62
    5e44:	0f be       	out	0x3f, r0	; 63
    5e46:	cd bf       	out	0x3d, r28	; 61
    5e48:	cf 91       	pop	r28
    5e4a:	df 91       	pop	r29
    5e4c:	08 95       	ret

00005e4e <xTimerCreateTimerTask>:
                                       TimerCallbackFunction_t pxCallbackFunction,
                                       Timer_t * pxNewTimer ) PRIVILEGED_FUNCTION;
/*-----------------------------------------------------------*/

    BaseType_t xTimerCreateTimerTask( void )
    {
    5e4e:	ef 92       	push	r14
    5e50:	ff 92       	push	r15
    5e52:	0f 93       	push	r16
    5e54:	df 93       	push	r29
    5e56:	cf 93       	push	r28
    5e58:	0f 92       	push	r0
    5e5a:	cd b7       	in	r28, 0x3d	; 61
    5e5c:	de b7       	in	r29, 0x3e	; 62
        BaseType_t xReturn = pdFAIL;
    5e5e:	19 82       	std	Y+1, r1	; 0x01

        /* This function is called when the scheduler is started if
         * configUSE_TIMERS is set to 1.  Check that the infrastructure used by the
         * timer service task has been created/initialised.  If timers have already
         * been created then the initialisation will already have been performed. */
        prvCheckForValidListAndQueue();
    5e60:	0e 94 e6 33 	call	0x67cc	; 0x67cc <prvCheckForValidListAndQueue>

        if( xTimerQueue != NULL )
    5e64:	80 91 ba 08 	lds	r24, 0x08BA
    5e68:	90 91 bb 08 	lds	r25, 0x08BB
    5e6c:	00 97       	sbiw	r24, 0x00	; 0
    5e6e:	81 f0       	breq	.+32     	; 0x5e90 <xTimerCreateTimerTask+0x42>
                        xReturn = pdPASS;
                    }
                }
            #else /* if ( configSUPPORT_STATIC_ALLOCATION == 1 ) */
                {
                    xReturn = xTaskCreate( prvTimerTask,
    5e70:	88 e7       	ldi	r24, 0x78	; 120
    5e72:	91 e3       	ldi	r25, 0x31	; 49
    5e74:	25 e0       	ldi	r18, 0x05	; 5
    5e76:	31 e0       	ldi	r19, 0x01	; 1
    5e78:	ec eb       	ldi	r30, 0xBC	; 188
    5e7a:	f8 e0       	ldi	r31, 0x08	; 8
    5e7c:	b9 01       	movw	r22, r18
    5e7e:	45 e5       	ldi	r20, 0x55	; 85
    5e80:	50 e0       	ldi	r21, 0x00	; 0
    5e82:	20 e0       	ldi	r18, 0x00	; 0
    5e84:	30 e0       	ldi	r19, 0x00	; 0
    5e86:	03 e0       	ldi	r16, 0x03	; 3
    5e88:	7f 01       	movw	r14, r30
    5e8a:	0e 94 37 1b 	call	0x366e	; 0x366e <xTaskCreate>
    5e8e:	89 83       	std	Y+1, r24	; 0x01
        {
            mtCOVERAGE_TEST_MARKER();
        }

        configASSERT( xReturn );
        return xReturn;
    5e90:	89 81       	ldd	r24, Y+1	; 0x01
    }
    5e92:	0f 90       	pop	r0
    5e94:	cf 91       	pop	r28
    5e96:	df 91       	pop	r29
    5e98:	0f 91       	pop	r16
    5e9a:	ff 90       	pop	r15
    5e9c:	ef 90       	pop	r14
    5e9e:	08 95       	ret

00005ea0 <xTimerCreate>:
        TimerHandle_t xTimerCreate( const char * const pcTimerName, /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
                                    const TickType_t xTimerPeriodInTicks,
                                    const UBaseType_t uxAutoReload,
                                    void * const pvTimerID,
                                    TimerCallbackFunction_t pxCallbackFunction )
        {
    5ea0:	ef 92       	push	r14
    5ea2:	ff 92       	push	r15
    5ea4:	0f 93       	push	r16
    5ea6:	1f 93       	push	r17
    5ea8:	df 93       	push	r29
    5eaa:	cf 93       	push	r28
    5eac:	cd b7       	in	r28, 0x3d	; 61
    5eae:	de b7       	in	r29, 0x3e	; 62
    5eb0:	2b 97       	sbiw	r28, 0x0b	; 11
    5eb2:	0f b6       	in	r0, 0x3f	; 63
    5eb4:	f8 94       	cli
    5eb6:	de bf       	out	0x3e, r29	; 62
    5eb8:	0f be       	out	0x3f, r0	; 63
    5eba:	cd bf       	out	0x3d, r28	; 61
    5ebc:	9c 83       	std	Y+4, r25	; 0x04
    5ebe:	8b 83       	std	Y+3, r24	; 0x03
    5ec0:	7e 83       	std	Y+6, r23	; 0x06
    5ec2:	6d 83       	std	Y+5, r22	; 0x05
    5ec4:	4f 83       	std	Y+7, r20	; 0x07
    5ec6:	39 87       	std	Y+9, r19	; 0x09
    5ec8:	28 87       	std	Y+8, r18	; 0x08
    5eca:	1b 87       	std	Y+11, r17	; 0x0b
    5ecc:	0a 87       	std	Y+10, r16	; 0x0a
            Timer_t * pxNewTimer;

            pxNewTimer = ( Timer_t * ) pvPortMalloc( sizeof( Timer_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of Timer_t is always a pointer to the timer's mame. */
    5ece:	83 e1       	ldi	r24, 0x13	; 19
    5ed0:	90 e0       	ldi	r25, 0x00	; 0
    5ed2:	0e 94 33 07 	call	0xe66	; 0xe66 <pvPortMalloc>
    5ed6:	9a 83       	std	Y+2, r25	; 0x02
    5ed8:	89 83       	std	Y+1, r24	; 0x01

            if( pxNewTimer != NULL )
    5eda:	89 81       	ldd	r24, Y+1	; 0x01
    5edc:	9a 81       	ldd	r25, Y+2	; 0x02
    5ede:	00 97       	sbiw	r24, 0x00	; 0
    5ee0:	99 f0       	breq	.+38     	; 0x5f08 <xTimerCreate+0x68>
            {
                /* Status is thus far zero as the timer is not created statically
                 * and has not been started.  The auto-reload bit may get set in
                 * prvInitialiseNewTimer. */
                pxNewTimer->ucStatus = 0x00;
    5ee2:	e9 81       	ldd	r30, Y+1	; 0x01
    5ee4:	fa 81       	ldd	r31, Y+2	; 0x02
    5ee6:	12 8a       	std	Z+18, r1	; 0x12
                prvInitialiseNewTimer( pcTimerName, xTimerPeriodInTicks, uxAutoReload, pvTimerID, pxCallbackFunction, pxNewTimer );
    5ee8:	8b 81       	ldd	r24, Y+3	; 0x03
    5eea:	9c 81       	ldd	r25, Y+4	; 0x04
    5eec:	2d 81       	ldd	r18, Y+5	; 0x05
    5eee:	3e 81       	ldd	r19, Y+6	; 0x06
    5ef0:	e8 85       	ldd	r30, Y+8	; 0x08
    5ef2:	f9 85       	ldd	r31, Y+9	; 0x09
    5ef4:	aa 85       	ldd	r26, Y+10	; 0x0a
    5ef6:	bb 85       	ldd	r27, Y+11	; 0x0b
    5ef8:	e9 80       	ldd	r14, Y+1	; 0x01
    5efa:	fa 80       	ldd	r15, Y+2	; 0x02
    5efc:	b9 01       	movw	r22, r18
    5efe:	4f 81       	ldd	r20, Y+7	; 0x07
    5f00:	9f 01       	movw	r18, r30
    5f02:	8d 01       	movw	r16, r26
    5f04:	0e 94 93 2f 	call	0x5f26	; 0x5f26 <prvInitialiseNewTimer>
            }

            return pxNewTimer;
    5f08:	89 81       	ldd	r24, Y+1	; 0x01
    5f0a:	9a 81       	ldd	r25, Y+2	; 0x02
        }
    5f0c:	2b 96       	adiw	r28, 0x0b	; 11
    5f0e:	0f b6       	in	r0, 0x3f	; 63
    5f10:	f8 94       	cli
    5f12:	de bf       	out	0x3e, r29	; 62
    5f14:	0f be       	out	0x3f, r0	; 63
    5f16:	cd bf       	out	0x3d, r28	; 61
    5f18:	cf 91       	pop	r28
    5f1a:	df 91       	pop	r29
    5f1c:	1f 91       	pop	r17
    5f1e:	0f 91       	pop	r16
    5f20:	ff 90       	pop	r15
    5f22:	ef 90       	pop	r14
    5f24:	08 95       	ret

00005f26 <prvInitialiseNewTimer>:
                                       const TickType_t xTimerPeriodInTicks,
                                       const UBaseType_t uxAutoReload,
                                       void * const pvTimerID,
                                       TimerCallbackFunction_t pxCallbackFunction,
                                       Timer_t * pxNewTimer )
    {
    5f26:	ef 92       	push	r14
    5f28:	ff 92       	push	r15
    5f2a:	0f 93       	push	r16
    5f2c:	1f 93       	push	r17
    5f2e:	df 93       	push	r29
    5f30:	cf 93       	push	r28
    5f32:	cd b7       	in	r28, 0x3d	; 61
    5f34:	de b7       	in	r29, 0x3e	; 62
    5f36:	2b 97       	sbiw	r28, 0x0b	; 11
    5f38:	0f b6       	in	r0, 0x3f	; 63
    5f3a:	f8 94       	cli
    5f3c:	de bf       	out	0x3e, r29	; 62
    5f3e:	0f be       	out	0x3f, r0	; 63
    5f40:	cd bf       	out	0x3d, r28	; 61
    5f42:	9a 83       	std	Y+2, r25	; 0x02
    5f44:	89 83       	std	Y+1, r24	; 0x01
    5f46:	7c 83       	std	Y+4, r23	; 0x04
    5f48:	6b 83       	std	Y+3, r22	; 0x03
    5f4a:	4d 83       	std	Y+5, r20	; 0x05
    5f4c:	3f 83       	std	Y+7, r19	; 0x07
    5f4e:	2e 83       	std	Y+6, r18	; 0x06
    5f50:	19 87       	std	Y+9, r17	; 0x09
    5f52:	08 87       	std	Y+8, r16	; 0x08
    5f54:	fb 86       	std	Y+11, r15	; 0x0b
    5f56:	ea 86       	std	Y+10, r14	; 0x0a
        /* 0 is not a valid value for xTimerPeriodInTicks. */
        configASSERT( ( xTimerPeriodInTicks > 0 ) );

        /* Ensure the infrastructure used by the timer service task has been
         * created/initialised. */
        prvCheckForValidListAndQueue();
    5f58:	0e 94 e6 33 	call	0x67cc	; 0x67cc <prvCheckForValidListAndQueue>

        /* Initialise the timer structure members using the function
         * parameters. */
        pxNewTimer->pcTimerName = pcTimerName;
    5f5c:	ea 85       	ldd	r30, Y+10	; 0x0a
    5f5e:	fb 85       	ldd	r31, Y+11	; 0x0b
    5f60:	89 81       	ldd	r24, Y+1	; 0x01
    5f62:	9a 81       	ldd	r25, Y+2	; 0x02
    5f64:	91 83       	std	Z+1, r25	; 0x01
    5f66:	80 83       	st	Z, r24
        pxNewTimer->xTimerPeriodInTicks = xTimerPeriodInTicks;
    5f68:	ea 85       	ldd	r30, Y+10	; 0x0a
    5f6a:	fb 85       	ldd	r31, Y+11	; 0x0b
    5f6c:	8b 81       	ldd	r24, Y+3	; 0x03
    5f6e:	9c 81       	ldd	r25, Y+4	; 0x04
    5f70:	95 87       	std	Z+13, r25	; 0x0d
    5f72:	84 87       	std	Z+12, r24	; 0x0c
        pxNewTimer->pvTimerID = pvTimerID;
    5f74:	ea 85       	ldd	r30, Y+10	; 0x0a
    5f76:	fb 85       	ldd	r31, Y+11	; 0x0b
    5f78:	8e 81       	ldd	r24, Y+6	; 0x06
    5f7a:	9f 81       	ldd	r25, Y+7	; 0x07
    5f7c:	97 87       	std	Z+15, r25	; 0x0f
    5f7e:	86 87       	std	Z+14, r24	; 0x0e
        pxNewTimer->pxCallbackFunction = pxCallbackFunction;
    5f80:	ea 85       	ldd	r30, Y+10	; 0x0a
    5f82:	fb 85       	ldd	r31, Y+11	; 0x0b
    5f84:	88 85       	ldd	r24, Y+8	; 0x08
    5f86:	99 85       	ldd	r25, Y+9	; 0x09
    5f88:	91 8b       	std	Z+17, r25	; 0x11
    5f8a:	80 8b       	std	Z+16, r24	; 0x10
        vListInitialiseItem( &( pxNewTimer->xTimerListItem ) );
    5f8c:	8a 85       	ldd	r24, Y+10	; 0x0a
    5f8e:	9b 85       	ldd	r25, Y+11	; 0x0b
    5f90:	02 96       	adiw	r24, 0x02	; 2
    5f92:	0e 94 d5 10 	call	0x21aa	; 0x21aa <vListInitialiseItem>

        if( uxAutoReload != pdFALSE )
    5f96:	8d 81       	ldd	r24, Y+5	; 0x05
    5f98:	88 23       	and	r24, r24
    5f9a:	39 f0       	breq	.+14     	; 0x5faa <prvInitialiseNewTimer+0x84>
        {
            pxNewTimer->ucStatus |= tmrSTATUS_IS_AUTORELOAD;
    5f9c:	ea 85       	ldd	r30, Y+10	; 0x0a
    5f9e:	fb 85       	ldd	r31, Y+11	; 0x0b
    5fa0:	82 89       	ldd	r24, Z+18	; 0x12
    5fa2:	84 60       	ori	r24, 0x04	; 4
    5fa4:	ea 85       	ldd	r30, Y+10	; 0x0a
    5fa6:	fb 85       	ldd	r31, Y+11	; 0x0b
    5fa8:	82 8b       	std	Z+18, r24	; 0x12
        }

        traceTIMER_CREATE( pxNewTimer );
    }
    5faa:	2b 96       	adiw	r28, 0x0b	; 11
    5fac:	0f b6       	in	r0, 0x3f	; 63
    5fae:	f8 94       	cli
    5fb0:	de bf       	out	0x3e, r29	; 62
    5fb2:	0f be       	out	0x3f, r0	; 63
    5fb4:	cd bf       	out	0x3d, r28	; 61
    5fb6:	cf 91       	pop	r28
    5fb8:	df 91       	pop	r29
    5fba:	1f 91       	pop	r17
    5fbc:	0f 91       	pop	r16
    5fbe:	ff 90       	pop	r15
    5fc0:	ef 90       	pop	r14
    5fc2:	08 95       	ret

00005fc4 <xTimerGenericCommand>:
    BaseType_t xTimerGenericCommand( TimerHandle_t xTimer,
                                     const BaseType_t xCommandID,
                                     const TickType_t xOptionalValue,
                                     BaseType_t * const pxHigherPriorityTaskWoken,
                                     const TickType_t xTicksToWait )
    {
    5fc4:	0f 93       	push	r16
    5fc6:	1f 93       	push	r17
    5fc8:	df 93       	push	r29
    5fca:	cf 93       	push	r28
    5fcc:	cd b7       	in	r28, 0x3d	; 61
    5fce:	de b7       	in	r29, 0x3e	; 62
    5fd0:	2f 97       	sbiw	r28, 0x0f	; 15
    5fd2:	0f b6       	in	r0, 0x3f	; 63
    5fd4:	f8 94       	cli
    5fd6:	de bf       	out	0x3e, r29	; 62
    5fd8:	0f be       	out	0x3f, r0	; 63
    5fda:	cd bf       	out	0x3d, r28	; 61
    5fdc:	98 87       	std	Y+8, r25	; 0x08
    5fde:	8f 83       	std	Y+7, r24	; 0x07
    5fe0:	69 87       	std	Y+9, r22	; 0x09
    5fe2:	5b 87       	std	Y+11, r21	; 0x0b
    5fe4:	4a 87       	std	Y+10, r20	; 0x0a
    5fe6:	3d 87       	std	Y+13, r19	; 0x0d
    5fe8:	2c 87       	std	Y+12, r18	; 0x0c
    5fea:	1f 87       	std	Y+15, r17	; 0x0f
    5fec:	0e 87       	std	Y+14, r16	; 0x0e
        BaseType_t xReturn = pdFAIL;
    5fee:	19 82       	std	Y+1, r1	; 0x01

        configASSERT( xTimer );

        /* Send a message to the timer service task to perform a particular action
         * on a particular timer definition. */
        if( xTimerQueue != NULL )
    5ff0:	80 91 ba 08 	lds	r24, 0x08BA
    5ff4:	90 91 bb 08 	lds	r25, 0x08BB
    5ff8:	00 97       	sbiw	r24, 0x00	; 0
    5ffa:	e9 f1       	breq	.+122    	; 0x6076 <xTimerGenericCommand+0xb2>
        {
            /* Send a command to the timer service task to start the xTimer timer. */
            xMessage.xMessageID = xCommandID;
    5ffc:	89 85       	ldd	r24, Y+9	; 0x09
    5ffe:	8a 83       	std	Y+2, r24	; 0x02
            xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
    6000:	8a 85       	ldd	r24, Y+10	; 0x0a
    6002:	9b 85       	ldd	r25, Y+11	; 0x0b
    6004:	9c 83       	std	Y+4, r25	; 0x04
    6006:	8b 83       	std	Y+3, r24	; 0x03
            xMessage.u.xTimerParameters.pxTimer = xTimer;
    6008:	8f 81       	ldd	r24, Y+7	; 0x07
    600a:	98 85       	ldd	r25, Y+8	; 0x08
    600c:	9e 83       	std	Y+6, r25	; 0x06
    600e:	8d 83       	std	Y+5, r24	; 0x05

            if( xCommandID < tmrFIRST_FROM_ISR_COMMAND )
    6010:	89 85       	ldd	r24, Y+9	; 0x09
    6012:	86 30       	cpi	r24, 0x06	; 6
    6014:	14 f5       	brge	.+68     	; 0x605a <xTimerGenericCommand+0x96>
            {
                if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
    6016:	0e 94 fc 26 	call	0x4df8	; 0x4df8 <xTaskGetSchedulerState>
    601a:	82 30       	cpi	r24, 0x02	; 2
    601c:	79 f4       	brne	.+30     	; 0x603c <xTimerGenericCommand+0x78>
                {
                    xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
    601e:	80 91 ba 08 	lds	r24, 0x08BA
    6022:	90 91 bb 08 	lds	r25, 0x08BB
    6026:	9e 01       	movw	r18, r28
    6028:	2e 5f       	subi	r18, 0xFE	; 254
    602a:	3f 4f       	sbci	r19, 0xFF	; 255
    602c:	4e 85       	ldd	r20, Y+14	; 0x0e
    602e:	5f 85       	ldd	r21, Y+15	; 0x0f
    6030:	b9 01       	movw	r22, r18
    6032:	20 e0       	ldi	r18, 0x00	; 0
    6034:	0e 94 3b 13 	call	0x2676	; 0x2676 <xQueueGenericSend>
    6038:	89 83       	std	Y+1, r24	; 0x01
    603a:	1d c0       	rjmp	.+58     	; 0x6076 <xTimerGenericCommand+0xb2>
                }
                else
                {
                    xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
    603c:	80 91 ba 08 	lds	r24, 0x08BA
    6040:	90 91 bb 08 	lds	r25, 0x08BB
    6044:	9e 01       	movw	r18, r28
    6046:	2e 5f       	subi	r18, 0xFE	; 254
    6048:	3f 4f       	sbci	r19, 0xFF	; 255
    604a:	b9 01       	movw	r22, r18
    604c:	40 e0       	ldi	r20, 0x00	; 0
    604e:	50 e0       	ldi	r21, 0x00	; 0
    6050:	20 e0       	ldi	r18, 0x00	; 0
    6052:	0e 94 3b 13 	call	0x2676	; 0x2676 <xQueueGenericSend>
    6056:	89 83       	std	Y+1, r24	; 0x01
    6058:	0e c0       	rjmp	.+28     	; 0x6076 <xTimerGenericCommand+0xb2>
                }
            }
            else
            {
                xReturn = xQueueSendToBackFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
    605a:	80 91 ba 08 	lds	r24, 0x08BA
    605e:	90 91 bb 08 	lds	r25, 0x08BB
    6062:	9e 01       	movw	r18, r28
    6064:	2e 5f       	subi	r18, 0xFE	; 254
    6066:	3f 4f       	sbci	r19, 0xFF	; 255
    6068:	4c 85       	ldd	r20, Y+12	; 0x0c
    606a:	5d 85       	ldd	r21, Y+13	; 0x0d
    606c:	b9 01       	movw	r22, r18
    606e:	20 e0       	ldi	r18, 0x00	; 0
    6070:	0e 94 e7 13 	call	0x27ce	; 0x27ce <xQueueGenericSendFromISR>
    6074:	89 83       	std	Y+1, r24	; 0x01
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        return xReturn;
    6076:	89 81       	ldd	r24, Y+1	; 0x01
    }
    6078:	2f 96       	adiw	r28, 0x0f	; 15
    607a:	0f b6       	in	r0, 0x3f	; 63
    607c:	f8 94       	cli
    607e:	de bf       	out	0x3e, r29	; 62
    6080:	0f be       	out	0x3f, r0	; 63
    6082:	cd bf       	out	0x3d, r28	; 61
    6084:	cf 91       	pop	r28
    6086:	df 91       	pop	r29
    6088:	1f 91       	pop	r17
    608a:	0f 91       	pop	r16
    608c:	08 95       	ret

0000608e <xTimerGetTimerDaemonTaskHandle>:
/*-----------------------------------------------------------*/

    TaskHandle_t xTimerGetTimerDaemonTaskHandle( void )
    {
    608e:	df 93       	push	r29
    6090:	cf 93       	push	r28
    6092:	cd b7       	in	r28, 0x3d	; 61
    6094:	de b7       	in	r29, 0x3e	; 62
        /* If xTimerGetTimerDaemonTaskHandle() is called before the scheduler has been
         * started, then xTimerTaskHandle will be NULL. */
        configASSERT( ( xTimerTaskHandle != NULL ) );
        return xTimerTaskHandle;
    6096:	80 91 bc 08 	lds	r24, 0x08BC
    609a:	90 91 bd 08 	lds	r25, 0x08BD
    }
    609e:	cf 91       	pop	r28
    60a0:	df 91       	pop	r29
    60a2:	08 95       	ret

000060a4 <xTimerGetPeriod>:
/*-----------------------------------------------------------*/

    TickType_t xTimerGetPeriod( TimerHandle_t xTimer )
    {
    60a4:	df 93       	push	r29
    60a6:	cf 93       	push	r28
    60a8:	00 d0       	rcall	.+0      	; 0x60aa <xTimerGetPeriod+0x6>
    60aa:	00 d0       	rcall	.+0      	; 0x60ac <xTimerGetPeriod+0x8>
    60ac:	cd b7       	in	r28, 0x3d	; 61
    60ae:	de b7       	in	r29, 0x3e	; 62
    60b0:	9c 83       	std	Y+4, r25	; 0x04
    60b2:	8b 83       	std	Y+3, r24	; 0x03
        Timer_t * pxTimer = xTimer;
    60b4:	8b 81       	ldd	r24, Y+3	; 0x03
    60b6:	9c 81       	ldd	r25, Y+4	; 0x04
    60b8:	9a 83       	std	Y+2, r25	; 0x02
    60ba:	89 83       	std	Y+1, r24	; 0x01

        configASSERT( xTimer );
        return pxTimer->xTimerPeriodInTicks;
    60bc:	e9 81       	ldd	r30, Y+1	; 0x01
    60be:	fa 81       	ldd	r31, Y+2	; 0x02
    60c0:	84 85       	ldd	r24, Z+12	; 0x0c
    60c2:	95 85       	ldd	r25, Z+13	; 0x0d
    }
    60c4:	0f 90       	pop	r0
    60c6:	0f 90       	pop	r0
    60c8:	0f 90       	pop	r0
    60ca:	0f 90       	pop	r0
    60cc:	cf 91       	pop	r28
    60ce:	df 91       	pop	r29
    60d0:	08 95       	ret

000060d2 <vTimerSetReloadMode>:
/*-----------------------------------------------------------*/

    void vTimerSetReloadMode( TimerHandle_t xTimer,
                              const UBaseType_t uxAutoReload )
    {
    60d2:	df 93       	push	r29
    60d4:	cf 93       	push	r28
    60d6:	00 d0       	rcall	.+0      	; 0x60d8 <vTimerSetReloadMode+0x6>
    60d8:	00 d0       	rcall	.+0      	; 0x60da <vTimerSetReloadMode+0x8>
    60da:	0f 92       	push	r0
    60dc:	cd b7       	in	r28, 0x3d	; 61
    60de:	de b7       	in	r29, 0x3e	; 62
    60e0:	9c 83       	std	Y+4, r25	; 0x04
    60e2:	8b 83       	std	Y+3, r24	; 0x03
    60e4:	6d 83       	std	Y+5, r22	; 0x05
        Timer_t * pxTimer = xTimer;
    60e6:	8b 81       	ldd	r24, Y+3	; 0x03
    60e8:	9c 81       	ldd	r25, Y+4	; 0x04
    60ea:	9a 83       	std	Y+2, r25	; 0x02
    60ec:	89 83       	std	Y+1, r24	; 0x01

        configASSERT( xTimer );
        taskENTER_CRITICAL();
    60ee:	0f b6       	in	r0, 0x3f	; 63
    60f0:	f8 94       	cli
    60f2:	0f 92       	push	r0
        {
            if( uxAutoReload != pdFALSE )
    60f4:	8d 81       	ldd	r24, Y+5	; 0x05
    60f6:	88 23       	and	r24, r24
    60f8:	41 f0       	breq	.+16     	; 0x610a <vTimerSetReloadMode+0x38>
            {
                pxTimer->ucStatus |= tmrSTATUS_IS_AUTORELOAD;
    60fa:	e9 81       	ldd	r30, Y+1	; 0x01
    60fc:	fa 81       	ldd	r31, Y+2	; 0x02
    60fe:	82 89       	ldd	r24, Z+18	; 0x12
    6100:	84 60       	ori	r24, 0x04	; 4
    6102:	e9 81       	ldd	r30, Y+1	; 0x01
    6104:	fa 81       	ldd	r31, Y+2	; 0x02
    6106:	82 8b       	std	Z+18, r24	; 0x12
    6108:	07 c0       	rjmp	.+14     	; 0x6118 <vTimerSetReloadMode+0x46>
            }
            else
            {
                pxTimer->ucStatus &= ( ( uint8_t ) ~tmrSTATUS_IS_AUTORELOAD );
    610a:	e9 81       	ldd	r30, Y+1	; 0x01
    610c:	fa 81       	ldd	r31, Y+2	; 0x02
    610e:	82 89       	ldd	r24, Z+18	; 0x12
    6110:	8b 7f       	andi	r24, 0xFB	; 251
    6112:	e9 81       	ldd	r30, Y+1	; 0x01
    6114:	fa 81       	ldd	r31, Y+2	; 0x02
    6116:	82 8b       	std	Z+18, r24	; 0x12
            }
        }
        taskEXIT_CRITICAL();
    6118:	0f 90       	pop	r0
    611a:	0f be       	out	0x3f, r0	; 63
    }
    611c:	0f 90       	pop	r0
    611e:	0f 90       	pop	r0
    6120:	0f 90       	pop	r0
    6122:	0f 90       	pop	r0
    6124:	0f 90       	pop	r0
    6126:	cf 91       	pop	r28
    6128:	df 91       	pop	r29
    612a:	08 95       	ret

0000612c <uxTimerGetReloadMode>:
/*-----------------------------------------------------------*/

    UBaseType_t uxTimerGetReloadMode( TimerHandle_t xTimer )
    {
    612c:	df 93       	push	r29
    612e:	cf 93       	push	r28
    6130:	00 d0       	rcall	.+0      	; 0x6132 <uxTimerGetReloadMode+0x6>
    6132:	00 d0       	rcall	.+0      	; 0x6134 <uxTimerGetReloadMode+0x8>
    6134:	0f 92       	push	r0
    6136:	cd b7       	in	r28, 0x3d	; 61
    6138:	de b7       	in	r29, 0x3e	; 62
    613a:	9d 83       	std	Y+5, r25	; 0x05
    613c:	8c 83       	std	Y+4, r24	; 0x04
        Timer_t * pxTimer = xTimer;
    613e:	8c 81       	ldd	r24, Y+4	; 0x04
    6140:	9d 81       	ldd	r25, Y+5	; 0x05
    6142:	9b 83       	std	Y+3, r25	; 0x03
    6144:	8a 83       	std	Y+2, r24	; 0x02
        UBaseType_t uxReturn;

        configASSERT( xTimer );
        taskENTER_CRITICAL();
    6146:	0f b6       	in	r0, 0x3f	; 63
    6148:	f8 94       	cli
    614a:	0f 92       	push	r0
        {
            if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) == 0 )
    614c:	ea 81       	ldd	r30, Y+2	; 0x02
    614e:	fb 81       	ldd	r31, Y+3	; 0x03
    6150:	82 89       	ldd	r24, Z+18	; 0x12
    6152:	88 2f       	mov	r24, r24
    6154:	90 e0       	ldi	r25, 0x00	; 0
    6156:	84 70       	andi	r24, 0x04	; 4
    6158:	90 70       	andi	r25, 0x00	; 0
    615a:	00 97       	sbiw	r24, 0x00	; 0
    615c:	11 f4       	brne	.+4      	; 0x6162 <uxTimerGetReloadMode+0x36>
            {
                /* Not an auto-reload timer. */
                uxReturn = ( UBaseType_t ) pdFALSE;
    615e:	19 82       	std	Y+1, r1	; 0x01
    6160:	02 c0       	rjmp	.+4      	; 0x6166 <uxTimerGetReloadMode+0x3a>
            }
            else
            {
                /* Is an auto-reload timer. */
                uxReturn = ( UBaseType_t ) pdTRUE;
    6162:	81 e0       	ldi	r24, 0x01	; 1
    6164:	89 83       	std	Y+1, r24	; 0x01
            }
        }
        taskEXIT_CRITICAL();
    6166:	0f 90       	pop	r0
    6168:	0f be       	out	0x3f, r0	; 63

        return uxReturn;
    616a:	89 81       	ldd	r24, Y+1	; 0x01
    }
    616c:	0f 90       	pop	r0
    616e:	0f 90       	pop	r0
    6170:	0f 90       	pop	r0
    6172:	0f 90       	pop	r0
    6174:	0f 90       	pop	r0
    6176:	cf 91       	pop	r28
    6178:	df 91       	pop	r29
    617a:	08 95       	ret

0000617c <xTimerGetExpiryTime>:
/*-----------------------------------------------------------*/

    TickType_t xTimerGetExpiryTime( TimerHandle_t xTimer )
    {
    617c:	df 93       	push	r29
    617e:	cf 93       	push	r28
    6180:	00 d0       	rcall	.+0      	; 0x6182 <xTimerGetExpiryTime+0x6>
    6182:	00 d0       	rcall	.+0      	; 0x6184 <xTimerGetExpiryTime+0x8>
    6184:	00 d0       	rcall	.+0      	; 0x6186 <xTimerGetExpiryTime+0xa>
    6186:	cd b7       	in	r28, 0x3d	; 61
    6188:	de b7       	in	r29, 0x3e	; 62
    618a:	9e 83       	std	Y+6, r25	; 0x06
    618c:	8d 83       	std	Y+5, r24	; 0x05
        Timer_t * pxTimer = xTimer;
    618e:	8d 81       	ldd	r24, Y+5	; 0x05
    6190:	9e 81       	ldd	r25, Y+6	; 0x06
    6192:	9c 83       	std	Y+4, r25	; 0x04
    6194:	8b 83       	std	Y+3, r24	; 0x03
        TickType_t xReturn;

        configASSERT( xTimer );
        xReturn = listGET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ) );
    6196:	eb 81       	ldd	r30, Y+3	; 0x03
    6198:	fc 81       	ldd	r31, Y+4	; 0x04
    619a:	82 81       	ldd	r24, Z+2	; 0x02
    619c:	93 81       	ldd	r25, Z+3	; 0x03
    619e:	9a 83       	std	Y+2, r25	; 0x02
    61a0:	89 83       	std	Y+1, r24	; 0x01
        return xReturn;
    61a2:	89 81       	ldd	r24, Y+1	; 0x01
    61a4:	9a 81       	ldd	r25, Y+2	; 0x02
    }
    61a6:	26 96       	adiw	r28, 0x06	; 6
    61a8:	0f b6       	in	r0, 0x3f	; 63
    61aa:	f8 94       	cli
    61ac:	de bf       	out	0x3e, r29	; 62
    61ae:	0f be       	out	0x3f, r0	; 63
    61b0:	cd bf       	out	0x3d, r28	; 61
    61b2:	cf 91       	pop	r28
    61b4:	df 91       	pop	r29
    61b6:	08 95       	ret

000061b8 <pcTimerGetName>:
/*-----------------------------------------------------------*/

    const char * pcTimerGetName( TimerHandle_t xTimer ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
    {
    61b8:	df 93       	push	r29
    61ba:	cf 93       	push	r28
    61bc:	00 d0       	rcall	.+0      	; 0x61be <pcTimerGetName+0x6>
    61be:	00 d0       	rcall	.+0      	; 0x61c0 <pcTimerGetName+0x8>
    61c0:	cd b7       	in	r28, 0x3d	; 61
    61c2:	de b7       	in	r29, 0x3e	; 62
    61c4:	9c 83       	std	Y+4, r25	; 0x04
    61c6:	8b 83       	std	Y+3, r24	; 0x03
        Timer_t * pxTimer = xTimer;
    61c8:	8b 81       	ldd	r24, Y+3	; 0x03
    61ca:	9c 81       	ldd	r25, Y+4	; 0x04
    61cc:	9a 83       	std	Y+2, r25	; 0x02
    61ce:	89 83       	std	Y+1, r24	; 0x01

        configASSERT( xTimer );
        return pxTimer->pcTimerName;
    61d0:	e9 81       	ldd	r30, Y+1	; 0x01
    61d2:	fa 81       	ldd	r31, Y+2	; 0x02
    61d4:	80 81       	ld	r24, Z
    61d6:	91 81       	ldd	r25, Z+1	; 0x01
    }
    61d8:	0f 90       	pop	r0
    61da:	0f 90       	pop	r0
    61dc:	0f 90       	pop	r0
    61de:	0f 90       	pop	r0
    61e0:	cf 91       	pop	r28
    61e2:	df 91       	pop	r29
    61e4:	08 95       	ret

000061e6 <prvReloadTimer>:
/*-----------------------------------------------------------*/

    static void prvReloadTimer( Timer_t * const pxTimer,
                                TickType_t xExpiredTime,
                                const TickType_t xTimeNow )
    {
    61e6:	df 93       	push	r29
    61e8:	cf 93       	push	r28
    61ea:	00 d0       	rcall	.+0      	; 0x61ec <prvReloadTimer+0x6>
    61ec:	00 d0       	rcall	.+0      	; 0x61ee <prvReloadTimer+0x8>
    61ee:	00 d0       	rcall	.+0      	; 0x61f0 <prvReloadTimer+0xa>
    61f0:	cd b7       	in	r28, 0x3d	; 61
    61f2:	de b7       	in	r29, 0x3e	; 62
    61f4:	9a 83       	std	Y+2, r25	; 0x02
    61f6:	89 83       	std	Y+1, r24	; 0x01
    61f8:	7c 83       	std	Y+4, r23	; 0x04
    61fa:	6b 83       	std	Y+3, r22	; 0x03
    61fc:	5e 83       	std	Y+6, r21	; 0x06
    61fe:	4d 83       	std	Y+5, r20	; 0x05
    6200:	12 c0       	rjmp	.+36     	; 0x6226 <prvReloadTimer+0x40>
         * If the next expiry time has already passed, advance the expiry time,
         * call the callback function, and try again. */
        while( prvInsertTimerInActiveList( pxTimer, ( xExpiredTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xExpiredTime ) != pdFALSE )
        {
            /* Advance the expiry time. */
            xExpiredTime += pxTimer->xTimerPeriodInTicks;
    6202:	e9 81       	ldd	r30, Y+1	; 0x01
    6204:	fa 81       	ldd	r31, Y+2	; 0x02
    6206:	24 85       	ldd	r18, Z+12	; 0x0c
    6208:	35 85       	ldd	r19, Z+13	; 0x0d
    620a:	8b 81       	ldd	r24, Y+3	; 0x03
    620c:	9c 81       	ldd	r25, Y+4	; 0x04
    620e:	82 0f       	add	r24, r18
    6210:	93 1f       	adc	r25, r19
    6212:	9c 83       	std	Y+4, r25	; 0x04
    6214:	8b 83       	std	Y+3, r24	; 0x03

            /* Call the timer callback. */
            traceTIMER_EXPIRED( pxTimer );
            pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    6216:	e9 81       	ldd	r30, Y+1	; 0x01
    6218:	fa 81       	ldd	r31, Y+2	; 0x02
    621a:	00 88       	ldd	r0, Z+16	; 0x10
    621c:	f1 89       	ldd	r31, Z+17	; 0x11
    621e:	e0 2d       	mov	r30, r0
    6220:	89 81       	ldd	r24, Y+1	; 0x01
    6222:	9a 81       	ldd	r25, Y+2	; 0x02
    6224:	09 95       	icall
                                const TickType_t xTimeNow )
    {
        /* Insert the timer into the appropriate list for the next expiry time.
         * If the next expiry time has already passed, advance the expiry time,
         * call the callback function, and try again. */
        while( prvInsertTimerInActiveList( pxTimer, ( xExpiredTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xExpiredTime ) != pdFALSE )
    6226:	e9 81       	ldd	r30, Y+1	; 0x01
    6228:	fa 81       	ldd	r31, Y+2	; 0x02
    622a:	24 85       	ldd	r18, Z+12	; 0x0c
    622c:	35 85       	ldd	r19, Z+13	; 0x0d
    622e:	8b 81       	ldd	r24, Y+3	; 0x03
    6230:	9c 81       	ldd	r25, Y+4	; 0x04
    6232:	a9 01       	movw	r20, r18
    6234:	48 0f       	add	r20, r24
    6236:	59 1f       	adc	r21, r25
    6238:	89 81       	ldd	r24, Y+1	; 0x01
    623a:	9a 81       	ldd	r25, Y+2	; 0x02
    623c:	2d 81       	ldd	r18, Y+5	; 0x05
    623e:	3e 81       	ldd	r19, Y+6	; 0x06
    6240:	eb 81       	ldd	r30, Y+3	; 0x03
    6242:	fc 81       	ldd	r31, Y+4	; 0x04
    6244:	ba 01       	movw	r22, r20
    6246:	a9 01       	movw	r20, r18
    6248:	9f 01       	movw	r18, r30
    624a:	0e 94 49 32 	call	0x6492	; 0x6492 <prvInsertTimerInActiveList>
    624e:	88 23       	and	r24, r24
    6250:	c1 f6       	brne	.-80     	; 0x6202 <prvReloadTimer+0x1c>

            /* Call the timer callback. */
            traceTIMER_EXPIRED( pxTimer );
            pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
        }
    }
    6252:	26 96       	adiw	r28, 0x06	; 6
    6254:	0f b6       	in	r0, 0x3f	; 63
    6256:	f8 94       	cli
    6258:	de bf       	out	0x3e, r29	; 62
    625a:	0f be       	out	0x3f, r0	; 63
    625c:	cd bf       	out	0x3d, r28	; 61
    625e:	cf 91       	pop	r28
    6260:	df 91       	pop	r29
    6262:	08 95       	ret

00006264 <prvProcessExpiredTimer>:
/*-----------------------------------------------------------*/

    static void prvProcessExpiredTimer( const TickType_t xNextExpireTime,
                                        const TickType_t xTimeNow )
    {
    6264:	df 93       	push	r29
    6266:	cf 93       	push	r28
    6268:	00 d0       	rcall	.+0      	; 0x626a <prvProcessExpiredTimer+0x6>
    626a:	00 d0       	rcall	.+0      	; 0x626c <prvProcessExpiredTimer+0x8>
    626c:	00 d0       	rcall	.+0      	; 0x626e <prvProcessExpiredTimer+0xa>
    626e:	cd b7       	in	r28, 0x3d	; 61
    6270:	de b7       	in	r29, 0x3e	; 62
    6272:	9c 83       	std	Y+4, r25	; 0x04
    6274:	8b 83       	std	Y+3, r24	; 0x03
    6276:	7e 83       	std	Y+6, r23	; 0x06
    6278:	6d 83       	std	Y+5, r22	; 0x05
        Timer_t * const pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); /*lint !e9087 !e9079 void * is used as this macro is used with tasks and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    627a:	e0 91 d2 08 	lds	r30, 0x08D2
    627e:	f0 91 d3 08 	lds	r31, 0x08D3
    6282:	05 80       	ldd	r0, Z+5	; 0x05
    6284:	f6 81       	ldd	r31, Z+6	; 0x06
    6286:	e0 2d       	mov	r30, r0
    6288:	86 81       	ldd	r24, Z+6	; 0x06
    628a:	97 81       	ldd	r25, Z+7	; 0x07
    628c:	9a 83       	std	Y+2, r25	; 0x02
    628e:	89 83       	std	Y+1, r24	; 0x01

        /* Remove the timer from the list of active timers.  A check has already
         * been performed to ensure the list is not empty. */

        ( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    6290:	89 81       	ldd	r24, Y+1	; 0x01
    6292:	9a 81       	ldd	r25, Y+2	; 0x02
    6294:	02 96       	adiw	r24, 0x02	; 2
    6296:	0e 94 95 11 	call	0x232a	; 0x232a <uxListRemove>

        /* If the timer is an auto-reload timer then calculate the next
         * expiry time and re-insert the timer in the list of active timers. */
        if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
    629a:	e9 81       	ldd	r30, Y+1	; 0x01
    629c:	fa 81       	ldd	r31, Y+2	; 0x02
    629e:	82 89       	ldd	r24, Z+18	; 0x12
    62a0:	88 2f       	mov	r24, r24
    62a2:	90 e0       	ldi	r25, 0x00	; 0
    62a4:	84 70       	andi	r24, 0x04	; 4
    62a6:	90 70       	andi	r25, 0x00	; 0
    62a8:	00 97       	sbiw	r24, 0x00	; 0
    62aa:	51 f0       	breq	.+20     	; 0x62c0 <prvProcessExpiredTimer+0x5c>
        {
            prvReloadTimer( pxTimer, xNextExpireTime, xTimeNow );
    62ac:	89 81       	ldd	r24, Y+1	; 0x01
    62ae:	9a 81       	ldd	r25, Y+2	; 0x02
    62b0:	2b 81       	ldd	r18, Y+3	; 0x03
    62b2:	3c 81       	ldd	r19, Y+4	; 0x04
    62b4:	4d 81       	ldd	r20, Y+5	; 0x05
    62b6:	5e 81       	ldd	r21, Y+6	; 0x06
    62b8:	b9 01       	movw	r22, r18
    62ba:	0e 94 f3 30 	call	0x61e6	; 0x61e6 <prvReloadTimer>
    62be:	07 c0       	rjmp	.+14     	; 0x62ce <prvProcessExpiredTimer+0x6a>
        }
        else
        {
            pxTimer->ucStatus &= ( ( uint8_t ) ~tmrSTATUS_IS_ACTIVE );
    62c0:	e9 81       	ldd	r30, Y+1	; 0x01
    62c2:	fa 81       	ldd	r31, Y+2	; 0x02
    62c4:	82 89       	ldd	r24, Z+18	; 0x12
    62c6:	8e 7f       	andi	r24, 0xFE	; 254
    62c8:	e9 81       	ldd	r30, Y+1	; 0x01
    62ca:	fa 81       	ldd	r31, Y+2	; 0x02
    62cc:	82 8b       	std	Z+18, r24	; 0x12
        }

        /* Call the timer callback. */
        traceTIMER_EXPIRED( pxTimer );
        pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    62ce:	e9 81       	ldd	r30, Y+1	; 0x01
    62d0:	fa 81       	ldd	r31, Y+2	; 0x02
    62d2:	00 88       	ldd	r0, Z+16	; 0x10
    62d4:	f1 89       	ldd	r31, Z+17	; 0x11
    62d6:	e0 2d       	mov	r30, r0
    62d8:	89 81       	ldd	r24, Y+1	; 0x01
    62da:	9a 81       	ldd	r25, Y+2	; 0x02
    62dc:	09 95       	icall
    }
    62de:	26 96       	adiw	r28, 0x06	; 6
    62e0:	0f b6       	in	r0, 0x3f	; 63
    62e2:	f8 94       	cli
    62e4:	de bf       	out	0x3e, r29	; 62
    62e6:	0f be       	out	0x3f, r0	; 63
    62e8:	cd bf       	out	0x3d, r28	; 61
    62ea:	cf 91       	pop	r28
    62ec:	df 91       	pop	r29
    62ee:	08 95       	ret

000062f0 <prvTimerTask>:
/*-----------------------------------------------------------*/

    static portTASK_FUNCTION( prvTimerTask, pvParameters )
    {
    62f0:	df 93       	push	r29
    62f2:	cf 93       	push	r28
    62f4:	00 d0       	rcall	.+0      	; 0x62f6 <prvTimerTask+0x6>
    62f6:	00 d0       	rcall	.+0      	; 0x62f8 <prvTimerTask+0x8>
    62f8:	0f 92       	push	r0
    62fa:	cd b7       	in	r28, 0x3d	; 61
    62fc:	de b7       	in	r29, 0x3e	; 62
    62fe:	9d 83       	std	Y+5, r25	; 0x05
    6300:	8c 83       	std	Y+4, r24	; 0x04

        for( ; ; )
        {
            /* Query the timers list to see if it contains any timers, and if so,
             * obtain the time at which the next timer will expire. */
            xNextExpireTime = prvGetNextExpireTime( &xListWasEmpty );
    6302:	ce 01       	movw	r24, r28
    6304:	03 96       	adiw	r24, 0x03	; 3
    6306:	0e 94 e7 31 	call	0x63ce	; 0x63ce <prvGetNextExpireTime>
    630a:	9a 83       	std	Y+2, r25	; 0x02
    630c:	89 83       	std	Y+1, r24	; 0x01

            /* If a timer has expired, process it.  Otherwise, block this task
             * until either a timer does expire, or a command is received. */
            prvProcessTimerOrBlockTask( xNextExpireTime, xListWasEmpty );
    630e:	2b 81       	ldd	r18, Y+3	; 0x03
    6310:	89 81       	ldd	r24, Y+1	; 0x01
    6312:	9a 81       	ldd	r25, Y+2	; 0x02
    6314:	62 2f       	mov	r22, r18
    6316:	0e 94 90 31 	call	0x6320	; 0x6320 <prvProcessTimerOrBlockTask>

            /* Empty the command queue. */
            prvProcessReceivedCommands();
    631a:	0e 94 b1 32 	call	0x6562	; 0x6562 <prvProcessReceivedCommands>
    631e:	f1 cf       	rjmp	.-30     	; 0x6302 <prvTimerTask+0x12>

00006320 <prvProcessTimerOrBlockTask>:
    }
/*-----------------------------------------------------------*/

    static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime,
                                            BaseType_t xListWasEmpty )
    {
    6320:	df 93       	push	r29
    6322:	cf 93       	push	r28
    6324:	00 d0       	rcall	.+0      	; 0x6326 <prvProcessTimerOrBlockTask+0x6>
    6326:	00 d0       	rcall	.+0      	; 0x6328 <prvProcessTimerOrBlockTask+0x8>
    6328:	00 d0       	rcall	.+0      	; 0x632a <prvProcessTimerOrBlockTask+0xa>
    632a:	cd b7       	in	r28, 0x3d	; 61
    632c:	de b7       	in	r29, 0x3e	; 62
    632e:	9d 83       	std	Y+5, r25	; 0x05
    6330:	8c 83       	std	Y+4, r24	; 0x04
    6332:	6e 83       	std	Y+6, r22	; 0x06
        TickType_t xTimeNow;
        BaseType_t xTimerListsWereSwitched;

        vTaskSuspendAll();
    6334:	0e 94 88 1e 	call	0x3d10	; 0x3d10 <vTaskSuspendAll>
            /* Obtain the time now to make an assessment as to whether the timer
             * has expired or not.  If obtaining the time causes the lists to switch
             * then don't process this timer as any timers that remained in the list
             * when the lists were switched will have been processed within the
             * prvSampleTimeNow() function. */
            xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    6338:	ce 01       	movw	r24, r28
    633a:	03 96       	adiw	r24, 0x03	; 3
    633c:	0e 94 1b 32 	call	0x6436	; 0x6436 <prvSampleTimeNow>
    6340:	9a 83       	std	Y+2, r25	; 0x02
    6342:	89 83       	std	Y+1, r24	; 0x01

            if( xTimerListsWereSwitched == pdFALSE )
    6344:	8b 81       	ldd	r24, Y+3	; 0x03
    6346:	88 23       	and	r24, r24
    6348:	b9 f5       	brne	.+110    	; 0x63b8 <prvProcessTimerOrBlockTask+0x98>
            {
                /* The tick count has not overflowed, has the timer expired? */
                if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
    634a:	8e 81       	ldd	r24, Y+6	; 0x06
    634c:	88 23       	and	r24, r24
    634e:	89 f4       	brne	.+34     	; 0x6372 <prvProcessTimerOrBlockTask+0x52>
    6350:	2c 81       	ldd	r18, Y+4	; 0x04
    6352:	3d 81       	ldd	r19, Y+5	; 0x05
    6354:	89 81       	ldd	r24, Y+1	; 0x01
    6356:	9a 81       	ldd	r25, Y+2	; 0x02
    6358:	82 17       	cp	r24, r18
    635a:	93 07       	cpc	r25, r19
    635c:	50 f0       	brcs	.+20     	; 0x6372 <prvProcessTimerOrBlockTask+0x52>
                {
                    ( void ) xTaskResumeAll();
    635e:	0e 94 94 1e 	call	0x3d28	; 0x3d28 <xTaskResumeAll>
                    prvProcessExpiredTimer( xNextExpireTime, xTimeNow );
    6362:	8c 81       	ldd	r24, Y+4	; 0x04
    6364:	9d 81       	ldd	r25, Y+5	; 0x05
    6366:	29 81       	ldd	r18, Y+1	; 0x01
    6368:	3a 81       	ldd	r19, Y+2	; 0x02
    636a:	b9 01       	movw	r22, r18
    636c:	0e 94 32 31 	call	0x6264	; 0x6264 <prvProcessExpiredTimer>
    6370:	25 c0       	rjmp	.+74     	; 0x63bc <prvProcessTimerOrBlockTask+0x9c>
                     * time has not been reached yet.  This task should therefore
                     * block to wait for the next expire time or a command to be
                     * received - whichever comes first.  The following line cannot
                     * be reached unless xNextExpireTime > xTimeNow, except in the
                     * case when the current timer list is empty. */
                    if( xListWasEmpty != pdFALSE )
    6372:	8e 81       	ldd	r24, Y+6	; 0x06
    6374:	88 23       	and	r24, r24
    6376:	51 f0       	breq	.+20     	; 0x638c <prvProcessTimerOrBlockTask+0x6c>
                    {
                        /* The current timer list is empty - is the overflow list
                         * also empty? */
                        xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
    6378:	e0 91 d4 08 	lds	r30, 0x08D4
    637c:	f0 91 d5 08 	lds	r31, 0x08D5
    6380:	80 81       	ld	r24, Z
    6382:	1e 82       	std	Y+6, r1	; 0x06
    6384:	88 23       	and	r24, r24
    6386:	11 f4       	brne	.+4      	; 0x638c <prvProcessTimerOrBlockTask+0x6c>
    6388:	81 e0       	ldi	r24, 0x01	; 1
    638a:	8e 83       	std	Y+6, r24	; 0x06
                    }

                    vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ), xListWasEmpty );
    638c:	40 91 ba 08 	lds	r20, 0x08BA
    6390:	50 91 bb 08 	lds	r21, 0x08BB
    6394:	2c 81       	ldd	r18, Y+4	; 0x04
    6396:	3d 81       	ldd	r19, Y+5	; 0x05
    6398:	89 81       	ldd	r24, Y+1	; 0x01
    639a:	9a 81       	ldd	r25, Y+2	; 0x02
    639c:	28 1b       	sub	r18, r24
    639e:	39 0b       	sbc	r19, r25
    63a0:	ca 01       	movw	r24, r20
    63a2:	b9 01       	movw	r22, r18
    63a4:	4e 81       	ldd	r20, Y+6	; 0x06
    63a6:	0e 94 f4 1a 	call	0x35e8	; 0x35e8 <vQueueWaitForMessageRestricted>

                    if( xTaskResumeAll() == pdFALSE )
    63aa:	0e 94 94 1e 	call	0x3d28	; 0x3d28 <xTaskResumeAll>
    63ae:	88 23       	and	r24, r24
    63b0:	29 f4       	brne	.+10     	; 0x63bc <prvProcessTimerOrBlockTask+0x9c>
                    {
                        /* Yield to wait for either a command to arrive, or the
                         * block time to expire.  If a command arrived between the
                         * critical section being exited and this yield then the yield
                         * will not cause the task to block. */
                        portYIELD_WITHIN_API();
    63b2:	0e 94 72 09 	call	0x12e4	; 0x12e4 <vPortYield>
    63b6:	02 c0       	rjmp	.+4      	; 0x63bc <prvProcessTimerOrBlockTask+0x9c>
                    }
                }
            }
            else
            {
                ( void ) xTaskResumeAll();
    63b8:	0e 94 94 1e 	call	0x3d28	; 0x3d28 <xTaskResumeAll>
            }
        }
    }
    63bc:	26 96       	adiw	r28, 0x06	; 6
    63be:	0f b6       	in	r0, 0x3f	; 63
    63c0:	f8 94       	cli
    63c2:	de bf       	out	0x3e, r29	; 62
    63c4:	0f be       	out	0x3f, r0	; 63
    63c6:	cd bf       	out	0x3d, r28	; 61
    63c8:	cf 91       	pop	r28
    63ca:	df 91       	pop	r29
    63cc:	08 95       	ret

000063ce <prvGetNextExpireTime>:
/*-----------------------------------------------------------*/

    static TickType_t prvGetNextExpireTime( BaseType_t * const pxListWasEmpty )
    {
    63ce:	df 93       	push	r29
    63d0:	cf 93       	push	r28
    63d2:	00 d0       	rcall	.+0      	; 0x63d4 <prvGetNextExpireTime+0x6>
    63d4:	00 d0       	rcall	.+0      	; 0x63d6 <prvGetNextExpireTime+0x8>
    63d6:	0f 92       	push	r0
    63d8:	cd b7       	in	r28, 0x3d	; 61
    63da:	de b7       	in	r29, 0x3e	; 62
    63dc:	9c 83       	std	Y+4, r25	; 0x04
    63de:	8b 83       	std	Y+3, r24	; 0x03
         * the timer with the nearest expiry time will expire.  If there are no
         * active timers then just set the next expire time to 0.  That will cause
         * this task to unblock when the tick count overflows, at which point the
         * timer lists will be switched and the next expiry time can be
         * re-assessed.  */
        *pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
    63e0:	e0 91 d2 08 	lds	r30, 0x08D2
    63e4:	f0 91 d3 08 	lds	r31, 0x08D3
    63e8:	80 81       	ld	r24, Z
    63ea:	1d 82       	std	Y+5, r1	; 0x05
    63ec:	88 23       	and	r24, r24
    63ee:	11 f4       	brne	.+4      	; 0x63f4 <prvGetNextExpireTime+0x26>
    63f0:	81 e0       	ldi	r24, 0x01	; 1
    63f2:	8d 83       	std	Y+5, r24	; 0x05
    63f4:	eb 81       	ldd	r30, Y+3	; 0x03
    63f6:	fc 81       	ldd	r31, Y+4	; 0x04
    63f8:	8d 81       	ldd	r24, Y+5	; 0x05
    63fa:	80 83       	st	Z, r24

        if( *pxListWasEmpty == pdFALSE )
    63fc:	eb 81       	ldd	r30, Y+3	; 0x03
    63fe:	fc 81       	ldd	r31, Y+4	; 0x04
    6400:	80 81       	ld	r24, Z
    6402:	88 23       	and	r24, r24
    6404:	61 f4       	brne	.+24     	; 0x641e <prvGetNextExpireTime+0x50>
        {
            xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    6406:	e0 91 d2 08 	lds	r30, 0x08D2
    640a:	f0 91 d3 08 	lds	r31, 0x08D3
    640e:	05 80       	ldd	r0, Z+5	; 0x05
    6410:	f6 81       	ldd	r31, Z+6	; 0x06
    6412:	e0 2d       	mov	r30, r0
    6414:	80 81       	ld	r24, Z
    6416:	91 81       	ldd	r25, Z+1	; 0x01
    6418:	9a 83       	std	Y+2, r25	; 0x02
    641a:	89 83       	std	Y+1, r24	; 0x01
    641c:	02 c0       	rjmp	.+4      	; 0x6422 <prvGetNextExpireTime+0x54>
        }
        else
        {
            /* Ensure the task unblocks when the tick count rolls over. */
            xNextExpireTime = ( TickType_t ) 0U;
    641e:	1a 82       	std	Y+2, r1	; 0x02
    6420:	19 82       	std	Y+1, r1	; 0x01
        }

        return xNextExpireTime;
    6422:	89 81       	ldd	r24, Y+1	; 0x01
    6424:	9a 81       	ldd	r25, Y+2	; 0x02
    }
    6426:	0f 90       	pop	r0
    6428:	0f 90       	pop	r0
    642a:	0f 90       	pop	r0
    642c:	0f 90       	pop	r0
    642e:	0f 90       	pop	r0
    6430:	cf 91       	pop	r28
    6432:	df 91       	pop	r29
    6434:	08 95       	ret

00006436 <prvSampleTimeNow>:
/*-----------------------------------------------------------*/

    static TickType_t prvSampleTimeNow( BaseType_t * const pxTimerListsWereSwitched )
    {
    6436:	df 93       	push	r29
    6438:	cf 93       	push	r28
    643a:	00 d0       	rcall	.+0      	; 0x643c <prvSampleTimeNow+0x6>
    643c:	00 d0       	rcall	.+0      	; 0x643e <prvSampleTimeNow+0x8>
    643e:	cd b7       	in	r28, 0x3d	; 61
    6440:	de b7       	in	r29, 0x3e	; 62
    6442:	9c 83       	std	Y+4, r25	; 0x04
    6444:	8b 83       	std	Y+3, r24	; 0x03
        TickType_t xTimeNow;
        PRIVILEGED_DATA static TickType_t xLastTime = ( TickType_t ) 0U; /*lint !e956 Variable is only accessible to one task. */

        xTimeNow = xTaskGetTickCount();
    6446:	0e 94 e4 1f 	call	0x3fc8	; 0x3fc8 <xTaskGetTickCount>
    644a:	9a 83       	std	Y+2, r25	; 0x02
    644c:	89 83       	std	Y+1, r24	; 0x01

        if( xTimeNow < xLastTime )
    644e:	20 91 be 08 	lds	r18, 0x08BE
    6452:	30 91 bf 08 	lds	r19, 0x08BF
    6456:	89 81       	ldd	r24, Y+1	; 0x01
    6458:	9a 81       	ldd	r25, Y+2	; 0x02
    645a:	82 17       	cp	r24, r18
    645c:	93 07       	cpc	r25, r19
    645e:	38 f4       	brcc	.+14     	; 0x646e <prvSampleTimeNow+0x38>
        {
            prvSwitchTimerLists();
    6460:	0e 94 ac 33 	call	0x6758	; 0x6758 <prvSwitchTimerLists>
            *pxTimerListsWereSwitched = pdTRUE;
    6464:	eb 81       	ldd	r30, Y+3	; 0x03
    6466:	fc 81       	ldd	r31, Y+4	; 0x04
    6468:	81 e0       	ldi	r24, 0x01	; 1
    646a:	80 83       	st	Z, r24
    646c:	03 c0       	rjmp	.+6      	; 0x6474 <prvSampleTimeNow+0x3e>
        }
        else
        {
            *pxTimerListsWereSwitched = pdFALSE;
    646e:	eb 81       	ldd	r30, Y+3	; 0x03
    6470:	fc 81       	ldd	r31, Y+4	; 0x04
    6472:	10 82       	st	Z, r1
        }

        xLastTime = xTimeNow;
    6474:	89 81       	ldd	r24, Y+1	; 0x01
    6476:	9a 81       	ldd	r25, Y+2	; 0x02
    6478:	90 93 bf 08 	sts	0x08BF, r25
    647c:	80 93 be 08 	sts	0x08BE, r24

        return xTimeNow;
    6480:	89 81       	ldd	r24, Y+1	; 0x01
    6482:	9a 81       	ldd	r25, Y+2	; 0x02
    }
    6484:	0f 90       	pop	r0
    6486:	0f 90       	pop	r0
    6488:	0f 90       	pop	r0
    648a:	0f 90       	pop	r0
    648c:	cf 91       	pop	r28
    648e:	df 91       	pop	r29
    6490:	08 95       	ret

00006492 <prvInsertTimerInActiveList>:

    static BaseType_t prvInsertTimerInActiveList( Timer_t * const pxTimer,
                                                  const TickType_t xNextExpiryTime,
                                                  const TickType_t xTimeNow,
                                                  const TickType_t xCommandTime )
    {
    6492:	df 93       	push	r29
    6494:	cf 93       	push	r28
    6496:	cd b7       	in	r28, 0x3d	; 61
    6498:	de b7       	in	r29, 0x3e	; 62
    649a:	29 97       	sbiw	r28, 0x09	; 9
    649c:	0f b6       	in	r0, 0x3f	; 63
    649e:	f8 94       	cli
    64a0:	de bf       	out	0x3e, r29	; 62
    64a2:	0f be       	out	0x3f, r0	; 63
    64a4:	cd bf       	out	0x3d, r28	; 61
    64a6:	9b 83       	std	Y+3, r25	; 0x03
    64a8:	8a 83       	std	Y+2, r24	; 0x02
    64aa:	7d 83       	std	Y+5, r23	; 0x05
    64ac:	6c 83       	std	Y+4, r22	; 0x04
    64ae:	5f 83       	std	Y+7, r21	; 0x07
    64b0:	4e 83       	std	Y+6, r20	; 0x06
    64b2:	39 87       	std	Y+9, r19	; 0x09
    64b4:	28 87       	std	Y+8, r18	; 0x08
        BaseType_t xProcessTimerNow = pdFALSE;
    64b6:	19 82       	std	Y+1, r1	; 0x01

        listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xNextExpiryTime );
    64b8:	ea 81       	ldd	r30, Y+2	; 0x02
    64ba:	fb 81       	ldd	r31, Y+3	; 0x03
    64bc:	8c 81       	ldd	r24, Y+4	; 0x04
    64be:	9d 81       	ldd	r25, Y+5	; 0x05
    64c0:	93 83       	std	Z+3, r25	; 0x03
    64c2:	82 83       	std	Z+2, r24	; 0x02
        listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
    64c4:	ea 81       	ldd	r30, Y+2	; 0x02
    64c6:	fb 81       	ldd	r31, Y+3	; 0x03
    64c8:	8a 81       	ldd	r24, Y+2	; 0x02
    64ca:	9b 81       	ldd	r25, Y+3	; 0x03
    64cc:	91 87       	std	Z+9, r25	; 0x09
    64ce:	80 87       	std	Z+8, r24	; 0x08

        if( xNextExpiryTime <= xTimeNow )
    64d0:	2c 81       	ldd	r18, Y+4	; 0x04
    64d2:	3d 81       	ldd	r19, Y+5	; 0x05
    64d4:	8e 81       	ldd	r24, Y+6	; 0x06
    64d6:	9f 81       	ldd	r25, Y+7	; 0x07
    64d8:	82 17       	cp	r24, r18
    64da:	93 07       	cpc	r25, r19
    64dc:	e0 f0       	brcs	.+56     	; 0x6516 <prvInsertTimerInActiveList+0x84>
        {
            /* Has the expiry time elapsed between the command to start/reset a
             * timer was issued, and the time the command was processed? */
            if( ( ( TickType_t ) ( xTimeNow - xCommandTime ) ) >= pxTimer->xTimerPeriodInTicks ) /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    64de:	2e 81       	ldd	r18, Y+6	; 0x06
    64e0:	3f 81       	ldd	r19, Y+7	; 0x07
    64e2:	88 85       	ldd	r24, Y+8	; 0x08
    64e4:	99 85       	ldd	r25, Y+9	; 0x09
    64e6:	28 1b       	sub	r18, r24
    64e8:	39 0b       	sbc	r19, r25
    64ea:	ea 81       	ldd	r30, Y+2	; 0x02
    64ec:	fb 81       	ldd	r31, Y+3	; 0x03
    64ee:	84 85       	ldd	r24, Z+12	; 0x0c
    64f0:	95 85       	ldd	r25, Z+13	; 0x0d
    64f2:	28 17       	cp	r18, r24
    64f4:	39 07       	cpc	r19, r25
    64f6:	18 f0       	brcs	.+6      	; 0x64fe <prvInsertTimerInActiveList+0x6c>
            {
                /* The time between a command being issued and the command being
                 * processed actually exceeds the timers period.  */
                xProcessTimerNow = pdTRUE;
    64f8:	81 e0       	ldi	r24, 0x01	; 1
    64fa:	89 83       	std	Y+1, r24	; 0x01
    64fc:	28 c0       	rjmp	.+80     	; 0x654e <prvInsertTimerInActiveList+0xbc>
            }
            else
            {
                vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
    64fe:	80 91 d4 08 	lds	r24, 0x08D4
    6502:	90 91 d5 08 	lds	r25, 0x08D5
    6506:	2a 81       	ldd	r18, Y+2	; 0x02
    6508:	3b 81       	ldd	r19, Y+3	; 0x03
    650a:	2e 5f       	subi	r18, 0xFE	; 254
    650c:	3f 4f       	sbci	r19, 0xFF	; 255
    650e:	b9 01       	movw	r22, r18
    6510:	0e 94 29 11 	call	0x2252	; 0x2252 <vListInsert>
    6514:	1c c0       	rjmp	.+56     	; 0x654e <prvInsertTimerInActiveList+0xbc>
            }
        }
        else
        {
            if( ( xTimeNow < xCommandTime ) && ( xNextExpiryTime >= xCommandTime ) )
    6516:	2e 81       	ldd	r18, Y+6	; 0x06
    6518:	3f 81       	ldd	r19, Y+7	; 0x07
    651a:	88 85       	ldd	r24, Y+8	; 0x08
    651c:	99 85       	ldd	r25, Y+9	; 0x09
    651e:	28 17       	cp	r18, r24
    6520:	39 07       	cpc	r19, r25
    6522:	50 f4       	brcc	.+20     	; 0x6538 <prvInsertTimerInActiveList+0xa6>
    6524:	2c 81       	ldd	r18, Y+4	; 0x04
    6526:	3d 81       	ldd	r19, Y+5	; 0x05
    6528:	88 85       	ldd	r24, Y+8	; 0x08
    652a:	99 85       	ldd	r25, Y+9	; 0x09
    652c:	28 17       	cp	r18, r24
    652e:	39 07       	cpc	r19, r25
    6530:	18 f0       	brcs	.+6      	; 0x6538 <prvInsertTimerInActiveList+0xa6>
            {
                /* If, since the command was issued, the tick count has overflowed
                 * but the expiry time has not, then the timer must have already passed
                 * its expiry time and should be processed immediately. */
                xProcessTimerNow = pdTRUE;
    6532:	81 e0       	ldi	r24, 0x01	; 1
    6534:	89 83       	std	Y+1, r24	; 0x01
    6536:	0b c0       	rjmp	.+22     	; 0x654e <prvInsertTimerInActiveList+0xbc>
            }
            else
            {
                vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
    6538:	80 91 d2 08 	lds	r24, 0x08D2
    653c:	90 91 d3 08 	lds	r25, 0x08D3
    6540:	2a 81       	ldd	r18, Y+2	; 0x02
    6542:	3b 81       	ldd	r19, Y+3	; 0x03
    6544:	2e 5f       	subi	r18, 0xFE	; 254
    6546:	3f 4f       	sbci	r19, 0xFF	; 255
    6548:	b9 01       	movw	r22, r18
    654a:	0e 94 29 11 	call	0x2252	; 0x2252 <vListInsert>
            }
        }

        return xProcessTimerNow;
    654e:	89 81       	ldd	r24, Y+1	; 0x01
    }
    6550:	29 96       	adiw	r28, 0x09	; 9
    6552:	0f b6       	in	r0, 0x3f	; 63
    6554:	f8 94       	cli
    6556:	de bf       	out	0x3e, r29	; 62
    6558:	0f be       	out	0x3f, r0	; 63
    655a:	cd bf       	out	0x3d, r28	; 61
    655c:	cf 91       	pop	r28
    655e:	df 91       	pop	r29
    6560:	08 95       	ret

00006562 <prvProcessReceivedCommands>:
/*-----------------------------------------------------------*/

    static void prvProcessReceivedCommands( void )
    {
    6562:	df 93       	push	r29
    6564:	cf 93       	push	r28
    6566:	cd b7       	in	r28, 0x3d	; 61
    6568:	de b7       	in	r29, 0x3e	; 62
    656a:	2c 97       	sbiw	r28, 0x0c	; 12
    656c:	0f b6       	in	r0, 0x3f	; 63
    656e:	f8 94       	cli
    6570:	de bf       	out	0x3e, r29	; 62
    6572:	0f be       	out	0x3f, r0	; 63
    6574:	cd bf       	out	0x3d, r28	; 61
    6576:	d8 c0       	rjmp	.+432    	; 0x6728 <prvProcessReceivedCommands+0x1c6>
                }
            #endif /* INCLUDE_xTimerPendFunctionCall */

            /* Commands that are positive are timer commands rather than pended
             * function calls. */
            if( xMessage.xMessageID >= ( BaseType_t ) 0 )
    6578:	8d 81       	ldd	r24, Y+5	; 0x05
    657a:	88 23       	and	r24, r24
    657c:	0c f4       	brge	.+2      	; 0x6580 <prvProcessReceivedCommands+0x1e>
    657e:	d4 c0       	rjmp	.+424    	; 0x6728 <prvProcessReceivedCommands+0x1c6>
            {
                /* The messages uses the xTimerParameters member to work on a
                 * software timer. */
                pxTimer = xMessage.u.xTimerParameters.pxTimer;
    6580:	88 85       	ldd	r24, Y+8	; 0x08
    6582:	99 85       	ldd	r25, Y+9	; 0x09
    6584:	9c 83       	std	Y+4, r25	; 0x04
    6586:	8b 83       	std	Y+3, r24	; 0x03

                if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdFALSE ) /*lint !e961. The cast is only redundant when NULL is passed into the macro. */
    6588:	eb 81       	ldd	r30, Y+3	; 0x03
    658a:	fc 81       	ldd	r31, Y+4	; 0x04
    658c:	82 85       	ldd	r24, Z+10	; 0x0a
    658e:	93 85       	ldd	r25, Z+11	; 0x0b
    6590:	00 97       	sbiw	r24, 0x00	; 0
    6592:	29 f0       	breq	.+10     	; 0x659e <prvProcessReceivedCommands+0x3c>
                {
                    /* The timer is in a list, remove it. */
                    ( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    6594:	8b 81       	ldd	r24, Y+3	; 0x03
    6596:	9c 81       	ldd	r25, Y+4	; 0x04
    6598:	02 96       	adiw	r24, 0x02	; 2
    659a:	0e 94 95 11 	call	0x232a	; 0x232a <uxListRemove>
                 *  it must be present in the function call.  prvSampleTimeNow() must be
                 *  called after the message is received from xTimerQueue so there is no
                 *  possibility of a higher priority task adding a message to the message
                 *  queue with a time that is ahead of the timer daemon task (because it
                 *  pre-empted the timer daemon task after the xTimeNow value was set). */
                xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    659e:	ce 01       	movw	r24, r28
    65a0:	0a 96       	adiw	r24, 0x0a	; 10
    65a2:	0e 94 1b 32 	call	0x6436	; 0x6436 <prvSampleTimeNow>
    65a6:	9a 83       	std	Y+2, r25	; 0x02
    65a8:	89 83       	std	Y+1, r24	; 0x01

                switch( xMessage.xMessageID )
    65aa:	8d 81       	ldd	r24, Y+5	; 0x05
    65ac:	28 2f       	mov	r18, r24
    65ae:	33 27       	eor	r19, r19
    65b0:	27 fd       	sbrc	r18, 7
    65b2:	30 95       	com	r19
    65b4:	3c 87       	std	Y+12, r19	; 0x0c
    65b6:	2b 87       	std	Y+11, r18	; 0x0b
    65b8:	8b 85       	ldd	r24, Y+11	; 0x0b
    65ba:	9c 85       	ldd	r25, Y+12	; 0x0c
    65bc:	85 30       	cpi	r24, 0x05	; 5
    65be:	91 05       	cpc	r25, r1
    65c0:	09 f4       	brne	.+2      	; 0x65c4 <prvProcessReceivedCommands+0x62>
    65c2:	9d c0       	rjmp	.+314    	; 0x66fe <prvProcessReceivedCommands+0x19c>
    65c4:	2b 85       	ldd	r18, Y+11	; 0x0b
    65c6:	3c 85       	ldd	r19, Y+12	; 0x0c
    65c8:	26 30       	cpi	r18, 0x06	; 6
    65ca:	31 05       	cpc	r19, r1
    65cc:	9c f4       	brge	.+38     	; 0x65f4 <prvProcessReceivedCommands+0x92>
    65ce:	8b 85       	ldd	r24, Y+11	; 0x0b
    65d0:	9c 85       	ldd	r25, Y+12	; 0x0c
    65d2:	83 30       	cpi	r24, 0x03	; 3
    65d4:	91 05       	cpc	r25, r1
    65d6:	09 f4       	brne	.+2      	; 0x65da <prvProcessReceivedCommands+0x78>
    65d8:	68 c0       	rjmp	.+208    	; 0x66aa <prvProcessReceivedCommands+0x148>
    65da:	2b 85       	ldd	r18, Y+11	; 0x0b
    65dc:	3c 85       	ldd	r19, Y+12	; 0x0c
    65de:	24 30       	cpi	r18, 0x04	; 4
    65e0:	31 05       	cpc	r19, r1
    65e2:	0c f0       	brlt	.+2      	; 0x65e6 <prvProcessReceivedCommands+0x84>
    65e4:	6a c0       	rjmp	.+212    	; 0x66ba <prvProcessReceivedCommands+0x158>
    65e6:	8b 85       	ldd	r24, Y+11	; 0x0b
    65e8:	9c 85       	ldd	r25, Y+12	; 0x0c
    65ea:	81 30       	cpi	r24, 0x01	; 1
    65ec:	91 05       	cpc	r25, r1
    65ee:	0c f4       	brge	.+2      	; 0x65f2 <prvProcessReceivedCommands+0x90>
    65f0:	9b c0       	rjmp	.+310    	; 0x6728 <prvProcessReceivedCommands+0x1c6>
    65f2:	12 c0       	rjmp	.+36     	; 0x6618 <prvProcessReceivedCommands+0xb6>
    65f4:	2b 85       	ldd	r18, Y+11	; 0x0b
    65f6:	3c 85       	ldd	r19, Y+12	; 0x0c
    65f8:	28 30       	cpi	r18, 0x08	; 8
    65fa:	31 05       	cpc	r19, r1
    65fc:	09 f4       	brne	.+2      	; 0x6600 <prvProcessReceivedCommands+0x9e>
    65fe:	55 c0       	rjmp	.+170    	; 0x66aa <prvProcessReceivedCommands+0x148>
    6600:	8b 85       	ldd	r24, Y+11	; 0x0b
    6602:	9c 85       	ldd	r25, Y+12	; 0x0c
    6604:	88 30       	cpi	r24, 0x08	; 8
    6606:	91 05       	cpc	r25, r1
    6608:	3c f0       	brlt	.+14     	; 0x6618 <prvProcessReceivedCommands+0xb6>
    660a:	2b 85       	ldd	r18, Y+11	; 0x0b
    660c:	3c 85       	ldd	r19, Y+12	; 0x0c
    660e:	29 30       	cpi	r18, 0x09	; 9
    6610:	31 05       	cpc	r19, r1
    6612:	09 f4       	brne	.+2      	; 0x6616 <prvProcessReceivedCommands+0xb4>
    6614:	52 c0       	rjmp	.+164    	; 0x66ba <prvProcessReceivedCommands+0x158>
    6616:	88 c0       	rjmp	.+272    	; 0x6728 <prvProcessReceivedCommands+0x1c6>
                    case tmrCOMMAND_START:
                    case tmrCOMMAND_START_FROM_ISR:
                    case tmrCOMMAND_RESET:
                    case tmrCOMMAND_RESET_FROM_ISR:
                        /* Start or restart a timer. */
                        pxTimer->ucStatus |= tmrSTATUS_IS_ACTIVE;
    6618:	eb 81       	ldd	r30, Y+3	; 0x03
    661a:	fc 81       	ldd	r31, Y+4	; 0x04
    661c:	82 89       	ldd	r24, Z+18	; 0x12
    661e:	81 60       	ori	r24, 0x01	; 1
    6620:	eb 81       	ldd	r30, Y+3	; 0x03
    6622:	fc 81       	ldd	r31, Y+4	; 0x04
    6624:	82 8b       	std	Z+18, r24	; 0x12

                        if( prvInsertTimerInActiveList( pxTimer, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.u.xTimerParameters.xMessageValue ) != pdFALSE )
    6626:	2e 81       	ldd	r18, Y+6	; 0x06
    6628:	3f 81       	ldd	r19, Y+7	; 0x07
    662a:	eb 81       	ldd	r30, Y+3	; 0x03
    662c:	fc 81       	ldd	r31, Y+4	; 0x04
    662e:	84 85       	ldd	r24, Z+12	; 0x0c
    6630:	95 85       	ldd	r25, Z+13	; 0x0d
    6632:	a9 01       	movw	r20, r18
    6634:	48 0f       	add	r20, r24
    6636:	59 1f       	adc	r21, r25
    6638:	ee 81       	ldd	r30, Y+6	; 0x06
    663a:	ff 81       	ldd	r31, Y+7	; 0x07
    663c:	8b 81       	ldd	r24, Y+3	; 0x03
    663e:	9c 81       	ldd	r25, Y+4	; 0x04
    6640:	29 81       	ldd	r18, Y+1	; 0x01
    6642:	3a 81       	ldd	r19, Y+2	; 0x02
    6644:	ba 01       	movw	r22, r20
    6646:	a9 01       	movw	r20, r18
    6648:	9f 01       	movw	r18, r30
    664a:	0e 94 49 32 	call	0x6492	; 0x6492 <prvInsertTimerInActiveList>
    664e:	88 23       	and	r24, r24
    6650:	09 f4       	brne	.+2      	; 0x6654 <prvProcessReceivedCommands+0xf2>
    6652:	6a c0       	rjmp	.+212    	; 0x6728 <prvProcessReceivedCommands+0x1c6>
                        {
                            /* The timer expired before it was added to the active
                             * timer list.  Process it now. */
                            if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
    6654:	eb 81       	ldd	r30, Y+3	; 0x03
    6656:	fc 81       	ldd	r31, Y+4	; 0x04
    6658:	82 89       	ldd	r24, Z+18	; 0x12
    665a:	88 2f       	mov	r24, r24
    665c:	90 e0       	ldi	r25, 0x00	; 0
    665e:	84 70       	andi	r24, 0x04	; 4
    6660:	90 70       	andi	r25, 0x00	; 0
    6662:	00 97       	sbiw	r24, 0x00	; 0
    6664:	91 f0       	breq	.+36     	; 0x668a <prvProcessReceivedCommands+0x128>
                            {
                                prvReloadTimer( pxTimer, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow );
    6666:	2e 81       	ldd	r18, Y+6	; 0x06
    6668:	3f 81       	ldd	r19, Y+7	; 0x07
    666a:	eb 81       	ldd	r30, Y+3	; 0x03
    666c:	fc 81       	ldd	r31, Y+4	; 0x04
    666e:	84 85       	ldd	r24, Z+12	; 0x0c
    6670:	95 85       	ldd	r25, Z+13	; 0x0d
    6672:	a9 01       	movw	r20, r18
    6674:	48 0f       	add	r20, r24
    6676:	59 1f       	adc	r21, r25
    6678:	8b 81       	ldd	r24, Y+3	; 0x03
    667a:	9c 81       	ldd	r25, Y+4	; 0x04
    667c:	29 81       	ldd	r18, Y+1	; 0x01
    667e:	3a 81       	ldd	r19, Y+2	; 0x02
    6680:	ba 01       	movw	r22, r20
    6682:	a9 01       	movw	r20, r18
    6684:	0e 94 f3 30 	call	0x61e6	; 0x61e6 <prvReloadTimer>
    6688:	07 c0       	rjmp	.+14     	; 0x6698 <prvProcessReceivedCommands+0x136>
                            }
                            else
                            {
                                pxTimer->ucStatus &= ( ( uint8_t ) ~tmrSTATUS_IS_ACTIVE );
    668a:	eb 81       	ldd	r30, Y+3	; 0x03
    668c:	fc 81       	ldd	r31, Y+4	; 0x04
    668e:	82 89       	ldd	r24, Z+18	; 0x12
    6690:	8e 7f       	andi	r24, 0xFE	; 254
    6692:	eb 81       	ldd	r30, Y+3	; 0x03
    6694:	fc 81       	ldd	r31, Y+4	; 0x04
    6696:	82 8b       	std	Z+18, r24	; 0x12
                            }

                            /* Call the timer callback. */
                            traceTIMER_EXPIRED( pxTimer );
                            pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    6698:	eb 81       	ldd	r30, Y+3	; 0x03
    669a:	fc 81       	ldd	r31, Y+4	; 0x04
    669c:	00 88       	ldd	r0, Z+16	; 0x10
    669e:	f1 89       	ldd	r31, Z+17	; 0x11
    66a0:	e0 2d       	mov	r30, r0
    66a2:	8b 81       	ldd	r24, Y+3	; 0x03
    66a4:	9c 81       	ldd	r25, Y+4	; 0x04
    66a6:	09 95       	icall
    66a8:	3f c0       	rjmp	.+126    	; 0x6728 <prvProcessReceivedCommands+0x1c6>
                        break;

                    case tmrCOMMAND_STOP:
                    case tmrCOMMAND_STOP_FROM_ISR:
                        /* The timer has already been removed from the active list. */
                        pxTimer->ucStatus &= ( ( uint8_t ) ~tmrSTATUS_IS_ACTIVE );
    66aa:	eb 81       	ldd	r30, Y+3	; 0x03
    66ac:	fc 81       	ldd	r31, Y+4	; 0x04
    66ae:	82 89       	ldd	r24, Z+18	; 0x12
    66b0:	8e 7f       	andi	r24, 0xFE	; 254
    66b2:	eb 81       	ldd	r30, Y+3	; 0x03
    66b4:	fc 81       	ldd	r31, Y+4	; 0x04
    66b6:	82 8b       	std	Z+18, r24	; 0x12
    66b8:	37 c0       	rjmp	.+110    	; 0x6728 <prvProcessReceivedCommands+0x1c6>
                        break;

                    case tmrCOMMAND_CHANGE_PERIOD:
                    case tmrCOMMAND_CHANGE_PERIOD_FROM_ISR:
                        pxTimer->ucStatus |= tmrSTATUS_IS_ACTIVE;
    66ba:	eb 81       	ldd	r30, Y+3	; 0x03
    66bc:	fc 81       	ldd	r31, Y+4	; 0x04
    66be:	82 89       	ldd	r24, Z+18	; 0x12
    66c0:	81 60       	ori	r24, 0x01	; 1
    66c2:	eb 81       	ldd	r30, Y+3	; 0x03
    66c4:	fc 81       	ldd	r31, Y+4	; 0x04
    66c6:	82 8b       	std	Z+18, r24	; 0x12
                        pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
    66c8:	8e 81       	ldd	r24, Y+6	; 0x06
    66ca:	9f 81       	ldd	r25, Y+7	; 0x07
    66cc:	eb 81       	ldd	r30, Y+3	; 0x03
    66ce:	fc 81       	ldd	r31, Y+4	; 0x04
    66d0:	95 87       	std	Z+13, r25	; 0x0d
    66d2:	84 87       	std	Z+12, r24	; 0x0c
                         * be longer or shorter than the old one.  The command time is
                         * therefore set to the current time, and as the period cannot
                         * be zero the next expiry time can only be in the future,
                         * meaning (unlike for the xTimerStart() case above) there is
                         * no fail case that needs to be handled here. */
                        ( void ) prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
    66d4:	eb 81       	ldd	r30, Y+3	; 0x03
    66d6:	fc 81       	ldd	r31, Y+4	; 0x04
    66d8:	24 85       	ldd	r18, Z+12	; 0x0c
    66da:	35 85       	ldd	r19, Z+13	; 0x0d
    66dc:	89 81       	ldd	r24, Y+1	; 0x01
    66de:	9a 81       	ldd	r25, Y+2	; 0x02
    66e0:	a9 01       	movw	r20, r18
    66e2:	48 0f       	add	r20, r24
    66e4:	59 1f       	adc	r21, r25
    66e6:	8b 81       	ldd	r24, Y+3	; 0x03
    66e8:	9c 81       	ldd	r25, Y+4	; 0x04
    66ea:	29 81       	ldd	r18, Y+1	; 0x01
    66ec:	3a 81       	ldd	r19, Y+2	; 0x02
    66ee:	e9 81       	ldd	r30, Y+1	; 0x01
    66f0:	fa 81       	ldd	r31, Y+2	; 0x02
    66f2:	ba 01       	movw	r22, r20
    66f4:	a9 01       	movw	r20, r18
    66f6:	9f 01       	movw	r18, r30
    66f8:	0e 94 49 32 	call	0x6492	; 0x6492 <prvInsertTimerInActiveList>
    66fc:	15 c0       	rjmp	.+42     	; 0x6728 <prvProcessReceivedCommands+0x1c6>
                        #if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
                            {
                                /* The timer has already been removed from the active list,
                                 * just free up the memory if the memory was dynamically
                                 * allocated. */
                                if( ( pxTimer->ucStatus & tmrSTATUS_IS_STATICALLY_ALLOCATED ) == ( uint8_t ) 0 )
    66fe:	eb 81       	ldd	r30, Y+3	; 0x03
    6700:	fc 81       	ldd	r31, Y+4	; 0x04
    6702:	82 89       	ldd	r24, Z+18	; 0x12
    6704:	88 2f       	mov	r24, r24
    6706:	90 e0       	ldi	r25, 0x00	; 0
    6708:	82 70       	andi	r24, 0x02	; 2
    670a:	90 70       	andi	r25, 0x00	; 0
    670c:	00 97       	sbiw	r24, 0x00	; 0
    670e:	29 f4       	brne	.+10     	; 0x671a <prvProcessReceivedCommands+0x1b8>
                                {
                                    vPortFree( pxTimer );
    6710:	8b 81       	ldd	r24, Y+3	; 0x03
    6712:	9c 81       	ldd	r25, Y+4	; 0x04
    6714:	0e 94 8d 07 	call	0xf1a	; 0xf1a <vPortFree>
    6718:	07 c0       	rjmp	.+14     	; 0x6728 <prvProcessReceivedCommands+0x1c6>
                                }
                                else
                                {
                                    pxTimer->ucStatus &= ( ( uint8_t ) ~tmrSTATUS_IS_ACTIVE );
    671a:	eb 81       	ldd	r30, Y+3	; 0x03
    671c:	fc 81       	ldd	r31, Y+4	; 0x04
    671e:	82 89       	ldd	r24, Z+18	; 0x12
    6720:	8e 7f       	andi	r24, 0xFE	; 254
    6722:	eb 81       	ldd	r30, Y+3	; 0x03
    6724:	fc 81       	ldd	r31, Y+4	; 0x04
    6726:	82 8b       	std	Z+18, r24	; 0x12
        DaemonTaskMessage_t xMessage;
        Timer_t * pxTimer;
        BaseType_t xTimerListsWereSwitched;
        TickType_t xTimeNow;

        while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
    6728:	80 91 ba 08 	lds	r24, 0x08BA
    672c:	90 91 bb 08 	lds	r25, 0x08BB
    6730:	9e 01       	movw	r18, r28
    6732:	2b 5f       	subi	r18, 0xFB	; 251
    6734:	3f 4f       	sbci	r19, 0xFF	; 255
    6736:	b9 01       	movw	r22, r18
    6738:	40 e0       	ldi	r20, 0x00	; 0
    673a:	50 e0       	ldi	r21, 0x00	; 0
    673c:	0e 94 94 14 	call	0x2928	; 0x2928 <xQueueReceive>
    6740:	88 23       	and	r24, r24
    6742:	09 f0       	breq	.+2      	; 0x6746 <prvProcessReceivedCommands+0x1e4>
    6744:	19 cf       	rjmp	.-462    	; 0x6578 <prvProcessReceivedCommands+0x16>
                        /* Don't expect to get here. */
                        break;
                }
            }
        }
    }
    6746:	2c 96       	adiw	r28, 0x0c	; 12
    6748:	0f b6       	in	r0, 0x3f	; 63
    674a:	f8 94       	cli
    674c:	de bf       	out	0x3e, r29	; 62
    674e:	0f be       	out	0x3f, r0	; 63
    6750:	cd bf       	out	0x3d, r28	; 61
    6752:	cf 91       	pop	r28
    6754:	df 91       	pop	r29
    6756:	08 95       	ret

00006758 <prvSwitchTimerLists>:
/*-----------------------------------------------------------*/

    static void prvSwitchTimerLists( void )
    {
    6758:	df 93       	push	r29
    675a:	cf 93       	push	r28
    675c:	00 d0       	rcall	.+0      	; 0x675e <prvSwitchTimerLists+0x6>
    675e:	00 d0       	rcall	.+0      	; 0x6760 <prvSwitchTimerLists+0x8>
    6760:	cd b7       	in	r28, 0x3d	; 61
    6762:	de b7       	in	r29, 0x3e	; 62
    6764:	11 c0       	rjmp	.+34     	; 0x6788 <prvSwitchTimerLists+0x30>
         * If there are any timers still referenced from the current timer list
         * then they must have expired and should be processed before the lists
         * are switched. */
        while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
        {
            xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    6766:	e0 91 d2 08 	lds	r30, 0x08D2
    676a:	f0 91 d3 08 	lds	r31, 0x08D3
    676e:	05 80       	ldd	r0, Z+5	; 0x05
    6770:	f6 81       	ldd	r31, Z+6	; 0x06
    6772:	e0 2d       	mov	r30, r0
    6774:	80 81       	ld	r24, Z
    6776:	91 81       	ldd	r25, Z+1	; 0x01
    6778:	9c 83       	std	Y+4, r25	; 0x04
    677a:	8b 83       	std	Y+3, r24	; 0x03

            /* Process the expired timer.  For auto-reload timers, be careful to
             * process only expirations that occur on the current list.  Further
             * expirations must wait until after the lists are switched. */
            prvProcessExpiredTimer( xNextExpireTime, tmrMAX_TIME_BEFORE_OVERFLOW );
    677c:	8b 81       	ldd	r24, Y+3	; 0x03
    677e:	9c 81       	ldd	r25, Y+4	; 0x04
    6780:	6f ef       	ldi	r22, 0xFF	; 255
    6782:	7f ef       	ldi	r23, 0xFF	; 255
    6784:	0e 94 32 31 	call	0x6264	; 0x6264 <prvProcessExpiredTimer>

        /* The tick count has overflowed.  The timer lists must be switched.
         * If there are any timers still referenced from the current timer list
         * then they must have expired and should be processed before the lists
         * are switched. */
        while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
    6788:	e0 91 d2 08 	lds	r30, 0x08D2
    678c:	f0 91 d3 08 	lds	r31, 0x08D3
    6790:	80 81       	ld	r24, Z
    6792:	88 23       	and	r24, r24
    6794:	41 f7       	brne	.-48     	; 0x6766 <prvSwitchTimerLists+0xe>
             * process only expirations that occur on the current list.  Further
             * expirations must wait until after the lists are switched. */
            prvProcessExpiredTimer( xNextExpireTime, tmrMAX_TIME_BEFORE_OVERFLOW );
        }

        pxTemp = pxCurrentTimerList;
    6796:	80 91 d2 08 	lds	r24, 0x08D2
    679a:	90 91 d3 08 	lds	r25, 0x08D3
    679e:	9a 83       	std	Y+2, r25	; 0x02
    67a0:	89 83       	std	Y+1, r24	; 0x01
        pxCurrentTimerList = pxOverflowTimerList;
    67a2:	80 91 d4 08 	lds	r24, 0x08D4
    67a6:	90 91 d5 08 	lds	r25, 0x08D5
    67aa:	90 93 d3 08 	sts	0x08D3, r25
    67ae:	80 93 d2 08 	sts	0x08D2, r24
        pxOverflowTimerList = pxTemp;
    67b2:	89 81       	ldd	r24, Y+1	; 0x01
    67b4:	9a 81       	ldd	r25, Y+2	; 0x02
    67b6:	90 93 d5 08 	sts	0x08D5, r25
    67ba:	80 93 d4 08 	sts	0x08D4, r24
    }
    67be:	0f 90       	pop	r0
    67c0:	0f 90       	pop	r0
    67c2:	0f 90       	pop	r0
    67c4:	0f 90       	pop	r0
    67c6:	cf 91       	pop	r28
    67c8:	df 91       	pop	r29
    67ca:	08 95       	ret

000067cc <prvCheckForValidListAndQueue>:
/*-----------------------------------------------------------*/

    static void prvCheckForValidListAndQueue( void )
    {
    67cc:	df 93       	push	r29
    67ce:	cf 93       	push	r28
    67d0:	cd b7       	in	r28, 0x3d	; 61
    67d2:	de b7       	in	r29, 0x3e	; 62
        /* Check that the list from which active timers are referenced, and the
         * queue used to communicate with the timer service, have been
         * initialised. */
        taskENTER_CRITICAL();
    67d4:	0f b6       	in	r0, 0x3f	; 63
    67d6:	f8 94       	cli
    67d8:	0f 92       	push	r0
        {
            if( xTimerQueue == NULL )
    67da:	80 91 ba 08 	lds	r24, 0x08BA
    67de:	90 91 bb 08 	lds	r25, 0x08BB
    67e2:	00 97       	sbiw	r24, 0x00	; 0
    67e4:	e9 f4       	brne	.+58     	; 0x6820 <prvCheckForValidListAndQueue+0x54>
            {
                vListInitialise( &xActiveTimerList1 );
    67e6:	80 ec       	ldi	r24, 0xC0	; 192
    67e8:	98 e0       	ldi	r25, 0x08	; 8
    67ea:	0e 94 ab 10 	call	0x2156	; 0x2156 <vListInitialise>
                vListInitialise( &xActiveTimerList2 );
    67ee:	89 ec       	ldi	r24, 0xC9	; 201
    67f0:	98 e0       	ldi	r25, 0x08	; 8
    67f2:	0e 94 ab 10 	call	0x2156	; 0x2156 <vListInitialise>
                pxCurrentTimerList = &xActiveTimerList1;
    67f6:	80 ec       	ldi	r24, 0xC0	; 192
    67f8:	98 e0       	ldi	r25, 0x08	; 8
    67fa:	90 93 d3 08 	sts	0x08D3, r25
    67fe:	80 93 d2 08 	sts	0x08D2, r24
                pxOverflowTimerList = &xActiveTimerList2;
    6802:	89 ec       	ldi	r24, 0xC9	; 201
    6804:	98 e0       	ldi	r25, 0x08	; 8
    6806:	90 93 d5 08 	sts	0x08D5, r25
    680a:	80 93 d4 08 	sts	0x08D4, r24

                        xTimerQueue = xQueueCreateStatic( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, ( UBaseType_t ) sizeof( DaemonTaskMessage_t ), &( ucStaticTimerQueueStorage[ 0 ] ), &xStaticTimerQueue );
                    }
                #else
                    {
                        xTimerQueue = xQueueCreate( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, sizeof( DaemonTaskMessage_t ) );
    680e:	8a e0       	ldi	r24, 0x0A	; 10
    6810:	65 e0       	ldi	r22, 0x05	; 5
    6812:	40 e0       	ldi	r20, 0x00	; 0
    6814:	0e 94 8c 12 	call	0x2518	; 0x2518 <xQueueGenericCreate>
    6818:	90 93 bb 08 	sts	0x08BB, r25
    681c:	80 93 ba 08 	sts	0x08BA, r24
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        taskEXIT_CRITICAL();
    6820:	0f 90       	pop	r0
    6822:	0f be       	out	0x3f, r0	; 63
    }
    6824:	cf 91       	pop	r28
    6826:	df 91       	pop	r29
    6828:	08 95       	ret

0000682a <xTimerIsTimerActive>:
/*-----------------------------------------------------------*/

    BaseType_t xTimerIsTimerActive( TimerHandle_t xTimer )
    {
    682a:	df 93       	push	r29
    682c:	cf 93       	push	r28
    682e:	00 d0       	rcall	.+0      	; 0x6830 <xTimerIsTimerActive+0x6>
    6830:	00 d0       	rcall	.+0      	; 0x6832 <xTimerIsTimerActive+0x8>
    6832:	0f 92       	push	r0
    6834:	cd b7       	in	r28, 0x3d	; 61
    6836:	de b7       	in	r29, 0x3e	; 62
    6838:	9d 83       	std	Y+5, r25	; 0x05
    683a:	8c 83       	std	Y+4, r24	; 0x04
        BaseType_t xReturn;
        Timer_t * pxTimer = xTimer;
    683c:	8c 81       	ldd	r24, Y+4	; 0x04
    683e:	9d 81       	ldd	r25, Y+5	; 0x05
    6840:	9a 83       	std	Y+2, r25	; 0x02
    6842:	89 83       	std	Y+1, r24	; 0x01

        configASSERT( xTimer );

        /* Is the timer in the list of active timers? */
        taskENTER_CRITICAL();
    6844:	0f b6       	in	r0, 0x3f	; 63
    6846:	f8 94       	cli
    6848:	0f 92       	push	r0
        {
            if( ( pxTimer->ucStatus & tmrSTATUS_IS_ACTIVE ) == 0 )
    684a:	e9 81       	ldd	r30, Y+1	; 0x01
    684c:	fa 81       	ldd	r31, Y+2	; 0x02
    684e:	82 89       	ldd	r24, Z+18	; 0x12
    6850:	88 2f       	mov	r24, r24
    6852:	90 e0       	ldi	r25, 0x00	; 0
    6854:	81 70       	andi	r24, 0x01	; 1
    6856:	90 70       	andi	r25, 0x00	; 0
    6858:	00 97       	sbiw	r24, 0x00	; 0
    685a:	11 f4       	brne	.+4      	; 0x6860 <xTimerIsTimerActive+0x36>
            {
                xReturn = pdFALSE;
    685c:	1b 82       	std	Y+3, r1	; 0x03
    685e:	02 c0       	rjmp	.+4      	; 0x6864 <xTimerIsTimerActive+0x3a>
            }
            else
            {
                xReturn = pdTRUE;
    6860:	81 e0       	ldi	r24, 0x01	; 1
    6862:	8b 83       	std	Y+3, r24	; 0x03
            }
        }
        taskEXIT_CRITICAL();
    6864:	0f 90       	pop	r0
    6866:	0f be       	out	0x3f, r0	; 63

        return xReturn;
    6868:	8b 81       	ldd	r24, Y+3	; 0x03
    } /*lint !e818 Can't be pointer to const due to the typedef. */
    686a:	0f 90       	pop	r0
    686c:	0f 90       	pop	r0
    686e:	0f 90       	pop	r0
    6870:	0f 90       	pop	r0
    6872:	0f 90       	pop	r0
    6874:	cf 91       	pop	r28
    6876:	df 91       	pop	r29
    6878:	08 95       	ret

0000687a <pvTimerGetTimerID>:
/*-----------------------------------------------------------*/

    void * pvTimerGetTimerID( const TimerHandle_t xTimer )
    {
    687a:	df 93       	push	r29
    687c:	cf 93       	push	r28
    687e:	00 d0       	rcall	.+0      	; 0x6880 <pvTimerGetTimerID+0x6>
    6880:	00 d0       	rcall	.+0      	; 0x6882 <pvTimerGetTimerID+0x8>
    6882:	00 d0       	rcall	.+0      	; 0x6884 <pvTimerGetTimerID+0xa>
    6884:	cd b7       	in	r28, 0x3d	; 61
    6886:	de b7       	in	r29, 0x3e	; 62
    6888:	9e 83       	std	Y+6, r25	; 0x06
    688a:	8d 83       	std	Y+5, r24	; 0x05
        Timer_t * const pxTimer = xTimer;
    688c:	8d 81       	ldd	r24, Y+5	; 0x05
    688e:	9e 81       	ldd	r25, Y+6	; 0x06
    6890:	9c 83       	std	Y+4, r25	; 0x04
    6892:	8b 83       	std	Y+3, r24	; 0x03
        void * pvReturn;

        configASSERT( xTimer );

        taskENTER_CRITICAL();
    6894:	0f b6       	in	r0, 0x3f	; 63
    6896:	f8 94       	cli
    6898:	0f 92       	push	r0
        {
            pvReturn = pxTimer->pvTimerID;
    689a:	eb 81       	ldd	r30, Y+3	; 0x03
    689c:	fc 81       	ldd	r31, Y+4	; 0x04
    689e:	86 85       	ldd	r24, Z+14	; 0x0e
    68a0:	97 85       	ldd	r25, Z+15	; 0x0f
    68a2:	9a 83       	std	Y+2, r25	; 0x02
    68a4:	89 83       	std	Y+1, r24	; 0x01
        }
        taskEXIT_CRITICAL();
    68a6:	0f 90       	pop	r0
    68a8:	0f be       	out	0x3f, r0	; 63

        return pvReturn;
    68aa:	89 81       	ldd	r24, Y+1	; 0x01
    68ac:	9a 81       	ldd	r25, Y+2	; 0x02
    }
    68ae:	26 96       	adiw	r28, 0x06	; 6
    68b0:	0f b6       	in	r0, 0x3f	; 63
    68b2:	f8 94       	cli
    68b4:	de bf       	out	0x3e, r29	; 62
    68b6:	0f be       	out	0x3f, r0	; 63
    68b8:	cd bf       	out	0x3d, r28	; 61
    68ba:	cf 91       	pop	r28
    68bc:	df 91       	pop	r29
    68be:	08 95       	ret

000068c0 <vTimerSetTimerID>:
/*-----------------------------------------------------------*/

    void vTimerSetTimerID( TimerHandle_t xTimer,
                           void * pvNewID )
    {
    68c0:	df 93       	push	r29
    68c2:	cf 93       	push	r28
    68c4:	00 d0       	rcall	.+0      	; 0x68c6 <vTimerSetTimerID+0x6>
    68c6:	00 d0       	rcall	.+0      	; 0x68c8 <vTimerSetTimerID+0x8>
    68c8:	00 d0       	rcall	.+0      	; 0x68ca <vTimerSetTimerID+0xa>
    68ca:	cd b7       	in	r28, 0x3d	; 61
    68cc:	de b7       	in	r29, 0x3e	; 62
    68ce:	9c 83       	std	Y+4, r25	; 0x04
    68d0:	8b 83       	std	Y+3, r24	; 0x03
    68d2:	7e 83       	std	Y+6, r23	; 0x06
    68d4:	6d 83       	std	Y+5, r22	; 0x05
        Timer_t * const pxTimer = xTimer;
    68d6:	8b 81       	ldd	r24, Y+3	; 0x03
    68d8:	9c 81       	ldd	r25, Y+4	; 0x04
    68da:	9a 83       	std	Y+2, r25	; 0x02
    68dc:	89 83       	std	Y+1, r24	; 0x01

        configASSERT( xTimer );

        taskENTER_CRITICAL();
    68de:	0f b6       	in	r0, 0x3f	; 63
    68e0:	f8 94       	cli
    68e2:	0f 92       	push	r0
        {
            pxTimer->pvTimerID = pvNewID;
    68e4:	e9 81       	ldd	r30, Y+1	; 0x01
    68e6:	fa 81       	ldd	r31, Y+2	; 0x02
    68e8:	8d 81       	ldd	r24, Y+5	; 0x05
    68ea:	9e 81       	ldd	r25, Y+6	; 0x06
    68ec:	97 87       	std	Z+15, r25	; 0x0f
    68ee:	86 87       	std	Z+14, r24	; 0x0e
        }
        taskEXIT_CRITICAL();
    68f0:	0f 90       	pop	r0
    68f2:	0f be       	out	0x3f, r0	; 63
    }
    68f4:	26 96       	adiw	r28, 0x06	; 6
    68f6:	0f b6       	in	r0, 0x3f	; 63
    68f8:	f8 94       	cli
    68fa:	de bf       	out	0x3e, r29	; 62
    68fc:	0f be       	out	0x3f, r0	; 63
    68fe:	cd bf       	out	0x3d, r28	; 61
    6900:	cf 91       	pop	r28
    6902:	df 91       	pop	r29
    6904:	08 95       	ret

00006906 <State_Handler>:
//
////	State_Handler();
//}

void State_Handler()
{
    6906:	df 93       	push	r29
    6908:	cf 93       	push	r28
    690a:	00 d0       	rcall	.+0      	; 0x690c <State_Handler+0x6>
    690c:	cd b7       	in	r28, 0x3d	; 61
    690e:	de b7       	in	r29, 0x3e	; 62
	switch(state)
    6910:	80 91 e4 08 	lds	r24, 0x08E4
    6914:	28 2f       	mov	r18, r24
    6916:	30 e0       	ldi	r19, 0x00	; 0
    6918:	3a 83       	std	Y+2, r19	; 0x02
    691a:	29 83       	std	Y+1, r18	; 0x01
    691c:	89 81       	ldd	r24, Y+1	; 0x01
    691e:	9a 81       	ldd	r25, Y+2	; 0x02
    6920:	82 30       	cpi	r24, 0x02	; 2
    6922:	91 05       	cpc	r25, r1
    6924:	e1 f0       	breq	.+56     	; 0x695e <State_Handler+0x58>
    6926:	29 81       	ldd	r18, Y+1	; 0x01
    6928:	3a 81       	ldd	r19, Y+2	; 0x02
    692a:	23 30       	cpi	r18, 0x03	; 3
    692c:	31 05       	cpc	r19, r1
    692e:	34 f4       	brge	.+12     	; 0x693c <State_Handler+0x36>
    6930:	89 81       	ldd	r24, Y+1	; 0x01
    6932:	9a 81       	ldd	r25, Y+2	; 0x02
    6934:	81 30       	cpi	r24, 0x01	; 1
    6936:	91 05       	cpc	r25, r1
    6938:	79 f0       	breq	.+30     	; 0x6958 <State_Handler+0x52>
    693a:	16 c0       	rjmp	.+44     	; 0x6968 <State_Handler+0x62>
    693c:	29 81       	ldd	r18, Y+1	; 0x01
    693e:	3a 81       	ldd	r19, Y+2	; 0x02
    6940:	23 30       	cpi	r18, 0x03	; 3
    6942:	31 05       	cpc	r19, r1
    6944:	31 f0       	breq	.+12     	; 0x6952 <State_Handler+0x4c>
    6946:	89 81       	ldd	r24, Y+1	; 0x01
    6948:	9a 81       	ldd	r25, Y+2	; 0x02
    694a:	84 30       	cpi	r24, 0x04	; 4
    694c:	91 05       	cpc	r25, r1
    694e:	51 f0       	breq	.+20     	; 0x6964 <State_Handler+0x5e>
    6950:	0b c0       	rjmp	.+22     	; 0x6968 <State_Handler+0x62>
	{
	case NO_INDICATOR:
		NoLED_Blink();
    6952:	0e 94 eb 34 	call	0x69d6	; 0x69d6 <NoLED_Blink>
    6956:	08 c0       	rjmp	.+16     	; 0x6968 <State_Handler+0x62>
		break;
	case RIGHT_INDICATOR:
		RightLED_Blink();
    6958:	0e 94 b9 34 	call	0x6972	; 0x6972 <RightLED_Blink>
    695c:	05 c0       	rjmp	.+10     	; 0x6968 <State_Handler+0x62>
		break;
	case LEFT_INDICATOR:
		LeftLED_Blink();
    695e:	0e 94 d2 34 	call	0x69a4	; 0x69a4 <LeftLED_Blink>
    6962:	02 c0       	rjmp	.+4      	; 0x6968 <State_Handler+0x62>
		break;
	case HAZARD_BUTTON:
		BothLEDS_Blink();
    6964:	0e 94 02 35 	call	0x6a04	; 0x6a04 <BothLEDS_Blink>
		break;
	}

}
    6968:	0f 90       	pop	r0
    696a:	0f 90       	pop	r0
    696c:	cf 91       	pop	r28
    696e:	df 91       	pop	r29
    6970:	08 95       	ret

00006972 <RightLED_Blink>:

void RightLED_Blink()
{
    6972:	df 93       	push	r29
    6974:	cf 93       	push	r28
    6976:	cd b7       	in	r28, 0x3d	; 61
    6978:	de b7       	in	r29, 0x3e	; 62
//	xTimerReset(xTimer1);
	GPIO_writePin(dio_config_array[RIGHT_LED_ID].port_id, dio_config_array[RIGHT_LED_ID].pin_num, ToggleLED);
    697a:	80 91 3c 02 	lds	r24, 0x023C
    697e:	90 91 3d 02 	lds	r25, 0x023D
    6982:	20 91 d6 08 	lds	r18, 0x08D6
    6986:	69 2f       	mov	r22, r25
    6988:	42 2f       	mov	r20, r18
    698a:	0e 94 9e 38 	call	0x713c	; 0x713c <GPIO_writePin>
	GPIO_writePin(dio_config_array[LEFT_LED_ID].port_id, dio_config_array[LEFT_LED_ID].pin_num, LOGIC_LOW);
    698e:	80 91 3f 02 	lds	r24, 0x023F
    6992:	90 91 40 02 	lds	r25, 0x0240
    6996:	69 2f       	mov	r22, r25
    6998:	40 e0       	ldi	r20, 0x00	; 0
    699a:	0e 94 9e 38 	call	0x713c	; 0x713c <GPIO_writePin>

}
    699e:	cf 91       	pop	r28
    69a0:	df 91       	pop	r29
    69a2:	08 95       	ret

000069a4 <LeftLED_Blink>:

void LeftLED_Blink()
{
    69a4:	df 93       	push	r29
    69a6:	cf 93       	push	r28
    69a8:	cd b7       	in	r28, 0x3d	; 61
    69aa:	de b7       	in	r29, 0x3e	; 62
//	xTimerReset(xTimer1);

	GPIO_writePin(dio_config_array[LEFT_LED_ID].port_id, dio_config_array[LEFT_LED_ID].pin_num, ToggleLED);
    69ac:	80 91 3f 02 	lds	r24, 0x023F
    69b0:	90 91 40 02 	lds	r25, 0x0240
    69b4:	20 91 d6 08 	lds	r18, 0x08D6
    69b8:	69 2f       	mov	r22, r25
    69ba:	42 2f       	mov	r20, r18
    69bc:	0e 94 9e 38 	call	0x713c	; 0x713c <GPIO_writePin>
	GPIO_writePin(dio_config_array[RIGHT_LED_ID].port_id, dio_config_array[RIGHT_LED_ID].pin_num, LOGIC_LOW);
    69c0:	80 91 3c 02 	lds	r24, 0x023C
    69c4:	90 91 3d 02 	lds	r25, 0x023D
    69c8:	69 2f       	mov	r22, r25
    69ca:	40 e0       	ldi	r20, 0x00	; 0
    69cc:	0e 94 9e 38 	call	0x713c	; 0x713c <GPIO_writePin>

}
    69d0:	cf 91       	pop	r28
    69d2:	df 91       	pop	r29
    69d4:	08 95       	ret

000069d6 <NoLED_Blink>:

void NoLED_Blink(void)
{
    69d6:	df 93       	push	r29
    69d8:	cf 93       	push	r28
    69da:	cd b7       	in	r28, 0x3d	; 61
    69dc:	de b7       	in	r29, 0x3e	; 62

	GPIO_writePin(dio_config_array[RIGHT_LED_ID].port_id, dio_config_array[RIGHT_LED_ID].pin_num, LOGIC_LOW);
    69de:	80 91 3c 02 	lds	r24, 0x023C
    69e2:	90 91 3d 02 	lds	r25, 0x023D
    69e6:	69 2f       	mov	r22, r25
    69e8:	40 e0       	ldi	r20, 0x00	; 0
    69ea:	0e 94 9e 38 	call	0x713c	; 0x713c <GPIO_writePin>
	GPIO_writePin(dio_config_array[LEFT_LED_ID].port_id, dio_config_array[LEFT_LED_ID].pin_num, LOGIC_LOW);
    69ee:	80 91 3f 02 	lds	r24, 0x023F
    69f2:	90 91 40 02 	lds	r25, 0x0240
    69f6:	69 2f       	mov	r22, r25
    69f8:	40 e0       	ldi	r20, 0x00	; 0
    69fa:	0e 94 9e 38 	call	0x713c	; 0x713c <GPIO_writePin>
}
    69fe:	cf 91       	pop	r28
    6a00:	df 91       	pop	r29
    6a02:	08 95       	ret

00006a04 <BothLEDS_Blink>:

void BothLEDS_Blink()
{
    6a04:	df 93       	push	r29
    6a06:	cf 93       	push	r28
    6a08:	cd b7       	in	r28, 0x3d	; 61
    6a0a:	de b7       	in	r29, 0x3e	; 62
//	xTimerReset(xTimer1);
	GPIO_writePin(dio_config_array[RIGHT_LED_ID].port_id, dio_config_array[RIGHT_LED_ID].pin_num, ToggleLED);
    6a0c:	80 91 3c 02 	lds	r24, 0x023C
    6a10:	90 91 3d 02 	lds	r25, 0x023D
    6a14:	20 91 d6 08 	lds	r18, 0x08D6
    6a18:	69 2f       	mov	r22, r25
    6a1a:	42 2f       	mov	r20, r18
    6a1c:	0e 94 9e 38 	call	0x713c	; 0x713c <GPIO_writePin>
	GPIO_writePin(dio_config_array[LEFT_LED_ID].port_id, dio_config_array[LEFT_LED_ID].pin_num, ToggleLED);
    6a20:	80 91 3f 02 	lds	r24, 0x023F
    6a24:	90 91 40 02 	lds	r25, 0x0240
    6a28:	20 91 d6 08 	lds	r18, 0x08D6
    6a2c:	69 2f       	mov	r22, r25
    6a2e:	42 2f       	mov	r20, r18
    6a30:	0e 94 9e 38 	call	0x713c	; 0x713c <GPIO_writePin>
}
    6a34:	cf 91       	pop	r28
    6a36:	df 91       	pop	r29
    6a38:	08 95       	ret

00006a3a <timer1_PWM_Init>:
#include <avr/io.h>
#include "Timer1_PWM.h"

unsigned long TopValue = 0;

void timer1_PWM_Init(void){
    6a3a:	df 93       	push	r29
    6a3c:	cf 93       	push	r28
    6a3e:	cd b7       	in	r28, 0x3d	; 61
    6a40:	de b7       	in	r29, 0x3e	; 62
	TCCR1A = (1 << COM1A1) | (1 << COM1B1) | (1<< WGM11);
    6a42:	ef e4       	ldi	r30, 0x4F	; 79
    6a44:	f0 e0       	ldi	r31, 0x00	; 0
    6a46:	82 ea       	ldi	r24, 0xA2	; 162
    6a48:	80 83       	st	Z, r24
	TCCR1B = (1<<WGM13) | (1<<WGM12) | (1<<CS10);
    6a4a:	ee e4       	ldi	r30, 0x4E	; 78
    6a4c:	f0 e0       	ldi	r31, 0x00	; 0
    6a4e:	89 e1       	ldi	r24, 0x19	; 25
    6a50:	80 83       	st	Z, r24
	TopValue = ((float)100/PWM_FREQUENCY_IN_KHZ)*160;
    6a52:	80 ea       	ldi	r24, 0xA0	; 160
    6a54:	90 e0       	ldi	r25, 0x00	; 0
    6a56:	a0 e0       	ldi	r26, 0x00	; 0
    6a58:	b0 e0       	ldi	r27, 0x00	; 0
    6a5a:	80 93 d7 08 	sts	0x08D7, r24
    6a5e:	90 93 d8 08 	sts	0x08D8, r25
    6a62:	a0 93 d9 08 	sts	0x08D9, r26
    6a66:	b0 93 da 08 	sts	0x08DA, r27
	ICR1 = TopValue;
    6a6a:	e6 e4       	ldi	r30, 0x46	; 70
    6a6c:	f0 e0       	ldi	r31, 0x00	; 0
    6a6e:	80 91 d7 08 	lds	r24, 0x08D7
    6a72:	90 91 d8 08 	lds	r25, 0x08D8
    6a76:	a0 91 d9 08 	lds	r26, 0x08D9
    6a7a:	b0 91 da 08 	lds	r27, 0x08DA
    6a7e:	91 83       	std	Z+1, r25	; 0x01
    6a80:	80 83       	st	Z, r24
//	OCR1A = 20000;
//	OCR1B = 45500;
	DDRB |= (1<<PB5) | (1<<PB6);
    6a82:	a7 e3       	ldi	r26, 0x37	; 55
    6a84:	b0 e0       	ldi	r27, 0x00	; 0
    6a86:	e7 e3       	ldi	r30, 0x37	; 55
    6a88:	f0 e0       	ldi	r31, 0x00	; 0
    6a8a:	80 81       	ld	r24, Z
    6a8c:	80 66       	ori	r24, 0x60	; 96
    6a8e:	8c 93       	st	X, r24
	PORTB = 0x00;
    6a90:	e8 e3       	ldi	r30, 0x38	; 56
    6a92:	f0 e0       	ldi	r31, 0x00	; 0
    6a94:	10 82       	st	Z, r1

}
    6a96:	cf 91       	pop	r28
    6a98:	df 91       	pop	r29
    6a9a:	08 95       	ret

00006a9c <timer1_SetPWM_B>:

void timer1_SetPWM_B(unsigned char dutyB){
    6a9c:	ef 92       	push	r14
    6a9e:	ff 92       	push	r15
    6aa0:	0f 93       	push	r16
    6aa2:	1f 93       	push	r17
    6aa4:	df 93       	push	r29
    6aa6:	cf 93       	push	r28
    6aa8:	00 d0       	rcall	.+0      	; 0x6aaa <timer1_SetPWM_B+0xe>
    6aaa:	00 d0       	rcall	.+0      	; 0x6aac <timer1_SetPWM_B+0x10>
    6aac:	0f 92       	push	r0
    6aae:	cd b7       	in	r28, 0x3d	; 61
    6ab0:	de b7       	in	r29, 0x3e	; 62
    6ab2:	8d 83       	std	Y+5, r24	; 0x05
	unsigned long actualDuty = (unsigned long)(((float)dutyB/100)*(TopValue));
    6ab4:	8d 81       	ldd	r24, Y+5	; 0x05
    6ab6:	88 2f       	mov	r24, r24
    6ab8:	90 e0       	ldi	r25, 0x00	; 0
    6aba:	a0 e0       	ldi	r26, 0x00	; 0
    6abc:	b0 e0       	ldi	r27, 0x00	; 0
    6abe:	bc 01       	movw	r22, r24
    6ac0:	cd 01       	movw	r24, r26
    6ac2:	0e 94 c5 04 	call	0x98a	; 0x98a <__floatunsisf>
    6ac6:	dc 01       	movw	r26, r24
    6ac8:	cb 01       	movw	r24, r22
    6aca:	bc 01       	movw	r22, r24
    6acc:	cd 01       	movw	r24, r26
    6ace:	20 e0       	ldi	r18, 0x00	; 0
    6ad0:	30 e0       	ldi	r19, 0x00	; 0
    6ad2:	48 ec       	ldi	r20, 0xC8	; 200
    6ad4:	52 e4       	ldi	r21, 0x42	; 66
    6ad6:	0e 94 35 03 	call	0x66a	; 0x66a <__divsf3>
    6ada:	dc 01       	movw	r26, r24
    6adc:	cb 01       	movw	r24, r22
    6ade:	7c 01       	movw	r14, r24
    6ae0:	8d 01       	movw	r16, r26
    6ae2:	80 91 d7 08 	lds	r24, 0x08D7
    6ae6:	90 91 d8 08 	lds	r25, 0x08D8
    6aea:	a0 91 d9 08 	lds	r26, 0x08D9
    6aee:	b0 91 da 08 	lds	r27, 0x08DA
    6af2:	bc 01       	movw	r22, r24
    6af4:	cd 01       	movw	r24, r26
    6af6:	0e 94 c5 04 	call	0x98a	; 0x98a <__floatunsisf>
    6afa:	9b 01       	movw	r18, r22
    6afc:	ac 01       	movw	r20, r24
    6afe:	c8 01       	movw	r24, r16
    6b00:	b7 01       	movw	r22, r14
    6b02:	0e 94 3b 02 	call	0x476	; 0x476 <__mulsf3>
    6b06:	dc 01       	movw	r26, r24
    6b08:	cb 01       	movw	r24, r22
    6b0a:	bc 01       	movw	r22, r24
    6b0c:	cd 01       	movw	r24, r26
    6b0e:	0e 94 65 00 	call	0xca	; 0xca <__fixunssfsi>
    6b12:	dc 01       	movw	r26, r24
    6b14:	cb 01       	movw	r24, r22
    6b16:	89 83       	std	Y+1, r24	; 0x01
    6b18:	9a 83       	std	Y+2, r25	; 0x02
    6b1a:	ab 83       	std	Y+3, r26	; 0x03
    6b1c:	bc 83       	std	Y+4, r27	; 0x04
	OCR1B = actualDuty;
    6b1e:	e8 e4       	ldi	r30, 0x48	; 72
    6b20:	f0 e0       	ldi	r31, 0x00	; 0
    6b22:	89 81       	ldd	r24, Y+1	; 0x01
    6b24:	9a 81       	ldd	r25, Y+2	; 0x02
    6b26:	91 83       	std	Z+1, r25	; 0x01
    6b28:	80 83       	st	Z, r24
}
    6b2a:	0f 90       	pop	r0
    6b2c:	0f 90       	pop	r0
    6b2e:	0f 90       	pop	r0
    6b30:	0f 90       	pop	r0
    6b32:	0f 90       	pop	r0
    6b34:	cf 91       	pop	r28
    6b36:	df 91       	pop	r29
    6b38:	1f 91       	pop	r17
    6b3a:	0f 91       	pop	r16
    6b3c:	ff 90       	pop	r15
    6b3e:	ef 90       	pop	r14
    6b40:	08 95       	ret

00006b42 <timer1_SetPWM_A>:


void timer1_SetPWM_A(unsigned char dutyA){
    6b42:	ef 92       	push	r14
    6b44:	ff 92       	push	r15
    6b46:	0f 93       	push	r16
    6b48:	1f 93       	push	r17
    6b4a:	df 93       	push	r29
    6b4c:	cf 93       	push	r28
    6b4e:	00 d0       	rcall	.+0      	; 0x6b50 <timer1_SetPWM_A+0xe>
    6b50:	00 d0       	rcall	.+0      	; 0x6b52 <timer1_SetPWM_A+0x10>
    6b52:	0f 92       	push	r0
    6b54:	cd b7       	in	r28, 0x3d	; 61
    6b56:	de b7       	in	r29, 0x3e	; 62
    6b58:	8d 83       	std	Y+5, r24	; 0x05
	unsigned long actualDuty = (unsigned long)(((float)dutyA/100)*(TopValue));
    6b5a:	8d 81       	ldd	r24, Y+5	; 0x05
    6b5c:	88 2f       	mov	r24, r24
    6b5e:	90 e0       	ldi	r25, 0x00	; 0
    6b60:	a0 e0       	ldi	r26, 0x00	; 0
    6b62:	b0 e0       	ldi	r27, 0x00	; 0
    6b64:	bc 01       	movw	r22, r24
    6b66:	cd 01       	movw	r24, r26
    6b68:	0e 94 c5 04 	call	0x98a	; 0x98a <__floatunsisf>
    6b6c:	dc 01       	movw	r26, r24
    6b6e:	cb 01       	movw	r24, r22
    6b70:	bc 01       	movw	r22, r24
    6b72:	cd 01       	movw	r24, r26
    6b74:	20 e0       	ldi	r18, 0x00	; 0
    6b76:	30 e0       	ldi	r19, 0x00	; 0
    6b78:	48 ec       	ldi	r20, 0xC8	; 200
    6b7a:	52 e4       	ldi	r21, 0x42	; 66
    6b7c:	0e 94 35 03 	call	0x66a	; 0x66a <__divsf3>
    6b80:	dc 01       	movw	r26, r24
    6b82:	cb 01       	movw	r24, r22
    6b84:	7c 01       	movw	r14, r24
    6b86:	8d 01       	movw	r16, r26
    6b88:	80 91 d7 08 	lds	r24, 0x08D7
    6b8c:	90 91 d8 08 	lds	r25, 0x08D8
    6b90:	a0 91 d9 08 	lds	r26, 0x08D9
    6b94:	b0 91 da 08 	lds	r27, 0x08DA
    6b98:	bc 01       	movw	r22, r24
    6b9a:	cd 01       	movw	r24, r26
    6b9c:	0e 94 c5 04 	call	0x98a	; 0x98a <__floatunsisf>
    6ba0:	9b 01       	movw	r18, r22
    6ba2:	ac 01       	movw	r20, r24
    6ba4:	c8 01       	movw	r24, r16
    6ba6:	b7 01       	movw	r22, r14
    6ba8:	0e 94 3b 02 	call	0x476	; 0x476 <__mulsf3>
    6bac:	dc 01       	movw	r26, r24
    6bae:	cb 01       	movw	r24, r22
    6bb0:	bc 01       	movw	r22, r24
    6bb2:	cd 01       	movw	r24, r26
    6bb4:	0e 94 65 00 	call	0xca	; 0xca <__fixunssfsi>
    6bb8:	dc 01       	movw	r26, r24
    6bba:	cb 01       	movw	r24, r22
    6bbc:	89 83       	std	Y+1, r24	; 0x01
    6bbe:	9a 83       	std	Y+2, r25	; 0x02
    6bc0:	ab 83       	std	Y+3, r26	; 0x03
    6bc2:	bc 83       	std	Y+4, r27	; 0x04
	OCR1A = actualDuty;
    6bc4:	ea e4       	ldi	r30, 0x4A	; 74
    6bc6:	f0 e0       	ldi	r31, 0x00	; 0
    6bc8:	89 81       	ldd	r24, Y+1	; 0x01
    6bca:	9a 81       	ldd	r25, Y+2	; 0x02
    6bcc:	91 83       	std	Z+1, r25	; 0x01
    6bce:	80 83       	st	Z, r24
}
    6bd0:	0f 90       	pop	r0
    6bd2:	0f 90       	pop	r0
    6bd4:	0f 90       	pop	r0
    6bd6:	0f 90       	pop	r0
    6bd8:	0f 90       	pop	r0
    6bda:	cf 91       	pop	r28
    6bdc:	df 91       	pop	r29
    6bde:	1f 91       	pop	r17
    6be0:	0f 91       	pop	r16
    6be2:	ff 90       	pop	r15
    6be4:	ef 90       	pop	r14
    6be6:	08 95       	ret

00006be8 <timer1_SetPWM_A_B>:


void timer1_SetPWM_A_B(unsigned char dutyA_B){
    6be8:	ef 92       	push	r14
    6bea:	ff 92       	push	r15
    6bec:	0f 93       	push	r16
    6bee:	1f 93       	push	r17
    6bf0:	df 93       	push	r29
    6bf2:	cf 93       	push	r28
    6bf4:	00 d0       	rcall	.+0      	; 0x6bf6 <timer1_SetPWM_A_B+0xe>
    6bf6:	00 d0       	rcall	.+0      	; 0x6bf8 <timer1_SetPWM_A_B+0x10>
    6bf8:	0f 92       	push	r0
    6bfa:	cd b7       	in	r28, 0x3d	; 61
    6bfc:	de b7       	in	r29, 0x3e	; 62
    6bfe:	8d 83       	std	Y+5, r24	; 0x05
	unsigned long actualDuty = (unsigned long)(((float)dutyA_B/100)*(TopValue));
    6c00:	8d 81       	ldd	r24, Y+5	; 0x05
    6c02:	88 2f       	mov	r24, r24
    6c04:	90 e0       	ldi	r25, 0x00	; 0
    6c06:	a0 e0       	ldi	r26, 0x00	; 0
    6c08:	b0 e0       	ldi	r27, 0x00	; 0
    6c0a:	bc 01       	movw	r22, r24
    6c0c:	cd 01       	movw	r24, r26
    6c0e:	0e 94 c5 04 	call	0x98a	; 0x98a <__floatunsisf>
    6c12:	dc 01       	movw	r26, r24
    6c14:	cb 01       	movw	r24, r22
    6c16:	bc 01       	movw	r22, r24
    6c18:	cd 01       	movw	r24, r26
    6c1a:	20 e0       	ldi	r18, 0x00	; 0
    6c1c:	30 e0       	ldi	r19, 0x00	; 0
    6c1e:	48 ec       	ldi	r20, 0xC8	; 200
    6c20:	52 e4       	ldi	r21, 0x42	; 66
    6c22:	0e 94 35 03 	call	0x66a	; 0x66a <__divsf3>
    6c26:	dc 01       	movw	r26, r24
    6c28:	cb 01       	movw	r24, r22
    6c2a:	7c 01       	movw	r14, r24
    6c2c:	8d 01       	movw	r16, r26
    6c2e:	80 91 d7 08 	lds	r24, 0x08D7
    6c32:	90 91 d8 08 	lds	r25, 0x08D8
    6c36:	a0 91 d9 08 	lds	r26, 0x08D9
    6c3a:	b0 91 da 08 	lds	r27, 0x08DA
    6c3e:	bc 01       	movw	r22, r24
    6c40:	cd 01       	movw	r24, r26
    6c42:	0e 94 c5 04 	call	0x98a	; 0x98a <__floatunsisf>
    6c46:	9b 01       	movw	r18, r22
    6c48:	ac 01       	movw	r20, r24
    6c4a:	c8 01       	movw	r24, r16
    6c4c:	b7 01       	movw	r22, r14
    6c4e:	0e 94 3b 02 	call	0x476	; 0x476 <__mulsf3>
    6c52:	dc 01       	movw	r26, r24
    6c54:	cb 01       	movw	r24, r22
    6c56:	bc 01       	movw	r22, r24
    6c58:	cd 01       	movw	r24, r26
    6c5a:	0e 94 65 00 	call	0xca	; 0xca <__fixunssfsi>
    6c5e:	dc 01       	movw	r26, r24
    6c60:	cb 01       	movw	r24, r22
    6c62:	89 83       	std	Y+1, r24	; 0x01
    6c64:	9a 83       	std	Y+2, r25	; 0x02
    6c66:	ab 83       	std	Y+3, r26	; 0x03
    6c68:	bc 83       	std	Y+4, r27	; 0x04
	OCR1A = actualDuty;
    6c6a:	ea e4       	ldi	r30, 0x4A	; 74
    6c6c:	f0 e0       	ldi	r31, 0x00	; 0
    6c6e:	89 81       	ldd	r24, Y+1	; 0x01
    6c70:	9a 81       	ldd	r25, Y+2	; 0x02
    6c72:	91 83       	std	Z+1, r25	; 0x01
    6c74:	80 83       	st	Z, r24
	OCR1B = actualDuty;
    6c76:	e8 e4       	ldi	r30, 0x48	; 72
    6c78:	f0 e0       	ldi	r31, 0x00	; 0
    6c7a:	89 81       	ldd	r24, Y+1	; 0x01
    6c7c:	9a 81       	ldd	r25, Y+2	; 0x02
    6c7e:	91 83       	std	Z+1, r25	; 0x01
    6c80:	80 83       	st	Z, r24
}
    6c82:	0f 90       	pop	r0
    6c84:	0f 90       	pop	r0
    6c86:	0f 90       	pop	r0
    6c88:	0f 90       	pop	r0
    6c8a:	0f 90       	pop	r0
    6c8c:	cf 91       	pop	r28
    6c8e:	df 91       	pop	r29
    6c90:	1f 91       	pop	r17
    6c92:	0f 91       	pop	r16
    6c94:	ff 90       	pop	r15
    6c96:	ef 90       	pop	r14
    6c98:	08 95       	ret

00006c9a <Timer2_Init_CTC_Mode>:
 */

#include "avr/io.h"

void Timer2_Init_CTC_Mode(unsigned char tick)
{
    6c9a:	df 93       	push	r29
    6c9c:	cf 93       	push	r28
    6c9e:	0f 92       	push	r0
    6ca0:	cd b7       	in	r28, 0x3d	; 61
    6ca2:	de b7       	in	r29, 0x3e	; 62
    6ca4:	89 83       	std	Y+1, r24	; 0x01
	TCNT2 = 0;    // Set Timer initial value to 0
    6ca6:	e4 e4       	ldi	r30, 0x44	; 68
    6ca8:	f0 e0       	ldi	r31, 0x00	; 0
    6caa:	10 82       	st	Z, r1
	OCR2  = tick; // Set Compare Value
    6cac:	e3 e4       	ldi	r30, 0x43	; 67
    6cae:	f0 e0       	ldi	r31, 0x00	; 0
    6cb0:	89 81       	ldd	r24, Y+1	; 0x01
    6cb2:	80 83       	st	Z, r24
	TIMSK |= (1<<OCIE2); // Enable Timer2 Compare Interrupt
    6cb4:	a7 e5       	ldi	r26, 0x57	; 87
    6cb6:	b0 e0       	ldi	r27, 0x00	; 0
    6cb8:	e7 e5       	ldi	r30, 0x57	; 87
    6cba:	f0 e0       	ldi	r31, 0x00	; 0
    6cbc:	80 81       	ld	r24, Z
    6cbe:	80 68       	ori	r24, 0x80	; 128
    6cc0:	8c 93       	st	X, r24
	 * 1. Non PWM mode FOC0=1
	 * 2. CTC Mode WGM01=1 & WGM00=0
	 * 3. No need for OC0 in this example so COM00=0 & COM01=0
	 * 4. clock = F_CPU/8 CS22=0 CS21=1 CS20=0
	 */
	TCCR2 = (1<<FOC2) | (1<<WGM21) | (1<<CS21);
    6cc2:	e5 e4       	ldi	r30, 0x45	; 69
    6cc4:	f0 e0       	ldi	r31, 0x00	; 0
    6cc6:	8a e8       	ldi	r24, 0x8A	; 138
    6cc8:	80 83       	st	Z, r24
}
    6cca:	0f 90       	pop	r0
    6ccc:	cf 91       	pop	r28
    6cce:	df 91       	pop	r29
    6cd0:	08 95       	ret

00006cd2 <Get_Data>:
unsigned char rightBtn_counter = 0;
unsigned char leftBtn_counter = 0;


States_GroupType Get_Data(void)
{
    6cd2:	df 93       	push	r29
    6cd4:	cf 93       	push	r28
    6cd6:	cd b7       	in	r28, 0x3d	; 61
    6cd8:	de b7       	in	r29, 0x3e	; 62

//	SET_BIT(PORTB,6);
	static unsigned char hazardBtn_releaseFlag = TRUE;
	static States_GroupType ButtonState = {0,0,0,0};

	if(GPIO_readPin(dio_config_array[HAZARD_BUTTON_ID].port_id,dio_config_array[HAZARD_BUTTON_ID].pin_num) ){
    6cda:	80 91 30 02 	lds	r24, 0x0230
    6cde:	90 91 31 02 	lds	r25, 0x0231
    6ce2:	69 2f       	mov	r22, r25
    6ce4:	0e 94 ed 39 	call	0x73da	; 0x73da <GPIO_readPin>
    6ce8:	88 23       	and	r24, r24
    6cea:	51 f0       	breq	.+20     	; 0x6d00 <Get_Data+0x2e>
		if(hazardBtn_releaseFlag == TRUE){
    6cec:	80 91 2a 02 	lds	r24, 0x022A
    6cf0:	81 30       	cpi	r24, 0x01	; 1
    6cf2:	59 f4       	brne	.+22     	; 0x6d0a <Get_Data+0x38>
			hazardBtn_releaseFlag = FALSE;
    6cf4:	10 92 2a 02 	sts	0x022A, r1
			ButtonState.hazard_Btn = TRUE;
    6cf8:	81 e0       	ldi	r24, 0x01	; 1
    6cfa:	80 93 e1 08 	sts	0x08E1, r24
    6cfe:	05 c0       	rjmp	.+10     	; 0x6d0a <Get_Data+0x38>
		}

	}
	else{
		ButtonState.hazard_Btn = FALSE;
    6d00:	10 92 e1 08 	sts	0x08E1, r1

		hazardBtn_releaseFlag = TRUE;
    6d04:	81 e0       	ldi	r24, 0x01	; 1
    6d06:	80 93 2a 02 	sts	0x022A, r24
	}




	if(!GPIO_readPin(dio_config_array[RIGHT_INDICATOR_BUTTON_ID].port_id,dio_config_array[RIGHT_INDICATOR_BUTTON_ID].pin_num) && !GPIO_readPin(dio_config_array[IGNITION_SWICH_ID].port_id,dio_config_array[IGNITION_SWICH_ID].pin_num)){
    6d0a:	80 91 33 02 	lds	r24, 0x0233
    6d0e:	90 91 34 02 	lds	r25, 0x0234
    6d12:	69 2f       	mov	r22, r25
    6d14:	0e 94 ed 39 	call	0x73da	; 0x73da <GPIO_readPin>
    6d18:	88 23       	and	r24, r24
    6d1a:	d9 f5       	brne	.+118    	; 0x6d92 <Get_Data+0xc0>
    6d1c:	80 91 39 02 	lds	r24, 0x0239
    6d20:	90 91 3a 02 	lds	r25, 0x023A
    6d24:	69 2f       	mov	r22, r25
    6d26:	0e 94 ed 39 	call	0x73da	; 0x73da <GPIO_readPin>
    6d2a:	88 23       	and	r24, r24
    6d2c:	91 f5       	brne	.+100    	; 0x6d92 <Get_Data+0xc0>

//		vTaskDelay(1/portTICK_PERIOD_MS);
//		vTaskDelay(pdMS_TO_TICKS( 5 ));
		rightBtn_counter++;
    6d2e:	80 91 dc 08 	lds	r24, 0x08DC
    6d32:	8f 5f       	subi	r24, 0xFF	; 255
    6d34:	80 93 dc 08 	sts	0x08DC, r24
		if(rightBtn_counter % 5 == 0)
    6d38:	80 91 dc 08 	lds	r24, 0x08DC
    6d3c:	95 e0       	ldi	r25, 0x05	; 5
    6d3e:	69 2f       	mov	r22, r25
    6d40:	0e 94 a4 48 	call	0x9148	; 0x9148 <__udivmodqi4>
    6d44:	89 2f       	mov	r24, r25
    6d46:	88 23       	and	r24, r24
    6d48:	09 f0       	breq	.+2      	; 0x6d4c <Get_Data+0x7a>
    6d4a:	9c c0       	rjmp	.+312    	; 0x6e84 <Get_Data+0x1b2>
		{
		rightBtn_counter = 0;
    6d4c:	10 92 dc 08 	sts	0x08DC, r1
		if(!GPIO_readPin(dio_config_array[IGNITION_SWICH_ID].port_id,dio_config_array[IGNITION_SWICH_ID].pin_num)){
    6d50:	80 91 39 02 	lds	r24, 0x0239
    6d54:	90 91 3a 02 	lds	r25, 0x023A
    6d58:	69 2f       	mov	r22, r25
    6d5a:	0e 94 ed 39 	call	0x73da	; 0x73da <GPIO_readPin>
    6d5e:	88 23       	and	r24, r24
    6d60:	99 f4       	brne	.+38     	; 0x6d88 <Get_Data+0xb6>
			ButtonState.ignition_key = 1;
    6d62:	81 e0       	ldi	r24, 0x01	; 1
    6d64:	80 93 de 08 	sts	0x08DE, r24
			if(!GPIO_readPin(dio_config_array[RIGHT_INDICATOR_BUTTON_ID].port_id,dio_config_array[RIGHT_INDICATOR_BUTTON_ID].pin_num)){
    6d68:	80 91 33 02 	lds	r24, 0x0233
    6d6c:	90 91 34 02 	lds	r25, 0x0234
    6d70:	69 2f       	mov	r22, r25
    6d72:	0e 94 ed 39 	call	0x73da	; 0x73da <GPIO_readPin>
    6d76:	88 23       	and	r24, r24
    6d78:	21 f4       	brne	.+8      	; 0x6d82 <Get_Data+0xb0>
				ButtonState.rightIndicator = 1;
    6d7a:	81 e0       	ldi	r24, 0x01	; 1
    6d7c:	80 93 df 08 	sts	0x08DF, r24
    6d80:	81 c0       	rjmp	.+258    	; 0x6e84 <Get_Data+0x1b2>
			}
			else{
				ButtonState.rightIndicator = 0;
    6d82:	10 92 df 08 	sts	0x08DF, r1
    6d86:	7e c0       	rjmp	.+252    	; 0x6e84 <Get_Data+0x1b2>
			}
		}
		else{
			ButtonState.ignition_key = 0;
    6d88:	10 92 de 08 	sts	0x08DE, r1
			ButtonState.rightIndicator = 0;
    6d8c:	10 92 df 08 	sts	0x08DF, r1
    6d90:	79 c0       	rjmp	.+242    	; 0x6e84 <Get_Data+0x1b2>
		}
		}

	}
	else if(!GPIO_readPin(dio_config_array[LEFT_INDICATOR_BUTTON_ID].port_id,dio_config_array[LEFT_INDICATOR_BUTTON_ID].pin_num) && !GPIO_readPin(dio_config_array[IGNITION_SWICH_ID].port_id,dio_config_array[IGNITION_SWICH_ID].pin_num)){
    6d92:	80 91 36 02 	lds	r24, 0x0236
    6d96:	90 91 37 02 	lds	r25, 0x0237
    6d9a:	69 2f       	mov	r22, r25
    6d9c:	0e 94 ed 39 	call	0x73da	; 0x73da <GPIO_readPin>
    6da0:	88 23       	and	r24, r24
    6da2:	d9 f5       	brne	.+118    	; 0x6e1a <Get_Data+0x148>
    6da4:	80 91 39 02 	lds	r24, 0x0239
    6da8:	90 91 3a 02 	lds	r25, 0x023A
    6dac:	69 2f       	mov	r22, r25
    6dae:	0e 94 ed 39 	call	0x73da	; 0x73da <GPIO_readPin>
    6db2:	88 23       	and	r24, r24
    6db4:	91 f5       	brne	.+100    	; 0x6e1a <Get_Data+0x148>
//		vTaskDelay(50/portTICK_PERIOD_MS);
//		vTaskDelay(pdMS_TO_TICKS( 5 ));
		leftBtn_counter++;
    6db6:	80 91 dd 08 	lds	r24, 0x08DD
    6dba:	8f 5f       	subi	r24, 0xFF	; 255
    6dbc:	80 93 dd 08 	sts	0x08DD, r24
		if(leftBtn_counter % 5 == 0)
    6dc0:	80 91 dd 08 	lds	r24, 0x08DD
    6dc4:	95 e0       	ldi	r25, 0x05	; 5
    6dc6:	69 2f       	mov	r22, r25
    6dc8:	0e 94 a4 48 	call	0x9148	; 0x9148 <__udivmodqi4>
    6dcc:	89 2f       	mov	r24, r25
    6dce:	88 23       	and	r24, r24
    6dd0:	09 f0       	breq	.+2      	; 0x6dd4 <Get_Data+0x102>
    6dd2:	58 c0       	rjmp	.+176    	; 0x6e84 <Get_Data+0x1b2>
		{
			leftBtn_counter = 0;
    6dd4:	10 92 dd 08 	sts	0x08DD, r1
		if(!GPIO_readPin(dio_config_array[IGNITION_SWICH_ID].port_id,dio_config_array[IGNITION_SWICH_ID].pin_num)){
    6dd8:	80 91 39 02 	lds	r24, 0x0239
    6ddc:	90 91 3a 02 	lds	r25, 0x023A
    6de0:	69 2f       	mov	r22, r25
    6de2:	0e 94 ed 39 	call	0x73da	; 0x73da <GPIO_readPin>
    6de6:	88 23       	and	r24, r24
    6de8:	99 f4       	brne	.+38     	; 0x6e10 <Get_Data+0x13e>
			ButtonState.ignition_key = 1;
    6dea:	81 e0       	ldi	r24, 0x01	; 1
    6dec:	80 93 de 08 	sts	0x08DE, r24
			if(!GPIO_readPin(dio_config_array[LEFT_INDICATOR_BUTTON_ID].port_id,dio_config_array[LEFT_INDICATOR_BUTTON_ID].pin_num)){
    6df0:	80 91 36 02 	lds	r24, 0x0236
    6df4:	90 91 37 02 	lds	r25, 0x0237
    6df8:	69 2f       	mov	r22, r25
    6dfa:	0e 94 ed 39 	call	0x73da	; 0x73da <GPIO_readPin>
    6dfe:	88 23       	and	r24, r24
    6e00:	21 f4       	brne	.+8      	; 0x6e0a <Get_Data+0x138>
				ButtonState.leftIndicator = 1;
    6e02:	81 e0       	ldi	r24, 0x01	; 1
    6e04:	80 93 e0 08 	sts	0x08E0, r24
    6e08:	3d c0       	rjmp	.+122    	; 0x6e84 <Get_Data+0x1b2>
			}
			else{
				ButtonState.leftIndicator = 0;
    6e0a:	10 92 e0 08 	sts	0x08E0, r1
    6e0e:	3a c0       	rjmp	.+116    	; 0x6e84 <Get_Data+0x1b2>
			}
		}
		else{
			ButtonState.ignition_key = 0;
    6e10:	10 92 de 08 	sts	0x08DE, r1
			ButtonState.leftIndicator = 0;
    6e14:	10 92 e0 08 	sts	0x08E0, r1
    6e18:	35 c0       	rjmp	.+106    	; 0x6e84 <Get_Data+0x1b2>
		}
		}
	}
	else if(!GPIO_readPin(dio_config_array[IGNITION_SWICH_ID].port_id,dio_config_array[IGNITION_SWICH_ID].pin_num)){
    6e1a:	80 91 39 02 	lds	r24, 0x0239
    6e1e:	90 91 3a 02 	lds	r25, 0x023A
    6e22:	69 2f       	mov	r22, r25
    6e24:	0e 94 ed 39 	call	0x73da	; 0x73da <GPIO_readPin>
    6e28:	88 23       	and	r24, r24
    6e2a:	31 f5       	brne	.+76     	; 0x6e78 <Get_Data+0x1a6>
//		vTaskDelayUntil(&xLastWakeTime,10/portTICK_PERIOD_MS);
//		vTaskDelay(pdMS_TO_TICKS( 5 ));
		ignitionBtn_counter ++;
    6e2c:	80 91 db 08 	lds	r24, 0x08DB
    6e30:	8f 5f       	subi	r24, 0xFF	; 255
    6e32:	80 93 db 08 	sts	0x08DB, r24
		if(ignitionBtn_counter % 5 == 0)
    6e36:	80 91 db 08 	lds	r24, 0x08DB
    6e3a:	95 e0       	ldi	r25, 0x05	; 5
    6e3c:	69 2f       	mov	r22, r25
    6e3e:	0e 94 a4 48 	call	0x9148	; 0x9148 <__udivmodqi4>
    6e42:	89 2f       	mov	r24, r25
    6e44:	88 23       	and	r24, r24
    6e46:	f1 f4       	brne	.+60     	; 0x6e84 <Get_Data+0x1b2>
		{
		if(!GPIO_readPin(dio_config_array[IGNITION_SWICH_ID].port_id,dio_config_array[IGNITION_SWICH_ID].pin_num)){
    6e48:	80 91 39 02 	lds	r24, 0x0239
    6e4c:	90 91 3a 02 	lds	r25, 0x023A
    6e50:	69 2f       	mov	r22, r25
    6e52:	0e 94 ed 39 	call	0x73da	; 0x73da <GPIO_readPin>
    6e56:	88 23       	and	r24, r24
    6e58:	41 f4       	brne	.+16     	; 0x6e6a <Get_Data+0x198>
			ButtonState.ignition_key = 1;
    6e5a:	81 e0       	ldi	r24, 0x01	; 1
    6e5c:	80 93 de 08 	sts	0x08DE, r24
			ButtonState.rightIndicator = 0;
    6e60:	10 92 df 08 	sts	0x08DF, r1
			ButtonState.leftIndicator = 0;
    6e64:	10 92 e0 08 	sts	0x08E0, r1
    6e68:	0d c0       	rjmp	.+26     	; 0x6e84 <Get_Data+0x1b2>
		}
		else{
			ButtonState.ignition_key = 0;
    6e6a:	10 92 de 08 	sts	0x08DE, r1
			ButtonState.rightIndicator = 0;
    6e6e:	10 92 df 08 	sts	0x08DF, r1
			ButtonState.leftIndicator = 0;
    6e72:	10 92 e0 08 	sts	0x08E0, r1
    6e76:	06 c0       	rjmp	.+12     	; 0x6e84 <Get_Data+0x1b2>
		}
	}
	}
	else{
		ButtonState.ignition_key = 0;
    6e78:	10 92 de 08 	sts	0x08DE, r1
		ButtonState.rightIndicator = 0;
    6e7c:	10 92 df 08 	sts	0x08DF, r1
		ButtonState.leftIndicator = 0;
    6e80:	10 92 e0 08 	sts	0x08E0, r1
	//	else{
	//		ButtonState.ignition_key = 0;
	//	}


	return ButtonState;
    6e84:	80 91 de 08 	lds	r24, 0x08DE
    6e88:	90 91 df 08 	lds	r25, 0x08DF
    6e8c:	a0 91 e0 08 	lds	r26, 0x08E0
    6e90:	b0 91 e1 08 	lds	r27, 0x08E1
}
    6e94:	bc 01       	movw	r22, r24
    6e96:	cd 01       	movw	r24, r26
    6e98:	cf 91       	pop	r28
    6e9a:	df 91       	pop	r29
    6e9c:	08 95       	ret

00006e9e <GPIO_setupPinDirection>:
 * Description :
 * Setup the direction of the required pin input/output.
 * If the input port number or pin number are not correct, The function will not handle the request.
 */
void GPIO_setupPinDirection(uint8 port_num, uint8 pin_num, GPIO_PinDirectionType direction)
{
    6e9e:	df 93       	push	r29
    6ea0:	cf 93       	push	r28
    6ea2:	00 d0       	rcall	.+0      	; 0x6ea4 <GPIO_setupPinDirection+0x6>
    6ea4:	00 d0       	rcall	.+0      	; 0x6ea6 <GPIO_setupPinDirection+0x8>
    6ea6:	0f 92       	push	r0
    6ea8:	cd b7       	in	r28, 0x3d	; 61
    6eaa:	de b7       	in	r29, 0x3e	; 62
    6eac:	89 83       	std	Y+1, r24	; 0x01
    6eae:	6a 83       	std	Y+2, r22	; 0x02
    6eb0:	4b 83       	std	Y+3, r20	; 0x03
	/*
	 * Check if the input port number is greater than NUM_OF_PINS_PER_PORT value.
	 * Or if the input pin number is greater than NUM_OF_PINS_PER_PORT value.
	 * In this case the input is not valid port/pin number
	 */
	if((pin_num >= NUM_OF_PINS_PER_PORT) || (port_num >= NUM_OF_PORTS))
    6eb2:	8a 81       	ldd	r24, Y+2	; 0x02
    6eb4:	88 30       	cpi	r24, 0x08	; 8
    6eb6:	08 f0       	brcs	.+2      	; 0x6eba <GPIO_setupPinDirection+0x1c>
    6eb8:	39 c1       	rjmp	.+626    	; 0x712c <GPIO_setupPinDirection+0x28e>
    6eba:	89 81       	ldd	r24, Y+1	; 0x01
    6ebc:	86 30       	cpi	r24, 0x06	; 6
    6ebe:	08 f0       	brcs	.+2      	; 0x6ec2 <GPIO_setupPinDirection+0x24>
    6ec0:	35 c1       	rjmp	.+618    	; 0x712c <GPIO_setupPinDirection+0x28e>
		/* Do Nothing */
	}
	else
	{
		/* Setup the pin direction as required */
		switch(port_num)
    6ec2:	89 81       	ldd	r24, Y+1	; 0x01
    6ec4:	28 2f       	mov	r18, r24
    6ec6:	30 e0       	ldi	r19, 0x00	; 0
    6ec8:	3d 83       	std	Y+5, r19	; 0x05
    6eca:	2c 83       	std	Y+4, r18	; 0x04
    6ecc:	8c 81       	ldd	r24, Y+4	; 0x04
    6ece:	9d 81       	ldd	r25, Y+5	; 0x05
    6ed0:	82 30       	cpi	r24, 0x02	; 2
    6ed2:	91 05       	cpc	r25, r1
    6ed4:	09 f4       	brne	.+2      	; 0x6ed8 <GPIO_setupPinDirection+0x3a>
    6ed6:	7b c0       	rjmp	.+246    	; 0x6fce <GPIO_setupPinDirection+0x130>
    6ed8:	2c 81       	ldd	r18, Y+4	; 0x04
    6eda:	3d 81       	ldd	r19, Y+5	; 0x05
    6edc:	23 30       	cpi	r18, 0x03	; 3
    6ede:	31 05       	cpc	r19, r1
    6ee0:	5c f4       	brge	.+22     	; 0x6ef8 <GPIO_setupPinDirection+0x5a>
    6ee2:	8c 81       	ldd	r24, Y+4	; 0x04
    6ee4:	9d 81       	ldd	r25, Y+5	; 0x05
    6ee6:	00 97       	sbiw	r24, 0x00	; 0
    6ee8:	d1 f0       	breq	.+52     	; 0x6f1e <GPIO_setupPinDirection+0x80>
    6eea:	2c 81       	ldd	r18, Y+4	; 0x04
    6eec:	3d 81       	ldd	r19, Y+5	; 0x05
    6eee:	21 30       	cpi	r18, 0x01	; 1
    6ef0:	31 05       	cpc	r19, r1
    6ef2:	09 f4       	brne	.+2      	; 0x6ef6 <GPIO_setupPinDirection+0x58>
    6ef4:	40 c0       	rjmp	.+128    	; 0x6f76 <GPIO_setupPinDirection+0xd8>
    6ef6:	1a c1       	rjmp	.+564    	; 0x712c <GPIO_setupPinDirection+0x28e>
    6ef8:	8c 81       	ldd	r24, Y+4	; 0x04
    6efa:	9d 81       	ldd	r25, Y+5	; 0x05
    6efc:	84 30       	cpi	r24, 0x04	; 4
    6efe:	91 05       	cpc	r25, r1
    6f00:	09 f4       	brne	.+2      	; 0x6f04 <GPIO_setupPinDirection+0x66>
    6f02:	bd c0       	rjmp	.+378    	; 0x707e <GPIO_setupPinDirection+0x1e0>
    6f04:	2c 81       	ldd	r18, Y+4	; 0x04
    6f06:	3d 81       	ldd	r19, Y+5	; 0x05
    6f08:	24 30       	cpi	r18, 0x04	; 4
    6f0a:	31 05       	cpc	r19, r1
    6f0c:	0c f4       	brge	.+2      	; 0x6f10 <GPIO_setupPinDirection+0x72>
    6f0e:	8b c0       	rjmp	.+278    	; 0x7026 <GPIO_setupPinDirection+0x188>
    6f10:	8c 81       	ldd	r24, Y+4	; 0x04
    6f12:	9d 81       	ldd	r25, Y+5	; 0x05
    6f14:	85 30       	cpi	r24, 0x05	; 5
    6f16:	91 05       	cpc	r25, r1
    6f18:	09 f4       	brne	.+2      	; 0x6f1c <GPIO_setupPinDirection+0x7e>
    6f1a:	dd c0       	rjmp	.+442    	; 0x70d6 <GPIO_setupPinDirection+0x238>
    6f1c:	07 c1       	rjmp	.+526    	; 0x712c <GPIO_setupPinDirection+0x28e>
		{
		case PORTA_ID:
			if(direction == PIN_OUTPUT)
    6f1e:	8b 81       	ldd	r24, Y+3	; 0x03
    6f20:	81 30       	cpi	r24, 0x01	; 1
    6f22:	a1 f4       	brne	.+40     	; 0x6f4c <GPIO_setupPinDirection+0xae>
			{
				SET_BIT(DDRA,pin_num);
    6f24:	aa e3       	ldi	r26, 0x3A	; 58
    6f26:	b0 e0       	ldi	r27, 0x00	; 0
    6f28:	ea e3       	ldi	r30, 0x3A	; 58
    6f2a:	f0 e0       	ldi	r31, 0x00	; 0
    6f2c:	80 81       	ld	r24, Z
    6f2e:	48 2f       	mov	r20, r24
    6f30:	8a 81       	ldd	r24, Y+2	; 0x02
    6f32:	28 2f       	mov	r18, r24
    6f34:	30 e0       	ldi	r19, 0x00	; 0
    6f36:	81 e0       	ldi	r24, 0x01	; 1
    6f38:	90 e0       	ldi	r25, 0x00	; 0
    6f3a:	02 2e       	mov	r0, r18
    6f3c:	02 c0       	rjmp	.+4      	; 0x6f42 <GPIO_setupPinDirection+0xa4>
    6f3e:	88 0f       	add	r24, r24
    6f40:	99 1f       	adc	r25, r25
    6f42:	0a 94       	dec	r0
    6f44:	e2 f7       	brpl	.-8      	; 0x6f3e <GPIO_setupPinDirection+0xa0>
    6f46:	84 2b       	or	r24, r20
    6f48:	8c 93       	st	X, r24
    6f4a:	f0 c0       	rjmp	.+480    	; 0x712c <GPIO_setupPinDirection+0x28e>
			}
			else
			{
				CLEAR_BIT(DDRA,pin_num);
    6f4c:	aa e3       	ldi	r26, 0x3A	; 58
    6f4e:	b0 e0       	ldi	r27, 0x00	; 0
    6f50:	ea e3       	ldi	r30, 0x3A	; 58
    6f52:	f0 e0       	ldi	r31, 0x00	; 0
    6f54:	80 81       	ld	r24, Z
    6f56:	48 2f       	mov	r20, r24
    6f58:	8a 81       	ldd	r24, Y+2	; 0x02
    6f5a:	28 2f       	mov	r18, r24
    6f5c:	30 e0       	ldi	r19, 0x00	; 0
    6f5e:	81 e0       	ldi	r24, 0x01	; 1
    6f60:	90 e0       	ldi	r25, 0x00	; 0
    6f62:	02 2e       	mov	r0, r18
    6f64:	02 c0       	rjmp	.+4      	; 0x6f6a <GPIO_setupPinDirection+0xcc>
    6f66:	88 0f       	add	r24, r24
    6f68:	99 1f       	adc	r25, r25
    6f6a:	0a 94       	dec	r0
    6f6c:	e2 f7       	brpl	.-8      	; 0x6f66 <GPIO_setupPinDirection+0xc8>
    6f6e:	80 95       	com	r24
    6f70:	84 23       	and	r24, r20
    6f72:	8c 93       	st	X, r24
    6f74:	db c0       	rjmp	.+438    	; 0x712c <GPIO_setupPinDirection+0x28e>
			}
			break;
		case PORTB_ID:
			if(direction == PIN_OUTPUT)
    6f76:	8b 81       	ldd	r24, Y+3	; 0x03
    6f78:	81 30       	cpi	r24, 0x01	; 1
    6f7a:	a1 f4       	brne	.+40     	; 0x6fa4 <GPIO_setupPinDirection+0x106>
			{
				SET_BIT(DDRB,pin_num);
    6f7c:	a7 e3       	ldi	r26, 0x37	; 55
    6f7e:	b0 e0       	ldi	r27, 0x00	; 0
    6f80:	e7 e3       	ldi	r30, 0x37	; 55
    6f82:	f0 e0       	ldi	r31, 0x00	; 0
    6f84:	80 81       	ld	r24, Z
    6f86:	48 2f       	mov	r20, r24
    6f88:	8a 81       	ldd	r24, Y+2	; 0x02
    6f8a:	28 2f       	mov	r18, r24
    6f8c:	30 e0       	ldi	r19, 0x00	; 0
    6f8e:	81 e0       	ldi	r24, 0x01	; 1
    6f90:	90 e0       	ldi	r25, 0x00	; 0
    6f92:	02 2e       	mov	r0, r18
    6f94:	02 c0       	rjmp	.+4      	; 0x6f9a <GPIO_setupPinDirection+0xfc>
    6f96:	88 0f       	add	r24, r24
    6f98:	99 1f       	adc	r25, r25
    6f9a:	0a 94       	dec	r0
    6f9c:	e2 f7       	brpl	.-8      	; 0x6f96 <GPIO_setupPinDirection+0xf8>
    6f9e:	84 2b       	or	r24, r20
    6fa0:	8c 93       	st	X, r24
    6fa2:	c4 c0       	rjmp	.+392    	; 0x712c <GPIO_setupPinDirection+0x28e>
			}
			else
			{
				CLEAR_BIT(DDRB,pin_num);
    6fa4:	a7 e3       	ldi	r26, 0x37	; 55
    6fa6:	b0 e0       	ldi	r27, 0x00	; 0
    6fa8:	e7 e3       	ldi	r30, 0x37	; 55
    6faa:	f0 e0       	ldi	r31, 0x00	; 0
    6fac:	80 81       	ld	r24, Z
    6fae:	48 2f       	mov	r20, r24
    6fb0:	8a 81       	ldd	r24, Y+2	; 0x02
    6fb2:	28 2f       	mov	r18, r24
    6fb4:	30 e0       	ldi	r19, 0x00	; 0
    6fb6:	81 e0       	ldi	r24, 0x01	; 1
    6fb8:	90 e0       	ldi	r25, 0x00	; 0
    6fba:	02 2e       	mov	r0, r18
    6fbc:	02 c0       	rjmp	.+4      	; 0x6fc2 <GPIO_setupPinDirection+0x124>
    6fbe:	88 0f       	add	r24, r24
    6fc0:	99 1f       	adc	r25, r25
    6fc2:	0a 94       	dec	r0
    6fc4:	e2 f7       	brpl	.-8      	; 0x6fbe <GPIO_setupPinDirection+0x120>
    6fc6:	80 95       	com	r24
    6fc8:	84 23       	and	r24, r20
    6fca:	8c 93       	st	X, r24
    6fcc:	af c0       	rjmp	.+350    	; 0x712c <GPIO_setupPinDirection+0x28e>
			}
			break;
		case PORTC_ID:
			if(direction == PIN_OUTPUT)
    6fce:	8b 81       	ldd	r24, Y+3	; 0x03
    6fd0:	81 30       	cpi	r24, 0x01	; 1
    6fd2:	a1 f4       	brne	.+40     	; 0x6ffc <GPIO_setupPinDirection+0x15e>
			{
				SET_BIT(DDRC,pin_num);
    6fd4:	a4 e3       	ldi	r26, 0x34	; 52
    6fd6:	b0 e0       	ldi	r27, 0x00	; 0
    6fd8:	e4 e3       	ldi	r30, 0x34	; 52
    6fda:	f0 e0       	ldi	r31, 0x00	; 0
    6fdc:	80 81       	ld	r24, Z
    6fde:	48 2f       	mov	r20, r24
    6fe0:	8a 81       	ldd	r24, Y+2	; 0x02
    6fe2:	28 2f       	mov	r18, r24
    6fe4:	30 e0       	ldi	r19, 0x00	; 0
    6fe6:	81 e0       	ldi	r24, 0x01	; 1
    6fe8:	90 e0       	ldi	r25, 0x00	; 0
    6fea:	02 2e       	mov	r0, r18
    6fec:	02 c0       	rjmp	.+4      	; 0x6ff2 <GPIO_setupPinDirection+0x154>
    6fee:	88 0f       	add	r24, r24
    6ff0:	99 1f       	adc	r25, r25
    6ff2:	0a 94       	dec	r0
    6ff4:	e2 f7       	brpl	.-8      	; 0x6fee <GPIO_setupPinDirection+0x150>
    6ff6:	84 2b       	or	r24, r20
    6ff8:	8c 93       	st	X, r24
    6ffa:	98 c0       	rjmp	.+304    	; 0x712c <GPIO_setupPinDirection+0x28e>
			}
			else
			{
				CLEAR_BIT(DDRC,pin_num);
    6ffc:	a4 e3       	ldi	r26, 0x34	; 52
    6ffe:	b0 e0       	ldi	r27, 0x00	; 0
    7000:	e4 e3       	ldi	r30, 0x34	; 52
    7002:	f0 e0       	ldi	r31, 0x00	; 0
    7004:	80 81       	ld	r24, Z
    7006:	48 2f       	mov	r20, r24
    7008:	8a 81       	ldd	r24, Y+2	; 0x02
    700a:	28 2f       	mov	r18, r24
    700c:	30 e0       	ldi	r19, 0x00	; 0
    700e:	81 e0       	ldi	r24, 0x01	; 1
    7010:	90 e0       	ldi	r25, 0x00	; 0
    7012:	02 2e       	mov	r0, r18
    7014:	02 c0       	rjmp	.+4      	; 0x701a <GPIO_setupPinDirection+0x17c>
    7016:	88 0f       	add	r24, r24
    7018:	99 1f       	adc	r25, r25
    701a:	0a 94       	dec	r0
    701c:	e2 f7       	brpl	.-8      	; 0x7016 <GPIO_setupPinDirection+0x178>
    701e:	80 95       	com	r24
    7020:	84 23       	and	r24, r20
    7022:	8c 93       	st	X, r24
    7024:	83 c0       	rjmp	.+262    	; 0x712c <GPIO_setupPinDirection+0x28e>
			}
			break;
		case PORTD_ID:
			if(direction == PIN_OUTPUT)
    7026:	8b 81       	ldd	r24, Y+3	; 0x03
    7028:	81 30       	cpi	r24, 0x01	; 1
    702a:	a1 f4       	brne	.+40     	; 0x7054 <GPIO_setupPinDirection+0x1b6>
			{
				SET_BIT(DDRD,pin_num);
    702c:	a1 e3       	ldi	r26, 0x31	; 49
    702e:	b0 e0       	ldi	r27, 0x00	; 0
    7030:	e1 e3       	ldi	r30, 0x31	; 49
    7032:	f0 e0       	ldi	r31, 0x00	; 0
    7034:	80 81       	ld	r24, Z
    7036:	48 2f       	mov	r20, r24
    7038:	8a 81       	ldd	r24, Y+2	; 0x02
    703a:	28 2f       	mov	r18, r24
    703c:	30 e0       	ldi	r19, 0x00	; 0
    703e:	81 e0       	ldi	r24, 0x01	; 1
    7040:	90 e0       	ldi	r25, 0x00	; 0
    7042:	02 2e       	mov	r0, r18
    7044:	02 c0       	rjmp	.+4      	; 0x704a <GPIO_setupPinDirection+0x1ac>
    7046:	88 0f       	add	r24, r24
    7048:	99 1f       	adc	r25, r25
    704a:	0a 94       	dec	r0
    704c:	e2 f7       	brpl	.-8      	; 0x7046 <GPIO_setupPinDirection+0x1a8>
    704e:	84 2b       	or	r24, r20
    7050:	8c 93       	st	X, r24
    7052:	6c c0       	rjmp	.+216    	; 0x712c <GPIO_setupPinDirection+0x28e>
			}
			else
			{
				CLEAR_BIT(DDRD,pin_num);
    7054:	a1 e3       	ldi	r26, 0x31	; 49
    7056:	b0 e0       	ldi	r27, 0x00	; 0
    7058:	e1 e3       	ldi	r30, 0x31	; 49
    705a:	f0 e0       	ldi	r31, 0x00	; 0
    705c:	80 81       	ld	r24, Z
    705e:	48 2f       	mov	r20, r24
    7060:	8a 81       	ldd	r24, Y+2	; 0x02
    7062:	28 2f       	mov	r18, r24
    7064:	30 e0       	ldi	r19, 0x00	; 0
    7066:	81 e0       	ldi	r24, 0x01	; 1
    7068:	90 e0       	ldi	r25, 0x00	; 0
    706a:	02 2e       	mov	r0, r18
    706c:	02 c0       	rjmp	.+4      	; 0x7072 <GPIO_setupPinDirection+0x1d4>
    706e:	88 0f       	add	r24, r24
    7070:	99 1f       	adc	r25, r25
    7072:	0a 94       	dec	r0
    7074:	e2 f7       	brpl	.-8      	; 0x706e <GPIO_setupPinDirection+0x1d0>
    7076:	80 95       	com	r24
    7078:	84 23       	and	r24, r20
    707a:	8c 93       	st	X, r24
    707c:	57 c0       	rjmp	.+174    	; 0x712c <GPIO_setupPinDirection+0x28e>
			}
			break;
		case PORTE_ID:
			if(direction == PIN_OUTPUT)
    707e:	8b 81       	ldd	r24, Y+3	; 0x03
    7080:	81 30       	cpi	r24, 0x01	; 1
    7082:	a1 f4       	brne	.+40     	; 0x70ac <GPIO_setupPinDirection+0x20e>
			{
				SET_BIT(DDRE,pin_num);
    7084:	a2 e2       	ldi	r26, 0x22	; 34
    7086:	b0 e0       	ldi	r27, 0x00	; 0
    7088:	e2 e2       	ldi	r30, 0x22	; 34
    708a:	f0 e0       	ldi	r31, 0x00	; 0
    708c:	80 81       	ld	r24, Z
    708e:	48 2f       	mov	r20, r24
    7090:	8a 81       	ldd	r24, Y+2	; 0x02
    7092:	28 2f       	mov	r18, r24
    7094:	30 e0       	ldi	r19, 0x00	; 0
    7096:	81 e0       	ldi	r24, 0x01	; 1
    7098:	90 e0       	ldi	r25, 0x00	; 0
    709a:	02 2e       	mov	r0, r18
    709c:	02 c0       	rjmp	.+4      	; 0x70a2 <GPIO_setupPinDirection+0x204>
    709e:	88 0f       	add	r24, r24
    70a0:	99 1f       	adc	r25, r25
    70a2:	0a 94       	dec	r0
    70a4:	e2 f7       	brpl	.-8      	; 0x709e <GPIO_setupPinDirection+0x200>
    70a6:	84 2b       	or	r24, r20
    70a8:	8c 93       	st	X, r24
    70aa:	40 c0       	rjmp	.+128    	; 0x712c <GPIO_setupPinDirection+0x28e>
			}
			else
			{
				CLEAR_BIT(DDRE,pin_num);
    70ac:	a2 e2       	ldi	r26, 0x22	; 34
    70ae:	b0 e0       	ldi	r27, 0x00	; 0
    70b0:	e2 e2       	ldi	r30, 0x22	; 34
    70b2:	f0 e0       	ldi	r31, 0x00	; 0
    70b4:	80 81       	ld	r24, Z
    70b6:	48 2f       	mov	r20, r24
    70b8:	8a 81       	ldd	r24, Y+2	; 0x02
    70ba:	28 2f       	mov	r18, r24
    70bc:	30 e0       	ldi	r19, 0x00	; 0
    70be:	81 e0       	ldi	r24, 0x01	; 1
    70c0:	90 e0       	ldi	r25, 0x00	; 0
    70c2:	02 2e       	mov	r0, r18
    70c4:	02 c0       	rjmp	.+4      	; 0x70ca <GPIO_setupPinDirection+0x22c>
    70c6:	88 0f       	add	r24, r24
    70c8:	99 1f       	adc	r25, r25
    70ca:	0a 94       	dec	r0
    70cc:	e2 f7       	brpl	.-8      	; 0x70c6 <GPIO_setupPinDirection+0x228>
    70ce:	80 95       	com	r24
    70d0:	84 23       	and	r24, r20
    70d2:	8c 93       	st	X, r24
    70d4:	2b c0       	rjmp	.+86     	; 0x712c <GPIO_setupPinDirection+0x28e>
			}
			break;
		case PORTF_ID:
			if(direction == PIN_OUTPUT)
    70d6:	8b 81       	ldd	r24, Y+3	; 0x03
    70d8:	81 30       	cpi	r24, 0x01	; 1
    70da:	a1 f4       	brne	.+40     	; 0x7104 <GPIO_setupPinDirection+0x266>
			{
				SET_BIT(DDRF,pin_num);
    70dc:	a1 e6       	ldi	r26, 0x61	; 97
    70de:	b0 e0       	ldi	r27, 0x00	; 0
    70e0:	e1 e6       	ldi	r30, 0x61	; 97
    70e2:	f0 e0       	ldi	r31, 0x00	; 0
    70e4:	80 81       	ld	r24, Z
    70e6:	48 2f       	mov	r20, r24
    70e8:	8a 81       	ldd	r24, Y+2	; 0x02
    70ea:	28 2f       	mov	r18, r24
    70ec:	30 e0       	ldi	r19, 0x00	; 0
    70ee:	81 e0       	ldi	r24, 0x01	; 1
    70f0:	90 e0       	ldi	r25, 0x00	; 0
    70f2:	02 2e       	mov	r0, r18
    70f4:	02 c0       	rjmp	.+4      	; 0x70fa <GPIO_setupPinDirection+0x25c>
    70f6:	88 0f       	add	r24, r24
    70f8:	99 1f       	adc	r25, r25
    70fa:	0a 94       	dec	r0
    70fc:	e2 f7       	brpl	.-8      	; 0x70f6 <GPIO_setupPinDirection+0x258>
    70fe:	84 2b       	or	r24, r20
    7100:	8c 93       	st	X, r24
    7102:	14 c0       	rjmp	.+40     	; 0x712c <GPIO_setupPinDirection+0x28e>
			}
			else
			{
				CLEAR_BIT(DDRF,pin_num);
    7104:	a1 e6       	ldi	r26, 0x61	; 97
    7106:	b0 e0       	ldi	r27, 0x00	; 0
    7108:	e1 e6       	ldi	r30, 0x61	; 97
    710a:	f0 e0       	ldi	r31, 0x00	; 0
    710c:	80 81       	ld	r24, Z
    710e:	48 2f       	mov	r20, r24
    7110:	8a 81       	ldd	r24, Y+2	; 0x02
    7112:	28 2f       	mov	r18, r24
    7114:	30 e0       	ldi	r19, 0x00	; 0
    7116:	81 e0       	ldi	r24, 0x01	; 1
    7118:	90 e0       	ldi	r25, 0x00	; 0
    711a:	02 2e       	mov	r0, r18
    711c:	02 c0       	rjmp	.+4      	; 0x7122 <GPIO_setupPinDirection+0x284>
    711e:	88 0f       	add	r24, r24
    7120:	99 1f       	adc	r25, r25
    7122:	0a 94       	dec	r0
    7124:	e2 f7       	brpl	.-8      	; 0x711e <GPIO_setupPinDirection+0x280>
    7126:	80 95       	com	r24
    7128:	84 23       	and	r24, r20
    712a:	8c 93       	st	X, r24
			}
			break;
		}
	}
}
    712c:	0f 90       	pop	r0
    712e:	0f 90       	pop	r0
    7130:	0f 90       	pop	r0
    7132:	0f 90       	pop	r0
    7134:	0f 90       	pop	r0
    7136:	cf 91       	pop	r28
    7138:	df 91       	pop	r29
    713a:	08 95       	ret

0000713c <GPIO_writePin>:
 * Write the value Logic High or Logic Low on the required pin.
 * If the input port number or pin number are not correct, The function will not handle the request.
 * If the pin is input, this function will enable/disable the internal pull-up resistor.
 */
void GPIO_writePin(uint8 port_num, uint8 pin_num, uint8 value)
{
    713c:	df 93       	push	r29
    713e:	cf 93       	push	r28
    7140:	00 d0       	rcall	.+0      	; 0x7142 <GPIO_writePin+0x6>
    7142:	00 d0       	rcall	.+0      	; 0x7144 <GPIO_writePin+0x8>
    7144:	0f 92       	push	r0
    7146:	cd b7       	in	r28, 0x3d	; 61
    7148:	de b7       	in	r29, 0x3e	; 62
    714a:	89 83       	std	Y+1, r24	; 0x01
    714c:	6a 83       	std	Y+2, r22	; 0x02
    714e:	4b 83       	std	Y+3, r20	; 0x03
	/*
	 * Check if the input port number is greater than NUM_OF_PINS_PER_PORT value.
	 * Or if the input pin number is greater than NUM_OF_PINS_PER_PORT value.
	 * In this case the input is not valid port/pin number
	 */
	if((pin_num >= NUM_OF_PINS_PER_PORT) || (port_num >= NUM_OF_PORTS))
    7150:	8a 81       	ldd	r24, Y+2	; 0x02
    7152:	88 30       	cpi	r24, 0x08	; 8
    7154:	08 f0       	brcs	.+2      	; 0x7158 <GPIO_writePin+0x1c>
    7156:	39 c1       	rjmp	.+626    	; 0x73ca <GPIO_writePin+0x28e>
    7158:	89 81       	ldd	r24, Y+1	; 0x01
    715a:	86 30       	cpi	r24, 0x06	; 6
    715c:	08 f0       	brcs	.+2      	; 0x7160 <GPIO_writePin+0x24>
    715e:	35 c1       	rjmp	.+618    	; 0x73ca <GPIO_writePin+0x28e>
		/* Do Nothing */
	}
	else
	{
		/* Write the pin value as required */
		switch(port_num)
    7160:	89 81       	ldd	r24, Y+1	; 0x01
    7162:	28 2f       	mov	r18, r24
    7164:	30 e0       	ldi	r19, 0x00	; 0
    7166:	3d 83       	std	Y+5, r19	; 0x05
    7168:	2c 83       	std	Y+4, r18	; 0x04
    716a:	8c 81       	ldd	r24, Y+4	; 0x04
    716c:	9d 81       	ldd	r25, Y+5	; 0x05
    716e:	82 30       	cpi	r24, 0x02	; 2
    7170:	91 05       	cpc	r25, r1
    7172:	09 f4       	brne	.+2      	; 0x7176 <GPIO_writePin+0x3a>
    7174:	7b c0       	rjmp	.+246    	; 0x726c <GPIO_writePin+0x130>
    7176:	2c 81       	ldd	r18, Y+4	; 0x04
    7178:	3d 81       	ldd	r19, Y+5	; 0x05
    717a:	23 30       	cpi	r18, 0x03	; 3
    717c:	31 05       	cpc	r19, r1
    717e:	5c f4       	brge	.+22     	; 0x7196 <GPIO_writePin+0x5a>
    7180:	8c 81       	ldd	r24, Y+4	; 0x04
    7182:	9d 81       	ldd	r25, Y+5	; 0x05
    7184:	00 97       	sbiw	r24, 0x00	; 0
    7186:	d1 f0       	breq	.+52     	; 0x71bc <GPIO_writePin+0x80>
    7188:	2c 81       	ldd	r18, Y+4	; 0x04
    718a:	3d 81       	ldd	r19, Y+5	; 0x05
    718c:	21 30       	cpi	r18, 0x01	; 1
    718e:	31 05       	cpc	r19, r1
    7190:	09 f4       	brne	.+2      	; 0x7194 <GPIO_writePin+0x58>
    7192:	40 c0       	rjmp	.+128    	; 0x7214 <GPIO_writePin+0xd8>
    7194:	1a c1       	rjmp	.+564    	; 0x73ca <GPIO_writePin+0x28e>
    7196:	8c 81       	ldd	r24, Y+4	; 0x04
    7198:	9d 81       	ldd	r25, Y+5	; 0x05
    719a:	84 30       	cpi	r24, 0x04	; 4
    719c:	91 05       	cpc	r25, r1
    719e:	09 f4       	brne	.+2      	; 0x71a2 <GPIO_writePin+0x66>
    71a0:	bd c0       	rjmp	.+378    	; 0x731c <GPIO_writePin+0x1e0>
    71a2:	2c 81       	ldd	r18, Y+4	; 0x04
    71a4:	3d 81       	ldd	r19, Y+5	; 0x05
    71a6:	24 30       	cpi	r18, 0x04	; 4
    71a8:	31 05       	cpc	r19, r1
    71aa:	0c f4       	brge	.+2      	; 0x71ae <GPIO_writePin+0x72>
    71ac:	8b c0       	rjmp	.+278    	; 0x72c4 <GPIO_writePin+0x188>
    71ae:	8c 81       	ldd	r24, Y+4	; 0x04
    71b0:	9d 81       	ldd	r25, Y+5	; 0x05
    71b2:	85 30       	cpi	r24, 0x05	; 5
    71b4:	91 05       	cpc	r25, r1
    71b6:	09 f4       	brne	.+2      	; 0x71ba <GPIO_writePin+0x7e>
    71b8:	dd c0       	rjmp	.+442    	; 0x7374 <GPIO_writePin+0x238>
    71ba:	07 c1       	rjmp	.+526    	; 0x73ca <GPIO_writePin+0x28e>
		{
		case PORTA_ID:
			if(value == LOGIC_HIGH)
    71bc:	8b 81       	ldd	r24, Y+3	; 0x03
    71be:	81 30       	cpi	r24, 0x01	; 1
    71c0:	a1 f4       	brne	.+40     	; 0x71ea <GPIO_writePin+0xae>
			{
				SET_BIT(PORTA,pin_num);
    71c2:	ab e3       	ldi	r26, 0x3B	; 59
    71c4:	b0 e0       	ldi	r27, 0x00	; 0
    71c6:	eb e3       	ldi	r30, 0x3B	; 59
    71c8:	f0 e0       	ldi	r31, 0x00	; 0
    71ca:	80 81       	ld	r24, Z
    71cc:	48 2f       	mov	r20, r24
    71ce:	8a 81       	ldd	r24, Y+2	; 0x02
    71d0:	28 2f       	mov	r18, r24
    71d2:	30 e0       	ldi	r19, 0x00	; 0
    71d4:	81 e0       	ldi	r24, 0x01	; 1
    71d6:	90 e0       	ldi	r25, 0x00	; 0
    71d8:	02 2e       	mov	r0, r18
    71da:	02 c0       	rjmp	.+4      	; 0x71e0 <GPIO_writePin+0xa4>
    71dc:	88 0f       	add	r24, r24
    71de:	99 1f       	adc	r25, r25
    71e0:	0a 94       	dec	r0
    71e2:	e2 f7       	brpl	.-8      	; 0x71dc <GPIO_writePin+0xa0>
    71e4:	84 2b       	or	r24, r20
    71e6:	8c 93       	st	X, r24
    71e8:	f0 c0       	rjmp	.+480    	; 0x73ca <GPIO_writePin+0x28e>
			}
			else
			{
				CLEAR_BIT(PORTA,pin_num);
    71ea:	ab e3       	ldi	r26, 0x3B	; 59
    71ec:	b0 e0       	ldi	r27, 0x00	; 0
    71ee:	eb e3       	ldi	r30, 0x3B	; 59
    71f0:	f0 e0       	ldi	r31, 0x00	; 0
    71f2:	80 81       	ld	r24, Z
    71f4:	48 2f       	mov	r20, r24
    71f6:	8a 81       	ldd	r24, Y+2	; 0x02
    71f8:	28 2f       	mov	r18, r24
    71fa:	30 e0       	ldi	r19, 0x00	; 0
    71fc:	81 e0       	ldi	r24, 0x01	; 1
    71fe:	90 e0       	ldi	r25, 0x00	; 0
    7200:	02 2e       	mov	r0, r18
    7202:	02 c0       	rjmp	.+4      	; 0x7208 <GPIO_writePin+0xcc>
    7204:	88 0f       	add	r24, r24
    7206:	99 1f       	adc	r25, r25
    7208:	0a 94       	dec	r0
    720a:	e2 f7       	brpl	.-8      	; 0x7204 <GPIO_writePin+0xc8>
    720c:	80 95       	com	r24
    720e:	84 23       	and	r24, r20
    7210:	8c 93       	st	X, r24
    7212:	db c0       	rjmp	.+438    	; 0x73ca <GPIO_writePin+0x28e>
			}
			break;
		case PORTB_ID:
			if(value == LOGIC_HIGH)
    7214:	8b 81       	ldd	r24, Y+3	; 0x03
    7216:	81 30       	cpi	r24, 0x01	; 1
    7218:	a1 f4       	brne	.+40     	; 0x7242 <GPIO_writePin+0x106>
			{
				SET_BIT(PORTB,pin_num);
    721a:	a8 e3       	ldi	r26, 0x38	; 56
    721c:	b0 e0       	ldi	r27, 0x00	; 0
    721e:	e8 e3       	ldi	r30, 0x38	; 56
    7220:	f0 e0       	ldi	r31, 0x00	; 0
    7222:	80 81       	ld	r24, Z
    7224:	48 2f       	mov	r20, r24
    7226:	8a 81       	ldd	r24, Y+2	; 0x02
    7228:	28 2f       	mov	r18, r24
    722a:	30 e0       	ldi	r19, 0x00	; 0
    722c:	81 e0       	ldi	r24, 0x01	; 1
    722e:	90 e0       	ldi	r25, 0x00	; 0
    7230:	02 2e       	mov	r0, r18
    7232:	02 c0       	rjmp	.+4      	; 0x7238 <GPIO_writePin+0xfc>
    7234:	88 0f       	add	r24, r24
    7236:	99 1f       	adc	r25, r25
    7238:	0a 94       	dec	r0
    723a:	e2 f7       	brpl	.-8      	; 0x7234 <GPIO_writePin+0xf8>
    723c:	84 2b       	or	r24, r20
    723e:	8c 93       	st	X, r24
    7240:	c4 c0       	rjmp	.+392    	; 0x73ca <GPIO_writePin+0x28e>
			}
			else
			{
				CLEAR_BIT(PORTB,pin_num);
    7242:	a8 e3       	ldi	r26, 0x38	; 56
    7244:	b0 e0       	ldi	r27, 0x00	; 0
    7246:	e8 e3       	ldi	r30, 0x38	; 56
    7248:	f0 e0       	ldi	r31, 0x00	; 0
    724a:	80 81       	ld	r24, Z
    724c:	48 2f       	mov	r20, r24
    724e:	8a 81       	ldd	r24, Y+2	; 0x02
    7250:	28 2f       	mov	r18, r24
    7252:	30 e0       	ldi	r19, 0x00	; 0
    7254:	81 e0       	ldi	r24, 0x01	; 1
    7256:	90 e0       	ldi	r25, 0x00	; 0
    7258:	02 2e       	mov	r0, r18
    725a:	02 c0       	rjmp	.+4      	; 0x7260 <GPIO_writePin+0x124>
    725c:	88 0f       	add	r24, r24
    725e:	99 1f       	adc	r25, r25
    7260:	0a 94       	dec	r0
    7262:	e2 f7       	brpl	.-8      	; 0x725c <GPIO_writePin+0x120>
    7264:	80 95       	com	r24
    7266:	84 23       	and	r24, r20
    7268:	8c 93       	st	X, r24
    726a:	af c0       	rjmp	.+350    	; 0x73ca <GPIO_writePin+0x28e>
			}
			break;
		case PORTC_ID:
			if(value == LOGIC_HIGH)
    726c:	8b 81       	ldd	r24, Y+3	; 0x03
    726e:	81 30       	cpi	r24, 0x01	; 1
    7270:	a1 f4       	brne	.+40     	; 0x729a <GPIO_writePin+0x15e>
			{
				SET_BIT(PORTC,pin_num);
    7272:	a5 e3       	ldi	r26, 0x35	; 53
    7274:	b0 e0       	ldi	r27, 0x00	; 0
    7276:	e5 e3       	ldi	r30, 0x35	; 53
    7278:	f0 e0       	ldi	r31, 0x00	; 0
    727a:	80 81       	ld	r24, Z
    727c:	48 2f       	mov	r20, r24
    727e:	8a 81       	ldd	r24, Y+2	; 0x02
    7280:	28 2f       	mov	r18, r24
    7282:	30 e0       	ldi	r19, 0x00	; 0
    7284:	81 e0       	ldi	r24, 0x01	; 1
    7286:	90 e0       	ldi	r25, 0x00	; 0
    7288:	02 2e       	mov	r0, r18
    728a:	02 c0       	rjmp	.+4      	; 0x7290 <GPIO_writePin+0x154>
    728c:	88 0f       	add	r24, r24
    728e:	99 1f       	adc	r25, r25
    7290:	0a 94       	dec	r0
    7292:	e2 f7       	brpl	.-8      	; 0x728c <GPIO_writePin+0x150>
    7294:	84 2b       	or	r24, r20
    7296:	8c 93       	st	X, r24
    7298:	98 c0       	rjmp	.+304    	; 0x73ca <GPIO_writePin+0x28e>
			}
			else
			{
				CLEAR_BIT(PORTC,pin_num);
    729a:	a5 e3       	ldi	r26, 0x35	; 53
    729c:	b0 e0       	ldi	r27, 0x00	; 0
    729e:	e5 e3       	ldi	r30, 0x35	; 53
    72a0:	f0 e0       	ldi	r31, 0x00	; 0
    72a2:	80 81       	ld	r24, Z
    72a4:	48 2f       	mov	r20, r24
    72a6:	8a 81       	ldd	r24, Y+2	; 0x02
    72a8:	28 2f       	mov	r18, r24
    72aa:	30 e0       	ldi	r19, 0x00	; 0
    72ac:	81 e0       	ldi	r24, 0x01	; 1
    72ae:	90 e0       	ldi	r25, 0x00	; 0
    72b0:	02 2e       	mov	r0, r18
    72b2:	02 c0       	rjmp	.+4      	; 0x72b8 <GPIO_writePin+0x17c>
    72b4:	88 0f       	add	r24, r24
    72b6:	99 1f       	adc	r25, r25
    72b8:	0a 94       	dec	r0
    72ba:	e2 f7       	brpl	.-8      	; 0x72b4 <GPIO_writePin+0x178>
    72bc:	80 95       	com	r24
    72be:	84 23       	and	r24, r20
    72c0:	8c 93       	st	X, r24
    72c2:	83 c0       	rjmp	.+262    	; 0x73ca <GPIO_writePin+0x28e>
			}
			break;
		case PORTD_ID:
			if(value == LOGIC_HIGH)
    72c4:	8b 81       	ldd	r24, Y+3	; 0x03
    72c6:	81 30       	cpi	r24, 0x01	; 1
    72c8:	a1 f4       	brne	.+40     	; 0x72f2 <GPIO_writePin+0x1b6>
			{
				SET_BIT(PORTD,pin_num);
    72ca:	a2 e3       	ldi	r26, 0x32	; 50
    72cc:	b0 e0       	ldi	r27, 0x00	; 0
    72ce:	e2 e3       	ldi	r30, 0x32	; 50
    72d0:	f0 e0       	ldi	r31, 0x00	; 0
    72d2:	80 81       	ld	r24, Z
    72d4:	48 2f       	mov	r20, r24
    72d6:	8a 81       	ldd	r24, Y+2	; 0x02
    72d8:	28 2f       	mov	r18, r24
    72da:	30 e0       	ldi	r19, 0x00	; 0
    72dc:	81 e0       	ldi	r24, 0x01	; 1
    72de:	90 e0       	ldi	r25, 0x00	; 0
    72e0:	02 2e       	mov	r0, r18
    72e2:	02 c0       	rjmp	.+4      	; 0x72e8 <GPIO_writePin+0x1ac>
    72e4:	88 0f       	add	r24, r24
    72e6:	99 1f       	adc	r25, r25
    72e8:	0a 94       	dec	r0
    72ea:	e2 f7       	brpl	.-8      	; 0x72e4 <GPIO_writePin+0x1a8>
    72ec:	84 2b       	or	r24, r20
    72ee:	8c 93       	st	X, r24
    72f0:	6c c0       	rjmp	.+216    	; 0x73ca <GPIO_writePin+0x28e>
			}
			else
			{
				CLEAR_BIT(PORTD,pin_num);
    72f2:	a2 e3       	ldi	r26, 0x32	; 50
    72f4:	b0 e0       	ldi	r27, 0x00	; 0
    72f6:	e2 e3       	ldi	r30, 0x32	; 50
    72f8:	f0 e0       	ldi	r31, 0x00	; 0
    72fa:	80 81       	ld	r24, Z
    72fc:	48 2f       	mov	r20, r24
    72fe:	8a 81       	ldd	r24, Y+2	; 0x02
    7300:	28 2f       	mov	r18, r24
    7302:	30 e0       	ldi	r19, 0x00	; 0
    7304:	81 e0       	ldi	r24, 0x01	; 1
    7306:	90 e0       	ldi	r25, 0x00	; 0
    7308:	02 2e       	mov	r0, r18
    730a:	02 c0       	rjmp	.+4      	; 0x7310 <GPIO_writePin+0x1d4>
    730c:	88 0f       	add	r24, r24
    730e:	99 1f       	adc	r25, r25
    7310:	0a 94       	dec	r0
    7312:	e2 f7       	brpl	.-8      	; 0x730c <GPIO_writePin+0x1d0>
    7314:	80 95       	com	r24
    7316:	84 23       	and	r24, r20
    7318:	8c 93       	st	X, r24
    731a:	57 c0       	rjmp	.+174    	; 0x73ca <GPIO_writePin+0x28e>
			}
			break;
		case PORTE_ID:
			if(value == LOGIC_HIGH)
    731c:	8b 81       	ldd	r24, Y+3	; 0x03
    731e:	81 30       	cpi	r24, 0x01	; 1
    7320:	a1 f4       	brne	.+40     	; 0x734a <GPIO_writePin+0x20e>
			{
				SET_BIT(PORTE,pin_num);
    7322:	a3 e2       	ldi	r26, 0x23	; 35
    7324:	b0 e0       	ldi	r27, 0x00	; 0
    7326:	e3 e2       	ldi	r30, 0x23	; 35
    7328:	f0 e0       	ldi	r31, 0x00	; 0
    732a:	80 81       	ld	r24, Z
    732c:	48 2f       	mov	r20, r24
    732e:	8a 81       	ldd	r24, Y+2	; 0x02
    7330:	28 2f       	mov	r18, r24
    7332:	30 e0       	ldi	r19, 0x00	; 0
    7334:	81 e0       	ldi	r24, 0x01	; 1
    7336:	90 e0       	ldi	r25, 0x00	; 0
    7338:	02 2e       	mov	r0, r18
    733a:	02 c0       	rjmp	.+4      	; 0x7340 <GPIO_writePin+0x204>
    733c:	88 0f       	add	r24, r24
    733e:	99 1f       	adc	r25, r25
    7340:	0a 94       	dec	r0
    7342:	e2 f7       	brpl	.-8      	; 0x733c <GPIO_writePin+0x200>
    7344:	84 2b       	or	r24, r20
    7346:	8c 93       	st	X, r24
    7348:	40 c0       	rjmp	.+128    	; 0x73ca <GPIO_writePin+0x28e>
			}
			else
			{
				CLEAR_BIT(PORTE,pin_num);
    734a:	a3 e2       	ldi	r26, 0x23	; 35
    734c:	b0 e0       	ldi	r27, 0x00	; 0
    734e:	e3 e2       	ldi	r30, 0x23	; 35
    7350:	f0 e0       	ldi	r31, 0x00	; 0
    7352:	80 81       	ld	r24, Z
    7354:	48 2f       	mov	r20, r24
    7356:	8a 81       	ldd	r24, Y+2	; 0x02
    7358:	28 2f       	mov	r18, r24
    735a:	30 e0       	ldi	r19, 0x00	; 0
    735c:	81 e0       	ldi	r24, 0x01	; 1
    735e:	90 e0       	ldi	r25, 0x00	; 0
    7360:	02 2e       	mov	r0, r18
    7362:	02 c0       	rjmp	.+4      	; 0x7368 <GPIO_writePin+0x22c>
    7364:	88 0f       	add	r24, r24
    7366:	99 1f       	adc	r25, r25
    7368:	0a 94       	dec	r0
    736a:	e2 f7       	brpl	.-8      	; 0x7364 <GPIO_writePin+0x228>
    736c:	80 95       	com	r24
    736e:	84 23       	and	r24, r20
    7370:	8c 93       	st	X, r24
    7372:	2b c0       	rjmp	.+86     	; 0x73ca <GPIO_writePin+0x28e>
			}
			break;
		case PORTF_ID:
			if(value == LOGIC_HIGH)
    7374:	8b 81       	ldd	r24, Y+3	; 0x03
    7376:	81 30       	cpi	r24, 0x01	; 1
    7378:	a1 f4       	brne	.+40     	; 0x73a2 <GPIO_writePin+0x266>
			{
				SET_BIT(PORTF,pin_num);
    737a:	a2 e6       	ldi	r26, 0x62	; 98
    737c:	b0 e0       	ldi	r27, 0x00	; 0
    737e:	e2 e6       	ldi	r30, 0x62	; 98
    7380:	f0 e0       	ldi	r31, 0x00	; 0
    7382:	80 81       	ld	r24, Z
    7384:	48 2f       	mov	r20, r24
    7386:	8a 81       	ldd	r24, Y+2	; 0x02
    7388:	28 2f       	mov	r18, r24
    738a:	30 e0       	ldi	r19, 0x00	; 0
    738c:	81 e0       	ldi	r24, 0x01	; 1
    738e:	90 e0       	ldi	r25, 0x00	; 0
    7390:	02 2e       	mov	r0, r18
    7392:	02 c0       	rjmp	.+4      	; 0x7398 <GPIO_writePin+0x25c>
    7394:	88 0f       	add	r24, r24
    7396:	99 1f       	adc	r25, r25
    7398:	0a 94       	dec	r0
    739a:	e2 f7       	brpl	.-8      	; 0x7394 <GPIO_writePin+0x258>
    739c:	84 2b       	or	r24, r20
    739e:	8c 93       	st	X, r24
    73a0:	14 c0       	rjmp	.+40     	; 0x73ca <GPIO_writePin+0x28e>
			}
			else
			{
				CLEAR_BIT(PORTF,pin_num);
    73a2:	a2 e6       	ldi	r26, 0x62	; 98
    73a4:	b0 e0       	ldi	r27, 0x00	; 0
    73a6:	e2 e6       	ldi	r30, 0x62	; 98
    73a8:	f0 e0       	ldi	r31, 0x00	; 0
    73aa:	80 81       	ld	r24, Z
    73ac:	48 2f       	mov	r20, r24
    73ae:	8a 81       	ldd	r24, Y+2	; 0x02
    73b0:	28 2f       	mov	r18, r24
    73b2:	30 e0       	ldi	r19, 0x00	; 0
    73b4:	81 e0       	ldi	r24, 0x01	; 1
    73b6:	90 e0       	ldi	r25, 0x00	; 0
    73b8:	02 2e       	mov	r0, r18
    73ba:	02 c0       	rjmp	.+4      	; 0x73c0 <GPIO_writePin+0x284>
    73bc:	88 0f       	add	r24, r24
    73be:	99 1f       	adc	r25, r25
    73c0:	0a 94       	dec	r0
    73c2:	e2 f7       	brpl	.-8      	; 0x73bc <GPIO_writePin+0x280>
    73c4:	80 95       	com	r24
    73c6:	84 23       	and	r24, r20
    73c8:	8c 93       	st	X, r24
			}
			break;
		}
	}
}
    73ca:	0f 90       	pop	r0
    73cc:	0f 90       	pop	r0
    73ce:	0f 90       	pop	r0
    73d0:	0f 90       	pop	r0
    73d2:	0f 90       	pop	r0
    73d4:	cf 91       	pop	r28
    73d6:	df 91       	pop	r29
    73d8:	08 95       	ret

000073da <GPIO_readPin>:
 * Description :
 * Read and return the value for the required pin, it should be Logic High or Logic Low.
 * If the input port number or pin number are not correct, The function will return Logic Low.
 */
uint8 GPIO_readPin(uint8 port_num, uint8 pin_num)
{
    73da:	df 93       	push	r29
    73dc:	cf 93       	push	r28
    73de:	00 d0       	rcall	.+0      	; 0x73e0 <GPIO_readPin+0x6>
    73e0:	00 d0       	rcall	.+0      	; 0x73e2 <GPIO_readPin+0x8>
    73e2:	0f 92       	push	r0
    73e4:	cd b7       	in	r28, 0x3d	; 61
    73e6:	de b7       	in	r29, 0x3e	; 62
    73e8:	8a 83       	std	Y+2, r24	; 0x02
    73ea:	6b 83       	std	Y+3, r22	; 0x03
	uint8 pin_value = LOGIC_LOW;
    73ec:	19 82       	std	Y+1, r1	; 0x01
	/*
	 * Check if the input port number is greater than NUM_OF_PINS_PER_PORT value.
	 * Or if the input pin number is greater than NUM_OF_PINS_PER_PORT value.
	 * In this case the input is not valid port/pin number
	 */
	if((pin_num >= NUM_OF_PINS_PER_PORT) || (port_num >= NUM_OF_PORTS))
    73ee:	8b 81       	ldd	r24, Y+3	; 0x03
    73f0:	88 30       	cpi	r24, 0x08	; 8
    73f2:	08 f0       	brcs	.+2      	; 0x73f6 <GPIO_readPin+0x1c>
    73f4:	c1 c0       	rjmp	.+386    	; 0x7578 <GPIO_readPin+0x19e>
    73f6:	8a 81       	ldd	r24, Y+2	; 0x02
    73f8:	86 30       	cpi	r24, 0x06	; 6
    73fa:	08 f0       	brcs	.+2      	; 0x73fe <GPIO_readPin+0x24>
    73fc:	bd c0       	rjmp	.+378    	; 0x7578 <GPIO_readPin+0x19e>
		/* Do Nothing */
	}
	else
	{
		/* Read the pin value as required */
		switch(port_num)
    73fe:	8a 81       	ldd	r24, Y+2	; 0x02
    7400:	28 2f       	mov	r18, r24
    7402:	30 e0       	ldi	r19, 0x00	; 0
    7404:	3d 83       	std	Y+5, r19	; 0x05
    7406:	2c 83       	std	Y+4, r18	; 0x04
    7408:	4c 81       	ldd	r20, Y+4	; 0x04
    740a:	5d 81       	ldd	r21, Y+5	; 0x05
    740c:	42 30       	cpi	r20, 0x02	; 2
    740e:	51 05       	cpc	r21, r1
    7410:	09 f4       	brne	.+2      	; 0x7414 <GPIO_readPin+0x3a>
    7412:	53 c0       	rjmp	.+166    	; 0x74ba <GPIO_readPin+0xe0>
    7414:	8c 81       	ldd	r24, Y+4	; 0x04
    7416:	9d 81       	ldd	r25, Y+5	; 0x05
    7418:	83 30       	cpi	r24, 0x03	; 3
    741a:	91 05       	cpc	r25, r1
    741c:	5c f4       	brge	.+22     	; 0x7434 <GPIO_readPin+0x5a>
    741e:	2c 81       	ldd	r18, Y+4	; 0x04
    7420:	3d 81       	ldd	r19, Y+5	; 0x05
    7422:	21 15       	cp	r18, r1
    7424:	31 05       	cpc	r19, r1
    7426:	c9 f0       	breq	.+50     	; 0x745a <GPIO_readPin+0x80>
    7428:	4c 81       	ldd	r20, Y+4	; 0x04
    742a:	5d 81       	ldd	r21, Y+5	; 0x05
    742c:	41 30       	cpi	r20, 0x01	; 1
    742e:	51 05       	cpc	r21, r1
    7430:	61 f1       	breq	.+88     	; 0x748a <GPIO_readPin+0xb0>
    7432:	a2 c0       	rjmp	.+324    	; 0x7578 <GPIO_readPin+0x19e>
    7434:	8c 81       	ldd	r24, Y+4	; 0x04
    7436:	9d 81       	ldd	r25, Y+5	; 0x05
    7438:	84 30       	cpi	r24, 0x04	; 4
    743a:	91 05       	cpc	r25, r1
    743c:	09 f4       	brne	.+2      	; 0x7440 <GPIO_readPin+0x66>
    743e:	6d c0       	rjmp	.+218    	; 0x751a <GPIO_readPin+0x140>
    7440:	2c 81       	ldd	r18, Y+4	; 0x04
    7442:	3d 81       	ldd	r19, Y+5	; 0x05
    7444:	24 30       	cpi	r18, 0x04	; 4
    7446:	31 05       	cpc	r19, r1
    7448:	0c f4       	brge	.+2      	; 0x744c <GPIO_readPin+0x72>
    744a:	4f c0       	rjmp	.+158    	; 0x74ea <GPIO_readPin+0x110>
    744c:	4c 81       	ldd	r20, Y+4	; 0x04
    744e:	5d 81       	ldd	r21, Y+5	; 0x05
    7450:	45 30       	cpi	r20, 0x05	; 5
    7452:	51 05       	cpc	r21, r1
    7454:	09 f4       	brne	.+2      	; 0x7458 <GPIO_readPin+0x7e>
    7456:	79 c0       	rjmp	.+242    	; 0x754a <GPIO_readPin+0x170>
    7458:	8f c0       	rjmp	.+286    	; 0x7578 <GPIO_readPin+0x19e>
		{
		case PORTA_ID:
			if(BIT_IS_SET(PINA,pin_num))
    745a:	e9 e3       	ldi	r30, 0x39	; 57
    745c:	f0 e0       	ldi	r31, 0x00	; 0
    745e:	80 81       	ld	r24, Z
    7460:	28 2f       	mov	r18, r24
    7462:	30 e0       	ldi	r19, 0x00	; 0
    7464:	8b 81       	ldd	r24, Y+3	; 0x03
    7466:	88 2f       	mov	r24, r24
    7468:	90 e0       	ldi	r25, 0x00	; 0
    746a:	a9 01       	movw	r20, r18
    746c:	02 c0       	rjmp	.+4      	; 0x7472 <GPIO_readPin+0x98>
    746e:	55 95       	asr	r21
    7470:	47 95       	ror	r20
    7472:	8a 95       	dec	r24
    7474:	e2 f7       	brpl	.-8      	; 0x746e <GPIO_readPin+0x94>
    7476:	ca 01       	movw	r24, r20
    7478:	81 70       	andi	r24, 0x01	; 1
    747a:	90 70       	andi	r25, 0x00	; 0
    747c:	88 23       	and	r24, r24
    747e:	19 f0       	breq	.+6      	; 0x7486 <GPIO_readPin+0xac>
			{
				pin_value = LOGIC_HIGH;
    7480:	81 e0       	ldi	r24, 0x01	; 1
    7482:	89 83       	std	Y+1, r24	; 0x01
    7484:	79 c0       	rjmp	.+242    	; 0x7578 <GPIO_readPin+0x19e>
			}
			else
			{
				pin_value = LOGIC_LOW;
    7486:	19 82       	std	Y+1, r1	; 0x01
    7488:	77 c0       	rjmp	.+238    	; 0x7578 <GPIO_readPin+0x19e>
			}
			break;
		case PORTB_ID:
			if(BIT_IS_SET(PINB,pin_num))
    748a:	e6 e3       	ldi	r30, 0x36	; 54
    748c:	f0 e0       	ldi	r31, 0x00	; 0
    748e:	80 81       	ld	r24, Z
    7490:	28 2f       	mov	r18, r24
    7492:	30 e0       	ldi	r19, 0x00	; 0
    7494:	8b 81       	ldd	r24, Y+3	; 0x03
    7496:	88 2f       	mov	r24, r24
    7498:	90 e0       	ldi	r25, 0x00	; 0
    749a:	a9 01       	movw	r20, r18
    749c:	02 c0       	rjmp	.+4      	; 0x74a2 <GPIO_readPin+0xc8>
    749e:	55 95       	asr	r21
    74a0:	47 95       	ror	r20
    74a2:	8a 95       	dec	r24
    74a4:	e2 f7       	brpl	.-8      	; 0x749e <GPIO_readPin+0xc4>
    74a6:	ca 01       	movw	r24, r20
    74a8:	81 70       	andi	r24, 0x01	; 1
    74aa:	90 70       	andi	r25, 0x00	; 0
    74ac:	88 23       	and	r24, r24
    74ae:	19 f0       	breq	.+6      	; 0x74b6 <GPIO_readPin+0xdc>
			{
				pin_value = LOGIC_HIGH;
    74b0:	81 e0       	ldi	r24, 0x01	; 1
    74b2:	89 83       	std	Y+1, r24	; 0x01
    74b4:	61 c0       	rjmp	.+194    	; 0x7578 <GPIO_readPin+0x19e>
			}
			else
			{
				pin_value = LOGIC_LOW;
    74b6:	19 82       	std	Y+1, r1	; 0x01
    74b8:	5f c0       	rjmp	.+190    	; 0x7578 <GPIO_readPin+0x19e>
			}
			break;
		case PORTC_ID:
			if(BIT_IS_SET(PINC,pin_num))
    74ba:	e3 e3       	ldi	r30, 0x33	; 51
    74bc:	f0 e0       	ldi	r31, 0x00	; 0
    74be:	80 81       	ld	r24, Z
    74c0:	28 2f       	mov	r18, r24
    74c2:	30 e0       	ldi	r19, 0x00	; 0
    74c4:	8b 81       	ldd	r24, Y+3	; 0x03
    74c6:	88 2f       	mov	r24, r24
    74c8:	90 e0       	ldi	r25, 0x00	; 0
    74ca:	a9 01       	movw	r20, r18
    74cc:	02 c0       	rjmp	.+4      	; 0x74d2 <GPIO_readPin+0xf8>
    74ce:	55 95       	asr	r21
    74d0:	47 95       	ror	r20
    74d2:	8a 95       	dec	r24
    74d4:	e2 f7       	brpl	.-8      	; 0x74ce <GPIO_readPin+0xf4>
    74d6:	ca 01       	movw	r24, r20
    74d8:	81 70       	andi	r24, 0x01	; 1
    74da:	90 70       	andi	r25, 0x00	; 0
    74dc:	88 23       	and	r24, r24
    74de:	19 f0       	breq	.+6      	; 0x74e6 <GPIO_readPin+0x10c>
			{
				pin_value = LOGIC_HIGH;
    74e0:	81 e0       	ldi	r24, 0x01	; 1
    74e2:	89 83       	std	Y+1, r24	; 0x01
    74e4:	49 c0       	rjmp	.+146    	; 0x7578 <GPIO_readPin+0x19e>
			}
			else
			{
				pin_value = LOGIC_LOW;
    74e6:	19 82       	std	Y+1, r1	; 0x01
    74e8:	47 c0       	rjmp	.+142    	; 0x7578 <GPIO_readPin+0x19e>
			}
			break;
		case PORTD_ID:
			if(BIT_IS_SET(PIND,pin_num))
    74ea:	e0 e3       	ldi	r30, 0x30	; 48
    74ec:	f0 e0       	ldi	r31, 0x00	; 0
    74ee:	80 81       	ld	r24, Z
    74f0:	28 2f       	mov	r18, r24
    74f2:	30 e0       	ldi	r19, 0x00	; 0
    74f4:	8b 81       	ldd	r24, Y+3	; 0x03
    74f6:	88 2f       	mov	r24, r24
    74f8:	90 e0       	ldi	r25, 0x00	; 0
    74fa:	a9 01       	movw	r20, r18
    74fc:	02 c0       	rjmp	.+4      	; 0x7502 <GPIO_readPin+0x128>
    74fe:	55 95       	asr	r21
    7500:	47 95       	ror	r20
    7502:	8a 95       	dec	r24
    7504:	e2 f7       	brpl	.-8      	; 0x74fe <GPIO_readPin+0x124>
    7506:	ca 01       	movw	r24, r20
    7508:	81 70       	andi	r24, 0x01	; 1
    750a:	90 70       	andi	r25, 0x00	; 0
    750c:	88 23       	and	r24, r24
    750e:	19 f0       	breq	.+6      	; 0x7516 <GPIO_readPin+0x13c>
			{
				pin_value = LOGIC_HIGH;
    7510:	81 e0       	ldi	r24, 0x01	; 1
    7512:	89 83       	std	Y+1, r24	; 0x01
    7514:	31 c0       	rjmp	.+98     	; 0x7578 <GPIO_readPin+0x19e>
			}
			else
			{
				pin_value = LOGIC_LOW;
    7516:	19 82       	std	Y+1, r1	; 0x01
    7518:	2f c0       	rjmp	.+94     	; 0x7578 <GPIO_readPin+0x19e>
			}
			break;
		case PORTE_ID:
			if(BIT_IS_SET(PINE,pin_num))
    751a:	e1 e2       	ldi	r30, 0x21	; 33
    751c:	f0 e0       	ldi	r31, 0x00	; 0
    751e:	80 81       	ld	r24, Z
    7520:	28 2f       	mov	r18, r24
    7522:	30 e0       	ldi	r19, 0x00	; 0
    7524:	8b 81       	ldd	r24, Y+3	; 0x03
    7526:	88 2f       	mov	r24, r24
    7528:	90 e0       	ldi	r25, 0x00	; 0
    752a:	a9 01       	movw	r20, r18
    752c:	02 c0       	rjmp	.+4      	; 0x7532 <GPIO_readPin+0x158>
    752e:	55 95       	asr	r21
    7530:	47 95       	ror	r20
    7532:	8a 95       	dec	r24
    7534:	e2 f7       	brpl	.-8      	; 0x752e <GPIO_readPin+0x154>
    7536:	ca 01       	movw	r24, r20
    7538:	81 70       	andi	r24, 0x01	; 1
    753a:	90 70       	andi	r25, 0x00	; 0
    753c:	88 23       	and	r24, r24
    753e:	19 f0       	breq	.+6      	; 0x7546 <GPIO_readPin+0x16c>
			{
				pin_value = LOGIC_HIGH;
    7540:	81 e0       	ldi	r24, 0x01	; 1
    7542:	89 83       	std	Y+1, r24	; 0x01
    7544:	19 c0       	rjmp	.+50     	; 0x7578 <GPIO_readPin+0x19e>
			}
			else
			{
				pin_value = LOGIC_LOW;
    7546:	19 82       	std	Y+1, r1	; 0x01
    7548:	17 c0       	rjmp	.+46     	; 0x7578 <GPIO_readPin+0x19e>
			}
			break;
		case PORTF_ID:
			if(BIT_IS_SET(PINF,pin_num))
    754a:	e0 e2       	ldi	r30, 0x20	; 32
    754c:	f0 e0       	ldi	r31, 0x00	; 0
    754e:	80 81       	ld	r24, Z
    7550:	28 2f       	mov	r18, r24
    7552:	30 e0       	ldi	r19, 0x00	; 0
    7554:	8b 81       	ldd	r24, Y+3	; 0x03
    7556:	88 2f       	mov	r24, r24
    7558:	90 e0       	ldi	r25, 0x00	; 0
    755a:	a9 01       	movw	r20, r18
    755c:	02 c0       	rjmp	.+4      	; 0x7562 <GPIO_readPin+0x188>
    755e:	55 95       	asr	r21
    7560:	47 95       	ror	r20
    7562:	8a 95       	dec	r24
    7564:	e2 f7       	brpl	.-8      	; 0x755e <GPIO_readPin+0x184>
    7566:	ca 01       	movw	r24, r20
    7568:	81 70       	andi	r24, 0x01	; 1
    756a:	90 70       	andi	r25, 0x00	; 0
    756c:	88 23       	and	r24, r24
    756e:	19 f0       	breq	.+6      	; 0x7576 <GPIO_readPin+0x19c>
			{
				pin_value = LOGIC_HIGH;
    7570:	81 e0       	ldi	r24, 0x01	; 1
    7572:	89 83       	std	Y+1, r24	; 0x01
    7574:	01 c0       	rjmp	.+2      	; 0x7578 <GPIO_readPin+0x19e>
			}
			else
			{
				pin_value = LOGIC_LOW;
    7576:	19 82       	std	Y+1, r1	; 0x01
			}
			break;
		}
	}

	return pin_value;
    7578:	89 81       	ldd	r24, Y+1	; 0x01
}
    757a:	0f 90       	pop	r0
    757c:	0f 90       	pop	r0
    757e:	0f 90       	pop	r0
    7580:	0f 90       	pop	r0
    7582:	0f 90       	pop	r0
    7584:	cf 91       	pop	r28
    7586:	df 91       	pop	r29
    7588:	08 95       	ret

0000758a <GPIO_setupPortDirection>:
 * If the direction value is PORT_INPUT all pins in this port should be input pins.
 * If the direction value is PORT_OUTPUT all pins in this port should be output pins.
 * If the input port number is not correct, The function will not handle the request.
 */
void GPIO_setupPortDirection(uint8 port_num, GPIO_PortDirectionType direction)
{
    758a:	df 93       	push	r29
    758c:	cf 93       	push	r28
    758e:	00 d0       	rcall	.+0      	; 0x7590 <GPIO_setupPortDirection+0x6>
    7590:	00 d0       	rcall	.+0      	; 0x7592 <GPIO_setupPortDirection+0x8>
    7592:	cd b7       	in	r28, 0x3d	; 61
    7594:	de b7       	in	r29, 0x3e	; 62
    7596:	89 83       	std	Y+1, r24	; 0x01
    7598:	6a 83       	std	Y+2, r22	; 0x02
	/*
	 * Check if the input number is greater than NUM_OF_PORTS value.
	 * In this case the input is not valid port number
	 */
	if(port_num >= NUM_OF_PORTS)
    759a:	89 81       	ldd	r24, Y+1	; 0x01
    759c:	86 30       	cpi	r24, 0x06	; 6
    759e:	08 f0       	brcs	.+2      	; 0x75a2 <GPIO_setupPortDirection+0x18>
    75a0:	46 c0       	rjmp	.+140    	; 0x762e <GPIO_setupPortDirection+0xa4>
		/* Do Nothing */
	}
	else
	{
		/* Setup the port direction as required */
		switch(port_num)
    75a2:	89 81       	ldd	r24, Y+1	; 0x01
    75a4:	28 2f       	mov	r18, r24
    75a6:	30 e0       	ldi	r19, 0x00	; 0
    75a8:	3c 83       	std	Y+4, r19	; 0x04
    75aa:	2b 83       	std	Y+3, r18	; 0x03
    75ac:	8b 81       	ldd	r24, Y+3	; 0x03
    75ae:	9c 81       	ldd	r25, Y+4	; 0x04
    75b0:	82 30       	cpi	r24, 0x02	; 2
    75b2:	91 05       	cpc	r25, r1
    75b4:	49 f1       	breq	.+82     	; 0x7608 <GPIO_setupPortDirection+0x7e>
    75b6:	2b 81       	ldd	r18, Y+3	; 0x03
    75b8:	3c 81       	ldd	r19, Y+4	; 0x04
    75ba:	23 30       	cpi	r18, 0x03	; 3
    75bc:	31 05       	cpc	r19, r1
    75be:	54 f4       	brge	.+20     	; 0x75d4 <GPIO_setupPortDirection+0x4a>
    75c0:	8b 81       	ldd	r24, Y+3	; 0x03
    75c2:	9c 81       	ldd	r25, Y+4	; 0x04
    75c4:	00 97       	sbiw	r24, 0x00	; 0
    75c6:	b1 f0       	breq	.+44     	; 0x75f4 <GPIO_setupPortDirection+0x6a>
    75c8:	2b 81       	ldd	r18, Y+3	; 0x03
    75ca:	3c 81       	ldd	r19, Y+4	; 0x04
    75cc:	21 30       	cpi	r18, 0x01	; 1
    75ce:	31 05       	cpc	r19, r1
    75d0:	b1 f0       	breq	.+44     	; 0x75fe <GPIO_setupPortDirection+0x74>
    75d2:	2d c0       	rjmp	.+90     	; 0x762e <GPIO_setupPortDirection+0xa4>
    75d4:	8b 81       	ldd	r24, Y+3	; 0x03
    75d6:	9c 81       	ldd	r25, Y+4	; 0x04
    75d8:	84 30       	cpi	r24, 0x04	; 4
    75da:	91 05       	cpc	r25, r1
    75dc:	f9 f0       	breq	.+62     	; 0x761c <GPIO_setupPortDirection+0x92>
    75de:	2b 81       	ldd	r18, Y+3	; 0x03
    75e0:	3c 81       	ldd	r19, Y+4	; 0x04
    75e2:	24 30       	cpi	r18, 0x04	; 4
    75e4:	31 05       	cpc	r19, r1
    75e6:	ac f0       	brlt	.+42     	; 0x7612 <GPIO_setupPortDirection+0x88>
    75e8:	8b 81       	ldd	r24, Y+3	; 0x03
    75ea:	9c 81       	ldd	r25, Y+4	; 0x04
    75ec:	85 30       	cpi	r24, 0x05	; 5
    75ee:	91 05       	cpc	r25, r1
    75f0:	d1 f0       	breq	.+52     	; 0x7626 <GPIO_setupPortDirection+0x9c>
    75f2:	1d c0       	rjmp	.+58     	; 0x762e <GPIO_setupPortDirection+0xa4>
		{
		case PORTA_ID:
			DDRA = direction;
    75f4:	ea e3       	ldi	r30, 0x3A	; 58
    75f6:	f0 e0       	ldi	r31, 0x00	; 0
    75f8:	8a 81       	ldd	r24, Y+2	; 0x02
    75fa:	80 83       	st	Z, r24
    75fc:	18 c0       	rjmp	.+48     	; 0x762e <GPIO_setupPortDirection+0xa4>
			break;
		case PORTB_ID:
			DDRB = direction;
    75fe:	e7 e3       	ldi	r30, 0x37	; 55
    7600:	f0 e0       	ldi	r31, 0x00	; 0
    7602:	8a 81       	ldd	r24, Y+2	; 0x02
    7604:	80 83       	st	Z, r24
    7606:	13 c0       	rjmp	.+38     	; 0x762e <GPIO_setupPortDirection+0xa4>
			break;
		case PORTC_ID:
			DDRC = direction;
    7608:	e4 e3       	ldi	r30, 0x34	; 52
    760a:	f0 e0       	ldi	r31, 0x00	; 0
    760c:	8a 81       	ldd	r24, Y+2	; 0x02
    760e:	80 83       	st	Z, r24
    7610:	0e c0       	rjmp	.+28     	; 0x762e <GPIO_setupPortDirection+0xa4>
			break;
		case PORTD_ID:
			DDRD = direction;
    7612:	e1 e3       	ldi	r30, 0x31	; 49
    7614:	f0 e0       	ldi	r31, 0x00	; 0
    7616:	8a 81       	ldd	r24, Y+2	; 0x02
    7618:	80 83       	st	Z, r24
    761a:	09 c0       	rjmp	.+18     	; 0x762e <GPIO_setupPortDirection+0xa4>
			break;
		case PORTE_ID:
			DDRE = direction;
    761c:	e2 e2       	ldi	r30, 0x22	; 34
    761e:	f0 e0       	ldi	r31, 0x00	; 0
    7620:	8a 81       	ldd	r24, Y+2	; 0x02
    7622:	80 83       	st	Z, r24
    7624:	04 c0       	rjmp	.+8      	; 0x762e <GPIO_setupPortDirection+0xa4>
			break;
		case PORTF_ID:
			DDRF = direction;
    7626:	e1 e6       	ldi	r30, 0x61	; 97
    7628:	f0 e0       	ldi	r31, 0x00	; 0
    762a:	8a 81       	ldd	r24, Y+2	; 0x02
    762c:	80 83       	st	Z, r24
			break;
		}
	}
}
    762e:	0f 90       	pop	r0
    7630:	0f 90       	pop	r0
    7632:	0f 90       	pop	r0
    7634:	0f 90       	pop	r0
    7636:	cf 91       	pop	r28
    7638:	df 91       	pop	r29
    763a:	08 95       	ret

0000763c <GPIO_writePort>:
 * If any pin in the port is output pin the value will be written.
 * If any pin in the port is input pin this will activate/deactivate the internal pull-up resistor.
 * If the input port number is not correct, The function will not handle the request.
 */
void GPIO_writePort(uint8 port_num, uint8 value)
{
    763c:	df 93       	push	r29
    763e:	cf 93       	push	r28
    7640:	00 d0       	rcall	.+0      	; 0x7642 <GPIO_writePort+0x6>
    7642:	00 d0       	rcall	.+0      	; 0x7644 <GPIO_writePort+0x8>
    7644:	cd b7       	in	r28, 0x3d	; 61
    7646:	de b7       	in	r29, 0x3e	; 62
    7648:	89 83       	std	Y+1, r24	; 0x01
    764a:	6a 83       	std	Y+2, r22	; 0x02
	/*
	 * Check if the input number is greater than NUM_OF_PORTS value.
	 * In this case the input is not valid port number
	 */
	if(port_num >= NUM_OF_PORTS)
    764c:	89 81       	ldd	r24, Y+1	; 0x01
    764e:	86 30       	cpi	r24, 0x06	; 6
    7650:	08 f0       	brcs	.+2      	; 0x7654 <GPIO_writePort+0x18>
    7652:	46 c0       	rjmp	.+140    	; 0x76e0 <GPIO_writePort+0xa4>
		/* Do Nothing */
	}
	else
	{
		/* Write the port value as required */
		switch(port_num)
    7654:	89 81       	ldd	r24, Y+1	; 0x01
    7656:	28 2f       	mov	r18, r24
    7658:	30 e0       	ldi	r19, 0x00	; 0
    765a:	3c 83       	std	Y+4, r19	; 0x04
    765c:	2b 83       	std	Y+3, r18	; 0x03
    765e:	8b 81       	ldd	r24, Y+3	; 0x03
    7660:	9c 81       	ldd	r25, Y+4	; 0x04
    7662:	82 30       	cpi	r24, 0x02	; 2
    7664:	91 05       	cpc	r25, r1
    7666:	49 f1       	breq	.+82     	; 0x76ba <GPIO_writePort+0x7e>
    7668:	2b 81       	ldd	r18, Y+3	; 0x03
    766a:	3c 81       	ldd	r19, Y+4	; 0x04
    766c:	23 30       	cpi	r18, 0x03	; 3
    766e:	31 05       	cpc	r19, r1
    7670:	54 f4       	brge	.+20     	; 0x7686 <GPIO_writePort+0x4a>
    7672:	8b 81       	ldd	r24, Y+3	; 0x03
    7674:	9c 81       	ldd	r25, Y+4	; 0x04
    7676:	00 97       	sbiw	r24, 0x00	; 0
    7678:	b1 f0       	breq	.+44     	; 0x76a6 <GPIO_writePort+0x6a>
    767a:	2b 81       	ldd	r18, Y+3	; 0x03
    767c:	3c 81       	ldd	r19, Y+4	; 0x04
    767e:	21 30       	cpi	r18, 0x01	; 1
    7680:	31 05       	cpc	r19, r1
    7682:	b1 f0       	breq	.+44     	; 0x76b0 <GPIO_writePort+0x74>
    7684:	2d c0       	rjmp	.+90     	; 0x76e0 <GPIO_writePort+0xa4>
    7686:	8b 81       	ldd	r24, Y+3	; 0x03
    7688:	9c 81       	ldd	r25, Y+4	; 0x04
    768a:	84 30       	cpi	r24, 0x04	; 4
    768c:	91 05       	cpc	r25, r1
    768e:	f9 f0       	breq	.+62     	; 0x76ce <GPIO_writePort+0x92>
    7690:	2b 81       	ldd	r18, Y+3	; 0x03
    7692:	3c 81       	ldd	r19, Y+4	; 0x04
    7694:	24 30       	cpi	r18, 0x04	; 4
    7696:	31 05       	cpc	r19, r1
    7698:	ac f0       	brlt	.+42     	; 0x76c4 <GPIO_writePort+0x88>
    769a:	8b 81       	ldd	r24, Y+3	; 0x03
    769c:	9c 81       	ldd	r25, Y+4	; 0x04
    769e:	85 30       	cpi	r24, 0x05	; 5
    76a0:	91 05       	cpc	r25, r1
    76a2:	d1 f0       	breq	.+52     	; 0x76d8 <GPIO_writePort+0x9c>
    76a4:	1d c0       	rjmp	.+58     	; 0x76e0 <GPIO_writePort+0xa4>
		{
		case PORTA_ID:
			PORTA = value;
    76a6:	eb e3       	ldi	r30, 0x3B	; 59
    76a8:	f0 e0       	ldi	r31, 0x00	; 0
    76aa:	8a 81       	ldd	r24, Y+2	; 0x02
    76ac:	80 83       	st	Z, r24
    76ae:	18 c0       	rjmp	.+48     	; 0x76e0 <GPIO_writePort+0xa4>
			break;
		case PORTB_ID:
			PORTB = value;
    76b0:	e8 e3       	ldi	r30, 0x38	; 56
    76b2:	f0 e0       	ldi	r31, 0x00	; 0
    76b4:	8a 81       	ldd	r24, Y+2	; 0x02
    76b6:	80 83       	st	Z, r24
    76b8:	13 c0       	rjmp	.+38     	; 0x76e0 <GPIO_writePort+0xa4>
			break;
		case PORTC_ID:
			PORTC = value;
    76ba:	e5 e3       	ldi	r30, 0x35	; 53
    76bc:	f0 e0       	ldi	r31, 0x00	; 0
    76be:	8a 81       	ldd	r24, Y+2	; 0x02
    76c0:	80 83       	st	Z, r24
    76c2:	0e c0       	rjmp	.+28     	; 0x76e0 <GPIO_writePort+0xa4>
			break;
		case PORTD_ID:
			PORTD = value;
    76c4:	e2 e3       	ldi	r30, 0x32	; 50
    76c6:	f0 e0       	ldi	r31, 0x00	; 0
    76c8:	8a 81       	ldd	r24, Y+2	; 0x02
    76ca:	80 83       	st	Z, r24
    76cc:	09 c0       	rjmp	.+18     	; 0x76e0 <GPIO_writePort+0xa4>
			break;
		case PORTE_ID:
			PORTE = value;
    76ce:	e3 e2       	ldi	r30, 0x23	; 35
    76d0:	f0 e0       	ldi	r31, 0x00	; 0
    76d2:	8a 81       	ldd	r24, Y+2	; 0x02
    76d4:	80 83       	st	Z, r24
    76d6:	04 c0       	rjmp	.+8      	; 0x76e0 <GPIO_writePort+0xa4>
			break;
		case PORTF_ID:
			PORTF = value;
    76d8:	e2 e6       	ldi	r30, 0x62	; 98
    76da:	f0 e0       	ldi	r31, 0x00	; 0
    76dc:	8a 81       	ldd	r24, Y+2	; 0x02
    76de:	80 83       	st	Z, r24
			break;
		}
	}
}
    76e0:	0f 90       	pop	r0
    76e2:	0f 90       	pop	r0
    76e4:	0f 90       	pop	r0
    76e6:	0f 90       	pop	r0
    76e8:	cf 91       	pop	r28
    76ea:	df 91       	pop	r29
    76ec:	08 95       	ret

000076ee <GPIO_readPort>:
 * Description :
 * Read and return the value of the required port.
 * If the input port number is not correct, The function will return ZERO value.
 */
uint8 GPIO_readPort(uint8 port_num)
{
    76ee:	df 93       	push	r29
    76f0:	cf 93       	push	r28
    76f2:	00 d0       	rcall	.+0      	; 0x76f4 <GPIO_readPort+0x6>
    76f4:	00 d0       	rcall	.+0      	; 0x76f6 <GPIO_readPort+0x8>
    76f6:	cd b7       	in	r28, 0x3d	; 61
    76f8:	de b7       	in	r29, 0x3e	; 62
    76fa:	8a 83       	std	Y+2, r24	; 0x02
	uint8 value = LOGIC_LOW;
    76fc:	19 82       	std	Y+1, r1	; 0x01

	/*
	 * Check if the input number is greater than NUM_OF_PORTS value.
	 * In this case the input is not valid port number
	 */
	if(port_num >= NUM_OF_PORTS)
    76fe:	8a 81       	ldd	r24, Y+2	; 0x02
    7700:	86 30       	cpi	r24, 0x06	; 6
    7702:	08 f0       	brcs	.+2      	; 0x7706 <GPIO_readPort+0x18>
    7704:	46 c0       	rjmp	.+140    	; 0x7792 <GPIO_readPort+0xa4>
		/* Do Nothing */
	}
	else
	{
		/* Read the port value as required */
		switch(port_num)
    7706:	8a 81       	ldd	r24, Y+2	; 0x02
    7708:	28 2f       	mov	r18, r24
    770a:	30 e0       	ldi	r19, 0x00	; 0
    770c:	3c 83       	std	Y+4, r19	; 0x04
    770e:	2b 83       	std	Y+3, r18	; 0x03
    7710:	8b 81       	ldd	r24, Y+3	; 0x03
    7712:	9c 81       	ldd	r25, Y+4	; 0x04
    7714:	82 30       	cpi	r24, 0x02	; 2
    7716:	91 05       	cpc	r25, r1
    7718:	49 f1       	breq	.+82     	; 0x776c <GPIO_readPort+0x7e>
    771a:	2b 81       	ldd	r18, Y+3	; 0x03
    771c:	3c 81       	ldd	r19, Y+4	; 0x04
    771e:	23 30       	cpi	r18, 0x03	; 3
    7720:	31 05       	cpc	r19, r1
    7722:	54 f4       	brge	.+20     	; 0x7738 <GPIO_readPort+0x4a>
    7724:	8b 81       	ldd	r24, Y+3	; 0x03
    7726:	9c 81       	ldd	r25, Y+4	; 0x04
    7728:	00 97       	sbiw	r24, 0x00	; 0
    772a:	b1 f0       	breq	.+44     	; 0x7758 <GPIO_readPort+0x6a>
    772c:	2b 81       	ldd	r18, Y+3	; 0x03
    772e:	3c 81       	ldd	r19, Y+4	; 0x04
    7730:	21 30       	cpi	r18, 0x01	; 1
    7732:	31 05       	cpc	r19, r1
    7734:	b1 f0       	breq	.+44     	; 0x7762 <GPIO_readPort+0x74>
    7736:	2d c0       	rjmp	.+90     	; 0x7792 <GPIO_readPort+0xa4>
    7738:	8b 81       	ldd	r24, Y+3	; 0x03
    773a:	9c 81       	ldd	r25, Y+4	; 0x04
    773c:	84 30       	cpi	r24, 0x04	; 4
    773e:	91 05       	cpc	r25, r1
    7740:	f9 f0       	breq	.+62     	; 0x7780 <GPIO_readPort+0x92>
    7742:	2b 81       	ldd	r18, Y+3	; 0x03
    7744:	3c 81       	ldd	r19, Y+4	; 0x04
    7746:	24 30       	cpi	r18, 0x04	; 4
    7748:	31 05       	cpc	r19, r1
    774a:	ac f0       	brlt	.+42     	; 0x7776 <GPIO_readPort+0x88>
    774c:	8b 81       	ldd	r24, Y+3	; 0x03
    774e:	9c 81       	ldd	r25, Y+4	; 0x04
    7750:	85 30       	cpi	r24, 0x05	; 5
    7752:	91 05       	cpc	r25, r1
    7754:	d1 f0       	breq	.+52     	; 0x778a <GPIO_readPort+0x9c>
    7756:	1d c0       	rjmp	.+58     	; 0x7792 <GPIO_readPort+0xa4>
		{
		case PORTA_ID:
			value = PINA;
    7758:	e9 e3       	ldi	r30, 0x39	; 57
    775a:	f0 e0       	ldi	r31, 0x00	; 0
    775c:	80 81       	ld	r24, Z
    775e:	89 83       	std	Y+1, r24	; 0x01
    7760:	18 c0       	rjmp	.+48     	; 0x7792 <GPIO_readPort+0xa4>
			break;
		case PORTB_ID:
			value = PINB;
    7762:	e6 e3       	ldi	r30, 0x36	; 54
    7764:	f0 e0       	ldi	r31, 0x00	; 0
    7766:	80 81       	ld	r24, Z
    7768:	89 83       	std	Y+1, r24	; 0x01
    776a:	13 c0       	rjmp	.+38     	; 0x7792 <GPIO_readPort+0xa4>
			break;
		case PORTC_ID:
			value = PINC;
    776c:	e3 e3       	ldi	r30, 0x33	; 51
    776e:	f0 e0       	ldi	r31, 0x00	; 0
    7770:	80 81       	ld	r24, Z
    7772:	89 83       	std	Y+1, r24	; 0x01
    7774:	0e c0       	rjmp	.+28     	; 0x7792 <GPIO_readPort+0xa4>
			break;
		case PORTD_ID:
			value = PIND;
    7776:	e0 e3       	ldi	r30, 0x30	; 48
    7778:	f0 e0       	ldi	r31, 0x00	; 0
    777a:	80 81       	ld	r24, Z
    777c:	89 83       	std	Y+1, r24	; 0x01
    777e:	09 c0       	rjmp	.+18     	; 0x7792 <GPIO_readPort+0xa4>
			break;
		case PORTE_ID:
			value = PINE;
    7780:	e1 e2       	ldi	r30, 0x21	; 33
    7782:	f0 e0       	ldi	r31, 0x00	; 0
    7784:	80 81       	ld	r24, Z
    7786:	89 83       	std	Y+1, r24	; 0x01
    7788:	04 c0       	rjmp	.+8      	; 0x7792 <GPIO_readPort+0xa4>
			break;
		case PORTF_ID:
			value = PINF;
    778a:	e0 e2       	ldi	r30, 0x20	; 32
    778c:	f0 e0       	ldi	r31, 0x00	; 0
    778e:	80 81       	ld	r24, Z
    7790:	89 83       	std	Y+1, r24	; 0x01
			break;
		}
	}

	return value;
    7792:	89 81       	ldd	r24, Y+1	; 0x01
}
    7794:	0f 90       	pop	r0
    7796:	0f 90       	pop	r0
    7798:	0f 90       	pop	r0
    779a:	0f 90       	pop	r0
    779c:	cf 91       	pop	r28
    779e:	df 91       	pop	r29
    77a0:	08 95       	ret

000077a2 <DIO_init>:


void DIO_init(void)
{
    77a2:	df 93       	push	r29
    77a4:	cf 93       	push	r28
    77a6:	00 d0       	rcall	.+0      	; 0x77a8 <DIO_init+0x6>
    77a8:	00 d0       	rcall	.+0      	; 0x77aa <DIO_init+0x8>
    77aa:	cd b7       	in	r28, 0x3d	; 61
    77ac:	de b7       	in	r29, 0x3e	; 62
	uint8_t loop;
	for(loop=0u; loop < DIO_NUM_OF_CHANNELS ; loop++ ){
    77ae:	1c 82       	std	Y+4, r1	; 0x04
    77b0:	2f c0       	rjmp	.+94     	; 0x7810 <DIO_init+0x6e>
		uint8_t portid=dio_config_array[loop].port_id;
    77b2:	8c 81       	ldd	r24, Y+4	; 0x04
    77b4:	28 2f       	mov	r18, r24
    77b6:	30 e0       	ldi	r19, 0x00	; 0
    77b8:	c9 01       	movw	r24, r18
    77ba:	88 0f       	add	r24, r24
    77bc:	99 1f       	adc	r25, r25
    77be:	82 0f       	add	r24, r18
    77c0:	93 1f       	adc	r25, r19
    77c2:	fc 01       	movw	r30, r24
    77c4:	e0 5d       	subi	r30, 0xD0	; 208
    77c6:	fd 4f       	sbci	r31, 0xFD	; 253
    77c8:	80 81       	ld	r24, Z
    77ca:	8b 83       	std	Y+3, r24	; 0x03
		uint8_t pin_num=dio_config_array[loop].pin_num;
    77cc:	8c 81       	ldd	r24, Y+4	; 0x04
    77ce:	28 2f       	mov	r18, r24
    77d0:	30 e0       	ldi	r19, 0x00	; 0
    77d2:	c9 01       	movw	r24, r18
    77d4:	88 0f       	add	r24, r24
    77d6:	99 1f       	adc	r25, r25
    77d8:	82 0f       	add	r24, r18
    77da:	93 1f       	adc	r25, r19
    77dc:	fc 01       	movw	r30, r24
    77de:	ef 5c       	subi	r30, 0xCF	; 207
    77e0:	fd 4f       	sbci	r31, 0xFD	; 253
    77e2:	80 81       	ld	r24, Z
    77e4:	8a 83       	std	Y+2, r24	; 0x02
		uint8_t direction=dio_config_array[loop].direction;
    77e6:	8c 81       	ldd	r24, Y+4	; 0x04
    77e8:	28 2f       	mov	r18, r24
    77ea:	30 e0       	ldi	r19, 0x00	; 0
    77ec:	c9 01       	movw	r24, r18
    77ee:	88 0f       	add	r24, r24
    77f0:	99 1f       	adc	r25, r25
    77f2:	82 0f       	add	r24, r18
    77f4:	93 1f       	adc	r25, r19
    77f6:	fc 01       	movw	r30, r24
    77f8:	ee 5c       	subi	r30, 0xCE	; 206
    77fa:	fd 4f       	sbci	r31, 0xFD	; 253
    77fc:	80 81       	ld	r24, Z
    77fe:	89 83       	std	Y+1, r24	; 0x01
		GPIO_setupPinDirection(portid,pin_num,direction);
    7800:	8b 81       	ldd	r24, Y+3	; 0x03
    7802:	6a 81       	ldd	r22, Y+2	; 0x02
    7804:	49 81       	ldd	r20, Y+1	; 0x01
    7806:	0e 94 4f 37 	call	0x6e9e	; 0x6e9e <GPIO_setupPinDirection>


void DIO_init(void)
{
	uint8_t loop;
	for(loop=0u; loop < DIO_NUM_OF_CHANNELS ; loop++ ){
    780a:	8c 81       	ldd	r24, Y+4	; 0x04
    780c:	8f 5f       	subi	r24, 0xFF	; 255
    780e:	8c 83       	std	Y+4, r24	; 0x04
    7810:	8c 81       	ldd	r24, Y+4	; 0x04
    7812:	86 30       	cpi	r24, 0x06	; 6
    7814:	70 f2       	brcs	.-100    	; 0x77b2 <DIO_init+0x10>
		uint8_t portid=dio_config_array[loop].port_id;
		uint8_t pin_num=dio_config_array[loop].pin_num;
		uint8_t direction=dio_config_array[loop].direction;
		GPIO_setupPinDirection(portid,pin_num,direction);
	}
}
    7816:	0f 90       	pop	r0
    7818:	0f 90       	pop	r0
    781a:	0f 90       	pop	r0
    781c:	0f 90       	pop	r0
    781e:	cf 91       	pop	r28
    7820:	df 91       	pop	r29
    7822:	08 95       	ret

00007824 <DIO_ChannelGroupWrite>:


void DIO_ChannelGroupWrite(ChannelGroupType channel_group_variabe , uint8_t data)
{
    7824:	af 92       	push	r10
    7826:	cf 92       	push	r12
    7828:	df 92       	push	r13
    782a:	ef 92       	push	r14
    782c:	ff 92       	push	r15
    782e:	0f 93       	push	r16
    7830:	1f 93       	push	r17
    7832:	df 93       	push	r29
    7834:	cf 93       	push	r28
    7836:	cd b7       	in	r28, 0x3d	; 61
    7838:	de b7       	in	r29, 0x3e	; 62
    783a:	65 97       	sbiw	r28, 0x15	; 21
    783c:	0f b6       	in	r0, 0x3f	; 63
    783e:	f8 94       	cli
    7840:	de bf       	out	0x3e, r29	; 62
    7842:	0f be       	out	0x3f, r0	; 63
    7844:	cd bf       	out	0x3d, r28	; 61
    7846:	cf 82       	std	Y+7, r12	; 0x07
    7848:	d8 86       	std	Y+8, r13	; 0x08
    784a:	e9 86       	std	Y+9, r14	; 0x09
    784c:	fa 86       	std	Y+10, r15	; 0x0a
    784e:	0b 87       	std	Y+11, r16	; 0x0b
    7850:	1c 87       	std	Y+12, r17	; 0x0c
    7852:	2d 87       	std	Y+13, r18	; 0x0d
    7854:	3e 87       	std	Y+14, r19	; 0x0e
    7856:	4f 87       	std	Y+15, r20	; 0x0f
    7858:	58 8b       	std	Y+16, r21	; 0x10
    785a:	69 8b       	std	Y+17, r22	; 0x11
    785c:	7a 8b       	std	Y+18, r23	; 0x12
    785e:	8b 8b       	std	Y+19, r24	; 0x13
    7860:	9c 8b       	std	Y+20, r25	; 0x14
    7862:	ad 8a       	std	Y+21, r10	; 0x15
	uint8_t loop;
	uint8_t to=channel_group_variabe.no_of_channels;
    7864:	8f 81       	ldd	r24, Y+7	; 0x07
    7866:	98 85       	ldd	r25, Y+8	; 0x08
    7868:	8d 83       	std	Y+5, r24	; 0x05

	for(loop=0u; loop <to ; loop++ ){
    786a:	1e 82       	std	Y+6, r1	; 0x06
    786c:	4c c0       	rjmp	.+152    	; 0x7906 <DIO_ChannelGroupWrite+0xe2>
		uint8_t channel_id=channel_group_variabe.group_ids[loop];
    786e:	8e 81       	ldd	r24, Y+6	; 0x06
    7870:	88 2f       	mov	r24, r24
    7872:	90 e0       	ldi	r25, 0x00	; 0
    7874:	01 96       	adiw	r24, 0x01	; 1
    7876:	9c 01       	movw	r18, r24
    7878:	22 0f       	add	r18, r18
    787a:	33 1f       	adc	r19, r19
    787c:	ce 01       	movw	r24, r28
    787e:	01 96       	adiw	r24, 0x01	; 1
    7880:	82 0f       	add	r24, r18
    7882:	93 1f       	adc	r25, r19
    7884:	fc 01       	movw	r30, r24
    7886:	36 96       	adiw	r30, 0x06	; 6
    7888:	80 81       	ld	r24, Z
    788a:	91 81       	ldd	r25, Z+1	; 0x01
    788c:	8c 83       	std	Y+4, r24	; 0x04
		uint8_t portid=dio_config_array[channel_id].port_id;
    788e:	8c 81       	ldd	r24, Y+4	; 0x04
    7890:	28 2f       	mov	r18, r24
    7892:	30 e0       	ldi	r19, 0x00	; 0
    7894:	c9 01       	movw	r24, r18
    7896:	88 0f       	add	r24, r24
    7898:	99 1f       	adc	r25, r25
    789a:	82 0f       	add	r24, r18
    789c:	93 1f       	adc	r25, r19
    789e:	fc 01       	movw	r30, r24
    78a0:	e0 5d       	subi	r30, 0xD0	; 208
    78a2:	fd 4f       	sbci	r31, 0xFD	; 253
    78a4:	80 81       	ld	r24, Z
    78a6:	8b 83       	std	Y+3, r24	; 0x03
		uint8_t pin_num=dio_config_array[channel_id].pin_num;
    78a8:	8c 81       	ldd	r24, Y+4	; 0x04
    78aa:	28 2f       	mov	r18, r24
    78ac:	30 e0       	ldi	r19, 0x00	; 0
    78ae:	c9 01       	movw	r24, r18
    78b0:	88 0f       	add	r24, r24
    78b2:	99 1f       	adc	r25, r25
    78b4:	82 0f       	add	r24, r18
    78b6:	93 1f       	adc	r25, r19
    78b8:	fc 01       	movw	r30, r24
    78ba:	ef 5c       	subi	r30, 0xCF	; 207
    78bc:	fd 4f       	sbci	r31, 0xFD	; 253
    78be:	80 81       	ld	r24, Z
    78c0:	8a 83       	std	Y+2, r24	; 0x02
		uint8_t bit_data=READ_BIT(data,loop);
    78c2:	8e 81       	ldd	r24, Y+6	; 0x06
    78c4:	28 2f       	mov	r18, r24
    78c6:	30 e0       	ldi	r19, 0x00	; 0
    78c8:	81 e0       	ldi	r24, 0x01	; 1
    78ca:	90 e0       	ldi	r25, 0x00	; 0
    78cc:	02 c0       	rjmp	.+4      	; 0x78d2 <DIO_ChannelGroupWrite+0xae>
    78ce:	88 0f       	add	r24, r24
    78d0:	99 1f       	adc	r25, r25
    78d2:	2a 95       	dec	r18
    78d4:	e2 f7       	brpl	.-8      	; 0x78ce <DIO_ChannelGroupWrite+0xaa>
    78d6:	98 2f       	mov	r25, r24
    78d8:	8d 89       	ldd	r24, Y+21	; 0x15
    78da:	89 23       	and	r24, r25
    78dc:	28 2f       	mov	r18, r24
    78de:	30 e0       	ldi	r19, 0x00	; 0
    78e0:	8e 81       	ldd	r24, Y+6	; 0x06
    78e2:	88 2f       	mov	r24, r24
    78e4:	90 e0       	ldi	r25, 0x00	; 0
    78e6:	a9 01       	movw	r20, r18
    78e8:	02 c0       	rjmp	.+4      	; 0x78ee <DIO_ChannelGroupWrite+0xca>
    78ea:	55 95       	asr	r21
    78ec:	47 95       	ror	r20
    78ee:	8a 95       	dec	r24
    78f0:	e2 f7       	brpl	.-8      	; 0x78ea <DIO_ChannelGroupWrite+0xc6>
    78f2:	ca 01       	movw	r24, r20
    78f4:	89 83       	std	Y+1, r24	; 0x01
		GPIO_writePin(portid,pin_num,bit_data);
    78f6:	8b 81       	ldd	r24, Y+3	; 0x03
    78f8:	6a 81       	ldd	r22, Y+2	; 0x02
    78fa:	49 81       	ldd	r20, Y+1	; 0x01
    78fc:	0e 94 9e 38 	call	0x713c	; 0x713c <GPIO_writePin>
void DIO_ChannelGroupWrite(ChannelGroupType channel_group_variabe , uint8_t data)
{
	uint8_t loop;
	uint8_t to=channel_group_variabe.no_of_channels;

	for(loop=0u; loop <to ; loop++ ){
    7900:	8e 81       	ldd	r24, Y+6	; 0x06
    7902:	8f 5f       	subi	r24, 0xFF	; 255
    7904:	8e 83       	std	Y+6, r24	; 0x06
    7906:	9e 81       	ldd	r25, Y+6	; 0x06
    7908:	8d 81       	ldd	r24, Y+5	; 0x05
    790a:	98 17       	cp	r25, r24
    790c:	08 f4       	brcc	.+2      	; 0x7910 <DIO_ChannelGroupWrite+0xec>
    790e:	af cf       	rjmp	.-162    	; 0x786e <DIO_ChannelGroupWrite+0x4a>
		GPIO_writePin(portid,pin_num,bit_data);

	}


}
    7910:	65 96       	adiw	r28, 0x15	; 21
    7912:	0f b6       	in	r0, 0x3f	; 63
    7914:	f8 94       	cli
    7916:	de bf       	out	0x3e, r29	; 62
    7918:	0f be       	out	0x3f, r0	; 63
    791a:	cd bf       	out	0x3d, r28	; 61
    791c:	cf 91       	pop	r28
    791e:	df 91       	pop	r29
    7920:	1f 91       	pop	r17
    7922:	0f 91       	pop	r16
    7924:	ff 90       	pop	r15
    7926:	ef 90       	pop	r14
    7928:	df 90       	pop	r13
    792a:	cf 90       	pop	r12
    792c:	af 90       	pop	r10
    792e:	08 95       	ret

00007930 <DIO_ChannelGroupRead>:


void DIO_ChannelGroupRead(ChannelGroupType channel_group_variabe ,uint8_t * data_ptr)
{
    7930:	af 92       	push	r10
    7932:	bf 92       	push	r11
    7934:	cf 92       	push	r12
    7936:	df 92       	push	r13
    7938:	ef 92       	push	r14
    793a:	ff 92       	push	r15
    793c:	0f 93       	push	r16
    793e:	1f 93       	push	r17
    7940:	df 93       	push	r29
    7942:	cf 93       	push	r28
    7944:	cd b7       	in	r28, 0x3d	; 61
    7946:	de b7       	in	r29, 0x3e	; 62
    7948:	66 97       	sbiw	r28, 0x16	; 22
    794a:	0f b6       	in	r0, 0x3f	; 63
    794c:	f8 94       	cli
    794e:	de bf       	out	0x3e, r29	; 62
    7950:	0f be       	out	0x3f, r0	; 63
    7952:	cd bf       	out	0x3d, r28	; 61
    7954:	cf 82       	std	Y+7, r12	; 0x07
    7956:	d8 86       	std	Y+8, r13	; 0x08
    7958:	e9 86       	std	Y+9, r14	; 0x09
    795a:	fa 86       	std	Y+10, r15	; 0x0a
    795c:	0b 87       	std	Y+11, r16	; 0x0b
    795e:	1c 87       	std	Y+12, r17	; 0x0c
    7960:	2d 87       	std	Y+13, r18	; 0x0d
    7962:	3e 87       	std	Y+14, r19	; 0x0e
    7964:	4f 87       	std	Y+15, r20	; 0x0f
    7966:	58 8b       	std	Y+16, r21	; 0x10
    7968:	69 8b       	std	Y+17, r22	; 0x11
    796a:	7a 8b       	std	Y+18, r23	; 0x12
    796c:	8b 8b       	std	Y+19, r24	; 0x13
    796e:	9c 8b       	std	Y+20, r25	; 0x14
    7970:	be 8a       	std	Y+22, r11	; 0x16
    7972:	ad 8a       	std	Y+21, r10	; 0x15

	uint8_t loop;
	uint8_t to=channel_group_variabe.no_of_channels;
    7974:	8f 81       	ldd	r24, Y+7	; 0x07
    7976:	98 85       	ldd	r25, Y+8	; 0x08
    7978:	8d 83       	std	Y+5, r24	; 0x05

	for(loop=0u; loop <to ; loop++ ){
    797a:	1e 82       	std	Y+6, r1	; 0x06
    797c:	5d c0       	rjmp	.+186    	; 0x7a38 <DIO_ChannelGroupRead+0x108>
		uint8_t channel_id=channel_group_variabe.group_ids[loop];
    797e:	8e 81       	ldd	r24, Y+6	; 0x06
    7980:	88 2f       	mov	r24, r24
    7982:	90 e0       	ldi	r25, 0x00	; 0
    7984:	01 96       	adiw	r24, 0x01	; 1
    7986:	9c 01       	movw	r18, r24
    7988:	22 0f       	add	r18, r18
    798a:	33 1f       	adc	r19, r19
    798c:	ce 01       	movw	r24, r28
    798e:	01 96       	adiw	r24, 0x01	; 1
    7990:	82 0f       	add	r24, r18
    7992:	93 1f       	adc	r25, r19
    7994:	fc 01       	movw	r30, r24
    7996:	36 96       	adiw	r30, 0x06	; 6
    7998:	80 81       	ld	r24, Z
    799a:	91 81       	ldd	r25, Z+1	; 0x01
    799c:	8c 83       	std	Y+4, r24	; 0x04
		uint8_t portid=dio_config_array[channel_id].port_id;
    799e:	8c 81       	ldd	r24, Y+4	; 0x04
    79a0:	28 2f       	mov	r18, r24
    79a2:	30 e0       	ldi	r19, 0x00	; 0
    79a4:	c9 01       	movw	r24, r18
    79a6:	88 0f       	add	r24, r24
    79a8:	99 1f       	adc	r25, r25
    79aa:	82 0f       	add	r24, r18
    79ac:	93 1f       	adc	r25, r19
    79ae:	fc 01       	movw	r30, r24
    79b0:	e0 5d       	subi	r30, 0xD0	; 208
    79b2:	fd 4f       	sbci	r31, 0xFD	; 253
    79b4:	80 81       	ld	r24, Z
    79b6:	8b 83       	std	Y+3, r24	; 0x03
		uint8_t pin_num=dio_config_array[channel_id].pin_num;
    79b8:	8c 81       	ldd	r24, Y+4	; 0x04
    79ba:	28 2f       	mov	r18, r24
    79bc:	30 e0       	ldi	r19, 0x00	; 0
    79be:	c9 01       	movw	r24, r18
    79c0:	88 0f       	add	r24, r24
    79c2:	99 1f       	adc	r25, r25
    79c4:	82 0f       	add	r24, r18
    79c6:	93 1f       	adc	r25, r19
    79c8:	fc 01       	movw	r30, r24
    79ca:	ef 5c       	subi	r30, 0xCF	; 207
    79cc:	fd 4f       	sbci	r31, 0xFD	; 253
    79ce:	80 81       	ld	r24, Z
    79d0:	8a 83       	std	Y+2, r24	; 0x02
		uint8_t data = GPIO_readPin(portid, pin_num);
    79d2:	8b 81       	ldd	r24, Y+3	; 0x03
    79d4:	6a 81       	ldd	r22, Y+2	; 0x02
    79d6:	0e 94 ed 39 	call	0x73da	; 0x73da <GPIO_readPin>
    79da:	89 83       	std	Y+1, r24	; 0x01
		if(data == LOGIC_HIGH){
    79dc:	89 81       	ldd	r24, Y+1	; 0x01
    79de:	81 30       	cpi	r24, 0x01	; 1
    79e0:	a1 f4       	brne	.+40     	; 0x7a0a <DIO_ChannelGroupRead+0xda>
			SET_BIT(* data_ptr,loop);
    79e2:	ed 89       	ldd	r30, Y+21	; 0x15
    79e4:	fe 89       	ldd	r31, Y+22	; 0x16
    79e6:	80 81       	ld	r24, Z
    79e8:	48 2f       	mov	r20, r24
    79ea:	8e 81       	ldd	r24, Y+6	; 0x06
    79ec:	28 2f       	mov	r18, r24
    79ee:	30 e0       	ldi	r19, 0x00	; 0
    79f0:	81 e0       	ldi	r24, 0x01	; 1
    79f2:	90 e0       	ldi	r25, 0x00	; 0
    79f4:	02 2e       	mov	r0, r18
    79f6:	02 c0       	rjmp	.+4      	; 0x79fc <DIO_ChannelGroupRead+0xcc>
    79f8:	88 0f       	add	r24, r24
    79fa:	99 1f       	adc	r25, r25
    79fc:	0a 94       	dec	r0
    79fe:	e2 f7       	brpl	.-8      	; 0x79f8 <DIO_ChannelGroupRead+0xc8>
    7a00:	84 2b       	or	r24, r20
    7a02:	ed 89       	ldd	r30, Y+21	; 0x15
    7a04:	fe 89       	ldd	r31, Y+22	; 0x16
    7a06:	80 83       	st	Z, r24
    7a08:	14 c0       	rjmp	.+40     	; 0x7a32 <DIO_ChannelGroupRead+0x102>
		}else{
			CLEAR_BIT(* data_ptr,loop);
    7a0a:	ed 89       	ldd	r30, Y+21	; 0x15
    7a0c:	fe 89       	ldd	r31, Y+22	; 0x16
    7a0e:	80 81       	ld	r24, Z
    7a10:	48 2f       	mov	r20, r24
    7a12:	8e 81       	ldd	r24, Y+6	; 0x06
    7a14:	28 2f       	mov	r18, r24
    7a16:	30 e0       	ldi	r19, 0x00	; 0
    7a18:	81 e0       	ldi	r24, 0x01	; 1
    7a1a:	90 e0       	ldi	r25, 0x00	; 0
    7a1c:	02 2e       	mov	r0, r18
    7a1e:	02 c0       	rjmp	.+4      	; 0x7a24 <DIO_ChannelGroupRead+0xf4>
    7a20:	88 0f       	add	r24, r24
    7a22:	99 1f       	adc	r25, r25
    7a24:	0a 94       	dec	r0
    7a26:	e2 f7       	brpl	.-8      	; 0x7a20 <DIO_ChannelGroupRead+0xf0>
    7a28:	80 95       	com	r24
    7a2a:	84 23       	and	r24, r20
    7a2c:	ed 89       	ldd	r30, Y+21	; 0x15
    7a2e:	fe 89       	ldd	r31, Y+22	; 0x16
    7a30:	80 83       	st	Z, r24
{

	uint8_t loop;
	uint8_t to=channel_group_variabe.no_of_channels;

	for(loop=0u; loop <to ; loop++ ){
    7a32:	8e 81       	ldd	r24, Y+6	; 0x06
    7a34:	8f 5f       	subi	r24, 0xFF	; 255
    7a36:	8e 83       	std	Y+6, r24	; 0x06
    7a38:	9e 81       	ldd	r25, Y+6	; 0x06
    7a3a:	8d 81       	ldd	r24, Y+5	; 0x05
    7a3c:	98 17       	cp	r25, r24
    7a3e:	08 f4       	brcc	.+2      	; 0x7a42 <DIO_ChannelGroupRead+0x112>
    7a40:	9e cf       	rjmp	.-196    	; 0x797e <DIO_ChannelGroupRead+0x4e>
		}else{
			CLEAR_BIT(* data_ptr,loop);
		}
	}

}
    7a42:	66 96       	adiw	r28, 0x16	; 22
    7a44:	0f b6       	in	r0, 0x3f	; 63
    7a46:	f8 94       	cli
    7a48:	de bf       	out	0x3e, r29	; 62
    7a4a:	0f be       	out	0x3f, r0	; 63
    7a4c:	cd bf       	out	0x3d, r28	; 61
    7a4e:	cf 91       	pop	r28
    7a50:	df 91       	pop	r29
    7a52:	1f 91       	pop	r17
    7a54:	0f 91       	pop	r16
    7a56:	ff 90       	pop	r15
    7a58:	ef 90       	pop	r14
    7a5a:	df 90       	pop	r13
    7a5c:	cf 90       	pop	r12
    7a5e:	bf 90       	pop	r11
    7a60:	af 90       	pop	r10
    7a62:	08 95       	ret

00007a64 <LCD_init>:
 * Initialize the LCD:
 * 1. Setup the LCD pins directions by use the GPIO driver.
 * 2. Setup the LCD Data Mode 4-bits or 8-bits.
 */
void LCD_init(void)
{
    7a64:	df 93       	push	r29
    7a66:	cf 93       	push	r28
    7a68:	cd b7       	in	r28, 0x3d	; 61
    7a6a:	de b7       	in	r29, 0x3e	; 62
    7a6c:	2e 97       	sbiw	r28, 0x0e	; 14
    7a6e:	0f b6       	in	r0, 0x3f	; 63
    7a70:	f8 94       	cli
    7a72:	de bf       	out	0x3e, r29	; 62
    7a74:	0f be       	out	0x3f, r0	; 63
    7a76:	cd bf       	out	0x3d, r28	; 61
	/* Configure the direction for RS and E pins as output pins */
	GPIO_setupPinDirection(LCD_RS_PORT_ID,LCD_RS_PIN_ID,PIN_OUTPUT);
    7a78:	83 e0       	ldi	r24, 0x03	; 3
    7a7a:	60 e0       	ldi	r22, 0x00	; 0
    7a7c:	41 e0       	ldi	r20, 0x01	; 1
    7a7e:	0e 94 4f 37 	call	0x6e9e	; 0x6e9e <GPIO_setupPinDirection>
	GPIO_setupPinDirection(LCD_E_PORT_ID,LCD_E_PIN_ID,PIN_OUTPUT);
    7a82:	83 e0       	ldi	r24, 0x03	; 3
    7a84:	62 e0       	ldi	r22, 0x02	; 2
    7a86:	41 e0       	ldi	r20, 0x01	; 1
    7a88:	0e 94 4f 37 	call	0x6e9e	; 0x6e9e <GPIO_setupPinDirection>
    7a8c:	80 e0       	ldi	r24, 0x00	; 0
    7a8e:	90 e0       	ldi	r25, 0x00	; 0
    7a90:	a0 ea       	ldi	r26, 0xA0	; 160
    7a92:	b1 e4       	ldi	r27, 0x41	; 65
    7a94:	8b 87       	std	Y+11, r24	; 0x0b
    7a96:	9c 87       	std	Y+12, r25	; 0x0c
    7a98:	ad 87       	std	Y+13, r26	; 0x0d
    7a9a:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    7a9c:	6b 85       	ldd	r22, Y+11	; 0x0b
    7a9e:	7c 85       	ldd	r23, Y+12	; 0x0c
    7aa0:	8d 85       	ldd	r24, Y+13	; 0x0d
    7aa2:	9e 85       	ldd	r25, Y+14	; 0x0e
    7aa4:	20 e0       	ldi	r18, 0x00	; 0
    7aa6:	30 e0       	ldi	r19, 0x00	; 0
    7aa8:	4a e7       	ldi	r20, 0x7A	; 122
    7aaa:	55 e4       	ldi	r21, 0x45	; 69
    7aac:	0e 94 3b 02 	call	0x476	; 0x476 <__mulsf3>
    7ab0:	dc 01       	movw	r26, r24
    7ab2:	cb 01       	movw	r24, r22
    7ab4:	8f 83       	std	Y+7, r24	; 0x07
    7ab6:	98 87       	std	Y+8, r25	; 0x08
    7ab8:	a9 87       	std	Y+9, r26	; 0x09
    7aba:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    7abc:	6f 81       	ldd	r22, Y+7	; 0x07
    7abe:	78 85       	ldd	r23, Y+8	; 0x08
    7ac0:	89 85       	ldd	r24, Y+9	; 0x09
    7ac2:	9a 85       	ldd	r25, Y+10	; 0x0a
    7ac4:	20 e0       	ldi	r18, 0x00	; 0
    7ac6:	30 e0       	ldi	r19, 0x00	; 0
    7ac8:	40 e8       	ldi	r20, 0x80	; 128
    7aca:	5f e3       	ldi	r21, 0x3F	; 63
    7acc:	0e 94 41 04 	call	0x882	; 0x882 <__ltsf2>
    7ad0:	88 23       	and	r24, r24
    7ad2:	2c f4       	brge	.+10     	; 0x7ade <LCD_init+0x7a>
		__ticks = 1;
    7ad4:	81 e0       	ldi	r24, 0x01	; 1
    7ad6:	90 e0       	ldi	r25, 0x00	; 0
    7ad8:	9e 83       	std	Y+6, r25	; 0x06
    7ada:	8d 83       	std	Y+5, r24	; 0x05
    7adc:	3f c0       	rjmp	.+126    	; 0x7b5c <LCD_init+0xf8>
	else if (__tmp > 65535)
    7ade:	6f 81       	ldd	r22, Y+7	; 0x07
    7ae0:	78 85       	ldd	r23, Y+8	; 0x08
    7ae2:	89 85       	ldd	r24, Y+9	; 0x09
    7ae4:	9a 85       	ldd	r25, Y+10	; 0x0a
    7ae6:	20 e0       	ldi	r18, 0x00	; 0
    7ae8:	3f ef       	ldi	r19, 0xFF	; 255
    7aea:	4f e7       	ldi	r20, 0x7F	; 127
    7aec:	57 e4       	ldi	r21, 0x47	; 71
    7aee:	0e 94 e1 03 	call	0x7c2	; 0x7c2 <__gtsf2>
    7af2:	18 16       	cp	r1, r24
    7af4:	4c f5       	brge	.+82     	; 0x7b48 <LCD_init+0xe4>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    7af6:	6b 85       	ldd	r22, Y+11	; 0x0b
    7af8:	7c 85       	ldd	r23, Y+12	; 0x0c
    7afa:	8d 85       	ldd	r24, Y+13	; 0x0d
    7afc:	9e 85       	ldd	r25, Y+14	; 0x0e
    7afe:	20 e0       	ldi	r18, 0x00	; 0
    7b00:	30 e0       	ldi	r19, 0x00	; 0
    7b02:	40 e2       	ldi	r20, 0x20	; 32
    7b04:	51 e4       	ldi	r21, 0x41	; 65
    7b06:	0e 94 3b 02 	call	0x476	; 0x476 <__mulsf3>
    7b0a:	dc 01       	movw	r26, r24
    7b0c:	cb 01       	movw	r24, r22
    7b0e:	bc 01       	movw	r22, r24
    7b10:	cd 01       	movw	r24, r26
    7b12:	0e 94 65 00 	call	0xca	; 0xca <__fixunssfsi>
    7b16:	dc 01       	movw	r26, r24
    7b18:	cb 01       	movw	r24, r22
    7b1a:	9e 83       	std	Y+6, r25	; 0x06
    7b1c:	8d 83       	std	Y+5, r24	; 0x05
    7b1e:	0f c0       	rjmp	.+30     	; 0x7b3e <LCD_init+0xda>
    7b20:	80 e9       	ldi	r24, 0x90	; 144
    7b22:	91 e0       	ldi	r25, 0x01	; 1
    7b24:	9c 83       	std	Y+4, r25	; 0x04
    7b26:	8b 83       	std	Y+3, r24	; 0x03
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    7b28:	8b 81       	ldd	r24, Y+3	; 0x03
    7b2a:	9c 81       	ldd	r25, Y+4	; 0x04
    7b2c:	01 97       	sbiw	r24, 0x01	; 1
    7b2e:	f1 f7       	brne	.-4      	; 0x7b2c <LCD_init+0xc8>
    7b30:	9c 83       	std	Y+4, r25	; 0x04
    7b32:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    7b34:	8d 81       	ldd	r24, Y+5	; 0x05
    7b36:	9e 81       	ldd	r25, Y+6	; 0x06
    7b38:	01 97       	sbiw	r24, 0x01	; 1
    7b3a:	9e 83       	std	Y+6, r25	; 0x06
    7b3c:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    7b3e:	8d 81       	ldd	r24, Y+5	; 0x05
    7b40:	9e 81       	ldd	r25, Y+6	; 0x06
    7b42:	00 97       	sbiw	r24, 0x00	; 0
    7b44:	69 f7       	brne	.-38     	; 0x7b20 <LCD_init+0xbc>
    7b46:	14 c0       	rjmp	.+40     	; 0x7b70 <LCD_init+0x10c>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    7b48:	6f 81       	ldd	r22, Y+7	; 0x07
    7b4a:	78 85       	ldd	r23, Y+8	; 0x08
    7b4c:	89 85       	ldd	r24, Y+9	; 0x09
    7b4e:	9a 85       	ldd	r25, Y+10	; 0x0a
    7b50:	0e 94 65 00 	call	0xca	; 0xca <__fixunssfsi>
    7b54:	dc 01       	movw	r26, r24
    7b56:	cb 01       	movw	r24, r22
    7b58:	9e 83       	std	Y+6, r25	; 0x06
    7b5a:	8d 83       	std	Y+5, r24	; 0x05
    7b5c:	8d 81       	ldd	r24, Y+5	; 0x05
    7b5e:	9e 81       	ldd	r25, Y+6	; 0x06
    7b60:	9a 83       	std	Y+2, r25	; 0x02
    7b62:	89 83       	std	Y+1, r24	; 0x01
    7b64:	89 81       	ldd	r24, Y+1	; 0x01
    7b66:	9a 81       	ldd	r25, Y+2	; 0x02
    7b68:	01 97       	sbiw	r24, 0x01	; 1
    7b6a:	f1 f7       	brne	.-4      	; 0x7b68 <LCD_init+0x104>
    7b6c:	9a 83       	std	Y+2, r25	; 0x02
    7b6e:	89 83       	std	Y+1, r24	; 0x01

	_delay_ms(20);		/* LCD Power ON delay always > 15ms */

#if(LCD_DATA_BITS_MODE == 4)
	/* Configure 4 pins in the data port as output pins */
	GPIO_setupPinDirection(LCD_DATA_PORT_ID,LCD_DB4_PIN_ID,PIN_OUTPUT);
    7b70:	83 e0       	ldi	r24, 0x03	; 3
    7b72:	64 e0       	ldi	r22, 0x04	; 4
    7b74:	41 e0       	ldi	r20, 0x01	; 1
    7b76:	0e 94 4f 37 	call	0x6e9e	; 0x6e9e <GPIO_setupPinDirection>
	GPIO_setupPinDirection(LCD_DATA_PORT_ID,LCD_DB5_PIN_ID,PIN_OUTPUT);
    7b7a:	83 e0       	ldi	r24, 0x03	; 3
    7b7c:	65 e0       	ldi	r22, 0x05	; 5
    7b7e:	41 e0       	ldi	r20, 0x01	; 1
    7b80:	0e 94 4f 37 	call	0x6e9e	; 0x6e9e <GPIO_setupPinDirection>
	GPIO_setupPinDirection(LCD_DATA_PORT_ID,LCD_DB6_PIN_ID,PIN_OUTPUT);
    7b84:	83 e0       	ldi	r24, 0x03	; 3
    7b86:	66 e0       	ldi	r22, 0x06	; 6
    7b88:	41 e0       	ldi	r20, 0x01	; 1
    7b8a:	0e 94 4f 37 	call	0x6e9e	; 0x6e9e <GPIO_setupPinDirection>
	GPIO_setupPinDirection(LCD_DATA_PORT_ID,LCD_DB7_PIN_ID,PIN_OUTPUT);
    7b8e:	83 e0       	ldi	r24, 0x03	; 3
    7b90:	67 e0       	ldi	r22, 0x07	; 7
    7b92:	41 e0       	ldi	r20, 0x01	; 1
    7b94:	0e 94 4f 37 	call	0x6e9e	; 0x6e9e <GPIO_setupPinDirection>

	/* Send for 4 bit initialization of LCD  */
	LCD_sendCommand(LCD_TWO_LINES_FOUR_BITS_MODE_INIT1);
    7b98:	83 e3       	ldi	r24, 0x33	; 51
    7b9a:	0e 94 e4 3d 	call	0x7bc8	; 0x7bc8 <LCD_sendCommand>
	LCD_sendCommand(LCD_TWO_LINES_FOUR_BITS_MODE_INIT2);
    7b9e:	82 e3       	ldi	r24, 0x32	; 50
    7ba0:	0e 94 e4 3d 	call	0x7bc8	; 0x7bc8 <LCD_sendCommand>

	/* use 2-lines LCD + 4-bits Data Mode + 5*7 dot display Mode */
	LCD_sendCommand(LCD_TWO_LINES_FOUR_BITS_MODE);
    7ba4:	88 e2       	ldi	r24, 0x28	; 40
    7ba6:	0e 94 e4 3d 	call	0x7bc8	; 0x7bc8 <LCD_sendCommand>
	/* use 2-lines LCD + 8-bits Data Mode + 5*7 dot display Mode */
	LCD_sendCommand(LCD_TWO_LINES_EIGHT_BITS_MODE);

#endif

	LCD_sendCommand(LCD_CURSOR_OFF); /* cursor off */
    7baa:	8c e0       	ldi	r24, 0x0C	; 12
    7bac:	0e 94 e4 3d 	call	0x7bc8	; 0x7bc8 <LCD_sendCommand>
	LCD_sendCommand(LCD_CLEAR_COMMAND); /* clear LCD at the beginning */
    7bb0:	81 e0       	ldi	r24, 0x01	; 1
    7bb2:	0e 94 e4 3d 	call	0x7bc8	; 0x7bc8 <LCD_sendCommand>
}
    7bb6:	2e 96       	adiw	r28, 0x0e	; 14
    7bb8:	0f b6       	in	r0, 0x3f	; 63
    7bba:	f8 94       	cli
    7bbc:	de bf       	out	0x3e, r29	; 62
    7bbe:	0f be       	out	0x3f, r0	; 63
    7bc0:	cd bf       	out	0x3d, r28	; 61
    7bc2:	cf 91       	pop	r28
    7bc4:	df 91       	pop	r29
    7bc6:	08 95       	ret

00007bc8 <LCD_sendCommand>:
/*
 * Description :
 * Send the required command to the screen
 */
void LCD_sendCommand(uint8 command)
{
    7bc8:	0f 93       	push	r16
    7bca:	1f 93       	push	r17
    7bcc:	df 93       	push	r29
    7bce:	cf 93       	push	r28
    7bd0:	cd b7       	in	r28, 0x3d	; 61
    7bd2:	de b7       	in	r29, 0x3e	; 62
    7bd4:	c3 56       	subi	r28, 0x63	; 99
    7bd6:	d0 40       	sbci	r29, 0x00	; 0
    7bd8:	0f b6       	in	r0, 0x3f	; 63
    7bda:	f8 94       	cli
    7bdc:	de bf       	out	0x3e, r29	; 62
    7bde:	0f be       	out	0x3f, r0	; 63
    7be0:	cd bf       	out	0x3d, r28	; 61
    7be2:	fe 01       	movw	r30, r28
    7be4:	ed 59       	subi	r30, 0x9D	; 157
    7be6:	ff 4f       	sbci	r31, 0xFF	; 255
    7be8:	80 83       	st	Z, r24
	GPIO_writePin(LCD_RS_PORT_ID,LCD_RS_PIN_ID,LOGIC_LOW); /* Instruction Mode RS=0 */
    7bea:	83 e0       	ldi	r24, 0x03	; 3
    7bec:	60 e0       	ldi	r22, 0x00	; 0
    7bee:	40 e0       	ldi	r20, 0x00	; 0
    7bf0:	0e 94 9e 38 	call	0x713c	; 0x713c <GPIO_writePin>
    7bf4:	fe 01       	movw	r30, r28
    7bf6:	e1 5a       	subi	r30, 0xA1	; 161
    7bf8:	ff 4f       	sbci	r31, 0xFF	; 255
    7bfa:	80 e0       	ldi	r24, 0x00	; 0
    7bfc:	90 e0       	ldi	r25, 0x00	; 0
    7bfe:	a0 e8       	ldi	r26, 0x80	; 128
    7c00:	bf e3       	ldi	r27, 0x3F	; 63
    7c02:	80 83       	st	Z, r24
    7c04:	91 83       	std	Z+1, r25	; 0x01
    7c06:	a2 83       	std	Z+2, r26	; 0x02
    7c08:	b3 83       	std	Z+3, r27	; 0x03
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    7c0a:	8e 01       	movw	r16, r28
    7c0c:	05 5a       	subi	r16, 0xA5	; 165
    7c0e:	1f 4f       	sbci	r17, 0xFF	; 255
    7c10:	fe 01       	movw	r30, r28
    7c12:	e1 5a       	subi	r30, 0xA1	; 161
    7c14:	ff 4f       	sbci	r31, 0xFF	; 255
    7c16:	60 81       	ld	r22, Z
    7c18:	71 81       	ldd	r23, Z+1	; 0x01
    7c1a:	82 81       	ldd	r24, Z+2	; 0x02
    7c1c:	93 81       	ldd	r25, Z+3	; 0x03
    7c1e:	20 e0       	ldi	r18, 0x00	; 0
    7c20:	30 e0       	ldi	r19, 0x00	; 0
    7c22:	4a e7       	ldi	r20, 0x7A	; 122
    7c24:	55 e4       	ldi	r21, 0x45	; 69
    7c26:	0e 94 3b 02 	call	0x476	; 0x476 <__mulsf3>
    7c2a:	dc 01       	movw	r26, r24
    7c2c:	cb 01       	movw	r24, r22
    7c2e:	f8 01       	movw	r30, r16
    7c30:	80 83       	st	Z, r24
    7c32:	91 83       	std	Z+1, r25	; 0x01
    7c34:	a2 83       	std	Z+2, r26	; 0x02
    7c36:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    7c38:	fe 01       	movw	r30, r28
    7c3a:	e5 5a       	subi	r30, 0xA5	; 165
    7c3c:	ff 4f       	sbci	r31, 0xFF	; 255
    7c3e:	60 81       	ld	r22, Z
    7c40:	71 81       	ldd	r23, Z+1	; 0x01
    7c42:	82 81       	ldd	r24, Z+2	; 0x02
    7c44:	93 81       	ldd	r25, Z+3	; 0x03
    7c46:	20 e0       	ldi	r18, 0x00	; 0
    7c48:	30 e0       	ldi	r19, 0x00	; 0
    7c4a:	40 e8       	ldi	r20, 0x80	; 128
    7c4c:	5f e3       	ldi	r21, 0x3F	; 63
    7c4e:	0e 94 41 04 	call	0x882	; 0x882 <__ltsf2>
    7c52:	88 23       	and	r24, r24
    7c54:	44 f4       	brge	.+16     	; 0x7c66 <LCD_sendCommand+0x9e>
		__ticks = 1;
    7c56:	fe 01       	movw	r30, r28
    7c58:	e7 5a       	subi	r30, 0xA7	; 167
    7c5a:	ff 4f       	sbci	r31, 0xFF	; 255
    7c5c:	81 e0       	ldi	r24, 0x01	; 1
    7c5e:	90 e0       	ldi	r25, 0x00	; 0
    7c60:	91 83       	std	Z+1, r25	; 0x01
    7c62:	80 83       	st	Z, r24
    7c64:	64 c0       	rjmp	.+200    	; 0x7d2e <LCD_sendCommand+0x166>
	else if (__tmp > 65535)
    7c66:	fe 01       	movw	r30, r28
    7c68:	e5 5a       	subi	r30, 0xA5	; 165
    7c6a:	ff 4f       	sbci	r31, 0xFF	; 255
    7c6c:	60 81       	ld	r22, Z
    7c6e:	71 81       	ldd	r23, Z+1	; 0x01
    7c70:	82 81       	ldd	r24, Z+2	; 0x02
    7c72:	93 81       	ldd	r25, Z+3	; 0x03
    7c74:	20 e0       	ldi	r18, 0x00	; 0
    7c76:	3f ef       	ldi	r19, 0xFF	; 255
    7c78:	4f e7       	ldi	r20, 0x7F	; 127
    7c7a:	57 e4       	ldi	r21, 0x47	; 71
    7c7c:	0e 94 e1 03 	call	0x7c2	; 0x7c2 <__gtsf2>
    7c80:	18 16       	cp	r1, r24
    7c82:	0c f0       	brlt	.+2      	; 0x7c86 <LCD_sendCommand+0xbe>
    7c84:	43 c0       	rjmp	.+134    	; 0x7d0c <LCD_sendCommand+0x144>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    7c86:	fe 01       	movw	r30, r28
    7c88:	e1 5a       	subi	r30, 0xA1	; 161
    7c8a:	ff 4f       	sbci	r31, 0xFF	; 255
    7c8c:	60 81       	ld	r22, Z
    7c8e:	71 81       	ldd	r23, Z+1	; 0x01
    7c90:	82 81       	ldd	r24, Z+2	; 0x02
    7c92:	93 81       	ldd	r25, Z+3	; 0x03
    7c94:	20 e0       	ldi	r18, 0x00	; 0
    7c96:	30 e0       	ldi	r19, 0x00	; 0
    7c98:	40 e2       	ldi	r20, 0x20	; 32
    7c9a:	51 e4       	ldi	r21, 0x41	; 65
    7c9c:	0e 94 3b 02 	call	0x476	; 0x476 <__mulsf3>
    7ca0:	dc 01       	movw	r26, r24
    7ca2:	cb 01       	movw	r24, r22
    7ca4:	8e 01       	movw	r16, r28
    7ca6:	07 5a       	subi	r16, 0xA7	; 167
    7ca8:	1f 4f       	sbci	r17, 0xFF	; 255
    7caa:	bc 01       	movw	r22, r24
    7cac:	cd 01       	movw	r24, r26
    7cae:	0e 94 65 00 	call	0xca	; 0xca <__fixunssfsi>
    7cb2:	dc 01       	movw	r26, r24
    7cb4:	cb 01       	movw	r24, r22
    7cb6:	f8 01       	movw	r30, r16
    7cb8:	91 83       	std	Z+1, r25	; 0x01
    7cba:	80 83       	st	Z, r24
    7cbc:	1f c0       	rjmp	.+62     	; 0x7cfc <LCD_sendCommand+0x134>
    7cbe:	fe 01       	movw	r30, r28
    7cc0:	e9 5a       	subi	r30, 0xA9	; 169
    7cc2:	ff 4f       	sbci	r31, 0xFF	; 255
    7cc4:	80 e9       	ldi	r24, 0x90	; 144
    7cc6:	91 e0       	ldi	r25, 0x01	; 1
    7cc8:	91 83       	std	Z+1, r25	; 0x01
    7cca:	80 83       	st	Z, r24
    7ccc:	fe 01       	movw	r30, r28
    7cce:	e9 5a       	subi	r30, 0xA9	; 169
    7cd0:	ff 4f       	sbci	r31, 0xFF	; 255
    7cd2:	80 81       	ld	r24, Z
    7cd4:	91 81       	ldd	r25, Z+1	; 0x01
    7cd6:	01 97       	sbiw	r24, 0x01	; 1
    7cd8:	f1 f7       	brne	.-4      	; 0x7cd6 <LCD_sendCommand+0x10e>
    7cda:	fe 01       	movw	r30, r28
    7cdc:	e9 5a       	subi	r30, 0xA9	; 169
    7cde:	ff 4f       	sbci	r31, 0xFF	; 255
    7ce0:	91 83       	std	Z+1, r25	; 0x01
    7ce2:	80 83       	st	Z, r24
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    7ce4:	de 01       	movw	r26, r28
    7ce6:	a7 5a       	subi	r26, 0xA7	; 167
    7ce8:	bf 4f       	sbci	r27, 0xFF	; 255
    7cea:	fe 01       	movw	r30, r28
    7cec:	e7 5a       	subi	r30, 0xA7	; 167
    7cee:	ff 4f       	sbci	r31, 0xFF	; 255
    7cf0:	80 81       	ld	r24, Z
    7cf2:	91 81       	ldd	r25, Z+1	; 0x01
    7cf4:	01 97       	sbiw	r24, 0x01	; 1
    7cf6:	11 96       	adiw	r26, 0x01	; 1
    7cf8:	9c 93       	st	X, r25
    7cfa:	8e 93       	st	-X, r24
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    7cfc:	fe 01       	movw	r30, r28
    7cfe:	e7 5a       	subi	r30, 0xA7	; 167
    7d00:	ff 4f       	sbci	r31, 0xFF	; 255
    7d02:	80 81       	ld	r24, Z
    7d04:	91 81       	ldd	r25, Z+1	; 0x01
    7d06:	00 97       	sbiw	r24, 0x00	; 0
    7d08:	d1 f6       	brne	.-76     	; 0x7cbe <LCD_sendCommand+0xf6>
    7d0a:	27 c0       	rjmp	.+78     	; 0x7d5a <LCD_sendCommand+0x192>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    7d0c:	8e 01       	movw	r16, r28
    7d0e:	07 5a       	subi	r16, 0xA7	; 167
    7d10:	1f 4f       	sbci	r17, 0xFF	; 255
    7d12:	fe 01       	movw	r30, r28
    7d14:	e5 5a       	subi	r30, 0xA5	; 165
    7d16:	ff 4f       	sbci	r31, 0xFF	; 255
    7d18:	60 81       	ld	r22, Z
    7d1a:	71 81       	ldd	r23, Z+1	; 0x01
    7d1c:	82 81       	ldd	r24, Z+2	; 0x02
    7d1e:	93 81       	ldd	r25, Z+3	; 0x03
    7d20:	0e 94 65 00 	call	0xca	; 0xca <__fixunssfsi>
    7d24:	dc 01       	movw	r26, r24
    7d26:	cb 01       	movw	r24, r22
    7d28:	f8 01       	movw	r30, r16
    7d2a:	91 83       	std	Z+1, r25	; 0x01
    7d2c:	80 83       	st	Z, r24
    7d2e:	de 01       	movw	r26, r28
    7d30:	ab 5a       	subi	r26, 0xAB	; 171
    7d32:	bf 4f       	sbci	r27, 0xFF	; 255
    7d34:	fe 01       	movw	r30, r28
    7d36:	e7 5a       	subi	r30, 0xA7	; 167
    7d38:	ff 4f       	sbci	r31, 0xFF	; 255
    7d3a:	80 81       	ld	r24, Z
    7d3c:	91 81       	ldd	r25, Z+1	; 0x01
    7d3e:	8d 93       	st	X+, r24
    7d40:	9c 93       	st	X, r25
    7d42:	fe 01       	movw	r30, r28
    7d44:	eb 5a       	subi	r30, 0xAB	; 171
    7d46:	ff 4f       	sbci	r31, 0xFF	; 255
    7d48:	80 81       	ld	r24, Z
    7d4a:	91 81       	ldd	r25, Z+1	; 0x01
    7d4c:	01 97       	sbiw	r24, 0x01	; 1
    7d4e:	f1 f7       	brne	.-4      	; 0x7d4c <LCD_sendCommand+0x184>
    7d50:	fe 01       	movw	r30, r28
    7d52:	eb 5a       	subi	r30, 0xAB	; 171
    7d54:	ff 4f       	sbci	r31, 0xFF	; 255
    7d56:	91 83       	std	Z+1, r25	; 0x01
    7d58:	80 83       	st	Z, r24
	_delay_ms(1); /* delay for processing Tas = 50ns */
	GPIO_writePin(LCD_E_PORT_ID,LCD_E_PIN_ID,LOGIC_HIGH); /* Enable LCD E=1 */
    7d5a:	83 e0       	ldi	r24, 0x03	; 3
    7d5c:	62 e0       	ldi	r22, 0x02	; 2
    7d5e:	41 e0       	ldi	r20, 0x01	; 1
    7d60:	0e 94 9e 38 	call	0x713c	; 0x713c <GPIO_writePin>
    7d64:	fe 01       	movw	r30, r28
    7d66:	ef 5a       	subi	r30, 0xAF	; 175
    7d68:	ff 4f       	sbci	r31, 0xFF	; 255
    7d6a:	80 e0       	ldi	r24, 0x00	; 0
    7d6c:	90 e0       	ldi	r25, 0x00	; 0
    7d6e:	a0 e8       	ldi	r26, 0x80	; 128
    7d70:	bf e3       	ldi	r27, 0x3F	; 63
    7d72:	80 83       	st	Z, r24
    7d74:	91 83       	std	Z+1, r25	; 0x01
    7d76:	a2 83       	std	Z+2, r26	; 0x02
    7d78:	b3 83       	std	Z+3, r27	; 0x03
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    7d7a:	8e 01       	movw	r16, r28
    7d7c:	03 5b       	subi	r16, 0xB3	; 179
    7d7e:	1f 4f       	sbci	r17, 0xFF	; 255
    7d80:	fe 01       	movw	r30, r28
    7d82:	ef 5a       	subi	r30, 0xAF	; 175
    7d84:	ff 4f       	sbci	r31, 0xFF	; 255
    7d86:	60 81       	ld	r22, Z
    7d88:	71 81       	ldd	r23, Z+1	; 0x01
    7d8a:	82 81       	ldd	r24, Z+2	; 0x02
    7d8c:	93 81       	ldd	r25, Z+3	; 0x03
    7d8e:	20 e0       	ldi	r18, 0x00	; 0
    7d90:	30 e0       	ldi	r19, 0x00	; 0
    7d92:	4a e7       	ldi	r20, 0x7A	; 122
    7d94:	55 e4       	ldi	r21, 0x45	; 69
    7d96:	0e 94 3b 02 	call	0x476	; 0x476 <__mulsf3>
    7d9a:	dc 01       	movw	r26, r24
    7d9c:	cb 01       	movw	r24, r22
    7d9e:	f8 01       	movw	r30, r16
    7da0:	80 83       	st	Z, r24
    7da2:	91 83       	std	Z+1, r25	; 0x01
    7da4:	a2 83       	std	Z+2, r26	; 0x02
    7da6:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    7da8:	fe 01       	movw	r30, r28
    7daa:	e3 5b       	subi	r30, 0xB3	; 179
    7dac:	ff 4f       	sbci	r31, 0xFF	; 255
    7dae:	60 81       	ld	r22, Z
    7db0:	71 81       	ldd	r23, Z+1	; 0x01
    7db2:	82 81       	ldd	r24, Z+2	; 0x02
    7db4:	93 81       	ldd	r25, Z+3	; 0x03
    7db6:	20 e0       	ldi	r18, 0x00	; 0
    7db8:	30 e0       	ldi	r19, 0x00	; 0
    7dba:	40 e8       	ldi	r20, 0x80	; 128
    7dbc:	5f e3       	ldi	r21, 0x3F	; 63
    7dbe:	0e 94 41 04 	call	0x882	; 0x882 <__ltsf2>
    7dc2:	88 23       	and	r24, r24
    7dc4:	44 f4       	brge	.+16     	; 0x7dd6 <LCD_sendCommand+0x20e>
		__ticks = 1;
    7dc6:	fe 01       	movw	r30, r28
    7dc8:	e5 5b       	subi	r30, 0xB5	; 181
    7dca:	ff 4f       	sbci	r31, 0xFF	; 255
    7dcc:	81 e0       	ldi	r24, 0x01	; 1
    7dce:	90 e0       	ldi	r25, 0x00	; 0
    7dd0:	91 83       	std	Z+1, r25	; 0x01
    7dd2:	80 83       	st	Z, r24
    7dd4:	64 c0       	rjmp	.+200    	; 0x7e9e <LCD_sendCommand+0x2d6>
	else if (__tmp > 65535)
    7dd6:	fe 01       	movw	r30, r28
    7dd8:	e3 5b       	subi	r30, 0xB3	; 179
    7dda:	ff 4f       	sbci	r31, 0xFF	; 255
    7ddc:	60 81       	ld	r22, Z
    7dde:	71 81       	ldd	r23, Z+1	; 0x01
    7de0:	82 81       	ldd	r24, Z+2	; 0x02
    7de2:	93 81       	ldd	r25, Z+3	; 0x03
    7de4:	20 e0       	ldi	r18, 0x00	; 0
    7de6:	3f ef       	ldi	r19, 0xFF	; 255
    7de8:	4f e7       	ldi	r20, 0x7F	; 127
    7dea:	57 e4       	ldi	r21, 0x47	; 71
    7dec:	0e 94 e1 03 	call	0x7c2	; 0x7c2 <__gtsf2>
    7df0:	18 16       	cp	r1, r24
    7df2:	0c f0       	brlt	.+2      	; 0x7df6 <LCD_sendCommand+0x22e>
    7df4:	43 c0       	rjmp	.+134    	; 0x7e7c <LCD_sendCommand+0x2b4>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    7df6:	fe 01       	movw	r30, r28
    7df8:	ef 5a       	subi	r30, 0xAF	; 175
    7dfa:	ff 4f       	sbci	r31, 0xFF	; 255
    7dfc:	60 81       	ld	r22, Z
    7dfe:	71 81       	ldd	r23, Z+1	; 0x01
    7e00:	82 81       	ldd	r24, Z+2	; 0x02
    7e02:	93 81       	ldd	r25, Z+3	; 0x03
    7e04:	20 e0       	ldi	r18, 0x00	; 0
    7e06:	30 e0       	ldi	r19, 0x00	; 0
    7e08:	40 e2       	ldi	r20, 0x20	; 32
    7e0a:	51 e4       	ldi	r21, 0x41	; 65
    7e0c:	0e 94 3b 02 	call	0x476	; 0x476 <__mulsf3>
    7e10:	dc 01       	movw	r26, r24
    7e12:	cb 01       	movw	r24, r22
    7e14:	8e 01       	movw	r16, r28
    7e16:	05 5b       	subi	r16, 0xB5	; 181
    7e18:	1f 4f       	sbci	r17, 0xFF	; 255
    7e1a:	bc 01       	movw	r22, r24
    7e1c:	cd 01       	movw	r24, r26
    7e1e:	0e 94 65 00 	call	0xca	; 0xca <__fixunssfsi>
    7e22:	dc 01       	movw	r26, r24
    7e24:	cb 01       	movw	r24, r22
    7e26:	f8 01       	movw	r30, r16
    7e28:	91 83       	std	Z+1, r25	; 0x01
    7e2a:	80 83       	st	Z, r24
    7e2c:	1f c0       	rjmp	.+62     	; 0x7e6c <LCD_sendCommand+0x2a4>
    7e2e:	fe 01       	movw	r30, r28
    7e30:	e7 5b       	subi	r30, 0xB7	; 183
    7e32:	ff 4f       	sbci	r31, 0xFF	; 255
    7e34:	80 e9       	ldi	r24, 0x90	; 144
    7e36:	91 e0       	ldi	r25, 0x01	; 1
    7e38:	91 83       	std	Z+1, r25	; 0x01
    7e3a:	80 83       	st	Z, r24
    7e3c:	fe 01       	movw	r30, r28
    7e3e:	e7 5b       	subi	r30, 0xB7	; 183
    7e40:	ff 4f       	sbci	r31, 0xFF	; 255
    7e42:	80 81       	ld	r24, Z
    7e44:	91 81       	ldd	r25, Z+1	; 0x01
    7e46:	01 97       	sbiw	r24, 0x01	; 1
    7e48:	f1 f7       	brne	.-4      	; 0x7e46 <LCD_sendCommand+0x27e>
    7e4a:	fe 01       	movw	r30, r28
    7e4c:	e7 5b       	subi	r30, 0xB7	; 183
    7e4e:	ff 4f       	sbci	r31, 0xFF	; 255
    7e50:	91 83       	std	Z+1, r25	; 0x01
    7e52:	80 83       	st	Z, r24
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    7e54:	de 01       	movw	r26, r28
    7e56:	a5 5b       	subi	r26, 0xB5	; 181
    7e58:	bf 4f       	sbci	r27, 0xFF	; 255
    7e5a:	fe 01       	movw	r30, r28
    7e5c:	e5 5b       	subi	r30, 0xB5	; 181
    7e5e:	ff 4f       	sbci	r31, 0xFF	; 255
    7e60:	80 81       	ld	r24, Z
    7e62:	91 81       	ldd	r25, Z+1	; 0x01
    7e64:	01 97       	sbiw	r24, 0x01	; 1
    7e66:	11 96       	adiw	r26, 0x01	; 1
    7e68:	9c 93       	st	X, r25
    7e6a:	8e 93       	st	-X, r24
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    7e6c:	fe 01       	movw	r30, r28
    7e6e:	e5 5b       	subi	r30, 0xB5	; 181
    7e70:	ff 4f       	sbci	r31, 0xFF	; 255
    7e72:	80 81       	ld	r24, Z
    7e74:	91 81       	ldd	r25, Z+1	; 0x01
    7e76:	00 97       	sbiw	r24, 0x00	; 0
    7e78:	d1 f6       	brne	.-76     	; 0x7e2e <LCD_sendCommand+0x266>
    7e7a:	27 c0       	rjmp	.+78     	; 0x7eca <LCD_sendCommand+0x302>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    7e7c:	8e 01       	movw	r16, r28
    7e7e:	05 5b       	subi	r16, 0xB5	; 181
    7e80:	1f 4f       	sbci	r17, 0xFF	; 255
    7e82:	fe 01       	movw	r30, r28
    7e84:	e3 5b       	subi	r30, 0xB3	; 179
    7e86:	ff 4f       	sbci	r31, 0xFF	; 255
    7e88:	60 81       	ld	r22, Z
    7e8a:	71 81       	ldd	r23, Z+1	; 0x01
    7e8c:	82 81       	ldd	r24, Z+2	; 0x02
    7e8e:	93 81       	ldd	r25, Z+3	; 0x03
    7e90:	0e 94 65 00 	call	0xca	; 0xca <__fixunssfsi>
    7e94:	dc 01       	movw	r26, r24
    7e96:	cb 01       	movw	r24, r22
    7e98:	f8 01       	movw	r30, r16
    7e9a:	91 83       	std	Z+1, r25	; 0x01
    7e9c:	80 83       	st	Z, r24
    7e9e:	de 01       	movw	r26, r28
    7ea0:	a9 5b       	subi	r26, 0xB9	; 185
    7ea2:	bf 4f       	sbci	r27, 0xFF	; 255
    7ea4:	fe 01       	movw	r30, r28
    7ea6:	e5 5b       	subi	r30, 0xB5	; 181
    7ea8:	ff 4f       	sbci	r31, 0xFF	; 255
    7eaa:	80 81       	ld	r24, Z
    7eac:	91 81       	ldd	r25, Z+1	; 0x01
    7eae:	8d 93       	st	X+, r24
    7eb0:	9c 93       	st	X, r25
    7eb2:	fe 01       	movw	r30, r28
    7eb4:	e9 5b       	subi	r30, 0xB9	; 185
    7eb6:	ff 4f       	sbci	r31, 0xFF	; 255
    7eb8:	80 81       	ld	r24, Z
    7eba:	91 81       	ldd	r25, Z+1	; 0x01
    7ebc:	01 97       	sbiw	r24, 0x01	; 1
    7ebe:	f1 f7       	brne	.-4      	; 0x7ebc <LCD_sendCommand+0x2f4>
    7ec0:	fe 01       	movw	r30, r28
    7ec2:	e9 5b       	subi	r30, 0xB9	; 185
    7ec4:	ff 4f       	sbci	r31, 0xFF	; 255
    7ec6:	91 83       	std	Z+1, r25	; 0x01
    7ec8:	80 83       	st	Z, r24
	_delay_ms(1); /* delay for processing Tpw - Tdws = 190ns */

#if(LCD_DATA_BITS_MODE == 4)
	GPIO_writePin(LCD_DATA_PORT_ID,LCD_DB4_PIN_ID,GET_BIT(command,4));
    7eca:	fe 01       	movw	r30, r28
    7ecc:	ed 59       	subi	r30, 0x9D	; 157
    7ece:	ff 4f       	sbci	r31, 0xFF	; 255
    7ed0:	80 81       	ld	r24, Z
    7ed2:	88 2f       	mov	r24, r24
    7ed4:	90 e0       	ldi	r25, 0x00	; 0
    7ed6:	80 71       	andi	r24, 0x10	; 16
    7ed8:	90 70       	andi	r25, 0x00	; 0
    7eda:	95 95       	asr	r25
    7edc:	87 95       	ror	r24
    7ede:	95 95       	asr	r25
    7ee0:	87 95       	ror	r24
    7ee2:	95 95       	asr	r25
    7ee4:	87 95       	ror	r24
    7ee6:	95 95       	asr	r25
    7ee8:	87 95       	ror	r24
    7eea:	98 2f       	mov	r25, r24
    7eec:	83 e0       	ldi	r24, 0x03	; 3
    7eee:	64 e0       	ldi	r22, 0x04	; 4
    7ef0:	49 2f       	mov	r20, r25
    7ef2:	0e 94 9e 38 	call	0x713c	; 0x713c <GPIO_writePin>
	GPIO_writePin(LCD_DATA_PORT_ID,LCD_DB5_PIN_ID,GET_BIT(command,5));
    7ef6:	fe 01       	movw	r30, r28
    7ef8:	ed 59       	subi	r30, 0x9D	; 157
    7efa:	ff 4f       	sbci	r31, 0xFF	; 255
    7efc:	80 81       	ld	r24, Z
    7efe:	88 2f       	mov	r24, r24
    7f00:	90 e0       	ldi	r25, 0x00	; 0
    7f02:	80 72       	andi	r24, 0x20	; 32
    7f04:	90 70       	andi	r25, 0x00	; 0
    7f06:	95 95       	asr	r25
    7f08:	87 95       	ror	r24
    7f0a:	95 95       	asr	r25
    7f0c:	87 95       	ror	r24
    7f0e:	95 95       	asr	r25
    7f10:	87 95       	ror	r24
    7f12:	95 95       	asr	r25
    7f14:	87 95       	ror	r24
    7f16:	95 95       	asr	r25
    7f18:	87 95       	ror	r24
    7f1a:	98 2f       	mov	r25, r24
    7f1c:	83 e0       	ldi	r24, 0x03	; 3
    7f1e:	65 e0       	ldi	r22, 0x05	; 5
    7f20:	49 2f       	mov	r20, r25
    7f22:	0e 94 9e 38 	call	0x713c	; 0x713c <GPIO_writePin>
	GPIO_writePin(LCD_DATA_PORT_ID,LCD_DB6_PIN_ID,GET_BIT(command,6));
    7f26:	fe 01       	movw	r30, r28
    7f28:	ed 59       	subi	r30, 0x9D	; 157
    7f2a:	ff 4f       	sbci	r31, 0xFF	; 255
    7f2c:	80 81       	ld	r24, Z
    7f2e:	88 2f       	mov	r24, r24
    7f30:	90 e0       	ldi	r25, 0x00	; 0
    7f32:	80 74       	andi	r24, 0x40	; 64
    7f34:	90 70       	andi	r25, 0x00	; 0
    7f36:	08 2e       	mov	r0, r24
    7f38:	89 2f       	mov	r24, r25
    7f3a:	00 0c       	add	r0, r0
    7f3c:	88 1f       	adc	r24, r24
    7f3e:	99 0b       	sbc	r25, r25
    7f40:	00 0c       	add	r0, r0
    7f42:	88 1f       	adc	r24, r24
    7f44:	99 1f       	adc	r25, r25
    7f46:	98 2f       	mov	r25, r24
    7f48:	83 e0       	ldi	r24, 0x03	; 3
    7f4a:	66 e0       	ldi	r22, 0x06	; 6
    7f4c:	49 2f       	mov	r20, r25
    7f4e:	0e 94 9e 38 	call	0x713c	; 0x713c <GPIO_writePin>
	GPIO_writePin(LCD_DATA_PORT_ID,LCD_DB7_PIN_ID,GET_BIT(command,7));
    7f52:	fe 01       	movw	r30, r28
    7f54:	ed 59       	subi	r30, 0x9D	; 157
    7f56:	ff 4f       	sbci	r31, 0xFF	; 255
    7f58:	80 81       	ld	r24, Z
    7f5a:	98 2f       	mov	r25, r24
    7f5c:	99 1f       	adc	r25, r25
    7f5e:	99 27       	eor	r25, r25
    7f60:	99 1f       	adc	r25, r25
    7f62:	83 e0       	ldi	r24, 0x03	; 3
    7f64:	67 e0       	ldi	r22, 0x07	; 7
    7f66:	49 2f       	mov	r20, r25
    7f68:	0e 94 9e 38 	call	0x713c	; 0x713c <GPIO_writePin>
    7f6c:	fe 01       	movw	r30, r28
    7f6e:	ed 5b       	subi	r30, 0xBD	; 189
    7f70:	ff 4f       	sbci	r31, 0xFF	; 255
    7f72:	80 e0       	ldi	r24, 0x00	; 0
    7f74:	90 e0       	ldi	r25, 0x00	; 0
    7f76:	a0 e8       	ldi	r26, 0x80	; 128
    7f78:	bf e3       	ldi	r27, 0x3F	; 63
    7f7a:	80 83       	st	Z, r24
    7f7c:	91 83       	std	Z+1, r25	; 0x01
    7f7e:	a2 83       	std	Z+2, r26	; 0x02
    7f80:	b3 83       	std	Z+3, r27	; 0x03
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    7f82:	8e 01       	movw	r16, r28
    7f84:	01 5c       	subi	r16, 0xC1	; 193
    7f86:	1f 4f       	sbci	r17, 0xFF	; 255
    7f88:	fe 01       	movw	r30, r28
    7f8a:	ed 5b       	subi	r30, 0xBD	; 189
    7f8c:	ff 4f       	sbci	r31, 0xFF	; 255
    7f8e:	60 81       	ld	r22, Z
    7f90:	71 81       	ldd	r23, Z+1	; 0x01
    7f92:	82 81       	ldd	r24, Z+2	; 0x02
    7f94:	93 81       	ldd	r25, Z+3	; 0x03
    7f96:	20 e0       	ldi	r18, 0x00	; 0
    7f98:	30 e0       	ldi	r19, 0x00	; 0
    7f9a:	4a e7       	ldi	r20, 0x7A	; 122
    7f9c:	55 e4       	ldi	r21, 0x45	; 69
    7f9e:	0e 94 3b 02 	call	0x476	; 0x476 <__mulsf3>
    7fa2:	dc 01       	movw	r26, r24
    7fa4:	cb 01       	movw	r24, r22
    7fa6:	f8 01       	movw	r30, r16
    7fa8:	80 83       	st	Z, r24
    7faa:	91 83       	std	Z+1, r25	; 0x01
    7fac:	a2 83       	std	Z+2, r26	; 0x02
    7fae:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    7fb0:	fe 01       	movw	r30, r28
    7fb2:	ff 96       	adiw	r30, 0x3f	; 63
    7fb4:	60 81       	ld	r22, Z
    7fb6:	71 81       	ldd	r23, Z+1	; 0x01
    7fb8:	82 81       	ldd	r24, Z+2	; 0x02
    7fba:	93 81       	ldd	r25, Z+3	; 0x03
    7fbc:	20 e0       	ldi	r18, 0x00	; 0
    7fbe:	30 e0       	ldi	r19, 0x00	; 0
    7fc0:	40 e8       	ldi	r20, 0x80	; 128
    7fc2:	5f e3       	ldi	r21, 0x3F	; 63
    7fc4:	0e 94 41 04 	call	0x882	; 0x882 <__ltsf2>
    7fc8:	88 23       	and	r24, r24
    7fca:	2c f4       	brge	.+10     	; 0x7fd6 <LCD_sendCommand+0x40e>
		__ticks = 1;
    7fcc:	81 e0       	ldi	r24, 0x01	; 1
    7fce:	90 e0       	ldi	r25, 0x00	; 0
    7fd0:	9e af       	std	Y+62, r25	; 0x3e
    7fd2:	8d af       	std	Y+61, r24	; 0x3d
    7fd4:	46 c0       	rjmp	.+140    	; 0x8062 <LCD_sendCommand+0x49a>
	else if (__tmp > 65535)
    7fd6:	fe 01       	movw	r30, r28
    7fd8:	ff 96       	adiw	r30, 0x3f	; 63
    7fda:	60 81       	ld	r22, Z
    7fdc:	71 81       	ldd	r23, Z+1	; 0x01
    7fde:	82 81       	ldd	r24, Z+2	; 0x02
    7fe0:	93 81       	ldd	r25, Z+3	; 0x03
    7fe2:	20 e0       	ldi	r18, 0x00	; 0
    7fe4:	3f ef       	ldi	r19, 0xFF	; 255
    7fe6:	4f e7       	ldi	r20, 0x7F	; 127
    7fe8:	57 e4       	ldi	r21, 0x47	; 71
    7fea:	0e 94 e1 03 	call	0x7c2	; 0x7c2 <__gtsf2>
    7fee:	18 16       	cp	r1, r24
    7ff0:	64 f5       	brge	.+88     	; 0x804a <LCD_sendCommand+0x482>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    7ff2:	fe 01       	movw	r30, r28
    7ff4:	ed 5b       	subi	r30, 0xBD	; 189
    7ff6:	ff 4f       	sbci	r31, 0xFF	; 255
    7ff8:	60 81       	ld	r22, Z
    7ffa:	71 81       	ldd	r23, Z+1	; 0x01
    7ffc:	82 81       	ldd	r24, Z+2	; 0x02
    7ffe:	93 81       	ldd	r25, Z+3	; 0x03
    8000:	20 e0       	ldi	r18, 0x00	; 0
    8002:	30 e0       	ldi	r19, 0x00	; 0
    8004:	40 e2       	ldi	r20, 0x20	; 32
    8006:	51 e4       	ldi	r21, 0x41	; 65
    8008:	0e 94 3b 02 	call	0x476	; 0x476 <__mulsf3>
    800c:	dc 01       	movw	r26, r24
    800e:	cb 01       	movw	r24, r22
    8010:	bc 01       	movw	r22, r24
    8012:	cd 01       	movw	r24, r26
    8014:	0e 94 65 00 	call	0xca	; 0xca <__fixunssfsi>
    8018:	dc 01       	movw	r26, r24
    801a:	cb 01       	movw	r24, r22
    801c:	9e af       	std	Y+62, r25	; 0x3e
    801e:	8d af       	std	Y+61, r24	; 0x3d
    8020:	0f c0       	rjmp	.+30     	; 0x8040 <LCD_sendCommand+0x478>
    8022:	80 e9       	ldi	r24, 0x90	; 144
    8024:	91 e0       	ldi	r25, 0x01	; 1
    8026:	9c af       	std	Y+60, r25	; 0x3c
    8028:	8b af       	std	Y+59, r24	; 0x3b
    802a:	8b ad       	ldd	r24, Y+59	; 0x3b
    802c:	9c ad       	ldd	r25, Y+60	; 0x3c
    802e:	01 97       	sbiw	r24, 0x01	; 1
    8030:	f1 f7       	brne	.-4      	; 0x802e <LCD_sendCommand+0x466>
    8032:	9c af       	std	Y+60, r25	; 0x3c
    8034:	8b af       	std	Y+59, r24	; 0x3b
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    8036:	8d ad       	ldd	r24, Y+61	; 0x3d
    8038:	9e ad       	ldd	r25, Y+62	; 0x3e
    803a:	01 97       	sbiw	r24, 0x01	; 1
    803c:	9e af       	std	Y+62, r25	; 0x3e
    803e:	8d af       	std	Y+61, r24	; 0x3d
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    8040:	8d ad       	ldd	r24, Y+61	; 0x3d
    8042:	9e ad       	ldd	r25, Y+62	; 0x3e
    8044:	00 97       	sbiw	r24, 0x00	; 0
    8046:	69 f7       	brne	.-38     	; 0x8022 <LCD_sendCommand+0x45a>
    8048:	16 c0       	rjmp	.+44     	; 0x8076 <LCD_sendCommand+0x4ae>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    804a:	fe 01       	movw	r30, r28
    804c:	ff 96       	adiw	r30, 0x3f	; 63
    804e:	60 81       	ld	r22, Z
    8050:	71 81       	ldd	r23, Z+1	; 0x01
    8052:	82 81       	ldd	r24, Z+2	; 0x02
    8054:	93 81       	ldd	r25, Z+3	; 0x03
    8056:	0e 94 65 00 	call	0xca	; 0xca <__fixunssfsi>
    805a:	dc 01       	movw	r26, r24
    805c:	cb 01       	movw	r24, r22
    805e:	9e af       	std	Y+62, r25	; 0x3e
    8060:	8d af       	std	Y+61, r24	; 0x3d
    8062:	8d ad       	ldd	r24, Y+61	; 0x3d
    8064:	9e ad       	ldd	r25, Y+62	; 0x3e
    8066:	9a af       	std	Y+58, r25	; 0x3a
    8068:	89 af       	std	Y+57, r24	; 0x39
    806a:	89 ad       	ldd	r24, Y+57	; 0x39
    806c:	9a ad       	ldd	r25, Y+58	; 0x3a
    806e:	01 97       	sbiw	r24, 0x01	; 1
    8070:	f1 f7       	brne	.-4      	; 0x806e <LCD_sendCommand+0x4a6>
    8072:	9a af       	std	Y+58, r25	; 0x3a
    8074:	89 af       	std	Y+57, r24	; 0x39

	_delay_ms(1); /* delay for processing Tdsw = 100ns */
	GPIO_writePin(LCD_E_PORT_ID,LCD_E_PIN_ID,LOGIC_LOW); /* Disable LCD E=0 */
    8076:	83 e0       	ldi	r24, 0x03	; 3
    8078:	62 e0       	ldi	r22, 0x02	; 2
    807a:	40 e0       	ldi	r20, 0x00	; 0
    807c:	0e 94 9e 38 	call	0x713c	; 0x713c <GPIO_writePin>
    8080:	80 e0       	ldi	r24, 0x00	; 0
    8082:	90 e0       	ldi	r25, 0x00	; 0
    8084:	a0 e8       	ldi	r26, 0x80	; 128
    8086:	bf e3       	ldi	r27, 0x3F	; 63
    8088:	8d ab       	std	Y+53, r24	; 0x35
    808a:	9e ab       	std	Y+54, r25	; 0x36
    808c:	af ab       	std	Y+55, r26	; 0x37
    808e:	b8 af       	std	Y+56, r27	; 0x38
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    8090:	6d a9       	ldd	r22, Y+53	; 0x35
    8092:	7e a9       	ldd	r23, Y+54	; 0x36
    8094:	8f a9       	ldd	r24, Y+55	; 0x37
    8096:	98 ad       	ldd	r25, Y+56	; 0x38
    8098:	20 e0       	ldi	r18, 0x00	; 0
    809a:	30 e0       	ldi	r19, 0x00	; 0
    809c:	4a e7       	ldi	r20, 0x7A	; 122
    809e:	55 e4       	ldi	r21, 0x45	; 69
    80a0:	0e 94 3b 02 	call	0x476	; 0x476 <__mulsf3>
    80a4:	dc 01       	movw	r26, r24
    80a6:	cb 01       	movw	r24, r22
    80a8:	89 ab       	std	Y+49, r24	; 0x31
    80aa:	9a ab       	std	Y+50, r25	; 0x32
    80ac:	ab ab       	std	Y+51, r26	; 0x33
    80ae:	bc ab       	std	Y+52, r27	; 0x34
	if (__tmp < 1.0)
    80b0:	69 a9       	ldd	r22, Y+49	; 0x31
    80b2:	7a a9       	ldd	r23, Y+50	; 0x32
    80b4:	8b a9       	ldd	r24, Y+51	; 0x33
    80b6:	9c a9       	ldd	r25, Y+52	; 0x34
    80b8:	20 e0       	ldi	r18, 0x00	; 0
    80ba:	30 e0       	ldi	r19, 0x00	; 0
    80bc:	40 e8       	ldi	r20, 0x80	; 128
    80be:	5f e3       	ldi	r21, 0x3F	; 63
    80c0:	0e 94 41 04 	call	0x882	; 0x882 <__ltsf2>
    80c4:	88 23       	and	r24, r24
    80c6:	2c f4       	brge	.+10     	; 0x80d2 <LCD_sendCommand+0x50a>
		__ticks = 1;
    80c8:	81 e0       	ldi	r24, 0x01	; 1
    80ca:	90 e0       	ldi	r25, 0x00	; 0
    80cc:	98 ab       	std	Y+48, r25	; 0x30
    80ce:	8f a7       	std	Y+47, r24	; 0x2f
    80d0:	3f c0       	rjmp	.+126    	; 0x8150 <LCD_sendCommand+0x588>
	else if (__tmp > 65535)
    80d2:	69 a9       	ldd	r22, Y+49	; 0x31
    80d4:	7a a9       	ldd	r23, Y+50	; 0x32
    80d6:	8b a9       	ldd	r24, Y+51	; 0x33
    80d8:	9c a9       	ldd	r25, Y+52	; 0x34
    80da:	20 e0       	ldi	r18, 0x00	; 0
    80dc:	3f ef       	ldi	r19, 0xFF	; 255
    80de:	4f e7       	ldi	r20, 0x7F	; 127
    80e0:	57 e4       	ldi	r21, 0x47	; 71
    80e2:	0e 94 e1 03 	call	0x7c2	; 0x7c2 <__gtsf2>
    80e6:	18 16       	cp	r1, r24
    80e8:	4c f5       	brge	.+82     	; 0x813c <LCD_sendCommand+0x574>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    80ea:	6d a9       	ldd	r22, Y+53	; 0x35
    80ec:	7e a9       	ldd	r23, Y+54	; 0x36
    80ee:	8f a9       	ldd	r24, Y+55	; 0x37
    80f0:	98 ad       	ldd	r25, Y+56	; 0x38
    80f2:	20 e0       	ldi	r18, 0x00	; 0
    80f4:	30 e0       	ldi	r19, 0x00	; 0
    80f6:	40 e2       	ldi	r20, 0x20	; 32
    80f8:	51 e4       	ldi	r21, 0x41	; 65
    80fa:	0e 94 3b 02 	call	0x476	; 0x476 <__mulsf3>
    80fe:	dc 01       	movw	r26, r24
    8100:	cb 01       	movw	r24, r22
    8102:	bc 01       	movw	r22, r24
    8104:	cd 01       	movw	r24, r26
    8106:	0e 94 65 00 	call	0xca	; 0xca <__fixunssfsi>
    810a:	dc 01       	movw	r26, r24
    810c:	cb 01       	movw	r24, r22
    810e:	98 ab       	std	Y+48, r25	; 0x30
    8110:	8f a7       	std	Y+47, r24	; 0x2f
    8112:	0f c0       	rjmp	.+30     	; 0x8132 <LCD_sendCommand+0x56a>
    8114:	80 e9       	ldi	r24, 0x90	; 144
    8116:	91 e0       	ldi	r25, 0x01	; 1
    8118:	9e a7       	std	Y+46, r25	; 0x2e
    811a:	8d a7       	std	Y+45, r24	; 0x2d
    811c:	8d a5       	ldd	r24, Y+45	; 0x2d
    811e:	9e a5       	ldd	r25, Y+46	; 0x2e
    8120:	01 97       	sbiw	r24, 0x01	; 1
    8122:	f1 f7       	brne	.-4      	; 0x8120 <LCD_sendCommand+0x558>
    8124:	9e a7       	std	Y+46, r25	; 0x2e
    8126:	8d a7       	std	Y+45, r24	; 0x2d
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    8128:	8f a5       	ldd	r24, Y+47	; 0x2f
    812a:	98 a9       	ldd	r25, Y+48	; 0x30
    812c:	01 97       	sbiw	r24, 0x01	; 1
    812e:	98 ab       	std	Y+48, r25	; 0x30
    8130:	8f a7       	std	Y+47, r24	; 0x2f
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    8132:	8f a5       	ldd	r24, Y+47	; 0x2f
    8134:	98 a9       	ldd	r25, Y+48	; 0x30
    8136:	00 97       	sbiw	r24, 0x00	; 0
    8138:	69 f7       	brne	.-38     	; 0x8114 <LCD_sendCommand+0x54c>
    813a:	14 c0       	rjmp	.+40     	; 0x8164 <LCD_sendCommand+0x59c>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    813c:	69 a9       	ldd	r22, Y+49	; 0x31
    813e:	7a a9       	ldd	r23, Y+50	; 0x32
    8140:	8b a9       	ldd	r24, Y+51	; 0x33
    8142:	9c a9       	ldd	r25, Y+52	; 0x34
    8144:	0e 94 65 00 	call	0xca	; 0xca <__fixunssfsi>
    8148:	dc 01       	movw	r26, r24
    814a:	cb 01       	movw	r24, r22
    814c:	98 ab       	std	Y+48, r25	; 0x30
    814e:	8f a7       	std	Y+47, r24	; 0x2f
    8150:	8f a5       	ldd	r24, Y+47	; 0x2f
    8152:	98 a9       	ldd	r25, Y+48	; 0x30
    8154:	9c a7       	std	Y+44, r25	; 0x2c
    8156:	8b a7       	std	Y+43, r24	; 0x2b
    8158:	8b a5       	ldd	r24, Y+43	; 0x2b
    815a:	9c a5       	ldd	r25, Y+44	; 0x2c
    815c:	01 97       	sbiw	r24, 0x01	; 1
    815e:	f1 f7       	brne	.-4      	; 0x815c <LCD_sendCommand+0x594>
    8160:	9c a7       	std	Y+44, r25	; 0x2c
    8162:	8b a7       	std	Y+43, r24	; 0x2b
	_delay_ms(1); /* delay for processing Th = 13ns */
	GPIO_writePin(LCD_E_PORT_ID,LCD_E_PIN_ID,LOGIC_HIGH); /* Enable LCD E=1 */
    8164:	83 e0       	ldi	r24, 0x03	; 3
    8166:	62 e0       	ldi	r22, 0x02	; 2
    8168:	41 e0       	ldi	r20, 0x01	; 1
    816a:	0e 94 9e 38 	call	0x713c	; 0x713c <GPIO_writePin>
    816e:	80 e0       	ldi	r24, 0x00	; 0
    8170:	90 e0       	ldi	r25, 0x00	; 0
    8172:	a0 e8       	ldi	r26, 0x80	; 128
    8174:	bf e3       	ldi	r27, 0x3F	; 63
    8176:	8f a3       	std	Y+39, r24	; 0x27
    8178:	98 a7       	std	Y+40, r25	; 0x28
    817a:	a9 a7       	std	Y+41, r26	; 0x29
    817c:	ba a7       	std	Y+42, r27	; 0x2a
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    817e:	6f a1       	ldd	r22, Y+39	; 0x27
    8180:	78 a5       	ldd	r23, Y+40	; 0x28
    8182:	89 a5       	ldd	r24, Y+41	; 0x29
    8184:	9a a5       	ldd	r25, Y+42	; 0x2a
    8186:	20 e0       	ldi	r18, 0x00	; 0
    8188:	30 e0       	ldi	r19, 0x00	; 0
    818a:	4a e7       	ldi	r20, 0x7A	; 122
    818c:	55 e4       	ldi	r21, 0x45	; 69
    818e:	0e 94 3b 02 	call	0x476	; 0x476 <__mulsf3>
    8192:	dc 01       	movw	r26, r24
    8194:	cb 01       	movw	r24, r22
    8196:	8b a3       	std	Y+35, r24	; 0x23
    8198:	9c a3       	std	Y+36, r25	; 0x24
    819a:	ad a3       	std	Y+37, r26	; 0x25
    819c:	be a3       	std	Y+38, r27	; 0x26
	if (__tmp < 1.0)
    819e:	6b a1       	ldd	r22, Y+35	; 0x23
    81a0:	7c a1       	ldd	r23, Y+36	; 0x24
    81a2:	8d a1       	ldd	r24, Y+37	; 0x25
    81a4:	9e a1       	ldd	r25, Y+38	; 0x26
    81a6:	20 e0       	ldi	r18, 0x00	; 0
    81a8:	30 e0       	ldi	r19, 0x00	; 0
    81aa:	40 e8       	ldi	r20, 0x80	; 128
    81ac:	5f e3       	ldi	r21, 0x3F	; 63
    81ae:	0e 94 41 04 	call	0x882	; 0x882 <__ltsf2>
    81b2:	88 23       	and	r24, r24
    81b4:	2c f4       	brge	.+10     	; 0x81c0 <LCD_sendCommand+0x5f8>
		__ticks = 1;
    81b6:	81 e0       	ldi	r24, 0x01	; 1
    81b8:	90 e0       	ldi	r25, 0x00	; 0
    81ba:	9a a3       	std	Y+34, r25	; 0x22
    81bc:	89 a3       	std	Y+33, r24	; 0x21
    81be:	3f c0       	rjmp	.+126    	; 0x823e <LCD_sendCommand+0x676>
	else if (__tmp > 65535)
    81c0:	6b a1       	ldd	r22, Y+35	; 0x23
    81c2:	7c a1       	ldd	r23, Y+36	; 0x24
    81c4:	8d a1       	ldd	r24, Y+37	; 0x25
    81c6:	9e a1       	ldd	r25, Y+38	; 0x26
    81c8:	20 e0       	ldi	r18, 0x00	; 0
    81ca:	3f ef       	ldi	r19, 0xFF	; 255
    81cc:	4f e7       	ldi	r20, 0x7F	; 127
    81ce:	57 e4       	ldi	r21, 0x47	; 71
    81d0:	0e 94 e1 03 	call	0x7c2	; 0x7c2 <__gtsf2>
    81d4:	18 16       	cp	r1, r24
    81d6:	4c f5       	brge	.+82     	; 0x822a <LCD_sendCommand+0x662>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    81d8:	6f a1       	ldd	r22, Y+39	; 0x27
    81da:	78 a5       	ldd	r23, Y+40	; 0x28
    81dc:	89 a5       	ldd	r24, Y+41	; 0x29
    81de:	9a a5       	ldd	r25, Y+42	; 0x2a
    81e0:	20 e0       	ldi	r18, 0x00	; 0
    81e2:	30 e0       	ldi	r19, 0x00	; 0
    81e4:	40 e2       	ldi	r20, 0x20	; 32
    81e6:	51 e4       	ldi	r21, 0x41	; 65
    81e8:	0e 94 3b 02 	call	0x476	; 0x476 <__mulsf3>
    81ec:	dc 01       	movw	r26, r24
    81ee:	cb 01       	movw	r24, r22
    81f0:	bc 01       	movw	r22, r24
    81f2:	cd 01       	movw	r24, r26
    81f4:	0e 94 65 00 	call	0xca	; 0xca <__fixunssfsi>
    81f8:	dc 01       	movw	r26, r24
    81fa:	cb 01       	movw	r24, r22
    81fc:	9a a3       	std	Y+34, r25	; 0x22
    81fe:	89 a3       	std	Y+33, r24	; 0x21
    8200:	0f c0       	rjmp	.+30     	; 0x8220 <LCD_sendCommand+0x658>
    8202:	80 e9       	ldi	r24, 0x90	; 144
    8204:	91 e0       	ldi	r25, 0x01	; 1
    8206:	98 a3       	std	Y+32, r25	; 0x20
    8208:	8f 8f       	std	Y+31, r24	; 0x1f
    820a:	8f 8d       	ldd	r24, Y+31	; 0x1f
    820c:	98 a1       	ldd	r25, Y+32	; 0x20
    820e:	01 97       	sbiw	r24, 0x01	; 1
    8210:	f1 f7       	brne	.-4      	; 0x820e <LCD_sendCommand+0x646>
    8212:	98 a3       	std	Y+32, r25	; 0x20
    8214:	8f 8f       	std	Y+31, r24	; 0x1f
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    8216:	89 a1       	ldd	r24, Y+33	; 0x21
    8218:	9a a1       	ldd	r25, Y+34	; 0x22
    821a:	01 97       	sbiw	r24, 0x01	; 1
    821c:	9a a3       	std	Y+34, r25	; 0x22
    821e:	89 a3       	std	Y+33, r24	; 0x21
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    8220:	89 a1       	ldd	r24, Y+33	; 0x21
    8222:	9a a1       	ldd	r25, Y+34	; 0x22
    8224:	00 97       	sbiw	r24, 0x00	; 0
    8226:	69 f7       	brne	.-38     	; 0x8202 <LCD_sendCommand+0x63a>
    8228:	14 c0       	rjmp	.+40     	; 0x8252 <LCD_sendCommand+0x68a>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    822a:	6b a1       	ldd	r22, Y+35	; 0x23
    822c:	7c a1       	ldd	r23, Y+36	; 0x24
    822e:	8d a1       	ldd	r24, Y+37	; 0x25
    8230:	9e a1       	ldd	r25, Y+38	; 0x26
    8232:	0e 94 65 00 	call	0xca	; 0xca <__fixunssfsi>
    8236:	dc 01       	movw	r26, r24
    8238:	cb 01       	movw	r24, r22
    823a:	9a a3       	std	Y+34, r25	; 0x22
    823c:	89 a3       	std	Y+33, r24	; 0x21
    823e:	89 a1       	ldd	r24, Y+33	; 0x21
    8240:	9a a1       	ldd	r25, Y+34	; 0x22
    8242:	9e 8f       	std	Y+30, r25	; 0x1e
    8244:	8d 8f       	std	Y+29, r24	; 0x1d
    8246:	8d 8d       	ldd	r24, Y+29	; 0x1d
    8248:	9e 8d       	ldd	r25, Y+30	; 0x1e
    824a:	01 97       	sbiw	r24, 0x01	; 1
    824c:	f1 f7       	brne	.-4      	; 0x824a <LCD_sendCommand+0x682>
    824e:	9e 8f       	std	Y+30, r25	; 0x1e
    8250:	8d 8f       	std	Y+29, r24	; 0x1d
	_delay_ms(1); /* delay for processing Tpw - Tdws = 190ns */

	GPIO_writePin(LCD_DATA_PORT_ID,LCD_DB4_PIN_ID,GET_BIT(command,0));
    8252:	fe 01       	movw	r30, r28
    8254:	ed 59       	subi	r30, 0x9D	; 157
    8256:	ff 4f       	sbci	r31, 0xFF	; 255
    8258:	80 81       	ld	r24, Z
    825a:	98 2f       	mov	r25, r24
    825c:	91 70       	andi	r25, 0x01	; 1
    825e:	83 e0       	ldi	r24, 0x03	; 3
    8260:	64 e0       	ldi	r22, 0x04	; 4
    8262:	49 2f       	mov	r20, r25
    8264:	0e 94 9e 38 	call	0x713c	; 0x713c <GPIO_writePin>
	GPIO_writePin(LCD_DATA_PORT_ID,LCD_DB5_PIN_ID,GET_BIT(command,1));
    8268:	fe 01       	movw	r30, r28
    826a:	ed 59       	subi	r30, 0x9D	; 157
    826c:	ff 4f       	sbci	r31, 0xFF	; 255
    826e:	80 81       	ld	r24, Z
    8270:	88 2f       	mov	r24, r24
    8272:	90 e0       	ldi	r25, 0x00	; 0
    8274:	82 70       	andi	r24, 0x02	; 2
    8276:	90 70       	andi	r25, 0x00	; 0
    8278:	95 95       	asr	r25
    827a:	87 95       	ror	r24
    827c:	98 2f       	mov	r25, r24
    827e:	83 e0       	ldi	r24, 0x03	; 3
    8280:	65 e0       	ldi	r22, 0x05	; 5
    8282:	49 2f       	mov	r20, r25
    8284:	0e 94 9e 38 	call	0x713c	; 0x713c <GPIO_writePin>
	GPIO_writePin(LCD_DATA_PORT_ID,LCD_DB6_PIN_ID,GET_BIT(command,2));
    8288:	fe 01       	movw	r30, r28
    828a:	ed 59       	subi	r30, 0x9D	; 157
    828c:	ff 4f       	sbci	r31, 0xFF	; 255
    828e:	80 81       	ld	r24, Z
    8290:	88 2f       	mov	r24, r24
    8292:	90 e0       	ldi	r25, 0x00	; 0
    8294:	84 70       	andi	r24, 0x04	; 4
    8296:	90 70       	andi	r25, 0x00	; 0
    8298:	95 95       	asr	r25
    829a:	87 95       	ror	r24
    829c:	95 95       	asr	r25
    829e:	87 95       	ror	r24
    82a0:	98 2f       	mov	r25, r24
    82a2:	83 e0       	ldi	r24, 0x03	; 3
    82a4:	66 e0       	ldi	r22, 0x06	; 6
    82a6:	49 2f       	mov	r20, r25
    82a8:	0e 94 9e 38 	call	0x713c	; 0x713c <GPIO_writePin>
	GPIO_writePin(LCD_DATA_PORT_ID,LCD_DB7_PIN_ID,GET_BIT(command,3));
    82ac:	fe 01       	movw	r30, r28
    82ae:	ed 59       	subi	r30, 0x9D	; 157
    82b0:	ff 4f       	sbci	r31, 0xFF	; 255
    82b2:	80 81       	ld	r24, Z
    82b4:	88 2f       	mov	r24, r24
    82b6:	90 e0       	ldi	r25, 0x00	; 0
    82b8:	88 70       	andi	r24, 0x08	; 8
    82ba:	90 70       	andi	r25, 0x00	; 0
    82bc:	95 95       	asr	r25
    82be:	87 95       	ror	r24
    82c0:	95 95       	asr	r25
    82c2:	87 95       	ror	r24
    82c4:	95 95       	asr	r25
    82c6:	87 95       	ror	r24
    82c8:	98 2f       	mov	r25, r24
    82ca:	83 e0       	ldi	r24, 0x03	; 3
    82cc:	67 e0       	ldi	r22, 0x07	; 7
    82ce:	49 2f       	mov	r20, r25
    82d0:	0e 94 9e 38 	call	0x713c	; 0x713c <GPIO_writePin>
    82d4:	80 e0       	ldi	r24, 0x00	; 0
    82d6:	90 e0       	ldi	r25, 0x00	; 0
    82d8:	a0 e8       	ldi	r26, 0x80	; 128
    82da:	bf e3       	ldi	r27, 0x3F	; 63
    82dc:	89 8f       	std	Y+25, r24	; 0x19
    82de:	9a 8f       	std	Y+26, r25	; 0x1a
    82e0:	ab 8f       	std	Y+27, r26	; 0x1b
    82e2:	bc 8f       	std	Y+28, r27	; 0x1c
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    82e4:	69 8d       	ldd	r22, Y+25	; 0x19
    82e6:	7a 8d       	ldd	r23, Y+26	; 0x1a
    82e8:	8b 8d       	ldd	r24, Y+27	; 0x1b
    82ea:	9c 8d       	ldd	r25, Y+28	; 0x1c
    82ec:	20 e0       	ldi	r18, 0x00	; 0
    82ee:	30 e0       	ldi	r19, 0x00	; 0
    82f0:	4a e7       	ldi	r20, 0x7A	; 122
    82f2:	55 e4       	ldi	r21, 0x45	; 69
    82f4:	0e 94 3b 02 	call	0x476	; 0x476 <__mulsf3>
    82f8:	dc 01       	movw	r26, r24
    82fa:	cb 01       	movw	r24, r22
    82fc:	8d 8b       	std	Y+21, r24	; 0x15
    82fe:	9e 8b       	std	Y+22, r25	; 0x16
    8300:	af 8b       	std	Y+23, r26	; 0x17
    8302:	b8 8f       	std	Y+24, r27	; 0x18
	if (__tmp < 1.0)
    8304:	6d 89       	ldd	r22, Y+21	; 0x15
    8306:	7e 89       	ldd	r23, Y+22	; 0x16
    8308:	8f 89       	ldd	r24, Y+23	; 0x17
    830a:	98 8d       	ldd	r25, Y+24	; 0x18
    830c:	20 e0       	ldi	r18, 0x00	; 0
    830e:	30 e0       	ldi	r19, 0x00	; 0
    8310:	40 e8       	ldi	r20, 0x80	; 128
    8312:	5f e3       	ldi	r21, 0x3F	; 63
    8314:	0e 94 41 04 	call	0x882	; 0x882 <__ltsf2>
    8318:	88 23       	and	r24, r24
    831a:	2c f4       	brge	.+10     	; 0x8326 <LCD_sendCommand+0x75e>
		__ticks = 1;
    831c:	81 e0       	ldi	r24, 0x01	; 1
    831e:	90 e0       	ldi	r25, 0x00	; 0
    8320:	9c 8b       	std	Y+20, r25	; 0x14
    8322:	8b 8b       	std	Y+19, r24	; 0x13
    8324:	3f c0       	rjmp	.+126    	; 0x83a4 <LCD_sendCommand+0x7dc>
	else if (__tmp > 65535)
    8326:	6d 89       	ldd	r22, Y+21	; 0x15
    8328:	7e 89       	ldd	r23, Y+22	; 0x16
    832a:	8f 89       	ldd	r24, Y+23	; 0x17
    832c:	98 8d       	ldd	r25, Y+24	; 0x18
    832e:	20 e0       	ldi	r18, 0x00	; 0
    8330:	3f ef       	ldi	r19, 0xFF	; 255
    8332:	4f e7       	ldi	r20, 0x7F	; 127
    8334:	57 e4       	ldi	r21, 0x47	; 71
    8336:	0e 94 e1 03 	call	0x7c2	; 0x7c2 <__gtsf2>
    833a:	18 16       	cp	r1, r24
    833c:	4c f5       	brge	.+82     	; 0x8390 <LCD_sendCommand+0x7c8>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    833e:	69 8d       	ldd	r22, Y+25	; 0x19
    8340:	7a 8d       	ldd	r23, Y+26	; 0x1a
    8342:	8b 8d       	ldd	r24, Y+27	; 0x1b
    8344:	9c 8d       	ldd	r25, Y+28	; 0x1c
    8346:	20 e0       	ldi	r18, 0x00	; 0
    8348:	30 e0       	ldi	r19, 0x00	; 0
    834a:	40 e2       	ldi	r20, 0x20	; 32
    834c:	51 e4       	ldi	r21, 0x41	; 65
    834e:	0e 94 3b 02 	call	0x476	; 0x476 <__mulsf3>
    8352:	dc 01       	movw	r26, r24
    8354:	cb 01       	movw	r24, r22
    8356:	bc 01       	movw	r22, r24
    8358:	cd 01       	movw	r24, r26
    835a:	0e 94 65 00 	call	0xca	; 0xca <__fixunssfsi>
    835e:	dc 01       	movw	r26, r24
    8360:	cb 01       	movw	r24, r22
    8362:	9c 8b       	std	Y+20, r25	; 0x14
    8364:	8b 8b       	std	Y+19, r24	; 0x13
    8366:	0f c0       	rjmp	.+30     	; 0x8386 <LCD_sendCommand+0x7be>
    8368:	80 e9       	ldi	r24, 0x90	; 144
    836a:	91 e0       	ldi	r25, 0x01	; 1
    836c:	9a 8b       	std	Y+18, r25	; 0x12
    836e:	89 8b       	std	Y+17, r24	; 0x11
    8370:	89 89       	ldd	r24, Y+17	; 0x11
    8372:	9a 89       	ldd	r25, Y+18	; 0x12
    8374:	01 97       	sbiw	r24, 0x01	; 1
    8376:	f1 f7       	brne	.-4      	; 0x8374 <LCD_sendCommand+0x7ac>
    8378:	9a 8b       	std	Y+18, r25	; 0x12
    837a:	89 8b       	std	Y+17, r24	; 0x11
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    837c:	8b 89       	ldd	r24, Y+19	; 0x13
    837e:	9c 89       	ldd	r25, Y+20	; 0x14
    8380:	01 97       	sbiw	r24, 0x01	; 1
    8382:	9c 8b       	std	Y+20, r25	; 0x14
    8384:	8b 8b       	std	Y+19, r24	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    8386:	8b 89       	ldd	r24, Y+19	; 0x13
    8388:	9c 89       	ldd	r25, Y+20	; 0x14
    838a:	00 97       	sbiw	r24, 0x00	; 0
    838c:	69 f7       	brne	.-38     	; 0x8368 <LCD_sendCommand+0x7a0>
    838e:	14 c0       	rjmp	.+40     	; 0x83b8 <LCD_sendCommand+0x7f0>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    8390:	6d 89       	ldd	r22, Y+21	; 0x15
    8392:	7e 89       	ldd	r23, Y+22	; 0x16
    8394:	8f 89       	ldd	r24, Y+23	; 0x17
    8396:	98 8d       	ldd	r25, Y+24	; 0x18
    8398:	0e 94 65 00 	call	0xca	; 0xca <__fixunssfsi>
    839c:	dc 01       	movw	r26, r24
    839e:	cb 01       	movw	r24, r22
    83a0:	9c 8b       	std	Y+20, r25	; 0x14
    83a2:	8b 8b       	std	Y+19, r24	; 0x13
    83a4:	8b 89       	ldd	r24, Y+19	; 0x13
    83a6:	9c 89       	ldd	r25, Y+20	; 0x14
    83a8:	98 8b       	std	Y+16, r25	; 0x10
    83aa:	8f 87       	std	Y+15, r24	; 0x0f
    83ac:	8f 85       	ldd	r24, Y+15	; 0x0f
    83ae:	98 89       	ldd	r25, Y+16	; 0x10
    83b0:	01 97       	sbiw	r24, 0x01	; 1
    83b2:	f1 f7       	brne	.-4      	; 0x83b0 <LCD_sendCommand+0x7e8>
    83b4:	98 8b       	std	Y+16, r25	; 0x10
    83b6:	8f 87       	std	Y+15, r24	; 0x0f

	_delay_ms(1); /* delay for processing Tdsw = 100ns */
	GPIO_writePin(LCD_E_PORT_ID,LCD_E_PIN_ID,LOGIC_LOW); /* Disable LCD E=0 */
    83b8:	83 e0       	ldi	r24, 0x03	; 3
    83ba:	62 e0       	ldi	r22, 0x02	; 2
    83bc:	40 e0       	ldi	r20, 0x00	; 0
    83be:	0e 94 9e 38 	call	0x713c	; 0x713c <GPIO_writePin>
    83c2:	80 e0       	ldi	r24, 0x00	; 0
    83c4:	90 e0       	ldi	r25, 0x00	; 0
    83c6:	a0 e8       	ldi	r26, 0x80	; 128
    83c8:	bf e3       	ldi	r27, 0x3F	; 63
    83ca:	8b 87       	std	Y+11, r24	; 0x0b
    83cc:	9c 87       	std	Y+12, r25	; 0x0c
    83ce:	ad 87       	std	Y+13, r26	; 0x0d
    83d0:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    83d2:	6b 85       	ldd	r22, Y+11	; 0x0b
    83d4:	7c 85       	ldd	r23, Y+12	; 0x0c
    83d6:	8d 85       	ldd	r24, Y+13	; 0x0d
    83d8:	9e 85       	ldd	r25, Y+14	; 0x0e
    83da:	20 e0       	ldi	r18, 0x00	; 0
    83dc:	30 e0       	ldi	r19, 0x00	; 0
    83de:	4a e7       	ldi	r20, 0x7A	; 122
    83e0:	55 e4       	ldi	r21, 0x45	; 69
    83e2:	0e 94 3b 02 	call	0x476	; 0x476 <__mulsf3>
    83e6:	dc 01       	movw	r26, r24
    83e8:	cb 01       	movw	r24, r22
    83ea:	8f 83       	std	Y+7, r24	; 0x07
    83ec:	98 87       	std	Y+8, r25	; 0x08
    83ee:	a9 87       	std	Y+9, r26	; 0x09
    83f0:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    83f2:	6f 81       	ldd	r22, Y+7	; 0x07
    83f4:	78 85       	ldd	r23, Y+8	; 0x08
    83f6:	89 85       	ldd	r24, Y+9	; 0x09
    83f8:	9a 85       	ldd	r25, Y+10	; 0x0a
    83fa:	20 e0       	ldi	r18, 0x00	; 0
    83fc:	30 e0       	ldi	r19, 0x00	; 0
    83fe:	40 e8       	ldi	r20, 0x80	; 128
    8400:	5f e3       	ldi	r21, 0x3F	; 63
    8402:	0e 94 41 04 	call	0x882	; 0x882 <__ltsf2>
    8406:	88 23       	and	r24, r24
    8408:	2c f4       	brge	.+10     	; 0x8414 <LCD_sendCommand+0x84c>
		__ticks = 1;
    840a:	81 e0       	ldi	r24, 0x01	; 1
    840c:	90 e0       	ldi	r25, 0x00	; 0
    840e:	9e 83       	std	Y+6, r25	; 0x06
    8410:	8d 83       	std	Y+5, r24	; 0x05
    8412:	3f c0       	rjmp	.+126    	; 0x8492 <LCD_sendCommand+0x8ca>
	else if (__tmp > 65535)
    8414:	6f 81       	ldd	r22, Y+7	; 0x07
    8416:	78 85       	ldd	r23, Y+8	; 0x08
    8418:	89 85       	ldd	r24, Y+9	; 0x09
    841a:	9a 85       	ldd	r25, Y+10	; 0x0a
    841c:	20 e0       	ldi	r18, 0x00	; 0
    841e:	3f ef       	ldi	r19, 0xFF	; 255
    8420:	4f e7       	ldi	r20, 0x7F	; 127
    8422:	57 e4       	ldi	r21, 0x47	; 71
    8424:	0e 94 e1 03 	call	0x7c2	; 0x7c2 <__gtsf2>
    8428:	18 16       	cp	r1, r24
    842a:	4c f5       	brge	.+82     	; 0x847e <LCD_sendCommand+0x8b6>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    842c:	6b 85       	ldd	r22, Y+11	; 0x0b
    842e:	7c 85       	ldd	r23, Y+12	; 0x0c
    8430:	8d 85       	ldd	r24, Y+13	; 0x0d
    8432:	9e 85       	ldd	r25, Y+14	; 0x0e
    8434:	20 e0       	ldi	r18, 0x00	; 0
    8436:	30 e0       	ldi	r19, 0x00	; 0
    8438:	40 e2       	ldi	r20, 0x20	; 32
    843a:	51 e4       	ldi	r21, 0x41	; 65
    843c:	0e 94 3b 02 	call	0x476	; 0x476 <__mulsf3>
    8440:	dc 01       	movw	r26, r24
    8442:	cb 01       	movw	r24, r22
    8444:	bc 01       	movw	r22, r24
    8446:	cd 01       	movw	r24, r26
    8448:	0e 94 65 00 	call	0xca	; 0xca <__fixunssfsi>
    844c:	dc 01       	movw	r26, r24
    844e:	cb 01       	movw	r24, r22
    8450:	9e 83       	std	Y+6, r25	; 0x06
    8452:	8d 83       	std	Y+5, r24	; 0x05
    8454:	0f c0       	rjmp	.+30     	; 0x8474 <LCD_sendCommand+0x8ac>
    8456:	80 e9       	ldi	r24, 0x90	; 144
    8458:	91 e0       	ldi	r25, 0x01	; 1
    845a:	9c 83       	std	Y+4, r25	; 0x04
    845c:	8b 83       	std	Y+3, r24	; 0x03
    845e:	8b 81       	ldd	r24, Y+3	; 0x03
    8460:	9c 81       	ldd	r25, Y+4	; 0x04
    8462:	01 97       	sbiw	r24, 0x01	; 1
    8464:	f1 f7       	brne	.-4      	; 0x8462 <LCD_sendCommand+0x89a>
    8466:	9c 83       	std	Y+4, r25	; 0x04
    8468:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    846a:	8d 81       	ldd	r24, Y+5	; 0x05
    846c:	9e 81       	ldd	r25, Y+6	; 0x06
    846e:	01 97       	sbiw	r24, 0x01	; 1
    8470:	9e 83       	std	Y+6, r25	; 0x06
    8472:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    8474:	8d 81       	ldd	r24, Y+5	; 0x05
    8476:	9e 81       	ldd	r25, Y+6	; 0x06
    8478:	00 97       	sbiw	r24, 0x00	; 0
    847a:	69 f7       	brne	.-38     	; 0x8456 <LCD_sendCommand+0x88e>
    847c:	14 c0       	rjmp	.+40     	; 0x84a6 <LCD_sendCommand+0x8de>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    847e:	6f 81       	ldd	r22, Y+7	; 0x07
    8480:	78 85       	ldd	r23, Y+8	; 0x08
    8482:	89 85       	ldd	r24, Y+9	; 0x09
    8484:	9a 85       	ldd	r25, Y+10	; 0x0a
    8486:	0e 94 65 00 	call	0xca	; 0xca <__fixunssfsi>
    848a:	dc 01       	movw	r26, r24
    848c:	cb 01       	movw	r24, r22
    848e:	9e 83       	std	Y+6, r25	; 0x06
    8490:	8d 83       	std	Y+5, r24	; 0x05
    8492:	8d 81       	ldd	r24, Y+5	; 0x05
    8494:	9e 81       	ldd	r25, Y+6	; 0x06
    8496:	9a 83       	std	Y+2, r25	; 0x02
    8498:	89 83       	std	Y+1, r24	; 0x01
    849a:	89 81       	ldd	r24, Y+1	; 0x01
    849c:	9a 81       	ldd	r25, Y+2	; 0x02
    849e:	01 97       	sbiw	r24, 0x01	; 1
    84a0:	f1 f7       	brne	.-4      	; 0x849e <LCD_sendCommand+0x8d6>
    84a2:	9a 83       	std	Y+2, r25	; 0x02
    84a4:	89 83       	std	Y+1, r24	; 0x01
	GPIO_writePort(LCD_DATA_PORT_ID,command); /* out the required command to the data bus D0 --> D7 */
	_delay_ms(1); /* delay for processing Tdsw = 100ns */
	GPIO_writePin(LCD_E_PORT_ID,LCD_E_PIN_ID,LOGIC_LOW); /* Disable LCD E=0 */
	_delay_ms(1); /* delay for processing Th = 13ns */
#endif
}
    84a6:	cd 59       	subi	r28, 0x9D	; 157
    84a8:	df 4f       	sbci	r29, 0xFF	; 255
    84aa:	0f b6       	in	r0, 0x3f	; 63
    84ac:	f8 94       	cli
    84ae:	de bf       	out	0x3e, r29	; 62
    84b0:	0f be       	out	0x3f, r0	; 63
    84b2:	cd bf       	out	0x3d, r28	; 61
    84b4:	cf 91       	pop	r28
    84b6:	df 91       	pop	r29
    84b8:	1f 91       	pop	r17
    84ba:	0f 91       	pop	r16
    84bc:	08 95       	ret

000084be <LCD_displayCharacter>:
/*
 * Description :
 * Display the required character on the screen
 */
void LCD_displayCharacter(uint8 data)
{
    84be:	0f 93       	push	r16
    84c0:	1f 93       	push	r17
    84c2:	df 93       	push	r29
    84c4:	cf 93       	push	r28
    84c6:	cd b7       	in	r28, 0x3d	; 61
    84c8:	de b7       	in	r29, 0x3e	; 62
    84ca:	c3 56       	subi	r28, 0x63	; 99
    84cc:	d0 40       	sbci	r29, 0x00	; 0
    84ce:	0f b6       	in	r0, 0x3f	; 63
    84d0:	f8 94       	cli
    84d2:	de bf       	out	0x3e, r29	; 62
    84d4:	0f be       	out	0x3f, r0	; 63
    84d6:	cd bf       	out	0x3d, r28	; 61
    84d8:	fe 01       	movw	r30, r28
    84da:	ed 59       	subi	r30, 0x9D	; 157
    84dc:	ff 4f       	sbci	r31, 0xFF	; 255
    84de:	80 83       	st	Z, r24
	GPIO_writePin(LCD_RS_PORT_ID,LCD_RS_PIN_ID,LOGIC_HIGH); /* Data Mode RS=1 */
    84e0:	83 e0       	ldi	r24, 0x03	; 3
    84e2:	60 e0       	ldi	r22, 0x00	; 0
    84e4:	41 e0       	ldi	r20, 0x01	; 1
    84e6:	0e 94 9e 38 	call	0x713c	; 0x713c <GPIO_writePin>
    84ea:	fe 01       	movw	r30, r28
    84ec:	e1 5a       	subi	r30, 0xA1	; 161
    84ee:	ff 4f       	sbci	r31, 0xFF	; 255
    84f0:	80 e0       	ldi	r24, 0x00	; 0
    84f2:	90 e0       	ldi	r25, 0x00	; 0
    84f4:	a0 e8       	ldi	r26, 0x80	; 128
    84f6:	bf e3       	ldi	r27, 0x3F	; 63
    84f8:	80 83       	st	Z, r24
    84fa:	91 83       	std	Z+1, r25	; 0x01
    84fc:	a2 83       	std	Z+2, r26	; 0x02
    84fe:	b3 83       	std	Z+3, r27	; 0x03
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    8500:	8e 01       	movw	r16, r28
    8502:	05 5a       	subi	r16, 0xA5	; 165
    8504:	1f 4f       	sbci	r17, 0xFF	; 255
    8506:	fe 01       	movw	r30, r28
    8508:	e1 5a       	subi	r30, 0xA1	; 161
    850a:	ff 4f       	sbci	r31, 0xFF	; 255
    850c:	60 81       	ld	r22, Z
    850e:	71 81       	ldd	r23, Z+1	; 0x01
    8510:	82 81       	ldd	r24, Z+2	; 0x02
    8512:	93 81       	ldd	r25, Z+3	; 0x03
    8514:	20 e0       	ldi	r18, 0x00	; 0
    8516:	30 e0       	ldi	r19, 0x00	; 0
    8518:	4a e7       	ldi	r20, 0x7A	; 122
    851a:	55 e4       	ldi	r21, 0x45	; 69
    851c:	0e 94 3b 02 	call	0x476	; 0x476 <__mulsf3>
    8520:	dc 01       	movw	r26, r24
    8522:	cb 01       	movw	r24, r22
    8524:	f8 01       	movw	r30, r16
    8526:	80 83       	st	Z, r24
    8528:	91 83       	std	Z+1, r25	; 0x01
    852a:	a2 83       	std	Z+2, r26	; 0x02
    852c:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    852e:	fe 01       	movw	r30, r28
    8530:	e5 5a       	subi	r30, 0xA5	; 165
    8532:	ff 4f       	sbci	r31, 0xFF	; 255
    8534:	60 81       	ld	r22, Z
    8536:	71 81       	ldd	r23, Z+1	; 0x01
    8538:	82 81       	ldd	r24, Z+2	; 0x02
    853a:	93 81       	ldd	r25, Z+3	; 0x03
    853c:	20 e0       	ldi	r18, 0x00	; 0
    853e:	30 e0       	ldi	r19, 0x00	; 0
    8540:	40 e8       	ldi	r20, 0x80	; 128
    8542:	5f e3       	ldi	r21, 0x3F	; 63
    8544:	0e 94 41 04 	call	0x882	; 0x882 <__ltsf2>
    8548:	88 23       	and	r24, r24
    854a:	44 f4       	brge	.+16     	; 0x855c <LCD_displayCharacter+0x9e>
		__ticks = 1;
    854c:	fe 01       	movw	r30, r28
    854e:	e7 5a       	subi	r30, 0xA7	; 167
    8550:	ff 4f       	sbci	r31, 0xFF	; 255
    8552:	81 e0       	ldi	r24, 0x01	; 1
    8554:	90 e0       	ldi	r25, 0x00	; 0
    8556:	91 83       	std	Z+1, r25	; 0x01
    8558:	80 83       	st	Z, r24
    855a:	64 c0       	rjmp	.+200    	; 0x8624 <LCD_displayCharacter+0x166>
	else if (__tmp > 65535)
    855c:	fe 01       	movw	r30, r28
    855e:	e5 5a       	subi	r30, 0xA5	; 165
    8560:	ff 4f       	sbci	r31, 0xFF	; 255
    8562:	60 81       	ld	r22, Z
    8564:	71 81       	ldd	r23, Z+1	; 0x01
    8566:	82 81       	ldd	r24, Z+2	; 0x02
    8568:	93 81       	ldd	r25, Z+3	; 0x03
    856a:	20 e0       	ldi	r18, 0x00	; 0
    856c:	3f ef       	ldi	r19, 0xFF	; 255
    856e:	4f e7       	ldi	r20, 0x7F	; 127
    8570:	57 e4       	ldi	r21, 0x47	; 71
    8572:	0e 94 e1 03 	call	0x7c2	; 0x7c2 <__gtsf2>
    8576:	18 16       	cp	r1, r24
    8578:	0c f0       	brlt	.+2      	; 0x857c <LCD_displayCharacter+0xbe>
    857a:	43 c0       	rjmp	.+134    	; 0x8602 <LCD_displayCharacter+0x144>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    857c:	fe 01       	movw	r30, r28
    857e:	e1 5a       	subi	r30, 0xA1	; 161
    8580:	ff 4f       	sbci	r31, 0xFF	; 255
    8582:	60 81       	ld	r22, Z
    8584:	71 81       	ldd	r23, Z+1	; 0x01
    8586:	82 81       	ldd	r24, Z+2	; 0x02
    8588:	93 81       	ldd	r25, Z+3	; 0x03
    858a:	20 e0       	ldi	r18, 0x00	; 0
    858c:	30 e0       	ldi	r19, 0x00	; 0
    858e:	40 e2       	ldi	r20, 0x20	; 32
    8590:	51 e4       	ldi	r21, 0x41	; 65
    8592:	0e 94 3b 02 	call	0x476	; 0x476 <__mulsf3>
    8596:	dc 01       	movw	r26, r24
    8598:	cb 01       	movw	r24, r22
    859a:	8e 01       	movw	r16, r28
    859c:	07 5a       	subi	r16, 0xA7	; 167
    859e:	1f 4f       	sbci	r17, 0xFF	; 255
    85a0:	bc 01       	movw	r22, r24
    85a2:	cd 01       	movw	r24, r26
    85a4:	0e 94 65 00 	call	0xca	; 0xca <__fixunssfsi>
    85a8:	dc 01       	movw	r26, r24
    85aa:	cb 01       	movw	r24, r22
    85ac:	f8 01       	movw	r30, r16
    85ae:	91 83       	std	Z+1, r25	; 0x01
    85b0:	80 83       	st	Z, r24
    85b2:	1f c0       	rjmp	.+62     	; 0x85f2 <LCD_displayCharacter+0x134>
    85b4:	fe 01       	movw	r30, r28
    85b6:	e9 5a       	subi	r30, 0xA9	; 169
    85b8:	ff 4f       	sbci	r31, 0xFF	; 255
    85ba:	80 e9       	ldi	r24, 0x90	; 144
    85bc:	91 e0       	ldi	r25, 0x01	; 1
    85be:	91 83       	std	Z+1, r25	; 0x01
    85c0:	80 83       	st	Z, r24
    85c2:	fe 01       	movw	r30, r28
    85c4:	e9 5a       	subi	r30, 0xA9	; 169
    85c6:	ff 4f       	sbci	r31, 0xFF	; 255
    85c8:	80 81       	ld	r24, Z
    85ca:	91 81       	ldd	r25, Z+1	; 0x01
    85cc:	01 97       	sbiw	r24, 0x01	; 1
    85ce:	f1 f7       	brne	.-4      	; 0x85cc <LCD_displayCharacter+0x10e>
    85d0:	fe 01       	movw	r30, r28
    85d2:	e9 5a       	subi	r30, 0xA9	; 169
    85d4:	ff 4f       	sbci	r31, 0xFF	; 255
    85d6:	91 83       	std	Z+1, r25	; 0x01
    85d8:	80 83       	st	Z, r24
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    85da:	de 01       	movw	r26, r28
    85dc:	a7 5a       	subi	r26, 0xA7	; 167
    85de:	bf 4f       	sbci	r27, 0xFF	; 255
    85e0:	fe 01       	movw	r30, r28
    85e2:	e7 5a       	subi	r30, 0xA7	; 167
    85e4:	ff 4f       	sbci	r31, 0xFF	; 255
    85e6:	80 81       	ld	r24, Z
    85e8:	91 81       	ldd	r25, Z+1	; 0x01
    85ea:	01 97       	sbiw	r24, 0x01	; 1
    85ec:	11 96       	adiw	r26, 0x01	; 1
    85ee:	9c 93       	st	X, r25
    85f0:	8e 93       	st	-X, r24
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    85f2:	fe 01       	movw	r30, r28
    85f4:	e7 5a       	subi	r30, 0xA7	; 167
    85f6:	ff 4f       	sbci	r31, 0xFF	; 255
    85f8:	80 81       	ld	r24, Z
    85fa:	91 81       	ldd	r25, Z+1	; 0x01
    85fc:	00 97       	sbiw	r24, 0x00	; 0
    85fe:	d1 f6       	brne	.-76     	; 0x85b4 <LCD_displayCharacter+0xf6>
    8600:	27 c0       	rjmp	.+78     	; 0x8650 <LCD_displayCharacter+0x192>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    8602:	8e 01       	movw	r16, r28
    8604:	07 5a       	subi	r16, 0xA7	; 167
    8606:	1f 4f       	sbci	r17, 0xFF	; 255
    8608:	fe 01       	movw	r30, r28
    860a:	e5 5a       	subi	r30, 0xA5	; 165
    860c:	ff 4f       	sbci	r31, 0xFF	; 255
    860e:	60 81       	ld	r22, Z
    8610:	71 81       	ldd	r23, Z+1	; 0x01
    8612:	82 81       	ldd	r24, Z+2	; 0x02
    8614:	93 81       	ldd	r25, Z+3	; 0x03
    8616:	0e 94 65 00 	call	0xca	; 0xca <__fixunssfsi>
    861a:	dc 01       	movw	r26, r24
    861c:	cb 01       	movw	r24, r22
    861e:	f8 01       	movw	r30, r16
    8620:	91 83       	std	Z+1, r25	; 0x01
    8622:	80 83       	st	Z, r24
    8624:	de 01       	movw	r26, r28
    8626:	ab 5a       	subi	r26, 0xAB	; 171
    8628:	bf 4f       	sbci	r27, 0xFF	; 255
    862a:	fe 01       	movw	r30, r28
    862c:	e7 5a       	subi	r30, 0xA7	; 167
    862e:	ff 4f       	sbci	r31, 0xFF	; 255
    8630:	80 81       	ld	r24, Z
    8632:	91 81       	ldd	r25, Z+1	; 0x01
    8634:	8d 93       	st	X+, r24
    8636:	9c 93       	st	X, r25
    8638:	fe 01       	movw	r30, r28
    863a:	eb 5a       	subi	r30, 0xAB	; 171
    863c:	ff 4f       	sbci	r31, 0xFF	; 255
    863e:	80 81       	ld	r24, Z
    8640:	91 81       	ldd	r25, Z+1	; 0x01
    8642:	01 97       	sbiw	r24, 0x01	; 1
    8644:	f1 f7       	brne	.-4      	; 0x8642 <LCD_displayCharacter+0x184>
    8646:	fe 01       	movw	r30, r28
    8648:	eb 5a       	subi	r30, 0xAB	; 171
    864a:	ff 4f       	sbci	r31, 0xFF	; 255
    864c:	91 83       	std	Z+1, r25	; 0x01
    864e:	80 83       	st	Z, r24
	_delay_ms(1); /* delay for processing Tas = 50ns */
	GPIO_writePin(LCD_E_PORT_ID,LCD_E_PIN_ID,LOGIC_HIGH); /* Enable LCD E=1 */
    8650:	83 e0       	ldi	r24, 0x03	; 3
    8652:	62 e0       	ldi	r22, 0x02	; 2
    8654:	41 e0       	ldi	r20, 0x01	; 1
    8656:	0e 94 9e 38 	call	0x713c	; 0x713c <GPIO_writePin>
    865a:	fe 01       	movw	r30, r28
    865c:	ef 5a       	subi	r30, 0xAF	; 175
    865e:	ff 4f       	sbci	r31, 0xFF	; 255
    8660:	80 e0       	ldi	r24, 0x00	; 0
    8662:	90 e0       	ldi	r25, 0x00	; 0
    8664:	a0 e8       	ldi	r26, 0x80	; 128
    8666:	bf e3       	ldi	r27, 0x3F	; 63
    8668:	80 83       	st	Z, r24
    866a:	91 83       	std	Z+1, r25	; 0x01
    866c:	a2 83       	std	Z+2, r26	; 0x02
    866e:	b3 83       	std	Z+3, r27	; 0x03
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    8670:	8e 01       	movw	r16, r28
    8672:	03 5b       	subi	r16, 0xB3	; 179
    8674:	1f 4f       	sbci	r17, 0xFF	; 255
    8676:	fe 01       	movw	r30, r28
    8678:	ef 5a       	subi	r30, 0xAF	; 175
    867a:	ff 4f       	sbci	r31, 0xFF	; 255
    867c:	60 81       	ld	r22, Z
    867e:	71 81       	ldd	r23, Z+1	; 0x01
    8680:	82 81       	ldd	r24, Z+2	; 0x02
    8682:	93 81       	ldd	r25, Z+3	; 0x03
    8684:	20 e0       	ldi	r18, 0x00	; 0
    8686:	30 e0       	ldi	r19, 0x00	; 0
    8688:	4a e7       	ldi	r20, 0x7A	; 122
    868a:	55 e4       	ldi	r21, 0x45	; 69
    868c:	0e 94 3b 02 	call	0x476	; 0x476 <__mulsf3>
    8690:	dc 01       	movw	r26, r24
    8692:	cb 01       	movw	r24, r22
    8694:	f8 01       	movw	r30, r16
    8696:	80 83       	st	Z, r24
    8698:	91 83       	std	Z+1, r25	; 0x01
    869a:	a2 83       	std	Z+2, r26	; 0x02
    869c:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    869e:	fe 01       	movw	r30, r28
    86a0:	e3 5b       	subi	r30, 0xB3	; 179
    86a2:	ff 4f       	sbci	r31, 0xFF	; 255
    86a4:	60 81       	ld	r22, Z
    86a6:	71 81       	ldd	r23, Z+1	; 0x01
    86a8:	82 81       	ldd	r24, Z+2	; 0x02
    86aa:	93 81       	ldd	r25, Z+3	; 0x03
    86ac:	20 e0       	ldi	r18, 0x00	; 0
    86ae:	30 e0       	ldi	r19, 0x00	; 0
    86b0:	40 e8       	ldi	r20, 0x80	; 128
    86b2:	5f e3       	ldi	r21, 0x3F	; 63
    86b4:	0e 94 41 04 	call	0x882	; 0x882 <__ltsf2>
    86b8:	88 23       	and	r24, r24
    86ba:	44 f4       	brge	.+16     	; 0x86cc <LCD_displayCharacter+0x20e>
		__ticks = 1;
    86bc:	fe 01       	movw	r30, r28
    86be:	e5 5b       	subi	r30, 0xB5	; 181
    86c0:	ff 4f       	sbci	r31, 0xFF	; 255
    86c2:	81 e0       	ldi	r24, 0x01	; 1
    86c4:	90 e0       	ldi	r25, 0x00	; 0
    86c6:	91 83       	std	Z+1, r25	; 0x01
    86c8:	80 83       	st	Z, r24
    86ca:	64 c0       	rjmp	.+200    	; 0x8794 <LCD_displayCharacter+0x2d6>
	else if (__tmp > 65535)
    86cc:	fe 01       	movw	r30, r28
    86ce:	e3 5b       	subi	r30, 0xB3	; 179
    86d0:	ff 4f       	sbci	r31, 0xFF	; 255
    86d2:	60 81       	ld	r22, Z
    86d4:	71 81       	ldd	r23, Z+1	; 0x01
    86d6:	82 81       	ldd	r24, Z+2	; 0x02
    86d8:	93 81       	ldd	r25, Z+3	; 0x03
    86da:	20 e0       	ldi	r18, 0x00	; 0
    86dc:	3f ef       	ldi	r19, 0xFF	; 255
    86de:	4f e7       	ldi	r20, 0x7F	; 127
    86e0:	57 e4       	ldi	r21, 0x47	; 71
    86e2:	0e 94 e1 03 	call	0x7c2	; 0x7c2 <__gtsf2>
    86e6:	18 16       	cp	r1, r24
    86e8:	0c f0       	brlt	.+2      	; 0x86ec <LCD_displayCharacter+0x22e>
    86ea:	43 c0       	rjmp	.+134    	; 0x8772 <LCD_displayCharacter+0x2b4>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    86ec:	fe 01       	movw	r30, r28
    86ee:	ef 5a       	subi	r30, 0xAF	; 175
    86f0:	ff 4f       	sbci	r31, 0xFF	; 255
    86f2:	60 81       	ld	r22, Z
    86f4:	71 81       	ldd	r23, Z+1	; 0x01
    86f6:	82 81       	ldd	r24, Z+2	; 0x02
    86f8:	93 81       	ldd	r25, Z+3	; 0x03
    86fa:	20 e0       	ldi	r18, 0x00	; 0
    86fc:	30 e0       	ldi	r19, 0x00	; 0
    86fe:	40 e2       	ldi	r20, 0x20	; 32
    8700:	51 e4       	ldi	r21, 0x41	; 65
    8702:	0e 94 3b 02 	call	0x476	; 0x476 <__mulsf3>
    8706:	dc 01       	movw	r26, r24
    8708:	cb 01       	movw	r24, r22
    870a:	8e 01       	movw	r16, r28
    870c:	05 5b       	subi	r16, 0xB5	; 181
    870e:	1f 4f       	sbci	r17, 0xFF	; 255
    8710:	bc 01       	movw	r22, r24
    8712:	cd 01       	movw	r24, r26
    8714:	0e 94 65 00 	call	0xca	; 0xca <__fixunssfsi>
    8718:	dc 01       	movw	r26, r24
    871a:	cb 01       	movw	r24, r22
    871c:	f8 01       	movw	r30, r16
    871e:	91 83       	std	Z+1, r25	; 0x01
    8720:	80 83       	st	Z, r24
    8722:	1f c0       	rjmp	.+62     	; 0x8762 <LCD_displayCharacter+0x2a4>
    8724:	fe 01       	movw	r30, r28
    8726:	e7 5b       	subi	r30, 0xB7	; 183
    8728:	ff 4f       	sbci	r31, 0xFF	; 255
    872a:	80 e9       	ldi	r24, 0x90	; 144
    872c:	91 e0       	ldi	r25, 0x01	; 1
    872e:	91 83       	std	Z+1, r25	; 0x01
    8730:	80 83       	st	Z, r24
    8732:	fe 01       	movw	r30, r28
    8734:	e7 5b       	subi	r30, 0xB7	; 183
    8736:	ff 4f       	sbci	r31, 0xFF	; 255
    8738:	80 81       	ld	r24, Z
    873a:	91 81       	ldd	r25, Z+1	; 0x01
    873c:	01 97       	sbiw	r24, 0x01	; 1
    873e:	f1 f7       	brne	.-4      	; 0x873c <LCD_displayCharacter+0x27e>
    8740:	fe 01       	movw	r30, r28
    8742:	e7 5b       	subi	r30, 0xB7	; 183
    8744:	ff 4f       	sbci	r31, 0xFF	; 255
    8746:	91 83       	std	Z+1, r25	; 0x01
    8748:	80 83       	st	Z, r24
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    874a:	de 01       	movw	r26, r28
    874c:	a5 5b       	subi	r26, 0xB5	; 181
    874e:	bf 4f       	sbci	r27, 0xFF	; 255
    8750:	fe 01       	movw	r30, r28
    8752:	e5 5b       	subi	r30, 0xB5	; 181
    8754:	ff 4f       	sbci	r31, 0xFF	; 255
    8756:	80 81       	ld	r24, Z
    8758:	91 81       	ldd	r25, Z+1	; 0x01
    875a:	01 97       	sbiw	r24, 0x01	; 1
    875c:	11 96       	adiw	r26, 0x01	; 1
    875e:	9c 93       	st	X, r25
    8760:	8e 93       	st	-X, r24
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    8762:	fe 01       	movw	r30, r28
    8764:	e5 5b       	subi	r30, 0xB5	; 181
    8766:	ff 4f       	sbci	r31, 0xFF	; 255
    8768:	80 81       	ld	r24, Z
    876a:	91 81       	ldd	r25, Z+1	; 0x01
    876c:	00 97       	sbiw	r24, 0x00	; 0
    876e:	d1 f6       	brne	.-76     	; 0x8724 <LCD_displayCharacter+0x266>
    8770:	27 c0       	rjmp	.+78     	; 0x87c0 <LCD_displayCharacter+0x302>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    8772:	8e 01       	movw	r16, r28
    8774:	05 5b       	subi	r16, 0xB5	; 181
    8776:	1f 4f       	sbci	r17, 0xFF	; 255
    8778:	fe 01       	movw	r30, r28
    877a:	e3 5b       	subi	r30, 0xB3	; 179
    877c:	ff 4f       	sbci	r31, 0xFF	; 255
    877e:	60 81       	ld	r22, Z
    8780:	71 81       	ldd	r23, Z+1	; 0x01
    8782:	82 81       	ldd	r24, Z+2	; 0x02
    8784:	93 81       	ldd	r25, Z+3	; 0x03
    8786:	0e 94 65 00 	call	0xca	; 0xca <__fixunssfsi>
    878a:	dc 01       	movw	r26, r24
    878c:	cb 01       	movw	r24, r22
    878e:	f8 01       	movw	r30, r16
    8790:	91 83       	std	Z+1, r25	; 0x01
    8792:	80 83       	st	Z, r24
    8794:	de 01       	movw	r26, r28
    8796:	a9 5b       	subi	r26, 0xB9	; 185
    8798:	bf 4f       	sbci	r27, 0xFF	; 255
    879a:	fe 01       	movw	r30, r28
    879c:	e5 5b       	subi	r30, 0xB5	; 181
    879e:	ff 4f       	sbci	r31, 0xFF	; 255
    87a0:	80 81       	ld	r24, Z
    87a2:	91 81       	ldd	r25, Z+1	; 0x01
    87a4:	8d 93       	st	X+, r24
    87a6:	9c 93       	st	X, r25
    87a8:	fe 01       	movw	r30, r28
    87aa:	e9 5b       	subi	r30, 0xB9	; 185
    87ac:	ff 4f       	sbci	r31, 0xFF	; 255
    87ae:	80 81       	ld	r24, Z
    87b0:	91 81       	ldd	r25, Z+1	; 0x01
    87b2:	01 97       	sbiw	r24, 0x01	; 1
    87b4:	f1 f7       	brne	.-4      	; 0x87b2 <LCD_displayCharacter+0x2f4>
    87b6:	fe 01       	movw	r30, r28
    87b8:	e9 5b       	subi	r30, 0xB9	; 185
    87ba:	ff 4f       	sbci	r31, 0xFF	; 255
    87bc:	91 83       	std	Z+1, r25	; 0x01
    87be:	80 83       	st	Z, r24
	_delay_ms(1); /* delay for processing Tpw - Tdws = 190ns */

#if(LCD_DATA_BITS_MODE == 4)
	GPIO_writePin(LCD_DATA_PORT_ID,LCD_DB4_PIN_ID,GET_BIT(data,4));
    87c0:	fe 01       	movw	r30, r28
    87c2:	ed 59       	subi	r30, 0x9D	; 157
    87c4:	ff 4f       	sbci	r31, 0xFF	; 255
    87c6:	80 81       	ld	r24, Z
    87c8:	88 2f       	mov	r24, r24
    87ca:	90 e0       	ldi	r25, 0x00	; 0
    87cc:	80 71       	andi	r24, 0x10	; 16
    87ce:	90 70       	andi	r25, 0x00	; 0
    87d0:	95 95       	asr	r25
    87d2:	87 95       	ror	r24
    87d4:	95 95       	asr	r25
    87d6:	87 95       	ror	r24
    87d8:	95 95       	asr	r25
    87da:	87 95       	ror	r24
    87dc:	95 95       	asr	r25
    87de:	87 95       	ror	r24
    87e0:	98 2f       	mov	r25, r24
    87e2:	83 e0       	ldi	r24, 0x03	; 3
    87e4:	64 e0       	ldi	r22, 0x04	; 4
    87e6:	49 2f       	mov	r20, r25
    87e8:	0e 94 9e 38 	call	0x713c	; 0x713c <GPIO_writePin>
	GPIO_writePin(LCD_DATA_PORT_ID,LCD_DB5_PIN_ID,GET_BIT(data,5));
    87ec:	fe 01       	movw	r30, r28
    87ee:	ed 59       	subi	r30, 0x9D	; 157
    87f0:	ff 4f       	sbci	r31, 0xFF	; 255
    87f2:	80 81       	ld	r24, Z
    87f4:	88 2f       	mov	r24, r24
    87f6:	90 e0       	ldi	r25, 0x00	; 0
    87f8:	80 72       	andi	r24, 0x20	; 32
    87fa:	90 70       	andi	r25, 0x00	; 0
    87fc:	95 95       	asr	r25
    87fe:	87 95       	ror	r24
    8800:	95 95       	asr	r25
    8802:	87 95       	ror	r24
    8804:	95 95       	asr	r25
    8806:	87 95       	ror	r24
    8808:	95 95       	asr	r25
    880a:	87 95       	ror	r24
    880c:	95 95       	asr	r25
    880e:	87 95       	ror	r24
    8810:	98 2f       	mov	r25, r24
    8812:	83 e0       	ldi	r24, 0x03	; 3
    8814:	65 e0       	ldi	r22, 0x05	; 5
    8816:	49 2f       	mov	r20, r25
    8818:	0e 94 9e 38 	call	0x713c	; 0x713c <GPIO_writePin>
	GPIO_writePin(LCD_DATA_PORT_ID,LCD_DB6_PIN_ID,GET_BIT(data,6));
    881c:	fe 01       	movw	r30, r28
    881e:	ed 59       	subi	r30, 0x9D	; 157
    8820:	ff 4f       	sbci	r31, 0xFF	; 255
    8822:	80 81       	ld	r24, Z
    8824:	88 2f       	mov	r24, r24
    8826:	90 e0       	ldi	r25, 0x00	; 0
    8828:	80 74       	andi	r24, 0x40	; 64
    882a:	90 70       	andi	r25, 0x00	; 0
    882c:	08 2e       	mov	r0, r24
    882e:	89 2f       	mov	r24, r25
    8830:	00 0c       	add	r0, r0
    8832:	88 1f       	adc	r24, r24
    8834:	99 0b       	sbc	r25, r25
    8836:	00 0c       	add	r0, r0
    8838:	88 1f       	adc	r24, r24
    883a:	99 1f       	adc	r25, r25
    883c:	98 2f       	mov	r25, r24
    883e:	83 e0       	ldi	r24, 0x03	; 3
    8840:	66 e0       	ldi	r22, 0x06	; 6
    8842:	49 2f       	mov	r20, r25
    8844:	0e 94 9e 38 	call	0x713c	; 0x713c <GPIO_writePin>
	GPIO_writePin(LCD_DATA_PORT_ID,LCD_DB7_PIN_ID,GET_BIT(data,7));
    8848:	fe 01       	movw	r30, r28
    884a:	ed 59       	subi	r30, 0x9D	; 157
    884c:	ff 4f       	sbci	r31, 0xFF	; 255
    884e:	80 81       	ld	r24, Z
    8850:	98 2f       	mov	r25, r24
    8852:	99 1f       	adc	r25, r25
    8854:	99 27       	eor	r25, r25
    8856:	99 1f       	adc	r25, r25
    8858:	83 e0       	ldi	r24, 0x03	; 3
    885a:	67 e0       	ldi	r22, 0x07	; 7
    885c:	49 2f       	mov	r20, r25
    885e:	0e 94 9e 38 	call	0x713c	; 0x713c <GPIO_writePin>
    8862:	fe 01       	movw	r30, r28
    8864:	ed 5b       	subi	r30, 0xBD	; 189
    8866:	ff 4f       	sbci	r31, 0xFF	; 255
    8868:	80 e0       	ldi	r24, 0x00	; 0
    886a:	90 e0       	ldi	r25, 0x00	; 0
    886c:	a0 e8       	ldi	r26, 0x80	; 128
    886e:	bf e3       	ldi	r27, 0x3F	; 63
    8870:	80 83       	st	Z, r24
    8872:	91 83       	std	Z+1, r25	; 0x01
    8874:	a2 83       	std	Z+2, r26	; 0x02
    8876:	b3 83       	std	Z+3, r27	; 0x03
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    8878:	8e 01       	movw	r16, r28
    887a:	01 5c       	subi	r16, 0xC1	; 193
    887c:	1f 4f       	sbci	r17, 0xFF	; 255
    887e:	fe 01       	movw	r30, r28
    8880:	ed 5b       	subi	r30, 0xBD	; 189
    8882:	ff 4f       	sbci	r31, 0xFF	; 255
    8884:	60 81       	ld	r22, Z
    8886:	71 81       	ldd	r23, Z+1	; 0x01
    8888:	82 81       	ldd	r24, Z+2	; 0x02
    888a:	93 81       	ldd	r25, Z+3	; 0x03
    888c:	20 e0       	ldi	r18, 0x00	; 0
    888e:	30 e0       	ldi	r19, 0x00	; 0
    8890:	4a e7       	ldi	r20, 0x7A	; 122
    8892:	55 e4       	ldi	r21, 0x45	; 69
    8894:	0e 94 3b 02 	call	0x476	; 0x476 <__mulsf3>
    8898:	dc 01       	movw	r26, r24
    889a:	cb 01       	movw	r24, r22
    889c:	f8 01       	movw	r30, r16
    889e:	80 83       	st	Z, r24
    88a0:	91 83       	std	Z+1, r25	; 0x01
    88a2:	a2 83       	std	Z+2, r26	; 0x02
    88a4:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    88a6:	fe 01       	movw	r30, r28
    88a8:	ff 96       	adiw	r30, 0x3f	; 63
    88aa:	60 81       	ld	r22, Z
    88ac:	71 81       	ldd	r23, Z+1	; 0x01
    88ae:	82 81       	ldd	r24, Z+2	; 0x02
    88b0:	93 81       	ldd	r25, Z+3	; 0x03
    88b2:	20 e0       	ldi	r18, 0x00	; 0
    88b4:	30 e0       	ldi	r19, 0x00	; 0
    88b6:	40 e8       	ldi	r20, 0x80	; 128
    88b8:	5f e3       	ldi	r21, 0x3F	; 63
    88ba:	0e 94 41 04 	call	0x882	; 0x882 <__ltsf2>
    88be:	88 23       	and	r24, r24
    88c0:	2c f4       	brge	.+10     	; 0x88cc <LCD_displayCharacter+0x40e>
		__ticks = 1;
    88c2:	81 e0       	ldi	r24, 0x01	; 1
    88c4:	90 e0       	ldi	r25, 0x00	; 0
    88c6:	9e af       	std	Y+62, r25	; 0x3e
    88c8:	8d af       	std	Y+61, r24	; 0x3d
    88ca:	46 c0       	rjmp	.+140    	; 0x8958 <LCD_displayCharacter+0x49a>
	else if (__tmp > 65535)
    88cc:	fe 01       	movw	r30, r28
    88ce:	ff 96       	adiw	r30, 0x3f	; 63
    88d0:	60 81       	ld	r22, Z
    88d2:	71 81       	ldd	r23, Z+1	; 0x01
    88d4:	82 81       	ldd	r24, Z+2	; 0x02
    88d6:	93 81       	ldd	r25, Z+3	; 0x03
    88d8:	20 e0       	ldi	r18, 0x00	; 0
    88da:	3f ef       	ldi	r19, 0xFF	; 255
    88dc:	4f e7       	ldi	r20, 0x7F	; 127
    88de:	57 e4       	ldi	r21, 0x47	; 71
    88e0:	0e 94 e1 03 	call	0x7c2	; 0x7c2 <__gtsf2>
    88e4:	18 16       	cp	r1, r24
    88e6:	64 f5       	brge	.+88     	; 0x8940 <LCD_displayCharacter+0x482>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    88e8:	fe 01       	movw	r30, r28
    88ea:	ed 5b       	subi	r30, 0xBD	; 189
    88ec:	ff 4f       	sbci	r31, 0xFF	; 255
    88ee:	60 81       	ld	r22, Z
    88f0:	71 81       	ldd	r23, Z+1	; 0x01
    88f2:	82 81       	ldd	r24, Z+2	; 0x02
    88f4:	93 81       	ldd	r25, Z+3	; 0x03
    88f6:	20 e0       	ldi	r18, 0x00	; 0
    88f8:	30 e0       	ldi	r19, 0x00	; 0
    88fa:	40 e2       	ldi	r20, 0x20	; 32
    88fc:	51 e4       	ldi	r21, 0x41	; 65
    88fe:	0e 94 3b 02 	call	0x476	; 0x476 <__mulsf3>
    8902:	dc 01       	movw	r26, r24
    8904:	cb 01       	movw	r24, r22
    8906:	bc 01       	movw	r22, r24
    8908:	cd 01       	movw	r24, r26
    890a:	0e 94 65 00 	call	0xca	; 0xca <__fixunssfsi>
    890e:	dc 01       	movw	r26, r24
    8910:	cb 01       	movw	r24, r22
    8912:	9e af       	std	Y+62, r25	; 0x3e
    8914:	8d af       	std	Y+61, r24	; 0x3d
    8916:	0f c0       	rjmp	.+30     	; 0x8936 <LCD_displayCharacter+0x478>
    8918:	80 e9       	ldi	r24, 0x90	; 144
    891a:	91 e0       	ldi	r25, 0x01	; 1
    891c:	9c af       	std	Y+60, r25	; 0x3c
    891e:	8b af       	std	Y+59, r24	; 0x3b
    8920:	8b ad       	ldd	r24, Y+59	; 0x3b
    8922:	9c ad       	ldd	r25, Y+60	; 0x3c
    8924:	01 97       	sbiw	r24, 0x01	; 1
    8926:	f1 f7       	brne	.-4      	; 0x8924 <LCD_displayCharacter+0x466>
    8928:	9c af       	std	Y+60, r25	; 0x3c
    892a:	8b af       	std	Y+59, r24	; 0x3b
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    892c:	8d ad       	ldd	r24, Y+61	; 0x3d
    892e:	9e ad       	ldd	r25, Y+62	; 0x3e
    8930:	01 97       	sbiw	r24, 0x01	; 1
    8932:	9e af       	std	Y+62, r25	; 0x3e
    8934:	8d af       	std	Y+61, r24	; 0x3d
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    8936:	8d ad       	ldd	r24, Y+61	; 0x3d
    8938:	9e ad       	ldd	r25, Y+62	; 0x3e
    893a:	00 97       	sbiw	r24, 0x00	; 0
    893c:	69 f7       	brne	.-38     	; 0x8918 <LCD_displayCharacter+0x45a>
    893e:	16 c0       	rjmp	.+44     	; 0x896c <LCD_displayCharacter+0x4ae>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    8940:	fe 01       	movw	r30, r28
    8942:	ff 96       	adiw	r30, 0x3f	; 63
    8944:	60 81       	ld	r22, Z
    8946:	71 81       	ldd	r23, Z+1	; 0x01
    8948:	82 81       	ldd	r24, Z+2	; 0x02
    894a:	93 81       	ldd	r25, Z+3	; 0x03
    894c:	0e 94 65 00 	call	0xca	; 0xca <__fixunssfsi>
    8950:	dc 01       	movw	r26, r24
    8952:	cb 01       	movw	r24, r22
    8954:	9e af       	std	Y+62, r25	; 0x3e
    8956:	8d af       	std	Y+61, r24	; 0x3d
    8958:	8d ad       	ldd	r24, Y+61	; 0x3d
    895a:	9e ad       	ldd	r25, Y+62	; 0x3e
    895c:	9a af       	std	Y+58, r25	; 0x3a
    895e:	89 af       	std	Y+57, r24	; 0x39
    8960:	89 ad       	ldd	r24, Y+57	; 0x39
    8962:	9a ad       	ldd	r25, Y+58	; 0x3a
    8964:	01 97       	sbiw	r24, 0x01	; 1
    8966:	f1 f7       	brne	.-4      	; 0x8964 <LCD_displayCharacter+0x4a6>
    8968:	9a af       	std	Y+58, r25	; 0x3a
    896a:	89 af       	std	Y+57, r24	; 0x39

	_delay_ms(1); /* delay for processing Tdsw = 100ns */
	GPIO_writePin(LCD_E_PORT_ID,LCD_E_PIN_ID,LOGIC_LOW); /* Disable LCD E=0 */
    896c:	83 e0       	ldi	r24, 0x03	; 3
    896e:	62 e0       	ldi	r22, 0x02	; 2
    8970:	40 e0       	ldi	r20, 0x00	; 0
    8972:	0e 94 9e 38 	call	0x713c	; 0x713c <GPIO_writePin>
    8976:	80 e0       	ldi	r24, 0x00	; 0
    8978:	90 e0       	ldi	r25, 0x00	; 0
    897a:	a0 e8       	ldi	r26, 0x80	; 128
    897c:	bf e3       	ldi	r27, 0x3F	; 63
    897e:	8d ab       	std	Y+53, r24	; 0x35
    8980:	9e ab       	std	Y+54, r25	; 0x36
    8982:	af ab       	std	Y+55, r26	; 0x37
    8984:	b8 af       	std	Y+56, r27	; 0x38
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    8986:	6d a9       	ldd	r22, Y+53	; 0x35
    8988:	7e a9       	ldd	r23, Y+54	; 0x36
    898a:	8f a9       	ldd	r24, Y+55	; 0x37
    898c:	98 ad       	ldd	r25, Y+56	; 0x38
    898e:	20 e0       	ldi	r18, 0x00	; 0
    8990:	30 e0       	ldi	r19, 0x00	; 0
    8992:	4a e7       	ldi	r20, 0x7A	; 122
    8994:	55 e4       	ldi	r21, 0x45	; 69
    8996:	0e 94 3b 02 	call	0x476	; 0x476 <__mulsf3>
    899a:	dc 01       	movw	r26, r24
    899c:	cb 01       	movw	r24, r22
    899e:	89 ab       	std	Y+49, r24	; 0x31
    89a0:	9a ab       	std	Y+50, r25	; 0x32
    89a2:	ab ab       	std	Y+51, r26	; 0x33
    89a4:	bc ab       	std	Y+52, r27	; 0x34
	if (__tmp < 1.0)
    89a6:	69 a9       	ldd	r22, Y+49	; 0x31
    89a8:	7a a9       	ldd	r23, Y+50	; 0x32
    89aa:	8b a9       	ldd	r24, Y+51	; 0x33
    89ac:	9c a9       	ldd	r25, Y+52	; 0x34
    89ae:	20 e0       	ldi	r18, 0x00	; 0
    89b0:	30 e0       	ldi	r19, 0x00	; 0
    89b2:	40 e8       	ldi	r20, 0x80	; 128
    89b4:	5f e3       	ldi	r21, 0x3F	; 63
    89b6:	0e 94 41 04 	call	0x882	; 0x882 <__ltsf2>
    89ba:	88 23       	and	r24, r24
    89bc:	2c f4       	brge	.+10     	; 0x89c8 <LCD_displayCharacter+0x50a>
		__ticks = 1;
    89be:	81 e0       	ldi	r24, 0x01	; 1
    89c0:	90 e0       	ldi	r25, 0x00	; 0
    89c2:	98 ab       	std	Y+48, r25	; 0x30
    89c4:	8f a7       	std	Y+47, r24	; 0x2f
    89c6:	3f c0       	rjmp	.+126    	; 0x8a46 <LCD_displayCharacter+0x588>
	else if (__tmp > 65535)
    89c8:	69 a9       	ldd	r22, Y+49	; 0x31
    89ca:	7a a9       	ldd	r23, Y+50	; 0x32
    89cc:	8b a9       	ldd	r24, Y+51	; 0x33
    89ce:	9c a9       	ldd	r25, Y+52	; 0x34
    89d0:	20 e0       	ldi	r18, 0x00	; 0
    89d2:	3f ef       	ldi	r19, 0xFF	; 255
    89d4:	4f e7       	ldi	r20, 0x7F	; 127
    89d6:	57 e4       	ldi	r21, 0x47	; 71
    89d8:	0e 94 e1 03 	call	0x7c2	; 0x7c2 <__gtsf2>
    89dc:	18 16       	cp	r1, r24
    89de:	4c f5       	brge	.+82     	; 0x8a32 <LCD_displayCharacter+0x574>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    89e0:	6d a9       	ldd	r22, Y+53	; 0x35
    89e2:	7e a9       	ldd	r23, Y+54	; 0x36
    89e4:	8f a9       	ldd	r24, Y+55	; 0x37
    89e6:	98 ad       	ldd	r25, Y+56	; 0x38
    89e8:	20 e0       	ldi	r18, 0x00	; 0
    89ea:	30 e0       	ldi	r19, 0x00	; 0
    89ec:	40 e2       	ldi	r20, 0x20	; 32
    89ee:	51 e4       	ldi	r21, 0x41	; 65
    89f0:	0e 94 3b 02 	call	0x476	; 0x476 <__mulsf3>
    89f4:	dc 01       	movw	r26, r24
    89f6:	cb 01       	movw	r24, r22
    89f8:	bc 01       	movw	r22, r24
    89fa:	cd 01       	movw	r24, r26
    89fc:	0e 94 65 00 	call	0xca	; 0xca <__fixunssfsi>
    8a00:	dc 01       	movw	r26, r24
    8a02:	cb 01       	movw	r24, r22
    8a04:	98 ab       	std	Y+48, r25	; 0x30
    8a06:	8f a7       	std	Y+47, r24	; 0x2f
    8a08:	0f c0       	rjmp	.+30     	; 0x8a28 <LCD_displayCharacter+0x56a>
    8a0a:	80 e9       	ldi	r24, 0x90	; 144
    8a0c:	91 e0       	ldi	r25, 0x01	; 1
    8a0e:	9e a7       	std	Y+46, r25	; 0x2e
    8a10:	8d a7       	std	Y+45, r24	; 0x2d
    8a12:	8d a5       	ldd	r24, Y+45	; 0x2d
    8a14:	9e a5       	ldd	r25, Y+46	; 0x2e
    8a16:	01 97       	sbiw	r24, 0x01	; 1
    8a18:	f1 f7       	brne	.-4      	; 0x8a16 <LCD_displayCharacter+0x558>
    8a1a:	9e a7       	std	Y+46, r25	; 0x2e
    8a1c:	8d a7       	std	Y+45, r24	; 0x2d
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    8a1e:	8f a5       	ldd	r24, Y+47	; 0x2f
    8a20:	98 a9       	ldd	r25, Y+48	; 0x30
    8a22:	01 97       	sbiw	r24, 0x01	; 1
    8a24:	98 ab       	std	Y+48, r25	; 0x30
    8a26:	8f a7       	std	Y+47, r24	; 0x2f
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    8a28:	8f a5       	ldd	r24, Y+47	; 0x2f
    8a2a:	98 a9       	ldd	r25, Y+48	; 0x30
    8a2c:	00 97       	sbiw	r24, 0x00	; 0
    8a2e:	69 f7       	brne	.-38     	; 0x8a0a <LCD_displayCharacter+0x54c>
    8a30:	14 c0       	rjmp	.+40     	; 0x8a5a <LCD_displayCharacter+0x59c>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    8a32:	69 a9       	ldd	r22, Y+49	; 0x31
    8a34:	7a a9       	ldd	r23, Y+50	; 0x32
    8a36:	8b a9       	ldd	r24, Y+51	; 0x33
    8a38:	9c a9       	ldd	r25, Y+52	; 0x34
    8a3a:	0e 94 65 00 	call	0xca	; 0xca <__fixunssfsi>
    8a3e:	dc 01       	movw	r26, r24
    8a40:	cb 01       	movw	r24, r22
    8a42:	98 ab       	std	Y+48, r25	; 0x30
    8a44:	8f a7       	std	Y+47, r24	; 0x2f
    8a46:	8f a5       	ldd	r24, Y+47	; 0x2f
    8a48:	98 a9       	ldd	r25, Y+48	; 0x30
    8a4a:	9c a7       	std	Y+44, r25	; 0x2c
    8a4c:	8b a7       	std	Y+43, r24	; 0x2b
    8a4e:	8b a5       	ldd	r24, Y+43	; 0x2b
    8a50:	9c a5       	ldd	r25, Y+44	; 0x2c
    8a52:	01 97       	sbiw	r24, 0x01	; 1
    8a54:	f1 f7       	brne	.-4      	; 0x8a52 <LCD_displayCharacter+0x594>
    8a56:	9c a7       	std	Y+44, r25	; 0x2c
    8a58:	8b a7       	std	Y+43, r24	; 0x2b
	_delay_ms(1); /* delay for processing Th = 13ns */
	GPIO_writePin(LCD_E_PORT_ID,LCD_E_PIN_ID,LOGIC_HIGH); /* Enable LCD E=1 */
    8a5a:	83 e0       	ldi	r24, 0x03	; 3
    8a5c:	62 e0       	ldi	r22, 0x02	; 2
    8a5e:	41 e0       	ldi	r20, 0x01	; 1
    8a60:	0e 94 9e 38 	call	0x713c	; 0x713c <GPIO_writePin>
    8a64:	80 e0       	ldi	r24, 0x00	; 0
    8a66:	90 e0       	ldi	r25, 0x00	; 0
    8a68:	a0 e8       	ldi	r26, 0x80	; 128
    8a6a:	bf e3       	ldi	r27, 0x3F	; 63
    8a6c:	8f a3       	std	Y+39, r24	; 0x27
    8a6e:	98 a7       	std	Y+40, r25	; 0x28
    8a70:	a9 a7       	std	Y+41, r26	; 0x29
    8a72:	ba a7       	std	Y+42, r27	; 0x2a
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    8a74:	6f a1       	ldd	r22, Y+39	; 0x27
    8a76:	78 a5       	ldd	r23, Y+40	; 0x28
    8a78:	89 a5       	ldd	r24, Y+41	; 0x29
    8a7a:	9a a5       	ldd	r25, Y+42	; 0x2a
    8a7c:	20 e0       	ldi	r18, 0x00	; 0
    8a7e:	30 e0       	ldi	r19, 0x00	; 0
    8a80:	4a e7       	ldi	r20, 0x7A	; 122
    8a82:	55 e4       	ldi	r21, 0x45	; 69
    8a84:	0e 94 3b 02 	call	0x476	; 0x476 <__mulsf3>
    8a88:	dc 01       	movw	r26, r24
    8a8a:	cb 01       	movw	r24, r22
    8a8c:	8b a3       	std	Y+35, r24	; 0x23
    8a8e:	9c a3       	std	Y+36, r25	; 0x24
    8a90:	ad a3       	std	Y+37, r26	; 0x25
    8a92:	be a3       	std	Y+38, r27	; 0x26
	if (__tmp < 1.0)
    8a94:	6b a1       	ldd	r22, Y+35	; 0x23
    8a96:	7c a1       	ldd	r23, Y+36	; 0x24
    8a98:	8d a1       	ldd	r24, Y+37	; 0x25
    8a9a:	9e a1       	ldd	r25, Y+38	; 0x26
    8a9c:	20 e0       	ldi	r18, 0x00	; 0
    8a9e:	30 e0       	ldi	r19, 0x00	; 0
    8aa0:	40 e8       	ldi	r20, 0x80	; 128
    8aa2:	5f e3       	ldi	r21, 0x3F	; 63
    8aa4:	0e 94 41 04 	call	0x882	; 0x882 <__ltsf2>
    8aa8:	88 23       	and	r24, r24
    8aaa:	2c f4       	brge	.+10     	; 0x8ab6 <LCD_displayCharacter+0x5f8>
		__ticks = 1;
    8aac:	81 e0       	ldi	r24, 0x01	; 1
    8aae:	90 e0       	ldi	r25, 0x00	; 0
    8ab0:	9a a3       	std	Y+34, r25	; 0x22
    8ab2:	89 a3       	std	Y+33, r24	; 0x21
    8ab4:	3f c0       	rjmp	.+126    	; 0x8b34 <LCD_displayCharacter+0x676>
	else if (__tmp > 65535)
    8ab6:	6b a1       	ldd	r22, Y+35	; 0x23
    8ab8:	7c a1       	ldd	r23, Y+36	; 0x24
    8aba:	8d a1       	ldd	r24, Y+37	; 0x25
    8abc:	9e a1       	ldd	r25, Y+38	; 0x26
    8abe:	20 e0       	ldi	r18, 0x00	; 0
    8ac0:	3f ef       	ldi	r19, 0xFF	; 255
    8ac2:	4f e7       	ldi	r20, 0x7F	; 127
    8ac4:	57 e4       	ldi	r21, 0x47	; 71
    8ac6:	0e 94 e1 03 	call	0x7c2	; 0x7c2 <__gtsf2>
    8aca:	18 16       	cp	r1, r24
    8acc:	4c f5       	brge	.+82     	; 0x8b20 <LCD_displayCharacter+0x662>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    8ace:	6f a1       	ldd	r22, Y+39	; 0x27
    8ad0:	78 a5       	ldd	r23, Y+40	; 0x28
    8ad2:	89 a5       	ldd	r24, Y+41	; 0x29
    8ad4:	9a a5       	ldd	r25, Y+42	; 0x2a
    8ad6:	20 e0       	ldi	r18, 0x00	; 0
    8ad8:	30 e0       	ldi	r19, 0x00	; 0
    8ada:	40 e2       	ldi	r20, 0x20	; 32
    8adc:	51 e4       	ldi	r21, 0x41	; 65
    8ade:	0e 94 3b 02 	call	0x476	; 0x476 <__mulsf3>
    8ae2:	dc 01       	movw	r26, r24
    8ae4:	cb 01       	movw	r24, r22
    8ae6:	bc 01       	movw	r22, r24
    8ae8:	cd 01       	movw	r24, r26
    8aea:	0e 94 65 00 	call	0xca	; 0xca <__fixunssfsi>
    8aee:	dc 01       	movw	r26, r24
    8af0:	cb 01       	movw	r24, r22
    8af2:	9a a3       	std	Y+34, r25	; 0x22
    8af4:	89 a3       	std	Y+33, r24	; 0x21
    8af6:	0f c0       	rjmp	.+30     	; 0x8b16 <LCD_displayCharacter+0x658>
    8af8:	80 e9       	ldi	r24, 0x90	; 144
    8afa:	91 e0       	ldi	r25, 0x01	; 1
    8afc:	98 a3       	std	Y+32, r25	; 0x20
    8afe:	8f 8f       	std	Y+31, r24	; 0x1f
    8b00:	8f 8d       	ldd	r24, Y+31	; 0x1f
    8b02:	98 a1       	ldd	r25, Y+32	; 0x20
    8b04:	01 97       	sbiw	r24, 0x01	; 1
    8b06:	f1 f7       	brne	.-4      	; 0x8b04 <LCD_displayCharacter+0x646>
    8b08:	98 a3       	std	Y+32, r25	; 0x20
    8b0a:	8f 8f       	std	Y+31, r24	; 0x1f
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    8b0c:	89 a1       	ldd	r24, Y+33	; 0x21
    8b0e:	9a a1       	ldd	r25, Y+34	; 0x22
    8b10:	01 97       	sbiw	r24, 0x01	; 1
    8b12:	9a a3       	std	Y+34, r25	; 0x22
    8b14:	89 a3       	std	Y+33, r24	; 0x21
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    8b16:	89 a1       	ldd	r24, Y+33	; 0x21
    8b18:	9a a1       	ldd	r25, Y+34	; 0x22
    8b1a:	00 97       	sbiw	r24, 0x00	; 0
    8b1c:	69 f7       	brne	.-38     	; 0x8af8 <LCD_displayCharacter+0x63a>
    8b1e:	14 c0       	rjmp	.+40     	; 0x8b48 <LCD_displayCharacter+0x68a>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    8b20:	6b a1       	ldd	r22, Y+35	; 0x23
    8b22:	7c a1       	ldd	r23, Y+36	; 0x24
    8b24:	8d a1       	ldd	r24, Y+37	; 0x25
    8b26:	9e a1       	ldd	r25, Y+38	; 0x26
    8b28:	0e 94 65 00 	call	0xca	; 0xca <__fixunssfsi>
    8b2c:	dc 01       	movw	r26, r24
    8b2e:	cb 01       	movw	r24, r22
    8b30:	9a a3       	std	Y+34, r25	; 0x22
    8b32:	89 a3       	std	Y+33, r24	; 0x21
    8b34:	89 a1       	ldd	r24, Y+33	; 0x21
    8b36:	9a a1       	ldd	r25, Y+34	; 0x22
    8b38:	9e 8f       	std	Y+30, r25	; 0x1e
    8b3a:	8d 8f       	std	Y+29, r24	; 0x1d
    8b3c:	8d 8d       	ldd	r24, Y+29	; 0x1d
    8b3e:	9e 8d       	ldd	r25, Y+30	; 0x1e
    8b40:	01 97       	sbiw	r24, 0x01	; 1
    8b42:	f1 f7       	brne	.-4      	; 0x8b40 <LCD_displayCharacter+0x682>
    8b44:	9e 8f       	std	Y+30, r25	; 0x1e
    8b46:	8d 8f       	std	Y+29, r24	; 0x1d
	_delay_ms(1); /* delay for processing Tpw - Tdws = 190ns */

	GPIO_writePin(LCD_DATA_PORT_ID,LCD_DB4_PIN_ID,GET_BIT(data,0));
    8b48:	fe 01       	movw	r30, r28
    8b4a:	ed 59       	subi	r30, 0x9D	; 157
    8b4c:	ff 4f       	sbci	r31, 0xFF	; 255
    8b4e:	80 81       	ld	r24, Z
    8b50:	98 2f       	mov	r25, r24
    8b52:	91 70       	andi	r25, 0x01	; 1
    8b54:	83 e0       	ldi	r24, 0x03	; 3
    8b56:	64 e0       	ldi	r22, 0x04	; 4
    8b58:	49 2f       	mov	r20, r25
    8b5a:	0e 94 9e 38 	call	0x713c	; 0x713c <GPIO_writePin>
	GPIO_writePin(LCD_DATA_PORT_ID,LCD_DB5_PIN_ID,GET_BIT(data,1));
    8b5e:	fe 01       	movw	r30, r28
    8b60:	ed 59       	subi	r30, 0x9D	; 157
    8b62:	ff 4f       	sbci	r31, 0xFF	; 255
    8b64:	80 81       	ld	r24, Z
    8b66:	88 2f       	mov	r24, r24
    8b68:	90 e0       	ldi	r25, 0x00	; 0
    8b6a:	82 70       	andi	r24, 0x02	; 2
    8b6c:	90 70       	andi	r25, 0x00	; 0
    8b6e:	95 95       	asr	r25
    8b70:	87 95       	ror	r24
    8b72:	98 2f       	mov	r25, r24
    8b74:	83 e0       	ldi	r24, 0x03	; 3
    8b76:	65 e0       	ldi	r22, 0x05	; 5
    8b78:	49 2f       	mov	r20, r25
    8b7a:	0e 94 9e 38 	call	0x713c	; 0x713c <GPIO_writePin>
	GPIO_writePin(LCD_DATA_PORT_ID,LCD_DB6_PIN_ID,GET_BIT(data,2));
    8b7e:	fe 01       	movw	r30, r28
    8b80:	ed 59       	subi	r30, 0x9D	; 157
    8b82:	ff 4f       	sbci	r31, 0xFF	; 255
    8b84:	80 81       	ld	r24, Z
    8b86:	88 2f       	mov	r24, r24
    8b88:	90 e0       	ldi	r25, 0x00	; 0
    8b8a:	84 70       	andi	r24, 0x04	; 4
    8b8c:	90 70       	andi	r25, 0x00	; 0
    8b8e:	95 95       	asr	r25
    8b90:	87 95       	ror	r24
    8b92:	95 95       	asr	r25
    8b94:	87 95       	ror	r24
    8b96:	98 2f       	mov	r25, r24
    8b98:	83 e0       	ldi	r24, 0x03	; 3
    8b9a:	66 e0       	ldi	r22, 0x06	; 6
    8b9c:	49 2f       	mov	r20, r25
    8b9e:	0e 94 9e 38 	call	0x713c	; 0x713c <GPIO_writePin>
	GPIO_writePin(LCD_DATA_PORT_ID,LCD_DB7_PIN_ID,GET_BIT(data,3));
    8ba2:	fe 01       	movw	r30, r28
    8ba4:	ed 59       	subi	r30, 0x9D	; 157
    8ba6:	ff 4f       	sbci	r31, 0xFF	; 255
    8ba8:	80 81       	ld	r24, Z
    8baa:	88 2f       	mov	r24, r24
    8bac:	90 e0       	ldi	r25, 0x00	; 0
    8bae:	88 70       	andi	r24, 0x08	; 8
    8bb0:	90 70       	andi	r25, 0x00	; 0
    8bb2:	95 95       	asr	r25
    8bb4:	87 95       	ror	r24
    8bb6:	95 95       	asr	r25
    8bb8:	87 95       	ror	r24
    8bba:	95 95       	asr	r25
    8bbc:	87 95       	ror	r24
    8bbe:	98 2f       	mov	r25, r24
    8bc0:	83 e0       	ldi	r24, 0x03	; 3
    8bc2:	67 e0       	ldi	r22, 0x07	; 7
    8bc4:	49 2f       	mov	r20, r25
    8bc6:	0e 94 9e 38 	call	0x713c	; 0x713c <GPIO_writePin>
    8bca:	80 e0       	ldi	r24, 0x00	; 0
    8bcc:	90 e0       	ldi	r25, 0x00	; 0
    8bce:	a0 e8       	ldi	r26, 0x80	; 128
    8bd0:	bf e3       	ldi	r27, 0x3F	; 63
    8bd2:	89 8f       	std	Y+25, r24	; 0x19
    8bd4:	9a 8f       	std	Y+26, r25	; 0x1a
    8bd6:	ab 8f       	std	Y+27, r26	; 0x1b
    8bd8:	bc 8f       	std	Y+28, r27	; 0x1c
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    8bda:	69 8d       	ldd	r22, Y+25	; 0x19
    8bdc:	7a 8d       	ldd	r23, Y+26	; 0x1a
    8bde:	8b 8d       	ldd	r24, Y+27	; 0x1b
    8be0:	9c 8d       	ldd	r25, Y+28	; 0x1c
    8be2:	20 e0       	ldi	r18, 0x00	; 0
    8be4:	30 e0       	ldi	r19, 0x00	; 0
    8be6:	4a e7       	ldi	r20, 0x7A	; 122
    8be8:	55 e4       	ldi	r21, 0x45	; 69
    8bea:	0e 94 3b 02 	call	0x476	; 0x476 <__mulsf3>
    8bee:	dc 01       	movw	r26, r24
    8bf0:	cb 01       	movw	r24, r22
    8bf2:	8d 8b       	std	Y+21, r24	; 0x15
    8bf4:	9e 8b       	std	Y+22, r25	; 0x16
    8bf6:	af 8b       	std	Y+23, r26	; 0x17
    8bf8:	b8 8f       	std	Y+24, r27	; 0x18
	if (__tmp < 1.0)
    8bfa:	6d 89       	ldd	r22, Y+21	; 0x15
    8bfc:	7e 89       	ldd	r23, Y+22	; 0x16
    8bfe:	8f 89       	ldd	r24, Y+23	; 0x17
    8c00:	98 8d       	ldd	r25, Y+24	; 0x18
    8c02:	20 e0       	ldi	r18, 0x00	; 0
    8c04:	30 e0       	ldi	r19, 0x00	; 0
    8c06:	40 e8       	ldi	r20, 0x80	; 128
    8c08:	5f e3       	ldi	r21, 0x3F	; 63
    8c0a:	0e 94 41 04 	call	0x882	; 0x882 <__ltsf2>
    8c0e:	88 23       	and	r24, r24
    8c10:	2c f4       	brge	.+10     	; 0x8c1c <LCD_displayCharacter+0x75e>
		__ticks = 1;
    8c12:	81 e0       	ldi	r24, 0x01	; 1
    8c14:	90 e0       	ldi	r25, 0x00	; 0
    8c16:	9c 8b       	std	Y+20, r25	; 0x14
    8c18:	8b 8b       	std	Y+19, r24	; 0x13
    8c1a:	3f c0       	rjmp	.+126    	; 0x8c9a <LCD_displayCharacter+0x7dc>
	else if (__tmp > 65535)
    8c1c:	6d 89       	ldd	r22, Y+21	; 0x15
    8c1e:	7e 89       	ldd	r23, Y+22	; 0x16
    8c20:	8f 89       	ldd	r24, Y+23	; 0x17
    8c22:	98 8d       	ldd	r25, Y+24	; 0x18
    8c24:	20 e0       	ldi	r18, 0x00	; 0
    8c26:	3f ef       	ldi	r19, 0xFF	; 255
    8c28:	4f e7       	ldi	r20, 0x7F	; 127
    8c2a:	57 e4       	ldi	r21, 0x47	; 71
    8c2c:	0e 94 e1 03 	call	0x7c2	; 0x7c2 <__gtsf2>
    8c30:	18 16       	cp	r1, r24
    8c32:	4c f5       	brge	.+82     	; 0x8c86 <LCD_displayCharacter+0x7c8>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    8c34:	69 8d       	ldd	r22, Y+25	; 0x19
    8c36:	7a 8d       	ldd	r23, Y+26	; 0x1a
    8c38:	8b 8d       	ldd	r24, Y+27	; 0x1b
    8c3a:	9c 8d       	ldd	r25, Y+28	; 0x1c
    8c3c:	20 e0       	ldi	r18, 0x00	; 0
    8c3e:	30 e0       	ldi	r19, 0x00	; 0
    8c40:	40 e2       	ldi	r20, 0x20	; 32
    8c42:	51 e4       	ldi	r21, 0x41	; 65
    8c44:	0e 94 3b 02 	call	0x476	; 0x476 <__mulsf3>
    8c48:	dc 01       	movw	r26, r24
    8c4a:	cb 01       	movw	r24, r22
    8c4c:	bc 01       	movw	r22, r24
    8c4e:	cd 01       	movw	r24, r26
    8c50:	0e 94 65 00 	call	0xca	; 0xca <__fixunssfsi>
    8c54:	dc 01       	movw	r26, r24
    8c56:	cb 01       	movw	r24, r22
    8c58:	9c 8b       	std	Y+20, r25	; 0x14
    8c5a:	8b 8b       	std	Y+19, r24	; 0x13
    8c5c:	0f c0       	rjmp	.+30     	; 0x8c7c <LCD_displayCharacter+0x7be>
    8c5e:	80 e9       	ldi	r24, 0x90	; 144
    8c60:	91 e0       	ldi	r25, 0x01	; 1
    8c62:	9a 8b       	std	Y+18, r25	; 0x12
    8c64:	89 8b       	std	Y+17, r24	; 0x11
    8c66:	89 89       	ldd	r24, Y+17	; 0x11
    8c68:	9a 89       	ldd	r25, Y+18	; 0x12
    8c6a:	01 97       	sbiw	r24, 0x01	; 1
    8c6c:	f1 f7       	brne	.-4      	; 0x8c6a <LCD_displayCharacter+0x7ac>
    8c6e:	9a 8b       	std	Y+18, r25	; 0x12
    8c70:	89 8b       	std	Y+17, r24	; 0x11
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    8c72:	8b 89       	ldd	r24, Y+19	; 0x13
    8c74:	9c 89       	ldd	r25, Y+20	; 0x14
    8c76:	01 97       	sbiw	r24, 0x01	; 1
    8c78:	9c 8b       	std	Y+20, r25	; 0x14
    8c7a:	8b 8b       	std	Y+19, r24	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    8c7c:	8b 89       	ldd	r24, Y+19	; 0x13
    8c7e:	9c 89       	ldd	r25, Y+20	; 0x14
    8c80:	00 97       	sbiw	r24, 0x00	; 0
    8c82:	69 f7       	brne	.-38     	; 0x8c5e <LCD_displayCharacter+0x7a0>
    8c84:	14 c0       	rjmp	.+40     	; 0x8cae <LCD_displayCharacter+0x7f0>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    8c86:	6d 89       	ldd	r22, Y+21	; 0x15
    8c88:	7e 89       	ldd	r23, Y+22	; 0x16
    8c8a:	8f 89       	ldd	r24, Y+23	; 0x17
    8c8c:	98 8d       	ldd	r25, Y+24	; 0x18
    8c8e:	0e 94 65 00 	call	0xca	; 0xca <__fixunssfsi>
    8c92:	dc 01       	movw	r26, r24
    8c94:	cb 01       	movw	r24, r22
    8c96:	9c 8b       	std	Y+20, r25	; 0x14
    8c98:	8b 8b       	std	Y+19, r24	; 0x13
    8c9a:	8b 89       	ldd	r24, Y+19	; 0x13
    8c9c:	9c 89       	ldd	r25, Y+20	; 0x14
    8c9e:	98 8b       	std	Y+16, r25	; 0x10
    8ca0:	8f 87       	std	Y+15, r24	; 0x0f
    8ca2:	8f 85       	ldd	r24, Y+15	; 0x0f
    8ca4:	98 89       	ldd	r25, Y+16	; 0x10
    8ca6:	01 97       	sbiw	r24, 0x01	; 1
    8ca8:	f1 f7       	brne	.-4      	; 0x8ca6 <LCD_displayCharacter+0x7e8>
    8caa:	98 8b       	std	Y+16, r25	; 0x10
    8cac:	8f 87       	std	Y+15, r24	; 0x0f

	_delay_ms(1); /* delay for processing Tdsw = 100ns */
	GPIO_writePin(LCD_E_PORT_ID,LCD_E_PIN_ID,LOGIC_LOW); /* Disable LCD E=0 */
    8cae:	83 e0       	ldi	r24, 0x03	; 3
    8cb0:	62 e0       	ldi	r22, 0x02	; 2
    8cb2:	40 e0       	ldi	r20, 0x00	; 0
    8cb4:	0e 94 9e 38 	call	0x713c	; 0x713c <GPIO_writePin>
    8cb8:	80 e0       	ldi	r24, 0x00	; 0
    8cba:	90 e0       	ldi	r25, 0x00	; 0
    8cbc:	a0 e8       	ldi	r26, 0x80	; 128
    8cbe:	bf e3       	ldi	r27, 0x3F	; 63
    8cc0:	8b 87       	std	Y+11, r24	; 0x0b
    8cc2:	9c 87       	std	Y+12, r25	; 0x0c
    8cc4:	ad 87       	std	Y+13, r26	; 0x0d
    8cc6:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    8cc8:	6b 85       	ldd	r22, Y+11	; 0x0b
    8cca:	7c 85       	ldd	r23, Y+12	; 0x0c
    8ccc:	8d 85       	ldd	r24, Y+13	; 0x0d
    8cce:	9e 85       	ldd	r25, Y+14	; 0x0e
    8cd0:	20 e0       	ldi	r18, 0x00	; 0
    8cd2:	30 e0       	ldi	r19, 0x00	; 0
    8cd4:	4a e7       	ldi	r20, 0x7A	; 122
    8cd6:	55 e4       	ldi	r21, 0x45	; 69
    8cd8:	0e 94 3b 02 	call	0x476	; 0x476 <__mulsf3>
    8cdc:	dc 01       	movw	r26, r24
    8cde:	cb 01       	movw	r24, r22
    8ce0:	8f 83       	std	Y+7, r24	; 0x07
    8ce2:	98 87       	std	Y+8, r25	; 0x08
    8ce4:	a9 87       	std	Y+9, r26	; 0x09
    8ce6:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    8ce8:	6f 81       	ldd	r22, Y+7	; 0x07
    8cea:	78 85       	ldd	r23, Y+8	; 0x08
    8cec:	89 85       	ldd	r24, Y+9	; 0x09
    8cee:	9a 85       	ldd	r25, Y+10	; 0x0a
    8cf0:	20 e0       	ldi	r18, 0x00	; 0
    8cf2:	30 e0       	ldi	r19, 0x00	; 0
    8cf4:	40 e8       	ldi	r20, 0x80	; 128
    8cf6:	5f e3       	ldi	r21, 0x3F	; 63
    8cf8:	0e 94 41 04 	call	0x882	; 0x882 <__ltsf2>
    8cfc:	88 23       	and	r24, r24
    8cfe:	2c f4       	brge	.+10     	; 0x8d0a <LCD_displayCharacter+0x84c>
		__ticks = 1;
    8d00:	81 e0       	ldi	r24, 0x01	; 1
    8d02:	90 e0       	ldi	r25, 0x00	; 0
    8d04:	9e 83       	std	Y+6, r25	; 0x06
    8d06:	8d 83       	std	Y+5, r24	; 0x05
    8d08:	3f c0       	rjmp	.+126    	; 0x8d88 <LCD_displayCharacter+0x8ca>
	else if (__tmp > 65535)
    8d0a:	6f 81       	ldd	r22, Y+7	; 0x07
    8d0c:	78 85       	ldd	r23, Y+8	; 0x08
    8d0e:	89 85       	ldd	r24, Y+9	; 0x09
    8d10:	9a 85       	ldd	r25, Y+10	; 0x0a
    8d12:	20 e0       	ldi	r18, 0x00	; 0
    8d14:	3f ef       	ldi	r19, 0xFF	; 255
    8d16:	4f e7       	ldi	r20, 0x7F	; 127
    8d18:	57 e4       	ldi	r21, 0x47	; 71
    8d1a:	0e 94 e1 03 	call	0x7c2	; 0x7c2 <__gtsf2>
    8d1e:	18 16       	cp	r1, r24
    8d20:	4c f5       	brge	.+82     	; 0x8d74 <LCD_displayCharacter+0x8b6>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    8d22:	6b 85       	ldd	r22, Y+11	; 0x0b
    8d24:	7c 85       	ldd	r23, Y+12	; 0x0c
    8d26:	8d 85       	ldd	r24, Y+13	; 0x0d
    8d28:	9e 85       	ldd	r25, Y+14	; 0x0e
    8d2a:	20 e0       	ldi	r18, 0x00	; 0
    8d2c:	30 e0       	ldi	r19, 0x00	; 0
    8d2e:	40 e2       	ldi	r20, 0x20	; 32
    8d30:	51 e4       	ldi	r21, 0x41	; 65
    8d32:	0e 94 3b 02 	call	0x476	; 0x476 <__mulsf3>
    8d36:	dc 01       	movw	r26, r24
    8d38:	cb 01       	movw	r24, r22
    8d3a:	bc 01       	movw	r22, r24
    8d3c:	cd 01       	movw	r24, r26
    8d3e:	0e 94 65 00 	call	0xca	; 0xca <__fixunssfsi>
    8d42:	dc 01       	movw	r26, r24
    8d44:	cb 01       	movw	r24, r22
    8d46:	9e 83       	std	Y+6, r25	; 0x06
    8d48:	8d 83       	std	Y+5, r24	; 0x05
    8d4a:	0f c0       	rjmp	.+30     	; 0x8d6a <LCD_displayCharacter+0x8ac>
    8d4c:	80 e9       	ldi	r24, 0x90	; 144
    8d4e:	91 e0       	ldi	r25, 0x01	; 1
    8d50:	9c 83       	std	Y+4, r25	; 0x04
    8d52:	8b 83       	std	Y+3, r24	; 0x03
    8d54:	8b 81       	ldd	r24, Y+3	; 0x03
    8d56:	9c 81       	ldd	r25, Y+4	; 0x04
    8d58:	01 97       	sbiw	r24, 0x01	; 1
    8d5a:	f1 f7       	brne	.-4      	; 0x8d58 <LCD_displayCharacter+0x89a>
    8d5c:	9c 83       	std	Y+4, r25	; 0x04
    8d5e:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    8d60:	8d 81       	ldd	r24, Y+5	; 0x05
    8d62:	9e 81       	ldd	r25, Y+6	; 0x06
    8d64:	01 97       	sbiw	r24, 0x01	; 1
    8d66:	9e 83       	std	Y+6, r25	; 0x06
    8d68:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    8d6a:	8d 81       	ldd	r24, Y+5	; 0x05
    8d6c:	9e 81       	ldd	r25, Y+6	; 0x06
    8d6e:	00 97       	sbiw	r24, 0x00	; 0
    8d70:	69 f7       	brne	.-38     	; 0x8d4c <LCD_displayCharacter+0x88e>
    8d72:	14 c0       	rjmp	.+40     	; 0x8d9c <LCD_displayCharacter+0x8de>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    8d74:	6f 81       	ldd	r22, Y+7	; 0x07
    8d76:	78 85       	ldd	r23, Y+8	; 0x08
    8d78:	89 85       	ldd	r24, Y+9	; 0x09
    8d7a:	9a 85       	ldd	r25, Y+10	; 0x0a
    8d7c:	0e 94 65 00 	call	0xca	; 0xca <__fixunssfsi>
    8d80:	dc 01       	movw	r26, r24
    8d82:	cb 01       	movw	r24, r22
    8d84:	9e 83       	std	Y+6, r25	; 0x06
    8d86:	8d 83       	std	Y+5, r24	; 0x05
    8d88:	8d 81       	ldd	r24, Y+5	; 0x05
    8d8a:	9e 81       	ldd	r25, Y+6	; 0x06
    8d8c:	9a 83       	std	Y+2, r25	; 0x02
    8d8e:	89 83       	std	Y+1, r24	; 0x01
    8d90:	89 81       	ldd	r24, Y+1	; 0x01
    8d92:	9a 81       	ldd	r25, Y+2	; 0x02
    8d94:	01 97       	sbiw	r24, 0x01	; 1
    8d96:	f1 f7       	brne	.-4      	; 0x8d94 <LCD_displayCharacter+0x8d6>
    8d98:	9a 83       	std	Y+2, r25	; 0x02
    8d9a:	89 83       	std	Y+1, r24	; 0x01
	GPIO_writePort(LCD_DATA_PORT_ID,data); /* out the required command to the data bus D0 --> D7 */
	_delay_ms(1); /* delay for processing Tdsw = 100ns */
	GPIO_writePin(LCD_E_PORT_ID,LCD_E_PIN_ID,LOGIC_LOW); /* Disable LCD E=0 */
	_delay_ms(1); /* delay for processing Th = 13ns */
#endif
}
    8d9c:	cd 59       	subi	r28, 0x9D	; 157
    8d9e:	df 4f       	sbci	r29, 0xFF	; 255
    8da0:	0f b6       	in	r0, 0x3f	; 63
    8da2:	f8 94       	cli
    8da4:	de bf       	out	0x3e, r29	; 62
    8da6:	0f be       	out	0x3f, r0	; 63
    8da8:	cd bf       	out	0x3d, r28	; 61
    8daa:	cf 91       	pop	r28
    8dac:	df 91       	pop	r29
    8dae:	1f 91       	pop	r17
    8db0:	0f 91       	pop	r16
    8db2:	08 95       	ret

00008db4 <LCD_displayString>:
/*
 * Description :
 * Display the required string on the screen
 */
void LCD_displayString(const char *Str)
{
    8db4:	df 93       	push	r29
    8db6:	cf 93       	push	r28
    8db8:	00 d0       	rcall	.+0      	; 0x8dba <LCD_displayString+0x6>
    8dba:	0f 92       	push	r0
    8dbc:	cd b7       	in	r28, 0x3d	; 61
    8dbe:	de b7       	in	r29, 0x3e	; 62
    8dc0:	9b 83       	std	Y+3, r25	; 0x03
    8dc2:	8a 83       	std	Y+2, r24	; 0x02
	uint8 i = 0;
    8dc4:	19 82       	std	Y+1, r1	; 0x01
    8dc6:	0e c0       	rjmp	.+28     	; 0x8de4 <LCD_displayString+0x30>
	while(Str[i] != '\0')
	{
		LCD_displayCharacter(Str[i]);
    8dc8:	89 81       	ldd	r24, Y+1	; 0x01
    8dca:	28 2f       	mov	r18, r24
    8dcc:	30 e0       	ldi	r19, 0x00	; 0
    8dce:	8a 81       	ldd	r24, Y+2	; 0x02
    8dd0:	9b 81       	ldd	r25, Y+3	; 0x03
    8dd2:	fc 01       	movw	r30, r24
    8dd4:	e2 0f       	add	r30, r18
    8dd6:	f3 1f       	adc	r31, r19
    8dd8:	80 81       	ld	r24, Z
    8dda:	0e 94 5f 42 	call	0x84be	; 0x84be <LCD_displayCharacter>
		i++;
    8dde:	89 81       	ldd	r24, Y+1	; 0x01
    8de0:	8f 5f       	subi	r24, 0xFF	; 255
    8de2:	89 83       	std	Y+1, r24	; 0x01
 * Display the required string on the screen
 */
void LCD_displayString(const char *Str)
{
	uint8 i = 0;
	while(Str[i] != '\0')
    8de4:	89 81       	ldd	r24, Y+1	; 0x01
    8de6:	28 2f       	mov	r18, r24
    8de8:	30 e0       	ldi	r19, 0x00	; 0
    8dea:	8a 81       	ldd	r24, Y+2	; 0x02
    8dec:	9b 81       	ldd	r25, Y+3	; 0x03
    8dee:	fc 01       	movw	r30, r24
    8df0:	e2 0f       	add	r30, r18
    8df2:	f3 1f       	adc	r31, r19
    8df4:	80 81       	ld	r24, Z
    8df6:	88 23       	and	r24, r24
    8df8:	39 f7       	brne	.-50     	; 0x8dc8 <LCD_displayString+0x14>
	{
		LCD_displayCharacter(*Str);
		Str++;
	}		
	*********************************************************/
}
    8dfa:	0f 90       	pop	r0
    8dfc:	0f 90       	pop	r0
    8dfe:	0f 90       	pop	r0
    8e00:	cf 91       	pop	r28
    8e02:	df 91       	pop	r29
    8e04:	08 95       	ret

00008e06 <LCD_moveCursor>:
/*
 * Description :
 * Move the cursor to a specified row and column index on the screen
 */
void LCD_moveCursor(uint8 row,uint8 col)
{
    8e06:	df 93       	push	r29
    8e08:	cf 93       	push	r28
    8e0a:	00 d0       	rcall	.+0      	; 0x8e0c <LCD_moveCursor+0x6>
    8e0c:	00 d0       	rcall	.+0      	; 0x8e0e <LCD_moveCursor+0x8>
    8e0e:	0f 92       	push	r0
    8e10:	cd b7       	in	r28, 0x3d	; 61
    8e12:	de b7       	in	r29, 0x3e	; 62
    8e14:	8a 83       	std	Y+2, r24	; 0x02
    8e16:	6b 83       	std	Y+3, r22	; 0x03
	uint8 lcd_memory_address;
	
	/* Calculate the required address in the LCD DDRAM */
	switch(row)
    8e18:	8a 81       	ldd	r24, Y+2	; 0x02
    8e1a:	28 2f       	mov	r18, r24
    8e1c:	30 e0       	ldi	r19, 0x00	; 0
    8e1e:	3d 83       	std	Y+5, r19	; 0x05
    8e20:	2c 83       	std	Y+4, r18	; 0x04
    8e22:	8c 81       	ldd	r24, Y+4	; 0x04
    8e24:	9d 81       	ldd	r25, Y+5	; 0x05
    8e26:	81 30       	cpi	r24, 0x01	; 1
    8e28:	91 05       	cpc	r25, r1
    8e2a:	c1 f0       	breq	.+48     	; 0x8e5c <LCD_moveCursor+0x56>
    8e2c:	2c 81       	ldd	r18, Y+4	; 0x04
    8e2e:	3d 81       	ldd	r19, Y+5	; 0x05
    8e30:	22 30       	cpi	r18, 0x02	; 2
    8e32:	31 05       	cpc	r19, r1
    8e34:	2c f4       	brge	.+10     	; 0x8e40 <LCD_moveCursor+0x3a>
    8e36:	8c 81       	ldd	r24, Y+4	; 0x04
    8e38:	9d 81       	ldd	r25, Y+5	; 0x05
    8e3a:	00 97       	sbiw	r24, 0x00	; 0
    8e3c:	61 f0       	breq	.+24     	; 0x8e56 <LCD_moveCursor+0x50>
    8e3e:	19 c0       	rjmp	.+50     	; 0x8e72 <LCD_moveCursor+0x6c>
    8e40:	2c 81       	ldd	r18, Y+4	; 0x04
    8e42:	3d 81       	ldd	r19, Y+5	; 0x05
    8e44:	22 30       	cpi	r18, 0x02	; 2
    8e46:	31 05       	cpc	r19, r1
    8e48:	69 f0       	breq	.+26     	; 0x8e64 <LCD_moveCursor+0x5e>
    8e4a:	8c 81       	ldd	r24, Y+4	; 0x04
    8e4c:	9d 81       	ldd	r25, Y+5	; 0x05
    8e4e:	83 30       	cpi	r24, 0x03	; 3
    8e50:	91 05       	cpc	r25, r1
    8e52:	61 f0       	breq	.+24     	; 0x8e6c <LCD_moveCursor+0x66>
    8e54:	0e c0       	rjmp	.+28     	; 0x8e72 <LCD_moveCursor+0x6c>
	{
		case 0:
			lcd_memory_address=col;
    8e56:	8b 81       	ldd	r24, Y+3	; 0x03
    8e58:	89 83       	std	Y+1, r24	; 0x01
    8e5a:	0b c0       	rjmp	.+22     	; 0x8e72 <LCD_moveCursor+0x6c>
				break;
		case 1:
			lcd_memory_address=col+0x40;
    8e5c:	8b 81       	ldd	r24, Y+3	; 0x03
    8e5e:	80 5c       	subi	r24, 0xC0	; 192
    8e60:	89 83       	std	Y+1, r24	; 0x01
    8e62:	07 c0       	rjmp	.+14     	; 0x8e72 <LCD_moveCursor+0x6c>
				break;
		case 2:
			lcd_memory_address=col+0x10;
    8e64:	8b 81       	ldd	r24, Y+3	; 0x03
    8e66:	80 5f       	subi	r24, 0xF0	; 240
    8e68:	89 83       	std	Y+1, r24	; 0x01
    8e6a:	03 c0       	rjmp	.+6      	; 0x8e72 <LCD_moveCursor+0x6c>
				break;
		case 3:
			lcd_memory_address=col+0x50;
    8e6c:	8b 81       	ldd	r24, Y+3	; 0x03
    8e6e:	80 5b       	subi	r24, 0xB0	; 176
    8e70:	89 83       	std	Y+1, r24	; 0x01
				break;
	}					
	/* Move the LCD cursor to this specific address */
	LCD_sendCommand(lcd_memory_address | LCD_SET_CURSOR_LOCATION);
    8e72:	89 81       	ldd	r24, Y+1	; 0x01
    8e74:	80 68       	ori	r24, 0x80	; 128
    8e76:	0e 94 e4 3d 	call	0x7bc8	; 0x7bc8 <LCD_sendCommand>
}
    8e7a:	0f 90       	pop	r0
    8e7c:	0f 90       	pop	r0
    8e7e:	0f 90       	pop	r0
    8e80:	0f 90       	pop	r0
    8e82:	0f 90       	pop	r0
    8e84:	cf 91       	pop	r28
    8e86:	df 91       	pop	r29
    8e88:	08 95       	ret

00008e8a <LCD_displayStringRowColumn>:
/*
 * Description :
 * Display the required string in a specified row and column index on the screen
 */
void LCD_displayStringRowColumn(uint8 row,uint8 col,const char *Str)
{
    8e8a:	df 93       	push	r29
    8e8c:	cf 93       	push	r28
    8e8e:	00 d0       	rcall	.+0      	; 0x8e90 <LCD_displayStringRowColumn+0x6>
    8e90:	00 d0       	rcall	.+0      	; 0x8e92 <LCD_displayStringRowColumn+0x8>
    8e92:	cd b7       	in	r28, 0x3d	; 61
    8e94:	de b7       	in	r29, 0x3e	; 62
    8e96:	89 83       	std	Y+1, r24	; 0x01
    8e98:	6a 83       	std	Y+2, r22	; 0x02
    8e9a:	5c 83       	std	Y+4, r21	; 0x04
    8e9c:	4b 83       	std	Y+3, r20	; 0x03
	LCD_moveCursor(row,col); /* go to to the required LCD position */
    8e9e:	89 81       	ldd	r24, Y+1	; 0x01
    8ea0:	6a 81       	ldd	r22, Y+2	; 0x02
    8ea2:	0e 94 03 47 	call	0x8e06	; 0x8e06 <LCD_moveCursor>
	LCD_displayString(Str); /* display the string */
    8ea6:	8b 81       	ldd	r24, Y+3	; 0x03
    8ea8:	9c 81       	ldd	r25, Y+4	; 0x04
    8eaa:	0e 94 da 46 	call	0x8db4	; 0x8db4 <LCD_displayString>
}
    8eae:	0f 90       	pop	r0
    8eb0:	0f 90       	pop	r0
    8eb2:	0f 90       	pop	r0
    8eb4:	0f 90       	pop	r0
    8eb6:	cf 91       	pop	r28
    8eb8:	df 91       	pop	r29
    8eba:	08 95       	ret

00008ebc <LCD_intgerToString>:
/*
 * Description :
 * Display the required decimal value on the screen
 */
void LCD_intgerToString(int data)
{
    8ebc:	df 93       	push	r29
    8ebe:	cf 93       	push	r28
    8ec0:	cd b7       	in	r28, 0x3d	; 61
    8ec2:	de b7       	in	r29, 0x3e	; 62
    8ec4:	62 97       	sbiw	r28, 0x12	; 18
    8ec6:	0f b6       	in	r0, 0x3f	; 63
    8ec8:	f8 94       	cli
    8eca:	de bf       	out	0x3e, r29	; 62
    8ecc:	0f be       	out	0x3f, r0	; 63
    8ece:	cd bf       	out	0x3d, r28	; 61
    8ed0:	9a 8b       	std	Y+18, r25	; 0x12
    8ed2:	89 8b       	std	Y+17, r24	; 0x11
   char buff[16]; /* String to hold the ascii result */
   itoa(data,buff,10); /* Use itoa C function to convert the data to its corresponding ASCII value, 10 for decimal */
    8ed4:	89 89       	ldd	r24, Y+17	; 0x11
    8ed6:	9a 89       	ldd	r25, Y+18	; 0x12
    8ed8:	9e 01       	movw	r18, r28
    8eda:	2f 5f       	subi	r18, 0xFF	; 255
    8edc:	3f 4f       	sbci	r19, 0xFF	; 255
    8ede:	b9 01       	movw	r22, r18
    8ee0:	4a e0       	ldi	r20, 0x0A	; 10
    8ee2:	50 e0       	ldi	r21, 0x00	; 0
    8ee4:	0e 94 1e 49 	call	0x923c	; 0x923c <itoa>
   LCD_displayString(buff); /* Display the string */
    8ee8:	ce 01       	movw	r24, r28
    8eea:	01 96       	adiw	r24, 0x01	; 1
    8eec:	0e 94 da 46 	call	0x8db4	; 0x8db4 <LCD_displayString>
}
    8ef0:	62 96       	adiw	r28, 0x12	; 18
    8ef2:	0f b6       	in	r0, 0x3f	; 63
    8ef4:	f8 94       	cli
    8ef6:	de bf       	out	0x3e, r29	; 62
    8ef8:	0f be       	out	0x3f, r0	; 63
    8efa:	cd bf       	out	0x3d, r28	; 61
    8efc:	cf 91       	pop	r28
    8efe:	df 91       	pop	r29
    8f00:	08 95       	ret

00008f02 <LCD_clearScreen>:
/*
 * Description :
 * Send the clear screen command
 */
void LCD_clearScreen(void)
{
    8f02:	df 93       	push	r29
    8f04:	cf 93       	push	r28
    8f06:	cd b7       	in	r28, 0x3d	; 61
    8f08:	de b7       	in	r29, 0x3e	; 62
	LCD_sendCommand(LCD_CLEAR_COMMAND); /* Send clear display command */
    8f0a:	81 e0       	ldi	r24, 0x01	; 1
    8f0c:	0e 94 e4 3d 	call	0x7bc8	; 0x7bc8 <LCD_sendCommand>
}
    8f10:	cf 91       	pop	r28
    8f12:	df 91       	pop	r29
    8f14:	08 95       	ret

00008f16 <main>:
TaskHandle_t task3ptr;

TimerHandle_t xTimer2;

int main(void)
{
    8f16:	ef 92       	push	r14
    8f18:	ff 92       	push	r15
    8f1a:	0f 93       	push	r16
    8f1c:	1f 93       	push	r17
    8f1e:	df 93       	push	r29
    8f20:	cf 93       	push	r28
    8f22:	00 d0       	rcall	.+0      	; 0x8f24 <main+0xe>
    8f24:	cd b7       	in	r28, 0x3d	; 61
    8f26:	de b7       	in	r29, 0x3e	; 62
	DIO_init();
    8f28:	0e 94 d1 3b 	call	0x77a2	; 0x77a2 <DIO_init>
	LCD_init();
    8f2c:	0e 94 32 3d 	call	0x7a64	; 0x7a64 <LCD_init>
//	timer1_PWM_Init();

	SREG |=(1<<7);			// I bit Enabled
    8f30:	af e5       	ldi	r26, 0x5F	; 95
    8f32:	b0 e0       	ldi	r27, 0x00	; 0
    8f34:	ef e5       	ldi	r30, 0x5F	; 95
    8f36:	f0 e0       	ldi	r31, 0x00	; 0
    8f38:	80 81       	ld	r24, Z
    8f3a:	80 68       	ori	r24, 0x80	; 128
    8f3c:	8c 93       	st	X, r24

//	xTaskCreate(Task1_Func,"first",configMINIMAL_STACK_SIZE,NULL,1,&task1ptr);
//	xTaskCreate(Task2_Func,"second",configMINIMAL_STACK_SIZE,NULL,1,&task2ptr);
	xTaskCreate(Task3_Func,"third",configMINIMAL_STACK_SIZE,NULL,1,&task3ptr);
    8f3e:	82 e1       	ldi	r24, 0x12	; 18
    8f40:	98 e4       	ldi	r25, 0x48	; 72
    8f42:	2d e0       	ldi	r18, 0x0D	; 13
    8f44:	31 e0       	ldi	r19, 0x01	; 1
    8f46:	ec ee       	ldi	r30, 0xEC	; 236
    8f48:	f8 e0       	ldi	r31, 0x08	; 8
    8f4a:	b9 01       	movw	r22, r18
    8f4c:	45 e5       	ldi	r20, 0x55	; 85
    8f4e:	50 e0       	ldi	r21, 0x00	; 0
    8f50:	20 e0       	ldi	r18, 0x00	; 0
    8f52:	30 e0       	ldi	r19, 0x00	; 0
    8f54:	01 e0       	ldi	r16, 0x01	; 1
    8f56:	7f 01       	movw	r14, r30
    8f58:	0e 94 37 1b 	call	0x366e	; 0x366e <xTaskCreate>

	xTimer2 = xTimerCreate("timer1",500/portTICK_PERIOD_MS,pdTRUE,0,Task2_Func);
    8f5c:	ec ee       	ldi	r30, 0xEC	; 236
    8f5e:	f7 e4       	ldi	r31, 0x47	; 71
    8f60:	83 e1       	ldi	r24, 0x13	; 19
    8f62:	91 e0       	ldi	r25, 0x01	; 1
    8f64:	64 ef       	ldi	r22, 0xF4	; 244
    8f66:	71 e0       	ldi	r23, 0x01	; 1
    8f68:	41 e0       	ldi	r20, 0x01	; 1
    8f6a:	20 e0       	ldi	r18, 0x00	; 0
    8f6c:	30 e0       	ldi	r19, 0x00	; 0
    8f6e:	8f 01       	movw	r16, r30
    8f70:	0e 94 50 2f 	call	0x5ea0	; 0x5ea0 <xTimerCreate>
    8f74:	90 93 f3 08 	sts	0x08F3, r25
    8f78:	80 93 f2 08 	sts	0x08F2, r24
	TimerHandle_t xTimer1 = xTimerCreate("timer2",5/portTICK_PERIOD_MS,pdTRUE,0,Task1_Func);
    8f7c:	ef ef       	ldi	r30, 0xFF	; 255
    8f7e:	f7 e4       	ldi	r31, 0x47	; 71
    8f80:	8a e1       	ldi	r24, 0x1A	; 26
    8f82:	91 e0       	ldi	r25, 0x01	; 1
    8f84:	65 e0       	ldi	r22, 0x05	; 5
    8f86:	70 e0       	ldi	r23, 0x00	; 0
    8f88:	41 e0       	ldi	r20, 0x01	; 1
    8f8a:	20 e0       	ldi	r18, 0x00	; 0
    8f8c:	30 e0       	ldi	r19, 0x00	; 0
    8f8e:	8f 01       	movw	r16, r30
    8f90:	0e 94 50 2f 	call	0x5ea0	; 0x5ea0 <xTimerCreate>
    8f94:	9a 83       	std	Y+2, r25	; 0x02
    8f96:	89 83       	std	Y+1, r24	; 0x01
	xTimerStart(xTimer2, 1);
    8f98:	00 91 f2 08 	lds	r16, 0x08F2
    8f9c:	10 91 f3 08 	lds	r17, 0x08F3
    8fa0:	0e 94 e4 1f 	call	0x3fc8	; 0x3fc8 <xTaskGetTickCount>
    8fa4:	9c 01       	movw	r18, r24
    8fa6:	c8 01       	movw	r24, r16
    8fa8:	61 e0       	ldi	r22, 0x01	; 1
    8faa:	a9 01       	movw	r20, r18
    8fac:	20 e0       	ldi	r18, 0x00	; 0
    8fae:	30 e0       	ldi	r19, 0x00	; 0
    8fb0:	01 e0       	ldi	r16, 0x01	; 1
    8fb2:	10 e0       	ldi	r17, 0x00	; 0
    8fb4:	0e 94 e2 2f 	call	0x5fc4	; 0x5fc4 <xTimerGenericCommand>
	xTimerStart(xTimer1, 10);
    8fb8:	0e 94 e4 1f 	call	0x3fc8	; 0x3fc8 <xTaskGetTickCount>
    8fbc:	9c 01       	movw	r18, r24
    8fbe:	89 81       	ldd	r24, Y+1	; 0x01
    8fc0:	9a 81       	ldd	r25, Y+2	; 0x02
    8fc2:	61 e0       	ldi	r22, 0x01	; 1
    8fc4:	a9 01       	movw	r20, r18
    8fc6:	20 e0       	ldi	r18, 0x00	; 0
    8fc8:	30 e0       	ldi	r19, 0x00	; 0
    8fca:	0a e0       	ldi	r16, 0x0A	; 10
    8fcc:	10 e0       	ldi	r17, 0x00	; 0
    8fce:	0e 94 e2 2f 	call	0x5fc4	; 0x5fc4 <xTimerGenericCommand>



	vTaskStartScheduler();
    8fd2:	0e 94 41 1e 	call	0x3c82	; 0x3c82 <vTaskStartScheduler>
    8fd6:	ff cf       	rjmp	.-2      	; 0x8fd6 <main+0xc0>

00008fd8 <Task2_Func>:
//	Poll();
//}


void Task2_Func(void)
{
    8fd8:	df 93       	push	r29
    8fda:	cf 93       	push	r28
    8fdc:	0f 92       	push	r0
    8fde:	cd b7       	in	r28, 0x3d	; 61
    8fe0:	de b7       	in	r29, 0x3e	; 62
//	while(1)
//	{
//		SET_BIT(PORTB,5);
		ToggleLED = !ToggleLED;
    8fe2:	80 91 d6 08 	lds	r24, 0x08D6
    8fe6:	19 82       	std	Y+1, r1	; 0x01
    8fe8:	88 23       	and	r24, r24
    8fea:	11 f4       	brne	.+4      	; 0x8ff0 <Task2_Func+0x18>
    8fec:	81 e0       	ldi	r24, 0x01	; 1
    8fee:	89 83       	std	Y+1, r24	; 0x01
    8ff0:	89 81       	ldd	r24, Y+1	; 0x01
    8ff2:	80 93 d6 08 	sts	0x08D6, r24
//		vTaskDelay(100/portTICK_PERIOD_MS);
//	}

}
    8ff6:	0f 90       	pop	r0
    8ff8:	cf 91       	pop	r28
    8ffa:	df 91       	pop	r29
    8ffc:	08 95       	ret

00008ffe <Task1_Func>:

void Task1_Func(void)
{
    8ffe:	df 93       	push	r29
    9000:	cf 93       	push	r28
    9002:	cd b7       	in	r28, 0x3d	; 61
    9004:	de b7       	in	r29, 0x3e	; 62

		ButtonStateTest = Get_Data();
    9006:	0e 94 69 36 	call	0x6cd2	; 0x6cd2 <Get_Data>
    900a:	dc 01       	movw	r26, r24
    900c:	cb 01       	movw	r24, r22
    900e:	80 93 e5 08 	sts	0x08E5, r24
    9012:	90 93 e6 08 	sts	0x08E6, r25
    9016:	a0 93 e7 08 	sts	0x08E7, r26
    901a:	b0 93 e8 08 	sts	0x08E8, r27


}
    901e:	cf 91       	pop	r28
    9020:	df 91       	pop	r29
    9022:	08 95       	ret

00009024 <Task3_Func>:


/*******************************Some unworking tests**************************************************************/
void Task3_Func(void){
    9024:	df 93       	push	r29
    9026:	cf 93       	push	r28
    9028:	cd b7       	in	r28, 0x3d	; 61
    902a:	de b7       	in	r29, 0x3e	; 62
	while(1)
	{

		if(ButtonStateTest.ignition_key==TRUE)
    902c:	80 91 e5 08 	lds	r24, 0x08E5
    9030:	81 30       	cpi	r24, 0x01	; 1
    9032:	a1 f4       	brne	.+40     	; 0x905c <Task3_Func+0x38>
			{
				if(ButtonStateTest.rightIndicator==TRUE)
    9034:	80 91 e6 08 	lds	r24, 0x08E6
    9038:	81 30       	cpi	r24, 0x01	; 1
    903a:	21 f4       	brne	.+8      	; 0x9044 <Task3_Func+0x20>
				{
					state = RIGHT_INDICATOR;
    903c:	81 e0       	ldi	r24, 0x01	; 1
    903e:	80 93 e4 08 	sts	0x08E4, r24
    9042:	0f c0       	rjmp	.+30     	; 0x9062 <Task3_Func+0x3e>
				}
				else if(ButtonStateTest.leftIndicator==TRUE)
    9044:	80 91 e7 08 	lds	r24, 0x08E7
    9048:	81 30       	cpi	r24, 0x01	; 1
    904a:	21 f4       	brne	.+8      	; 0x9054 <Task3_Func+0x30>
				{
					state = LEFT_INDICATOR;
    904c:	82 e0       	ldi	r24, 0x02	; 2
    904e:	80 93 e4 08 	sts	0x08E4, r24
    9052:	07 c0       	rjmp	.+14     	; 0x9062 <Task3_Func+0x3e>
				}
				else
				{
					state = NO_INDICATOR;
    9054:	83 e0       	ldi	r24, 0x03	; 3
    9056:	80 93 e4 08 	sts	0x08E4, r24
    905a:	03 c0       	rjmp	.+6      	; 0x9062 <Task3_Func+0x3e>
				}
			}
			else{
				state = NO_INDICATOR;
    905c:	83 e0       	ldi	r24, 0x03	; 3
    905e:	80 93 e4 08 	sts	0x08E4, r24
			}

			if(ButtonStateTest.hazard_Btn==TRUE)
    9062:	80 91 e8 08 	lds	r24, 0x08E8
    9066:	81 30       	cpi	r24, 0x01	; 1
    9068:	19 f4       	brne	.+6      	; 0x9070 <Task3_Func+0x4c>
			{
				state = HAZARD_BUTTON;
    906a:	84 e0       	ldi	r24, 0x04	; 4
    906c:	80 93 e4 08 	sts	0x08E4, r24
			}

		State_Handler();
    9070:	0e 94 83 34 	call	0x6906	; 0x6906 <State_Handler>
    9074:	db cf       	rjmp	.-74     	; 0x902c <Task3_Func+0x8>

00009076 <Poll>:

int polling_enabled= 1;
int polling_counter= 1;
int counter = 0 ;
void Poll(void)
{
    9076:	df 93       	push	r29
    9078:	cf 93       	push	r28
    907a:	00 d0       	rcall	.+0      	; 0x907c <Poll+0x6>
    907c:	00 d0       	rcall	.+0      	; 0x907e <Poll+0x8>
    907e:	cd b7       	in	r28, 0x3d	; 61
    9080:	de b7       	in	r29, 0x3e	; 62
	if(polling_enabled && (!counter))
    9082:	80 91 2c 02 	lds	r24, 0x022C
    9086:	90 91 2d 02 	lds	r25, 0x022D
    908a:	00 97       	sbiw	r24, 0x00	; 0
    908c:	71 f0       	breq	.+28     	; 0x90aa <Poll+0x34>
    908e:	80 91 e9 08 	lds	r24, 0x08E9
    9092:	90 91 ea 08 	lds	r25, 0x08EA
    9096:	00 97       	sbiw	r24, 0x00	; 0
    9098:	41 f4       	brne	.+16     	; 0x90aa <Poll+0x34>
	{
		States_GroupType data;
		data = Get_Data();
    909a:	0e 94 69 36 	call	0x6cd2	; 0x6cd2 <Get_Data>
    909e:	dc 01       	movw	r26, r24
    90a0:	cb 01       	movw	r24, r22
    90a2:	89 83       	std	Y+1, r24	; 0x01
    90a4:	9a 83       	std	Y+2, r25	; 0x02
    90a6:	ab 83       	std	Y+3, r26	; 0x03
    90a8:	bc 83       	std	Y+4, r27	; 0x04
//		Handle_data(&data);

	}
	counter++;
    90aa:	80 91 e9 08 	lds	r24, 0x08E9
    90ae:	90 91 ea 08 	lds	r25, 0x08EA
    90b2:	01 96       	adiw	r24, 0x01	; 1
    90b4:	90 93 ea 08 	sts	0x08EA, r25
    90b8:	80 93 e9 08 	sts	0x08E9, r24
	counter = counter%polling_counter;
    90bc:	80 91 e9 08 	lds	r24, 0x08E9
    90c0:	90 91 ea 08 	lds	r25, 0x08EA
    90c4:	20 91 2e 02 	lds	r18, 0x022E
    90c8:	30 91 2f 02 	lds	r19, 0x022F
    90cc:	b9 01       	movw	r22, r18
    90ce:	0e 94 c4 48 	call	0x9188	; 0x9188 <__divmodhi4>
    90d2:	90 93 ea 08 	sts	0x08EA, r25
    90d6:	80 93 e9 08 	sts	0x08E9, r24
}
    90da:	0f 90       	pop	r0
    90dc:	0f 90       	pop	r0
    90de:	0f 90       	pop	r0
    90e0:	0f 90       	pop	r0
    90e2:	cf 91       	pop	r28
    90e4:	df 91       	pop	r29
    90e6:	08 95       	ret

000090e8 <StartPolling>:

void StartPolling(void)
{
    90e8:	df 93       	push	r29
    90ea:	cf 93       	push	r28
    90ec:	cd b7       	in	r28, 0x3d	; 61
    90ee:	de b7       	in	r29, 0x3e	; 62
	polling_enabled=1;
    90f0:	81 e0       	ldi	r24, 0x01	; 1
    90f2:	90 e0       	ldi	r25, 0x00	; 0
    90f4:	90 93 2d 02 	sts	0x022D, r25
    90f8:	80 93 2c 02 	sts	0x022C, r24
}
    90fc:	cf 91       	pop	r28
    90fe:	df 91       	pop	r29
    9100:	08 95       	ret

00009102 <StopPolling>:

void StopPolling(void)
{
    9102:	df 93       	push	r29
    9104:	cf 93       	push	r28
    9106:	cd b7       	in	r28, 0x3d	; 61
    9108:	de b7       	in	r29, 0x3e	; 62
	polling_enabled=0;
    910a:	10 92 2d 02 	sts	0x022D, r1
    910e:	10 92 2c 02 	sts	0x022C, r1
}
    9112:	cf 91       	pop	r28
    9114:	df 91       	pop	r29
    9116:	08 95       	ret

00009118 <SetPollingTime>:

void SetPollingTime(int polling_time)
{
    9118:	df 93       	push	r29
    911a:	cf 93       	push	r28
    911c:	00 d0       	rcall	.+0      	; 0x911e <SetPollingTime+0x6>
    911e:	cd b7       	in	r28, 0x3d	; 61
    9120:	de b7       	in	r29, 0x3e	; 62
    9122:	9a 83       	std	Y+2, r25	; 0x02
    9124:	89 83       	std	Y+1, r24	; 0x01
	polling_counter = polling_time/(50*2);
    9126:	89 81       	ldd	r24, Y+1	; 0x01
    9128:	9a 81       	ldd	r25, Y+2	; 0x02
    912a:	24 e6       	ldi	r18, 0x64	; 100
    912c:	30 e0       	ldi	r19, 0x00	; 0
    912e:	b9 01       	movw	r22, r18
    9130:	0e 94 c4 48 	call	0x9188	; 0x9188 <__divmodhi4>
    9134:	cb 01       	movw	r24, r22
    9136:	90 93 2f 02 	sts	0x022F, r25
    913a:	80 93 2e 02 	sts	0x022E, r24
	 *
	 *
	 *
	 *
	 * */
}
    913e:	0f 90       	pop	r0
    9140:	0f 90       	pop	r0
    9142:	cf 91       	pop	r28
    9144:	df 91       	pop	r29
    9146:	08 95       	ret

00009148 <__udivmodqi4>:
    9148:	99 1b       	sub	r25, r25
    914a:	79 e0       	ldi	r23, 0x09	; 9
    914c:	04 c0       	rjmp	.+8      	; 0x9156 <__udivmodqi4_ep>

0000914e <__udivmodqi4_loop>:
    914e:	99 1f       	adc	r25, r25
    9150:	96 17       	cp	r25, r22
    9152:	08 f0       	brcs	.+2      	; 0x9156 <__udivmodqi4_ep>
    9154:	96 1b       	sub	r25, r22

00009156 <__udivmodqi4_ep>:
    9156:	88 1f       	adc	r24, r24
    9158:	7a 95       	dec	r23
    915a:	c9 f7       	brne	.-14     	; 0x914e <__udivmodqi4_loop>
    915c:	80 95       	com	r24
    915e:	08 95       	ret

00009160 <__udivmodhi4>:
    9160:	aa 1b       	sub	r26, r26
    9162:	bb 1b       	sub	r27, r27
    9164:	51 e1       	ldi	r21, 0x11	; 17
    9166:	07 c0       	rjmp	.+14     	; 0x9176 <__udivmodhi4_ep>

00009168 <__udivmodhi4_loop>:
    9168:	aa 1f       	adc	r26, r26
    916a:	bb 1f       	adc	r27, r27
    916c:	a6 17       	cp	r26, r22
    916e:	b7 07       	cpc	r27, r23
    9170:	10 f0       	brcs	.+4      	; 0x9176 <__udivmodhi4_ep>
    9172:	a6 1b       	sub	r26, r22
    9174:	b7 0b       	sbc	r27, r23

00009176 <__udivmodhi4_ep>:
    9176:	88 1f       	adc	r24, r24
    9178:	99 1f       	adc	r25, r25
    917a:	5a 95       	dec	r21
    917c:	a9 f7       	brne	.-22     	; 0x9168 <__udivmodhi4_loop>
    917e:	80 95       	com	r24
    9180:	90 95       	com	r25
    9182:	bc 01       	movw	r22, r24
    9184:	cd 01       	movw	r24, r26
    9186:	08 95       	ret

00009188 <__divmodhi4>:
    9188:	97 fb       	bst	r25, 7
    918a:	09 2e       	mov	r0, r25
    918c:	07 26       	eor	r0, r23
    918e:	0a d0       	rcall	.+20     	; 0x91a4 <__divmodhi4_neg1>
    9190:	77 fd       	sbrc	r23, 7
    9192:	04 d0       	rcall	.+8      	; 0x919c <__divmodhi4_neg2>
    9194:	e5 df       	rcall	.-54     	; 0x9160 <__udivmodhi4>
    9196:	06 d0       	rcall	.+12     	; 0x91a4 <__divmodhi4_neg1>
    9198:	00 20       	and	r0, r0
    919a:	1a f4       	brpl	.+6      	; 0x91a2 <__divmodhi4_exit>

0000919c <__divmodhi4_neg2>:
    919c:	70 95       	com	r23
    919e:	61 95       	neg	r22
    91a0:	7f 4f       	sbci	r23, 0xFF	; 255

000091a2 <__divmodhi4_exit>:
    91a2:	08 95       	ret

000091a4 <__divmodhi4_neg1>:
    91a4:	f6 f7       	brtc	.-4      	; 0x91a2 <__divmodhi4_exit>
    91a6:	90 95       	com	r25
    91a8:	81 95       	neg	r24
    91aa:	9f 4f       	sbci	r25, 0xFF	; 255
    91ac:	08 95       	ret

000091ae <__prologue_saves__>:
    91ae:	2f 92       	push	r2
    91b0:	3f 92       	push	r3
    91b2:	4f 92       	push	r4
    91b4:	5f 92       	push	r5
    91b6:	6f 92       	push	r6
    91b8:	7f 92       	push	r7
    91ba:	8f 92       	push	r8
    91bc:	9f 92       	push	r9
    91be:	af 92       	push	r10
    91c0:	bf 92       	push	r11
    91c2:	cf 92       	push	r12
    91c4:	df 92       	push	r13
    91c6:	ef 92       	push	r14
    91c8:	ff 92       	push	r15
    91ca:	0f 93       	push	r16
    91cc:	1f 93       	push	r17
    91ce:	cf 93       	push	r28
    91d0:	df 93       	push	r29
    91d2:	cd b7       	in	r28, 0x3d	; 61
    91d4:	de b7       	in	r29, 0x3e	; 62
    91d6:	ca 1b       	sub	r28, r26
    91d8:	db 0b       	sbc	r29, r27
    91da:	0f b6       	in	r0, 0x3f	; 63
    91dc:	f8 94       	cli
    91de:	de bf       	out	0x3e, r29	; 62
    91e0:	0f be       	out	0x3f, r0	; 63
    91e2:	cd bf       	out	0x3d, r28	; 61
    91e4:	09 94       	ijmp

000091e6 <__epilogue_restores__>:
    91e6:	2a 88       	ldd	r2, Y+18	; 0x12
    91e8:	39 88       	ldd	r3, Y+17	; 0x11
    91ea:	48 88       	ldd	r4, Y+16	; 0x10
    91ec:	5f 84       	ldd	r5, Y+15	; 0x0f
    91ee:	6e 84       	ldd	r6, Y+14	; 0x0e
    91f0:	7d 84       	ldd	r7, Y+13	; 0x0d
    91f2:	8c 84       	ldd	r8, Y+12	; 0x0c
    91f4:	9b 84       	ldd	r9, Y+11	; 0x0b
    91f6:	aa 84       	ldd	r10, Y+10	; 0x0a
    91f8:	b9 84       	ldd	r11, Y+9	; 0x09
    91fa:	c8 84       	ldd	r12, Y+8	; 0x08
    91fc:	df 80       	ldd	r13, Y+7	; 0x07
    91fe:	ee 80       	ldd	r14, Y+6	; 0x06
    9200:	fd 80       	ldd	r15, Y+5	; 0x05
    9202:	0c 81       	ldd	r16, Y+4	; 0x04
    9204:	1b 81       	ldd	r17, Y+3	; 0x03
    9206:	aa 81       	ldd	r26, Y+2	; 0x02
    9208:	b9 81       	ldd	r27, Y+1	; 0x01
    920a:	ce 0f       	add	r28, r30
    920c:	d1 1d       	adc	r29, r1
    920e:	0f b6       	in	r0, 0x3f	; 63
    9210:	f8 94       	cli
    9212:	de bf       	out	0x3e, r29	; 62
    9214:	0f be       	out	0x3f, r0	; 63
    9216:	cd bf       	out	0x3d, r28	; 61
    9218:	ed 01       	movw	r28, r26
    921a:	08 95       	ret

0000921c <memcpy>:
    921c:	fb 01       	movw	r30, r22
    921e:	dc 01       	movw	r26, r24
    9220:	02 c0       	rjmp	.+4      	; 0x9226 <memcpy+0xa>
    9222:	01 90       	ld	r0, Z+
    9224:	0d 92       	st	X+, r0
    9226:	41 50       	subi	r20, 0x01	; 1
    9228:	50 40       	sbci	r21, 0x00	; 0
    922a:	d8 f7       	brcc	.-10     	; 0x9222 <memcpy+0x6>
    922c:	08 95       	ret

0000922e <memset>:
    922e:	dc 01       	movw	r26, r24
    9230:	01 c0       	rjmp	.+2      	; 0x9234 <memset+0x6>
    9232:	6d 93       	st	X+, r22
    9234:	41 50       	subi	r20, 0x01	; 1
    9236:	50 40       	sbci	r21, 0x00	; 0
    9238:	e0 f7       	brcc	.-8      	; 0x9232 <memset+0x4>
    923a:	08 95       	ret

0000923c <itoa>:
    923c:	fb 01       	movw	r30, r22
    923e:	9f 01       	movw	r18, r30
    9240:	e8 94       	clt
    9242:	42 30       	cpi	r20, 0x02	; 2
    9244:	c4 f0       	brlt	.+48     	; 0x9276 <itoa+0x3a>
    9246:	45 32       	cpi	r20, 0x25	; 37
    9248:	b4 f4       	brge	.+44     	; 0x9276 <itoa+0x3a>
    924a:	4a 30       	cpi	r20, 0x0A	; 10
    924c:	29 f4       	brne	.+10     	; 0x9258 <itoa+0x1c>
    924e:	97 fb       	bst	r25, 7
    9250:	1e f4       	brtc	.+6      	; 0x9258 <itoa+0x1c>
    9252:	90 95       	com	r25
    9254:	81 95       	neg	r24
    9256:	9f 4f       	sbci	r25, 0xFF	; 255
    9258:	64 2f       	mov	r22, r20
    925a:	77 27       	eor	r23, r23
    925c:	0e 94 b0 48 	call	0x9160	; 0x9160 <__udivmodhi4>
    9260:	80 5d       	subi	r24, 0xD0	; 208
    9262:	8a 33       	cpi	r24, 0x3A	; 58
    9264:	0c f0       	brlt	.+2      	; 0x9268 <itoa+0x2c>
    9266:	89 5d       	subi	r24, 0xD9	; 217
    9268:	81 93       	st	Z+, r24
    926a:	cb 01       	movw	r24, r22
    926c:	00 97       	sbiw	r24, 0x00	; 0
    926e:	a1 f7       	brne	.-24     	; 0x9258 <itoa+0x1c>
    9270:	16 f4       	brtc	.+4      	; 0x9276 <itoa+0x3a>
    9272:	5d e2       	ldi	r21, 0x2D	; 45
    9274:	51 93       	st	Z+, r21
    9276:	10 82       	st	Z, r1
    9278:	c9 01       	movw	r24, r18
    927a:	0c 94 3f 49 	jmp	0x927e	; 0x927e <strrev>

0000927e <strrev>:
    927e:	dc 01       	movw	r26, r24
    9280:	fc 01       	movw	r30, r24
    9282:	67 2f       	mov	r22, r23
    9284:	71 91       	ld	r23, Z+
    9286:	77 23       	and	r23, r23
    9288:	e1 f7       	brne	.-8      	; 0x9282 <strrev+0x4>
    928a:	32 97       	sbiw	r30, 0x02	; 2
    928c:	04 c0       	rjmp	.+8      	; 0x9296 <strrev+0x18>
    928e:	7c 91       	ld	r23, X
    9290:	6d 93       	st	X+, r22
    9292:	70 83       	st	Z, r23
    9294:	62 91       	ld	r22, -Z
    9296:	ae 17       	cp	r26, r30
    9298:	bf 07       	cpc	r27, r31
    929a:	c8 f3       	brcs	.-14     	; 0x928e <strrev+0x10>
    929c:	08 95       	ret

0000929e <_exit>:
    929e:	f8 94       	cli

000092a0 <__stop_program>:
    92a0:	ff cf       	rjmp	.-2      	; 0x92a0 <__stop_program>
