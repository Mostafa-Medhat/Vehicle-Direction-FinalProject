
Vehicle-Direction-FinalProject.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000150  00800100  00009388  0000941c  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00009388  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          000006b3  00800250  00800250  0000956c  2**0
                  ALLOC
  3 .stab         0000b3ac  00000000  00000000  0000956c  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      0000667a  00000000  00000000  00014918  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 000001a0  00000000  00000000  0001af92  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_pubnames 000001f2  00000000  00000000  0001b132  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   0000240b  00000000  00000000  0001b324  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00001386  00000000  00000000  0001d72f  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   000011d6  00000000  00000000  0001eab5  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  000001c0  00000000  00000000  0001fc8c  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    000002f6  00000000  00000000  0001fe4c  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    0000096e  00000000  00000000  00020142  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000050  00000000  00000000  00020ab0  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 46 00 	jmp	0x8c	; 0x8c <__ctors_end>
       4:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
       8:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
       c:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
      10:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
      14:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
      18:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
      1c:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
      20:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
      24:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
      28:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
      2c:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
      30:	0c 94 84 0a 	jmp	0x1508	; 0x1508 <__vector_12>
      34:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
      38:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
      3c:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
      40:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
      44:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
      48:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
      4c:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
      50:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
      54:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
      58:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
      5c:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
      60:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
      64:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
      68:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
      6c:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
      70:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
      74:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
      78:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
      7c:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
      80:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
      84:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
      88:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>

0000008c <__ctors_end>:
      8c:	11 24       	eor	r1, r1
      8e:	1f be       	out	0x3f, r1	; 63
      90:	cf ef       	ldi	r28, 0xFF	; 255
      92:	d0 e1       	ldi	r29, 0x10	; 16
      94:	de bf       	out	0x3e, r29	; 62
      96:	cd bf       	out	0x3d, r28	; 61

00000098 <__do_copy_data>:
      98:	12 e0       	ldi	r17, 0x02	; 2
      9a:	a0 e0       	ldi	r26, 0x00	; 0
      9c:	b1 e0       	ldi	r27, 0x01	; 1
      9e:	e8 e8       	ldi	r30, 0x88	; 136
      a0:	f3 e9       	ldi	r31, 0x93	; 147
      a2:	02 c0       	rjmp	.+4      	; 0xa8 <.do_copy_data_start>

000000a4 <.do_copy_data_loop>:
      a4:	05 90       	lpm	r0, Z+
      a6:	0d 92       	st	X+, r0

000000a8 <.do_copy_data_start>:
      a8:	a0 35       	cpi	r26, 0x50	; 80
      aa:	b1 07       	cpc	r27, r17
      ac:	d9 f7       	brne	.-10     	; 0xa4 <.do_copy_data_loop>

000000ae <__do_clear_bss>:
      ae:	19 e0       	ldi	r17, 0x09	; 9
      b0:	a0 e5       	ldi	r26, 0x50	; 80
      b2:	b2 e0       	ldi	r27, 0x02	; 2
      b4:	01 c0       	rjmp	.+2      	; 0xb8 <.do_clear_bss_start>

000000b6 <.do_clear_bss_loop>:
      b6:	1d 92       	st	X+, r1

000000b8 <.do_clear_bss_start>:
      b8:	a3 30       	cpi	r26, 0x03	; 3
      ba:	b1 07       	cpc	r27, r17
      bc:	e1 f7       	brne	.-8      	; 0xb6 <.do_clear_bss_loop>
      be:	0e 94 33 48 	call	0x9066	; 0x9066 <main>
      c2:	0c 94 c2 49 	jmp	0x9384	; 0x9384 <_exit>

000000c6 <__bad_interrupt>:
      c6:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000ca <__fixunssfsi>:
      ca:	ef 92       	push	r14
      cc:	ff 92       	push	r15
      ce:	0f 93       	push	r16
      d0:	1f 93       	push	r17
      d2:	7b 01       	movw	r14, r22
      d4:	8c 01       	movw	r16, r24
      d6:	20 e0       	ldi	r18, 0x00	; 0
      d8:	30 e0       	ldi	r19, 0x00	; 0
      da:	40 e0       	ldi	r20, 0x00	; 0
      dc:	5f e4       	ldi	r21, 0x4F	; 79
      de:	0e 94 11 04 	call	0x822	; 0x822 <__gesf2>
      e2:	88 23       	and	r24, r24
      e4:	8c f0       	brlt	.+34     	; 0x108 <__fixunssfsi+0x3e>
      e6:	c8 01       	movw	r24, r16
      e8:	b7 01       	movw	r22, r14
      ea:	20 e0       	ldi	r18, 0x00	; 0
      ec:	30 e0       	ldi	r19, 0x00	; 0
      ee:	40 e0       	ldi	r20, 0x00	; 0
      f0:	5f e4       	ldi	r21, 0x4F	; 79
      f2:	0e 94 dd 01 	call	0x3ba	; 0x3ba <__subsf3>
      f6:	0e 94 71 04 	call	0x8e2	; 0x8e2 <__fixsfsi>
      fa:	9b 01       	movw	r18, r22
      fc:	ac 01       	movw	r20, r24
      fe:	20 50       	subi	r18, 0x00	; 0
     100:	30 40       	sbci	r19, 0x00	; 0
     102:	40 40       	sbci	r20, 0x00	; 0
     104:	50 48       	sbci	r21, 0x80	; 128
     106:	06 c0       	rjmp	.+12     	; 0x114 <__fixunssfsi+0x4a>
     108:	c8 01       	movw	r24, r16
     10a:	b7 01       	movw	r22, r14
     10c:	0e 94 71 04 	call	0x8e2	; 0x8e2 <__fixsfsi>
     110:	9b 01       	movw	r18, r22
     112:	ac 01       	movw	r20, r24
     114:	b9 01       	movw	r22, r18
     116:	ca 01       	movw	r24, r20
     118:	1f 91       	pop	r17
     11a:	0f 91       	pop	r16
     11c:	ff 90       	pop	r15
     11e:	ef 90       	pop	r14
     120:	08 95       	ret

00000122 <_fpadd_parts>:
     122:	a0 e0       	ldi	r26, 0x00	; 0
     124:	b0 e0       	ldi	r27, 0x00	; 0
     126:	e7 e9       	ldi	r30, 0x97	; 151
     128:	f0 e0       	ldi	r31, 0x00	; 0
     12a:	0c 94 4a 49 	jmp	0x9294	; 0x9294 <__prologue_saves__>
     12e:	dc 01       	movw	r26, r24
     130:	2b 01       	movw	r4, r22
     132:	fa 01       	movw	r30, r20
     134:	9c 91       	ld	r25, X
     136:	92 30       	cpi	r25, 0x02	; 2
     138:	08 f4       	brcc	.+2      	; 0x13c <_fpadd_parts+0x1a>
     13a:	39 c1       	rjmp	.+626    	; 0x3ae <_fpadd_parts+0x28c>
     13c:	eb 01       	movw	r28, r22
     13e:	88 81       	ld	r24, Y
     140:	82 30       	cpi	r24, 0x02	; 2
     142:	08 f4       	brcc	.+2      	; 0x146 <_fpadd_parts+0x24>
     144:	33 c1       	rjmp	.+614    	; 0x3ac <_fpadd_parts+0x28a>
     146:	94 30       	cpi	r25, 0x04	; 4
     148:	69 f4       	brne	.+26     	; 0x164 <_fpadd_parts+0x42>
     14a:	84 30       	cpi	r24, 0x04	; 4
     14c:	09 f0       	breq	.+2      	; 0x150 <_fpadd_parts+0x2e>
     14e:	2f c1       	rjmp	.+606    	; 0x3ae <_fpadd_parts+0x28c>
     150:	11 96       	adiw	r26, 0x01	; 1
     152:	9c 91       	ld	r25, X
     154:	11 97       	sbiw	r26, 0x01	; 1
     156:	89 81       	ldd	r24, Y+1	; 0x01
     158:	98 17       	cp	r25, r24
     15a:	09 f4       	brne	.+2      	; 0x15e <_fpadd_parts+0x3c>
     15c:	28 c1       	rjmp	.+592    	; 0x3ae <_fpadd_parts+0x28c>
     15e:	af e2       	ldi	r26, 0x2F	; 47
     160:	b1 e0       	ldi	r27, 0x01	; 1
     162:	25 c1       	rjmp	.+586    	; 0x3ae <_fpadd_parts+0x28c>
     164:	84 30       	cpi	r24, 0x04	; 4
     166:	09 f4       	brne	.+2      	; 0x16a <_fpadd_parts+0x48>
     168:	21 c1       	rjmp	.+578    	; 0x3ac <_fpadd_parts+0x28a>
     16a:	82 30       	cpi	r24, 0x02	; 2
     16c:	a9 f4       	brne	.+42     	; 0x198 <_fpadd_parts+0x76>
     16e:	92 30       	cpi	r25, 0x02	; 2
     170:	09 f0       	breq	.+2      	; 0x174 <_fpadd_parts+0x52>
     172:	1d c1       	rjmp	.+570    	; 0x3ae <_fpadd_parts+0x28c>
     174:	9a 01       	movw	r18, r20
     176:	ad 01       	movw	r20, r26
     178:	88 e0       	ldi	r24, 0x08	; 8
     17a:	ea 01       	movw	r28, r20
     17c:	09 90       	ld	r0, Y+
     17e:	ae 01       	movw	r20, r28
     180:	e9 01       	movw	r28, r18
     182:	09 92       	st	Y+, r0
     184:	9e 01       	movw	r18, r28
     186:	81 50       	subi	r24, 0x01	; 1
     188:	c1 f7       	brne	.-16     	; 0x17a <_fpadd_parts+0x58>
     18a:	e2 01       	movw	r28, r4
     18c:	89 81       	ldd	r24, Y+1	; 0x01
     18e:	11 96       	adiw	r26, 0x01	; 1
     190:	9c 91       	ld	r25, X
     192:	89 23       	and	r24, r25
     194:	81 83       	std	Z+1, r24	; 0x01
     196:	08 c1       	rjmp	.+528    	; 0x3a8 <_fpadd_parts+0x286>
     198:	92 30       	cpi	r25, 0x02	; 2
     19a:	09 f4       	brne	.+2      	; 0x19e <_fpadd_parts+0x7c>
     19c:	07 c1       	rjmp	.+526    	; 0x3ac <_fpadd_parts+0x28a>
     19e:	12 96       	adiw	r26, 0x02	; 2
     1a0:	2d 90       	ld	r2, X+
     1a2:	3c 90       	ld	r3, X
     1a4:	13 97       	sbiw	r26, 0x03	; 3
     1a6:	eb 01       	movw	r28, r22
     1a8:	8a 81       	ldd	r24, Y+2	; 0x02
     1aa:	9b 81       	ldd	r25, Y+3	; 0x03
     1ac:	14 96       	adiw	r26, 0x04	; 4
     1ae:	ad 90       	ld	r10, X+
     1b0:	bd 90       	ld	r11, X+
     1b2:	cd 90       	ld	r12, X+
     1b4:	dc 90       	ld	r13, X
     1b6:	17 97       	sbiw	r26, 0x07	; 7
     1b8:	ec 80       	ldd	r14, Y+4	; 0x04
     1ba:	fd 80       	ldd	r15, Y+5	; 0x05
     1bc:	0e 81       	ldd	r16, Y+6	; 0x06
     1be:	1f 81       	ldd	r17, Y+7	; 0x07
     1c0:	91 01       	movw	r18, r2
     1c2:	28 1b       	sub	r18, r24
     1c4:	39 0b       	sbc	r19, r25
     1c6:	b9 01       	movw	r22, r18
     1c8:	37 ff       	sbrs	r19, 7
     1ca:	04 c0       	rjmp	.+8      	; 0x1d4 <_fpadd_parts+0xb2>
     1cc:	66 27       	eor	r22, r22
     1ce:	77 27       	eor	r23, r23
     1d0:	62 1b       	sub	r22, r18
     1d2:	73 0b       	sbc	r23, r19
     1d4:	60 32       	cpi	r22, 0x20	; 32
     1d6:	71 05       	cpc	r23, r1
     1d8:	0c f0       	brlt	.+2      	; 0x1dc <_fpadd_parts+0xba>
     1da:	61 c0       	rjmp	.+194    	; 0x29e <_fpadd_parts+0x17c>
     1dc:	12 16       	cp	r1, r18
     1de:	13 06       	cpc	r1, r19
     1e0:	6c f5       	brge	.+90     	; 0x23c <_fpadd_parts+0x11a>
     1e2:	37 01       	movw	r6, r14
     1e4:	48 01       	movw	r8, r16
     1e6:	06 2e       	mov	r0, r22
     1e8:	04 c0       	rjmp	.+8      	; 0x1f2 <_fpadd_parts+0xd0>
     1ea:	96 94       	lsr	r9
     1ec:	87 94       	ror	r8
     1ee:	77 94       	ror	r7
     1f0:	67 94       	ror	r6
     1f2:	0a 94       	dec	r0
     1f4:	d2 f7       	brpl	.-12     	; 0x1ea <_fpadd_parts+0xc8>
     1f6:	21 e0       	ldi	r18, 0x01	; 1
     1f8:	30 e0       	ldi	r19, 0x00	; 0
     1fa:	40 e0       	ldi	r20, 0x00	; 0
     1fc:	50 e0       	ldi	r21, 0x00	; 0
     1fe:	04 c0       	rjmp	.+8      	; 0x208 <_fpadd_parts+0xe6>
     200:	22 0f       	add	r18, r18
     202:	33 1f       	adc	r19, r19
     204:	44 1f       	adc	r20, r20
     206:	55 1f       	adc	r21, r21
     208:	6a 95       	dec	r22
     20a:	d2 f7       	brpl	.-12     	; 0x200 <_fpadd_parts+0xde>
     20c:	21 50       	subi	r18, 0x01	; 1
     20e:	30 40       	sbci	r19, 0x00	; 0
     210:	40 40       	sbci	r20, 0x00	; 0
     212:	50 40       	sbci	r21, 0x00	; 0
     214:	2e 21       	and	r18, r14
     216:	3f 21       	and	r19, r15
     218:	40 23       	and	r20, r16
     21a:	51 23       	and	r21, r17
     21c:	21 15       	cp	r18, r1
     21e:	31 05       	cpc	r19, r1
     220:	41 05       	cpc	r20, r1
     222:	51 05       	cpc	r21, r1
     224:	21 f0       	breq	.+8      	; 0x22e <_fpadd_parts+0x10c>
     226:	21 e0       	ldi	r18, 0x01	; 1
     228:	30 e0       	ldi	r19, 0x00	; 0
     22a:	40 e0       	ldi	r20, 0x00	; 0
     22c:	50 e0       	ldi	r21, 0x00	; 0
     22e:	79 01       	movw	r14, r18
     230:	8a 01       	movw	r16, r20
     232:	e6 28       	or	r14, r6
     234:	f7 28       	or	r15, r7
     236:	08 29       	or	r16, r8
     238:	19 29       	or	r17, r9
     23a:	3c c0       	rjmp	.+120    	; 0x2b4 <_fpadd_parts+0x192>
     23c:	23 2b       	or	r18, r19
     23e:	d1 f1       	breq	.+116    	; 0x2b4 <_fpadd_parts+0x192>
     240:	26 0e       	add	r2, r22
     242:	37 1e       	adc	r3, r23
     244:	35 01       	movw	r6, r10
     246:	46 01       	movw	r8, r12
     248:	06 2e       	mov	r0, r22
     24a:	04 c0       	rjmp	.+8      	; 0x254 <_fpadd_parts+0x132>
     24c:	96 94       	lsr	r9
     24e:	87 94       	ror	r8
     250:	77 94       	ror	r7
     252:	67 94       	ror	r6
     254:	0a 94       	dec	r0
     256:	d2 f7       	brpl	.-12     	; 0x24c <_fpadd_parts+0x12a>
     258:	21 e0       	ldi	r18, 0x01	; 1
     25a:	30 e0       	ldi	r19, 0x00	; 0
     25c:	40 e0       	ldi	r20, 0x00	; 0
     25e:	50 e0       	ldi	r21, 0x00	; 0
     260:	04 c0       	rjmp	.+8      	; 0x26a <_fpadd_parts+0x148>
     262:	22 0f       	add	r18, r18
     264:	33 1f       	adc	r19, r19
     266:	44 1f       	adc	r20, r20
     268:	55 1f       	adc	r21, r21
     26a:	6a 95       	dec	r22
     26c:	d2 f7       	brpl	.-12     	; 0x262 <_fpadd_parts+0x140>
     26e:	21 50       	subi	r18, 0x01	; 1
     270:	30 40       	sbci	r19, 0x00	; 0
     272:	40 40       	sbci	r20, 0x00	; 0
     274:	50 40       	sbci	r21, 0x00	; 0
     276:	2a 21       	and	r18, r10
     278:	3b 21       	and	r19, r11
     27a:	4c 21       	and	r20, r12
     27c:	5d 21       	and	r21, r13
     27e:	21 15       	cp	r18, r1
     280:	31 05       	cpc	r19, r1
     282:	41 05       	cpc	r20, r1
     284:	51 05       	cpc	r21, r1
     286:	21 f0       	breq	.+8      	; 0x290 <_fpadd_parts+0x16e>
     288:	21 e0       	ldi	r18, 0x01	; 1
     28a:	30 e0       	ldi	r19, 0x00	; 0
     28c:	40 e0       	ldi	r20, 0x00	; 0
     28e:	50 e0       	ldi	r21, 0x00	; 0
     290:	59 01       	movw	r10, r18
     292:	6a 01       	movw	r12, r20
     294:	a6 28       	or	r10, r6
     296:	b7 28       	or	r11, r7
     298:	c8 28       	or	r12, r8
     29a:	d9 28       	or	r13, r9
     29c:	0b c0       	rjmp	.+22     	; 0x2b4 <_fpadd_parts+0x192>
     29e:	82 15       	cp	r24, r2
     2a0:	93 05       	cpc	r25, r3
     2a2:	2c f0       	brlt	.+10     	; 0x2ae <_fpadd_parts+0x18c>
     2a4:	1c 01       	movw	r2, r24
     2a6:	aa 24       	eor	r10, r10
     2a8:	bb 24       	eor	r11, r11
     2aa:	65 01       	movw	r12, r10
     2ac:	03 c0       	rjmp	.+6      	; 0x2b4 <_fpadd_parts+0x192>
     2ae:	ee 24       	eor	r14, r14
     2b0:	ff 24       	eor	r15, r15
     2b2:	87 01       	movw	r16, r14
     2b4:	11 96       	adiw	r26, 0x01	; 1
     2b6:	9c 91       	ld	r25, X
     2b8:	d2 01       	movw	r26, r4
     2ba:	11 96       	adiw	r26, 0x01	; 1
     2bc:	8c 91       	ld	r24, X
     2be:	98 17       	cp	r25, r24
     2c0:	09 f4       	brne	.+2      	; 0x2c4 <_fpadd_parts+0x1a2>
     2c2:	45 c0       	rjmp	.+138    	; 0x34e <_fpadd_parts+0x22c>
     2c4:	99 23       	and	r25, r25
     2c6:	39 f0       	breq	.+14     	; 0x2d6 <_fpadd_parts+0x1b4>
     2c8:	a8 01       	movw	r20, r16
     2ca:	97 01       	movw	r18, r14
     2cc:	2a 19       	sub	r18, r10
     2ce:	3b 09       	sbc	r19, r11
     2d0:	4c 09       	sbc	r20, r12
     2d2:	5d 09       	sbc	r21, r13
     2d4:	06 c0       	rjmp	.+12     	; 0x2e2 <_fpadd_parts+0x1c0>
     2d6:	a6 01       	movw	r20, r12
     2d8:	95 01       	movw	r18, r10
     2da:	2e 19       	sub	r18, r14
     2dc:	3f 09       	sbc	r19, r15
     2de:	40 0b       	sbc	r20, r16
     2e0:	51 0b       	sbc	r21, r17
     2e2:	57 fd       	sbrc	r21, 7
     2e4:	08 c0       	rjmp	.+16     	; 0x2f6 <_fpadd_parts+0x1d4>
     2e6:	11 82       	std	Z+1, r1	; 0x01
     2e8:	33 82       	std	Z+3, r3	; 0x03
     2ea:	22 82       	std	Z+2, r2	; 0x02
     2ec:	24 83       	std	Z+4, r18	; 0x04
     2ee:	35 83       	std	Z+5, r19	; 0x05
     2f0:	46 83       	std	Z+6, r20	; 0x06
     2f2:	57 83       	std	Z+7, r21	; 0x07
     2f4:	1d c0       	rjmp	.+58     	; 0x330 <_fpadd_parts+0x20e>
     2f6:	81 e0       	ldi	r24, 0x01	; 1
     2f8:	81 83       	std	Z+1, r24	; 0x01
     2fa:	33 82       	std	Z+3, r3	; 0x03
     2fc:	22 82       	std	Z+2, r2	; 0x02
     2fe:	88 27       	eor	r24, r24
     300:	99 27       	eor	r25, r25
     302:	dc 01       	movw	r26, r24
     304:	82 1b       	sub	r24, r18
     306:	93 0b       	sbc	r25, r19
     308:	a4 0b       	sbc	r26, r20
     30a:	b5 0b       	sbc	r27, r21
     30c:	84 83       	std	Z+4, r24	; 0x04
     30e:	95 83       	std	Z+5, r25	; 0x05
     310:	a6 83       	std	Z+6, r26	; 0x06
     312:	b7 83       	std	Z+7, r27	; 0x07
     314:	0d c0       	rjmp	.+26     	; 0x330 <_fpadd_parts+0x20e>
     316:	22 0f       	add	r18, r18
     318:	33 1f       	adc	r19, r19
     31a:	44 1f       	adc	r20, r20
     31c:	55 1f       	adc	r21, r21
     31e:	24 83       	std	Z+4, r18	; 0x04
     320:	35 83       	std	Z+5, r19	; 0x05
     322:	46 83       	std	Z+6, r20	; 0x06
     324:	57 83       	std	Z+7, r21	; 0x07
     326:	82 81       	ldd	r24, Z+2	; 0x02
     328:	93 81       	ldd	r25, Z+3	; 0x03
     32a:	01 97       	sbiw	r24, 0x01	; 1
     32c:	93 83       	std	Z+3, r25	; 0x03
     32e:	82 83       	std	Z+2, r24	; 0x02
     330:	24 81       	ldd	r18, Z+4	; 0x04
     332:	35 81       	ldd	r19, Z+5	; 0x05
     334:	46 81       	ldd	r20, Z+6	; 0x06
     336:	57 81       	ldd	r21, Z+7	; 0x07
     338:	da 01       	movw	r26, r20
     33a:	c9 01       	movw	r24, r18
     33c:	01 97       	sbiw	r24, 0x01	; 1
     33e:	a1 09       	sbc	r26, r1
     340:	b1 09       	sbc	r27, r1
     342:	8f 5f       	subi	r24, 0xFF	; 255
     344:	9f 4f       	sbci	r25, 0xFF	; 255
     346:	af 4f       	sbci	r26, 0xFF	; 255
     348:	bf 43       	sbci	r27, 0x3F	; 63
     34a:	28 f3       	brcs	.-54     	; 0x316 <_fpadd_parts+0x1f4>
     34c:	0b c0       	rjmp	.+22     	; 0x364 <_fpadd_parts+0x242>
     34e:	91 83       	std	Z+1, r25	; 0x01
     350:	33 82       	std	Z+3, r3	; 0x03
     352:	22 82       	std	Z+2, r2	; 0x02
     354:	ea 0c       	add	r14, r10
     356:	fb 1c       	adc	r15, r11
     358:	0c 1d       	adc	r16, r12
     35a:	1d 1d       	adc	r17, r13
     35c:	e4 82       	std	Z+4, r14	; 0x04
     35e:	f5 82       	std	Z+5, r15	; 0x05
     360:	06 83       	std	Z+6, r16	; 0x06
     362:	17 83       	std	Z+7, r17	; 0x07
     364:	83 e0       	ldi	r24, 0x03	; 3
     366:	80 83       	st	Z, r24
     368:	24 81       	ldd	r18, Z+4	; 0x04
     36a:	35 81       	ldd	r19, Z+5	; 0x05
     36c:	46 81       	ldd	r20, Z+6	; 0x06
     36e:	57 81       	ldd	r21, Z+7	; 0x07
     370:	57 ff       	sbrs	r21, 7
     372:	1a c0       	rjmp	.+52     	; 0x3a8 <_fpadd_parts+0x286>
     374:	c9 01       	movw	r24, r18
     376:	aa 27       	eor	r26, r26
     378:	97 fd       	sbrc	r25, 7
     37a:	a0 95       	com	r26
     37c:	ba 2f       	mov	r27, r26
     37e:	81 70       	andi	r24, 0x01	; 1
     380:	90 70       	andi	r25, 0x00	; 0
     382:	a0 70       	andi	r26, 0x00	; 0
     384:	b0 70       	andi	r27, 0x00	; 0
     386:	56 95       	lsr	r21
     388:	47 95       	ror	r20
     38a:	37 95       	ror	r19
     38c:	27 95       	ror	r18
     38e:	82 2b       	or	r24, r18
     390:	93 2b       	or	r25, r19
     392:	a4 2b       	or	r26, r20
     394:	b5 2b       	or	r27, r21
     396:	84 83       	std	Z+4, r24	; 0x04
     398:	95 83       	std	Z+5, r25	; 0x05
     39a:	a6 83       	std	Z+6, r26	; 0x06
     39c:	b7 83       	std	Z+7, r27	; 0x07
     39e:	82 81       	ldd	r24, Z+2	; 0x02
     3a0:	93 81       	ldd	r25, Z+3	; 0x03
     3a2:	01 96       	adiw	r24, 0x01	; 1
     3a4:	93 83       	std	Z+3, r25	; 0x03
     3a6:	82 83       	std	Z+2, r24	; 0x02
     3a8:	df 01       	movw	r26, r30
     3aa:	01 c0       	rjmp	.+2      	; 0x3ae <_fpadd_parts+0x28c>
     3ac:	d2 01       	movw	r26, r4
     3ae:	cd 01       	movw	r24, r26
     3b0:	cd b7       	in	r28, 0x3d	; 61
     3b2:	de b7       	in	r29, 0x3e	; 62
     3b4:	e2 e1       	ldi	r30, 0x12	; 18
     3b6:	0c 94 66 49 	jmp	0x92cc	; 0x92cc <__epilogue_restores__>

000003ba <__subsf3>:
     3ba:	a0 e2       	ldi	r26, 0x20	; 32
     3bc:	b0 e0       	ldi	r27, 0x00	; 0
     3be:	e3 ee       	ldi	r30, 0xE3	; 227
     3c0:	f1 e0       	ldi	r31, 0x01	; 1
     3c2:	0c 94 56 49 	jmp	0x92ac	; 0x92ac <__prologue_saves__+0x18>
     3c6:	69 83       	std	Y+1, r22	; 0x01
     3c8:	7a 83       	std	Y+2, r23	; 0x02
     3ca:	8b 83       	std	Y+3, r24	; 0x03
     3cc:	9c 83       	std	Y+4, r25	; 0x04
     3ce:	2d 83       	std	Y+5, r18	; 0x05
     3d0:	3e 83       	std	Y+6, r19	; 0x06
     3d2:	4f 83       	std	Y+7, r20	; 0x07
     3d4:	58 87       	std	Y+8, r21	; 0x08
     3d6:	e9 e0       	ldi	r30, 0x09	; 9
     3d8:	ee 2e       	mov	r14, r30
     3da:	f1 2c       	mov	r15, r1
     3dc:	ec 0e       	add	r14, r28
     3de:	fd 1e       	adc	r15, r29
     3e0:	ce 01       	movw	r24, r28
     3e2:	01 96       	adiw	r24, 0x01	; 1
     3e4:	b7 01       	movw	r22, r14
     3e6:	0e 94 62 06 	call	0xcc4	; 0xcc4 <__unpack_f>
     3ea:	8e 01       	movw	r16, r28
     3ec:	0f 5e       	subi	r16, 0xEF	; 239
     3ee:	1f 4f       	sbci	r17, 0xFF	; 255
     3f0:	ce 01       	movw	r24, r28
     3f2:	05 96       	adiw	r24, 0x05	; 5
     3f4:	b8 01       	movw	r22, r16
     3f6:	0e 94 62 06 	call	0xcc4	; 0xcc4 <__unpack_f>
     3fa:	8a 89       	ldd	r24, Y+18	; 0x12
     3fc:	91 e0       	ldi	r25, 0x01	; 1
     3fe:	89 27       	eor	r24, r25
     400:	8a 8b       	std	Y+18, r24	; 0x12
     402:	c7 01       	movw	r24, r14
     404:	b8 01       	movw	r22, r16
     406:	ae 01       	movw	r20, r28
     408:	47 5e       	subi	r20, 0xE7	; 231
     40a:	5f 4f       	sbci	r21, 0xFF	; 255
     40c:	0e 94 91 00 	call	0x122	; 0x122 <_fpadd_parts>
     410:	0e 94 8d 05 	call	0xb1a	; 0xb1a <__pack_f>
     414:	a0 96       	adiw	r28, 0x20	; 32
     416:	e6 e0       	ldi	r30, 0x06	; 6
     418:	0c 94 72 49 	jmp	0x92e4	; 0x92e4 <__epilogue_restores__+0x18>

0000041c <__addsf3>:
     41c:	a0 e2       	ldi	r26, 0x20	; 32
     41e:	b0 e0       	ldi	r27, 0x00	; 0
     420:	e4 e1       	ldi	r30, 0x14	; 20
     422:	f2 e0       	ldi	r31, 0x02	; 2
     424:	0c 94 56 49 	jmp	0x92ac	; 0x92ac <__prologue_saves__+0x18>
     428:	69 83       	std	Y+1, r22	; 0x01
     42a:	7a 83       	std	Y+2, r23	; 0x02
     42c:	8b 83       	std	Y+3, r24	; 0x03
     42e:	9c 83       	std	Y+4, r25	; 0x04
     430:	2d 83       	std	Y+5, r18	; 0x05
     432:	3e 83       	std	Y+6, r19	; 0x06
     434:	4f 83       	std	Y+7, r20	; 0x07
     436:	58 87       	std	Y+8, r21	; 0x08
     438:	f9 e0       	ldi	r31, 0x09	; 9
     43a:	ef 2e       	mov	r14, r31
     43c:	f1 2c       	mov	r15, r1
     43e:	ec 0e       	add	r14, r28
     440:	fd 1e       	adc	r15, r29
     442:	ce 01       	movw	r24, r28
     444:	01 96       	adiw	r24, 0x01	; 1
     446:	b7 01       	movw	r22, r14
     448:	0e 94 62 06 	call	0xcc4	; 0xcc4 <__unpack_f>
     44c:	8e 01       	movw	r16, r28
     44e:	0f 5e       	subi	r16, 0xEF	; 239
     450:	1f 4f       	sbci	r17, 0xFF	; 255
     452:	ce 01       	movw	r24, r28
     454:	05 96       	adiw	r24, 0x05	; 5
     456:	b8 01       	movw	r22, r16
     458:	0e 94 62 06 	call	0xcc4	; 0xcc4 <__unpack_f>
     45c:	c7 01       	movw	r24, r14
     45e:	b8 01       	movw	r22, r16
     460:	ae 01       	movw	r20, r28
     462:	47 5e       	subi	r20, 0xE7	; 231
     464:	5f 4f       	sbci	r21, 0xFF	; 255
     466:	0e 94 91 00 	call	0x122	; 0x122 <_fpadd_parts>
     46a:	0e 94 8d 05 	call	0xb1a	; 0xb1a <__pack_f>
     46e:	a0 96       	adiw	r28, 0x20	; 32
     470:	e6 e0       	ldi	r30, 0x06	; 6
     472:	0c 94 72 49 	jmp	0x92e4	; 0x92e4 <__epilogue_restores__+0x18>

00000476 <__mulsf3>:
     476:	a0 e2       	ldi	r26, 0x20	; 32
     478:	b0 e0       	ldi	r27, 0x00	; 0
     47a:	e1 e4       	ldi	r30, 0x41	; 65
     47c:	f2 e0       	ldi	r31, 0x02	; 2
     47e:	0c 94 4a 49 	jmp	0x9294	; 0x9294 <__prologue_saves__>
     482:	69 83       	std	Y+1, r22	; 0x01
     484:	7a 83       	std	Y+2, r23	; 0x02
     486:	8b 83       	std	Y+3, r24	; 0x03
     488:	9c 83       	std	Y+4, r25	; 0x04
     48a:	2d 83       	std	Y+5, r18	; 0x05
     48c:	3e 83       	std	Y+6, r19	; 0x06
     48e:	4f 83       	std	Y+7, r20	; 0x07
     490:	58 87       	std	Y+8, r21	; 0x08
     492:	ce 01       	movw	r24, r28
     494:	01 96       	adiw	r24, 0x01	; 1
     496:	be 01       	movw	r22, r28
     498:	67 5f       	subi	r22, 0xF7	; 247
     49a:	7f 4f       	sbci	r23, 0xFF	; 255
     49c:	0e 94 62 06 	call	0xcc4	; 0xcc4 <__unpack_f>
     4a0:	ce 01       	movw	r24, r28
     4a2:	05 96       	adiw	r24, 0x05	; 5
     4a4:	be 01       	movw	r22, r28
     4a6:	6f 5e       	subi	r22, 0xEF	; 239
     4a8:	7f 4f       	sbci	r23, 0xFF	; 255
     4aa:	0e 94 62 06 	call	0xcc4	; 0xcc4 <__unpack_f>
     4ae:	99 85       	ldd	r25, Y+9	; 0x09
     4b0:	92 30       	cpi	r25, 0x02	; 2
     4b2:	88 f0       	brcs	.+34     	; 0x4d6 <__mulsf3+0x60>
     4b4:	89 89       	ldd	r24, Y+17	; 0x11
     4b6:	82 30       	cpi	r24, 0x02	; 2
     4b8:	c8 f0       	brcs	.+50     	; 0x4ec <__mulsf3+0x76>
     4ba:	94 30       	cpi	r25, 0x04	; 4
     4bc:	19 f4       	brne	.+6      	; 0x4c4 <__mulsf3+0x4e>
     4be:	82 30       	cpi	r24, 0x02	; 2
     4c0:	51 f4       	brne	.+20     	; 0x4d6 <__mulsf3+0x60>
     4c2:	04 c0       	rjmp	.+8      	; 0x4cc <__mulsf3+0x56>
     4c4:	84 30       	cpi	r24, 0x04	; 4
     4c6:	29 f4       	brne	.+10     	; 0x4d2 <__mulsf3+0x5c>
     4c8:	92 30       	cpi	r25, 0x02	; 2
     4ca:	81 f4       	brne	.+32     	; 0x4ec <__mulsf3+0x76>
     4cc:	8f e2       	ldi	r24, 0x2F	; 47
     4ce:	91 e0       	ldi	r25, 0x01	; 1
     4d0:	c6 c0       	rjmp	.+396    	; 0x65e <__mulsf3+0x1e8>
     4d2:	92 30       	cpi	r25, 0x02	; 2
     4d4:	49 f4       	brne	.+18     	; 0x4e8 <__mulsf3+0x72>
     4d6:	20 e0       	ldi	r18, 0x00	; 0
     4d8:	9a 85       	ldd	r25, Y+10	; 0x0a
     4da:	8a 89       	ldd	r24, Y+18	; 0x12
     4dc:	98 13       	cpse	r25, r24
     4de:	21 e0       	ldi	r18, 0x01	; 1
     4e0:	2a 87       	std	Y+10, r18	; 0x0a
     4e2:	ce 01       	movw	r24, r28
     4e4:	09 96       	adiw	r24, 0x09	; 9
     4e6:	bb c0       	rjmp	.+374    	; 0x65e <__mulsf3+0x1e8>
     4e8:	82 30       	cpi	r24, 0x02	; 2
     4ea:	49 f4       	brne	.+18     	; 0x4fe <__mulsf3+0x88>
     4ec:	20 e0       	ldi	r18, 0x00	; 0
     4ee:	9a 85       	ldd	r25, Y+10	; 0x0a
     4f0:	8a 89       	ldd	r24, Y+18	; 0x12
     4f2:	98 13       	cpse	r25, r24
     4f4:	21 e0       	ldi	r18, 0x01	; 1
     4f6:	2a 8b       	std	Y+18, r18	; 0x12
     4f8:	ce 01       	movw	r24, r28
     4fa:	41 96       	adiw	r24, 0x11	; 17
     4fc:	b0 c0       	rjmp	.+352    	; 0x65e <__mulsf3+0x1e8>
     4fe:	2d 84       	ldd	r2, Y+13	; 0x0d
     500:	3e 84       	ldd	r3, Y+14	; 0x0e
     502:	4f 84       	ldd	r4, Y+15	; 0x0f
     504:	58 88       	ldd	r5, Y+16	; 0x10
     506:	6d 88       	ldd	r6, Y+21	; 0x15
     508:	7e 88       	ldd	r7, Y+22	; 0x16
     50a:	8f 88       	ldd	r8, Y+23	; 0x17
     50c:	98 8c       	ldd	r9, Y+24	; 0x18
     50e:	ee 24       	eor	r14, r14
     510:	ff 24       	eor	r15, r15
     512:	87 01       	movw	r16, r14
     514:	aa 24       	eor	r10, r10
     516:	bb 24       	eor	r11, r11
     518:	65 01       	movw	r12, r10
     51a:	40 e0       	ldi	r20, 0x00	; 0
     51c:	50 e0       	ldi	r21, 0x00	; 0
     51e:	60 e0       	ldi	r22, 0x00	; 0
     520:	70 e0       	ldi	r23, 0x00	; 0
     522:	e0 e0       	ldi	r30, 0x00	; 0
     524:	f0 e0       	ldi	r31, 0x00	; 0
     526:	c1 01       	movw	r24, r2
     528:	81 70       	andi	r24, 0x01	; 1
     52a:	90 70       	andi	r25, 0x00	; 0
     52c:	89 2b       	or	r24, r25
     52e:	e9 f0       	breq	.+58     	; 0x56a <__mulsf3+0xf4>
     530:	e6 0c       	add	r14, r6
     532:	f7 1c       	adc	r15, r7
     534:	08 1d       	adc	r16, r8
     536:	19 1d       	adc	r17, r9
     538:	9a 01       	movw	r18, r20
     53a:	ab 01       	movw	r20, r22
     53c:	2a 0d       	add	r18, r10
     53e:	3b 1d       	adc	r19, r11
     540:	4c 1d       	adc	r20, r12
     542:	5d 1d       	adc	r21, r13
     544:	80 e0       	ldi	r24, 0x00	; 0
     546:	90 e0       	ldi	r25, 0x00	; 0
     548:	a0 e0       	ldi	r26, 0x00	; 0
     54a:	b0 e0       	ldi	r27, 0x00	; 0
     54c:	e6 14       	cp	r14, r6
     54e:	f7 04       	cpc	r15, r7
     550:	08 05       	cpc	r16, r8
     552:	19 05       	cpc	r17, r9
     554:	20 f4       	brcc	.+8      	; 0x55e <__mulsf3+0xe8>
     556:	81 e0       	ldi	r24, 0x01	; 1
     558:	90 e0       	ldi	r25, 0x00	; 0
     55a:	a0 e0       	ldi	r26, 0x00	; 0
     55c:	b0 e0       	ldi	r27, 0x00	; 0
     55e:	ba 01       	movw	r22, r20
     560:	a9 01       	movw	r20, r18
     562:	48 0f       	add	r20, r24
     564:	59 1f       	adc	r21, r25
     566:	6a 1f       	adc	r22, r26
     568:	7b 1f       	adc	r23, r27
     56a:	aa 0c       	add	r10, r10
     56c:	bb 1c       	adc	r11, r11
     56e:	cc 1c       	adc	r12, r12
     570:	dd 1c       	adc	r13, r13
     572:	97 fe       	sbrs	r9, 7
     574:	08 c0       	rjmp	.+16     	; 0x586 <__mulsf3+0x110>
     576:	81 e0       	ldi	r24, 0x01	; 1
     578:	90 e0       	ldi	r25, 0x00	; 0
     57a:	a0 e0       	ldi	r26, 0x00	; 0
     57c:	b0 e0       	ldi	r27, 0x00	; 0
     57e:	a8 2a       	or	r10, r24
     580:	b9 2a       	or	r11, r25
     582:	ca 2a       	or	r12, r26
     584:	db 2a       	or	r13, r27
     586:	31 96       	adiw	r30, 0x01	; 1
     588:	e0 32       	cpi	r30, 0x20	; 32
     58a:	f1 05       	cpc	r31, r1
     58c:	49 f0       	breq	.+18     	; 0x5a0 <__mulsf3+0x12a>
     58e:	66 0c       	add	r6, r6
     590:	77 1c       	adc	r7, r7
     592:	88 1c       	adc	r8, r8
     594:	99 1c       	adc	r9, r9
     596:	56 94       	lsr	r5
     598:	47 94       	ror	r4
     59a:	37 94       	ror	r3
     59c:	27 94       	ror	r2
     59e:	c3 cf       	rjmp	.-122    	; 0x526 <__mulsf3+0xb0>
     5a0:	fa 85       	ldd	r31, Y+10	; 0x0a
     5a2:	ea 89       	ldd	r30, Y+18	; 0x12
     5a4:	2b 89       	ldd	r18, Y+19	; 0x13
     5a6:	3c 89       	ldd	r19, Y+20	; 0x14
     5a8:	8b 85       	ldd	r24, Y+11	; 0x0b
     5aa:	9c 85       	ldd	r25, Y+12	; 0x0c
     5ac:	28 0f       	add	r18, r24
     5ae:	39 1f       	adc	r19, r25
     5b0:	2e 5f       	subi	r18, 0xFE	; 254
     5b2:	3f 4f       	sbci	r19, 0xFF	; 255
     5b4:	17 c0       	rjmp	.+46     	; 0x5e4 <__mulsf3+0x16e>
     5b6:	ca 01       	movw	r24, r20
     5b8:	81 70       	andi	r24, 0x01	; 1
     5ba:	90 70       	andi	r25, 0x00	; 0
     5bc:	89 2b       	or	r24, r25
     5be:	61 f0       	breq	.+24     	; 0x5d8 <__mulsf3+0x162>
     5c0:	16 95       	lsr	r17
     5c2:	07 95       	ror	r16
     5c4:	f7 94       	ror	r15
     5c6:	e7 94       	ror	r14
     5c8:	80 e0       	ldi	r24, 0x00	; 0
     5ca:	90 e0       	ldi	r25, 0x00	; 0
     5cc:	a0 e0       	ldi	r26, 0x00	; 0
     5ce:	b0 e8       	ldi	r27, 0x80	; 128
     5d0:	e8 2a       	or	r14, r24
     5d2:	f9 2a       	or	r15, r25
     5d4:	0a 2b       	or	r16, r26
     5d6:	1b 2b       	or	r17, r27
     5d8:	76 95       	lsr	r23
     5da:	67 95       	ror	r22
     5dc:	57 95       	ror	r21
     5de:	47 95       	ror	r20
     5e0:	2f 5f       	subi	r18, 0xFF	; 255
     5e2:	3f 4f       	sbci	r19, 0xFF	; 255
     5e4:	77 fd       	sbrc	r23, 7
     5e6:	e7 cf       	rjmp	.-50     	; 0x5b6 <__mulsf3+0x140>
     5e8:	0c c0       	rjmp	.+24     	; 0x602 <__mulsf3+0x18c>
     5ea:	44 0f       	add	r20, r20
     5ec:	55 1f       	adc	r21, r21
     5ee:	66 1f       	adc	r22, r22
     5f0:	77 1f       	adc	r23, r23
     5f2:	17 fd       	sbrc	r17, 7
     5f4:	41 60       	ori	r20, 0x01	; 1
     5f6:	ee 0c       	add	r14, r14
     5f8:	ff 1c       	adc	r15, r15
     5fa:	00 1f       	adc	r16, r16
     5fc:	11 1f       	adc	r17, r17
     5fe:	21 50       	subi	r18, 0x01	; 1
     600:	30 40       	sbci	r19, 0x00	; 0
     602:	40 30       	cpi	r20, 0x00	; 0
     604:	90 e0       	ldi	r25, 0x00	; 0
     606:	59 07       	cpc	r21, r25
     608:	90 e0       	ldi	r25, 0x00	; 0
     60a:	69 07       	cpc	r22, r25
     60c:	90 e4       	ldi	r25, 0x40	; 64
     60e:	79 07       	cpc	r23, r25
     610:	60 f3       	brcs	.-40     	; 0x5ea <__mulsf3+0x174>
     612:	2b 8f       	std	Y+27, r18	; 0x1b
     614:	3c 8f       	std	Y+28, r19	; 0x1c
     616:	db 01       	movw	r26, r22
     618:	ca 01       	movw	r24, r20
     61a:	8f 77       	andi	r24, 0x7F	; 127
     61c:	90 70       	andi	r25, 0x00	; 0
     61e:	a0 70       	andi	r26, 0x00	; 0
     620:	b0 70       	andi	r27, 0x00	; 0
     622:	80 34       	cpi	r24, 0x40	; 64
     624:	91 05       	cpc	r25, r1
     626:	a1 05       	cpc	r26, r1
     628:	b1 05       	cpc	r27, r1
     62a:	61 f4       	brne	.+24     	; 0x644 <__mulsf3+0x1ce>
     62c:	47 fd       	sbrc	r20, 7
     62e:	0a c0       	rjmp	.+20     	; 0x644 <__mulsf3+0x1ce>
     630:	e1 14       	cp	r14, r1
     632:	f1 04       	cpc	r15, r1
     634:	01 05       	cpc	r16, r1
     636:	11 05       	cpc	r17, r1
     638:	29 f0       	breq	.+10     	; 0x644 <__mulsf3+0x1ce>
     63a:	40 5c       	subi	r20, 0xC0	; 192
     63c:	5f 4f       	sbci	r21, 0xFF	; 255
     63e:	6f 4f       	sbci	r22, 0xFF	; 255
     640:	7f 4f       	sbci	r23, 0xFF	; 255
     642:	40 78       	andi	r20, 0x80	; 128
     644:	1a 8e       	std	Y+26, r1	; 0x1a
     646:	fe 17       	cp	r31, r30
     648:	11 f0       	breq	.+4      	; 0x64e <__mulsf3+0x1d8>
     64a:	81 e0       	ldi	r24, 0x01	; 1
     64c:	8a 8f       	std	Y+26, r24	; 0x1a
     64e:	4d 8f       	std	Y+29, r20	; 0x1d
     650:	5e 8f       	std	Y+30, r21	; 0x1e
     652:	6f 8f       	std	Y+31, r22	; 0x1f
     654:	78 a3       	std	Y+32, r23	; 0x20
     656:	83 e0       	ldi	r24, 0x03	; 3
     658:	89 8f       	std	Y+25, r24	; 0x19
     65a:	ce 01       	movw	r24, r28
     65c:	49 96       	adiw	r24, 0x19	; 25
     65e:	0e 94 8d 05 	call	0xb1a	; 0xb1a <__pack_f>
     662:	a0 96       	adiw	r28, 0x20	; 32
     664:	e2 e1       	ldi	r30, 0x12	; 18
     666:	0c 94 66 49 	jmp	0x92cc	; 0x92cc <__epilogue_restores__>

0000066a <__divsf3>:
     66a:	a8 e1       	ldi	r26, 0x18	; 24
     66c:	b0 e0       	ldi	r27, 0x00	; 0
     66e:	eb e3       	ldi	r30, 0x3B	; 59
     670:	f3 e0       	ldi	r31, 0x03	; 3
     672:	0c 94 52 49 	jmp	0x92a4	; 0x92a4 <__prologue_saves__+0x10>
     676:	69 83       	std	Y+1, r22	; 0x01
     678:	7a 83       	std	Y+2, r23	; 0x02
     67a:	8b 83       	std	Y+3, r24	; 0x03
     67c:	9c 83       	std	Y+4, r25	; 0x04
     67e:	2d 83       	std	Y+5, r18	; 0x05
     680:	3e 83       	std	Y+6, r19	; 0x06
     682:	4f 83       	std	Y+7, r20	; 0x07
     684:	58 87       	std	Y+8, r21	; 0x08
     686:	b9 e0       	ldi	r27, 0x09	; 9
     688:	eb 2e       	mov	r14, r27
     68a:	f1 2c       	mov	r15, r1
     68c:	ec 0e       	add	r14, r28
     68e:	fd 1e       	adc	r15, r29
     690:	ce 01       	movw	r24, r28
     692:	01 96       	adiw	r24, 0x01	; 1
     694:	b7 01       	movw	r22, r14
     696:	0e 94 62 06 	call	0xcc4	; 0xcc4 <__unpack_f>
     69a:	8e 01       	movw	r16, r28
     69c:	0f 5e       	subi	r16, 0xEF	; 239
     69e:	1f 4f       	sbci	r17, 0xFF	; 255
     6a0:	ce 01       	movw	r24, r28
     6a2:	05 96       	adiw	r24, 0x05	; 5
     6a4:	b8 01       	movw	r22, r16
     6a6:	0e 94 62 06 	call	0xcc4	; 0xcc4 <__unpack_f>
     6aa:	29 85       	ldd	r18, Y+9	; 0x09
     6ac:	22 30       	cpi	r18, 0x02	; 2
     6ae:	08 f4       	brcc	.+2      	; 0x6b2 <__divsf3+0x48>
     6b0:	7e c0       	rjmp	.+252    	; 0x7ae <__divsf3+0x144>
     6b2:	39 89       	ldd	r19, Y+17	; 0x11
     6b4:	32 30       	cpi	r19, 0x02	; 2
     6b6:	10 f4       	brcc	.+4      	; 0x6bc <__divsf3+0x52>
     6b8:	b8 01       	movw	r22, r16
     6ba:	7c c0       	rjmp	.+248    	; 0x7b4 <__divsf3+0x14a>
     6bc:	8a 85       	ldd	r24, Y+10	; 0x0a
     6be:	9a 89       	ldd	r25, Y+18	; 0x12
     6c0:	89 27       	eor	r24, r25
     6c2:	8a 87       	std	Y+10, r24	; 0x0a
     6c4:	24 30       	cpi	r18, 0x04	; 4
     6c6:	11 f0       	breq	.+4      	; 0x6cc <__divsf3+0x62>
     6c8:	22 30       	cpi	r18, 0x02	; 2
     6ca:	31 f4       	brne	.+12     	; 0x6d8 <__divsf3+0x6e>
     6cc:	23 17       	cp	r18, r19
     6ce:	09 f0       	breq	.+2      	; 0x6d2 <__divsf3+0x68>
     6d0:	6e c0       	rjmp	.+220    	; 0x7ae <__divsf3+0x144>
     6d2:	6f e2       	ldi	r22, 0x2F	; 47
     6d4:	71 e0       	ldi	r23, 0x01	; 1
     6d6:	6e c0       	rjmp	.+220    	; 0x7b4 <__divsf3+0x14a>
     6d8:	34 30       	cpi	r19, 0x04	; 4
     6da:	39 f4       	brne	.+14     	; 0x6ea <__divsf3+0x80>
     6dc:	1d 86       	std	Y+13, r1	; 0x0d
     6de:	1e 86       	std	Y+14, r1	; 0x0e
     6e0:	1f 86       	std	Y+15, r1	; 0x0f
     6e2:	18 8a       	std	Y+16, r1	; 0x10
     6e4:	1c 86       	std	Y+12, r1	; 0x0c
     6e6:	1b 86       	std	Y+11, r1	; 0x0b
     6e8:	04 c0       	rjmp	.+8      	; 0x6f2 <__divsf3+0x88>
     6ea:	32 30       	cpi	r19, 0x02	; 2
     6ec:	21 f4       	brne	.+8      	; 0x6f6 <__divsf3+0x8c>
     6ee:	84 e0       	ldi	r24, 0x04	; 4
     6f0:	89 87       	std	Y+9, r24	; 0x09
     6f2:	b7 01       	movw	r22, r14
     6f4:	5f c0       	rjmp	.+190    	; 0x7b4 <__divsf3+0x14a>
     6f6:	2b 85       	ldd	r18, Y+11	; 0x0b
     6f8:	3c 85       	ldd	r19, Y+12	; 0x0c
     6fa:	8b 89       	ldd	r24, Y+19	; 0x13
     6fc:	9c 89       	ldd	r25, Y+20	; 0x14
     6fe:	28 1b       	sub	r18, r24
     700:	39 0b       	sbc	r19, r25
     702:	3c 87       	std	Y+12, r19	; 0x0c
     704:	2b 87       	std	Y+11, r18	; 0x0b
     706:	ed 84       	ldd	r14, Y+13	; 0x0d
     708:	fe 84       	ldd	r15, Y+14	; 0x0e
     70a:	0f 85       	ldd	r16, Y+15	; 0x0f
     70c:	18 89       	ldd	r17, Y+16	; 0x10
     70e:	ad 88       	ldd	r10, Y+21	; 0x15
     710:	be 88       	ldd	r11, Y+22	; 0x16
     712:	cf 88       	ldd	r12, Y+23	; 0x17
     714:	d8 8c       	ldd	r13, Y+24	; 0x18
     716:	ea 14       	cp	r14, r10
     718:	fb 04       	cpc	r15, r11
     71a:	0c 05       	cpc	r16, r12
     71c:	1d 05       	cpc	r17, r13
     71e:	40 f4       	brcc	.+16     	; 0x730 <__divsf3+0xc6>
     720:	ee 0c       	add	r14, r14
     722:	ff 1c       	adc	r15, r15
     724:	00 1f       	adc	r16, r16
     726:	11 1f       	adc	r17, r17
     728:	21 50       	subi	r18, 0x01	; 1
     72a:	30 40       	sbci	r19, 0x00	; 0
     72c:	3c 87       	std	Y+12, r19	; 0x0c
     72e:	2b 87       	std	Y+11, r18	; 0x0b
     730:	20 e0       	ldi	r18, 0x00	; 0
     732:	30 e0       	ldi	r19, 0x00	; 0
     734:	40 e0       	ldi	r20, 0x00	; 0
     736:	50 e0       	ldi	r21, 0x00	; 0
     738:	80 e0       	ldi	r24, 0x00	; 0
     73a:	90 e0       	ldi	r25, 0x00	; 0
     73c:	a0 e0       	ldi	r26, 0x00	; 0
     73e:	b0 e4       	ldi	r27, 0x40	; 64
     740:	60 e0       	ldi	r22, 0x00	; 0
     742:	70 e0       	ldi	r23, 0x00	; 0
     744:	ea 14       	cp	r14, r10
     746:	fb 04       	cpc	r15, r11
     748:	0c 05       	cpc	r16, r12
     74a:	1d 05       	cpc	r17, r13
     74c:	40 f0       	brcs	.+16     	; 0x75e <__divsf3+0xf4>
     74e:	28 2b       	or	r18, r24
     750:	39 2b       	or	r19, r25
     752:	4a 2b       	or	r20, r26
     754:	5b 2b       	or	r21, r27
     756:	ea 18       	sub	r14, r10
     758:	fb 08       	sbc	r15, r11
     75a:	0c 09       	sbc	r16, r12
     75c:	1d 09       	sbc	r17, r13
     75e:	b6 95       	lsr	r27
     760:	a7 95       	ror	r26
     762:	97 95       	ror	r25
     764:	87 95       	ror	r24
     766:	ee 0c       	add	r14, r14
     768:	ff 1c       	adc	r15, r15
     76a:	00 1f       	adc	r16, r16
     76c:	11 1f       	adc	r17, r17
     76e:	6f 5f       	subi	r22, 0xFF	; 255
     770:	7f 4f       	sbci	r23, 0xFF	; 255
     772:	6f 31       	cpi	r22, 0x1F	; 31
     774:	71 05       	cpc	r23, r1
     776:	31 f7       	brne	.-52     	; 0x744 <__divsf3+0xda>
     778:	da 01       	movw	r26, r20
     77a:	c9 01       	movw	r24, r18
     77c:	8f 77       	andi	r24, 0x7F	; 127
     77e:	90 70       	andi	r25, 0x00	; 0
     780:	a0 70       	andi	r26, 0x00	; 0
     782:	b0 70       	andi	r27, 0x00	; 0
     784:	80 34       	cpi	r24, 0x40	; 64
     786:	91 05       	cpc	r25, r1
     788:	a1 05       	cpc	r26, r1
     78a:	b1 05       	cpc	r27, r1
     78c:	61 f4       	brne	.+24     	; 0x7a6 <__divsf3+0x13c>
     78e:	27 fd       	sbrc	r18, 7
     790:	0a c0       	rjmp	.+20     	; 0x7a6 <__divsf3+0x13c>
     792:	e1 14       	cp	r14, r1
     794:	f1 04       	cpc	r15, r1
     796:	01 05       	cpc	r16, r1
     798:	11 05       	cpc	r17, r1
     79a:	29 f0       	breq	.+10     	; 0x7a6 <__divsf3+0x13c>
     79c:	20 5c       	subi	r18, 0xC0	; 192
     79e:	3f 4f       	sbci	r19, 0xFF	; 255
     7a0:	4f 4f       	sbci	r20, 0xFF	; 255
     7a2:	5f 4f       	sbci	r21, 0xFF	; 255
     7a4:	20 78       	andi	r18, 0x80	; 128
     7a6:	2d 87       	std	Y+13, r18	; 0x0d
     7a8:	3e 87       	std	Y+14, r19	; 0x0e
     7aa:	4f 87       	std	Y+15, r20	; 0x0f
     7ac:	58 8b       	std	Y+16, r21	; 0x10
     7ae:	be 01       	movw	r22, r28
     7b0:	67 5f       	subi	r22, 0xF7	; 247
     7b2:	7f 4f       	sbci	r23, 0xFF	; 255
     7b4:	cb 01       	movw	r24, r22
     7b6:	0e 94 8d 05 	call	0xb1a	; 0xb1a <__pack_f>
     7ba:	68 96       	adiw	r28, 0x18	; 24
     7bc:	ea e0       	ldi	r30, 0x0A	; 10
     7be:	0c 94 6e 49 	jmp	0x92dc	; 0x92dc <__epilogue_restores__+0x10>

000007c2 <__gtsf2>:
     7c2:	a8 e1       	ldi	r26, 0x18	; 24
     7c4:	b0 e0       	ldi	r27, 0x00	; 0
     7c6:	e7 ee       	ldi	r30, 0xE7	; 231
     7c8:	f3 e0       	ldi	r31, 0x03	; 3
     7ca:	0c 94 56 49 	jmp	0x92ac	; 0x92ac <__prologue_saves__+0x18>
     7ce:	69 83       	std	Y+1, r22	; 0x01
     7d0:	7a 83       	std	Y+2, r23	; 0x02
     7d2:	8b 83       	std	Y+3, r24	; 0x03
     7d4:	9c 83       	std	Y+4, r25	; 0x04
     7d6:	2d 83       	std	Y+5, r18	; 0x05
     7d8:	3e 83       	std	Y+6, r19	; 0x06
     7da:	4f 83       	std	Y+7, r20	; 0x07
     7dc:	58 87       	std	Y+8, r21	; 0x08
     7de:	89 e0       	ldi	r24, 0x09	; 9
     7e0:	e8 2e       	mov	r14, r24
     7e2:	f1 2c       	mov	r15, r1
     7e4:	ec 0e       	add	r14, r28
     7e6:	fd 1e       	adc	r15, r29
     7e8:	ce 01       	movw	r24, r28
     7ea:	01 96       	adiw	r24, 0x01	; 1
     7ec:	b7 01       	movw	r22, r14
     7ee:	0e 94 62 06 	call	0xcc4	; 0xcc4 <__unpack_f>
     7f2:	8e 01       	movw	r16, r28
     7f4:	0f 5e       	subi	r16, 0xEF	; 239
     7f6:	1f 4f       	sbci	r17, 0xFF	; 255
     7f8:	ce 01       	movw	r24, r28
     7fa:	05 96       	adiw	r24, 0x05	; 5
     7fc:	b8 01       	movw	r22, r16
     7fe:	0e 94 62 06 	call	0xcc4	; 0xcc4 <__unpack_f>
     802:	89 85       	ldd	r24, Y+9	; 0x09
     804:	82 30       	cpi	r24, 0x02	; 2
     806:	40 f0       	brcs	.+16     	; 0x818 <__gtsf2+0x56>
     808:	89 89       	ldd	r24, Y+17	; 0x11
     80a:	82 30       	cpi	r24, 0x02	; 2
     80c:	28 f0       	brcs	.+10     	; 0x818 <__gtsf2+0x56>
     80e:	c7 01       	movw	r24, r14
     810:	b8 01       	movw	r22, r16
     812:	0e 94 da 06 	call	0xdb4	; 0xdb4 <__fpcmp_parts_f>
     816:	01 c0       	rjmp	.+2      	; 0x81a <__gtsf2+0x58>
     818:	8f ef       	ldi	r24, 0xFF	; 255
     81a:	68 96       	adiw	r28, 0x18	; 24
     81c:	e6 e0       	ldi	r30, 0x06	; 6
     81e:	0c 94 72 49 	jmp	0x92e4	; 0x92e4 <__epilogue_restores__+0x18>

00000822 <__gesf2>:
     822:	a8 e1       	ldi	r26, 0x18	; 24
     824:	b0 e0       	ldi	r27, 0x00	; 0
     826:	e7 e1       	ldi	r30, 0x17	; 23
     828:	f4 e0       	ldi	r31, 0x04	; 4
     82a:	0c 94 56 49 	jmp	0x92ac	; 0x92ac <__prologue_saves__+0x18>
     82e:	69 83       	std	Y+1, r22	; 0x01
     830:	7a 83       	std	Y+2, r23	; 0x02
     832:	8b 83       	std	Y+3, r24	; 0x03
     834:	9c 83       	std	Y+4, r25	; 0x04
     836:	2d 83       	std	Y+5, r18	; 0x05
     838:	3e 83       	std	Y+6, r19	; 0x06
     83a:	4f 83       	std	Y+7, r20	; 0x07
     83c:	58 87       	std	Y+8, r21	; 0x08
     83e:	89 e0       	ldi	r24, 0x09	; 9
     840:	e8 2e       	mov	r14, r24
     842:	f1 2c       	mov	r15, r1
     844:	ec 0e       	add	r14, r28
     846:	fd 1e       	adc	r15, r29
     848:	ce 01       	movw	r24, r28
     84a:	01 96       	adiw	r24, 0x01	; 1
     84c:	b7 01       	movw	r22, r14
     84e:	0e 94 62 06 	call	0xcc4	; 0xcc4 <__unpack_f>
     852:	8e 01       	movw	r16, r28
     854:	0f 5e       	subi	r16, 0xEF	; 239
     856:	1f 4f       	sbci	r17, 0xFF	; 255
     858:	ce 01       	movw	r24, r28
     85a:	05 96       	adiw	r24, 0x05	; 5
     85c:	b8 01       	movw	r22, r16
     85e:	0e 94 62 06 	call	0xcc4	; 0xcc4 <__unpack_f>
     862:	89 85       	ldd	r24, Y+9	; 0x09
     864:	82 30       	cpi	r24, 0x02	; 2
     866:	40 f0       	brcs	.+16     	; 0x878 <__gesf2+0x56>
     868:	89 89       	ldd	r24, Y+17	; 0x11
     86a:	82 30       	cpi	r24, 0x02	; 2
     86c:	28 f0       	brcs	.+10     	; 0x878 <__gesf2+0x56>
     86e:	c7 01       	movw	r24, r14
     870:	b8 01       	movw	r22, r16
     872:	0e 94 da 06 	call	0xdb4	; 0xdb4 <__fpcmp_parts_f>
     876:	01 c0       	rjmp	.+2      	; 0x87a <__gesf2+0x58>
     878:	8f ef       	ldi	r24, 0xFF	; 255
     87a:	68 96       	adiw	r28, 0x18	; 24
     87c:	e6 e0       	ldi	r30, 0x06	; 6
     87e:	0c 94 72 49 	jmp	0x92e4	; 0x92e4 <__epilogue_restores__+0x18>

00000882 <__ltsf2>:
     882:	a8 e1       	ldi	r26, 0x18	; 24
     884:	b0 e0       	ldi	r27, 0x00	; 0
     886:	e7 e4       	ldi	r30, 0x47	; 71
     888:	f4 e0       	ldi	r31, 0x04	; 4
     88a:	0c 94 56 49 	jmp	0x92ac	; 0x92ac <__prologue_saves__+0x18>
     88e:	69 83       	std	Y+1, r22	; 0x01
     890:	7a 83       	std	Y+2, r23	; 0x02
     892:	8b 83       	std	Y+3, r24	; 0x03
     894:	9c 83       	std	Y+4, r25	; 0x04
     896:	2d 83       	std	Y+5, r18	; 0x05
     898:	3e 83       	std	Y+6, r19	; 0x06
     89a:	4f 83       	std	Y+7, r20	; 0x07
     89c:	58 87       	std	Y+8, r21	; 0x08
     89e:	89 e0       	ldi	r24, 0x09	; 9
     8a0:	e8 2e       	mov	r14, r24
     8a2:	f1 2c       	mov	r15, r1
     8a4:	ec 0e       	add	r14, r28
     8a6:	fd 1e       	adc	r15, r29
     8a8:	ce 01       	movw	r24, r28
     8aa:	01 96       	adiw	r24, 0x01	; 1
     8ac:	b7 01       	movw	r22, r14
     8ae:	0e 94 62 06 	call	0xcc4	; 0xcc4 <__unpack_f>
     8b2:	8e 01       	movw	r16, r28
     8b4:	0f 5e       	subi	r16, 0xEF	; 239
     8b6:	1f 4f       	sbci	r17, 0xFF	; 255
     8b8:	ce 01       	movw	r24, r28
     8ba:	05 96       	adiw	r24, 0x05	; 5
     8bc:	b8 01       	movw	r22, r16
     8be:	0e 94 62 06 	call	0xcc4	; 0xcc4 <__unpack_f>
     8c2:	89 85       	ldd	r24, Y+9	; 0x09
     8c4:	82 30       	cpi	r24, 0x02	; 2
     8c6:	40 f0       	brcs	.+16     	; 0x8d8 <__ltsf2+0x56>
     8c8:	89 89       	ldd	r24, Y+17	; 0x11
     8ca:	82 30       	cpi	r24, 0x02	; 2
     8cc:	28 f0       	brcs	.+10     	; 0x8d8 <__ltsf2+0x56>
     8ce:	c7 01       	movw	r24, r14
     8d0:	b8 01       	movw	r22, r16
     8d2:	0e 94 da 06 	call	0xdb4	; 0xdb4 <__fpcmp_parts_f>
     8d6:	01 c0       	rjmp	.+2      	; 0x8da <__ltsf2+0x58>
     8d8:	81 e0       	ldi	r24, 0x01	; 1
     8da:	68 96       	adiw	r28, 0x18	; 24
     8dc:	e6 e0       	ldi	r30, 0x06	; 6
     8de:	0c 94 72 49 	jmp	0x92e4	; 0x92e4 <__epilogue_restores__+0x18>

000008e2 <__fixsfsi>:
     8e2:	ac e0       	ldi	r26, 0x0C	; 12
     8e4:	b0 e0       	ldi	r27, 0x00	; 0
     8e6:	e7 e7       	ldi	r30, 0x77	; 119
     8e8:	f4 e0       	ldi	r31, 0x04	; 4
     8ea:	0c 94 5a 49 	jmp	0x92b4	; 0x92b4 <__prologue_saves__+0x20>
     8ee:	69 83       	std	Y+1, r22	; 0x01
     8f0:	7a 83       	std	Y+2, r23	; 0x02
     8f2:	8b 83       	std	Y+3, r24	; 0x03
     8f4:	9c 83       	std	Y+4, r25	; 0x04
     8f6:	ce 01       	movw	r24, r28
     8f8:	01 96       	adiw	r24, 0x01	; 1
     8fa:	be 01       	movw	r22, r28
     8fc:	6b 5f       	subi	r22, 0xFB	; 251
     8fe:	7f 4f       	sbci	r23, 0xFF	; 255
     900:	0e 94 62 06 	call	0xcc4	; 0xcc4 <__unpack_f>
     904:	8d 81       	ldd	r24, Y+5	; 0x05
     906:	82 30       	cpi	r24, 0x02	; 2
     908:	61 f1       	breq	.+88     	; 0x962 <__fixsfsi+0x80>
     90a:	82 30       	cpi	r24, 0x02	; 2
     90c:	50 f1       	brcs	.+84     	; 0x962 <__fixsfsi+0x80>
     90e:	84 30       	cpi	r24, 0x04	; 4
     910:	21 f4       	brne	.+8      	; 0x91a <__fixsfsi+0x38>
     912:	8e 81       	ldd	r24, Y+6	; 0x06
     914:	88 23       	and	r24, r24
     916:	51 f1       	breq	.+84     	; 0x96c <__fixsfsi+0x8a>
     918:	2e c0       	rjmp	.+92     	; 0x976 <__fixsfsi+0x94>
     91a:	2f 81       	ldd	r18, Y+7	; 0x07
     91c:	38 85       	ldd	r19, Y+8	; 0x08
     91e:	37 fd       	sbrc	r19, 7
     920:	20 c0       	rjmp	.+64     	; 0x962 <__fixsfsi+0x80>
     922:	6e 81       	ldd	r22, Y+6	; 0x06
     924:	2f 31       	cpi	r18, 0x1F	; 31
     926:	31 05       	cpc	r19, r1
     928:	1c f0       	brlt	.+6      	; 0x930 <__fixsfsi+0x4e>
     92a:	66 23       	and	r22, r22
     92c:	f9 f0       	breq	.+62     	; 0x96c <__fixsfsi+0x8a>
     92e:	23 c0       	rjmp	.+70     	; 0x976 <__fixsfsi+0x94>
     930:	8e e1       	ldi	r24, 0x1E	; 30
     932:	90 e0       	ldi	r25, 0x00	; 0
     934:	82 1b       	sub	r24, r18
     936:	93 0b       	sbc	r25, r19
     938:	29 85       	ldd	r18, Y+9	; 0x09
     93a:	3a 85       	ldd	r19, Y+10	; 0x0a
     93c:	4b 85       	ldd	r20, Y+11	; 0x0b
     93e:	5c 85       	ldd	r21, Y+12	; 0x0c
     940:	04 c0       	rjmp	.+8      	; 0x94a <__fixsfsi+0x68>
     942:	56 95       	lsr	r21
     944:	47 95       	ror	r20
     946:	37 95       	ror	r19
     948:	27 95       	ror	r18
     94a:	8a 95       	dec	r24
     94c:	d2 f7       	brpl	.-12     	; 0x942 <__fixsfsi+0x60>
     94e:	66 23       	and	r22, r22
     950:	b1 f0       	breq	.+44     	; 0x97e <__fixsfsi+0x9c>
     952:	50 95       	com	r21
     954:	40 95       	com	r20
     956:	30 95       	com	r19
     958:	21 95       	neg	r18
     95a:	3f 4f       	sbci	r19, 0xFF	; 255
     95c:	4f 4f       	sbci	r20, 0xFF	; 255
     95e:	5f 4f       	sbci	r21, 0xFF	; 255
     960:	0e c0       	rjmp	.+28     	; 0x97e <__fixsfsi+0x9c>
     962:	20 e0       	ldi	r18, 0x00	; 0
     964:	30 e0       	ldi	r19, 0x00	; 0
     966:	40 e0       	ldi	r20, 0x00	; 0
     968:	50 e0       	ldi	r21, 0x00	; 0
     96a:	09 c0       	rjmp	.+18     	; 0x97e <__fixsfsi+0x9c>
     96c:	2f ef       	ldi	r18, 0xFF	; 255
     96e:	3f ef       	ldi	r19, 0xFF	; 255
     970:	4f ef       	ldi	r20, 0xFF	; 255
     972:	5f e7       	ldi	r21, 0x7F	; 127
     974:	04 c0       	rjmp	.+8      	; 0x97e <__fixsfsi+0x9c>
     976:	20 e0       	ldi	r18, 0x00	; 0
     978:	30 e0       	ldi	r19, 0x00	; 0
     97a:	40 e0       	ldi	r20, 0x00	; 0
     97c:	50 e8       	ldi	r21, 0x80	; 128
     97e:	b9 01       	movw	r22, r18
     980:	ca 01       	movw	r24, r20
     982:	2c 96       	adiw	r28, 0x0c	; 12
     984:	e2 e0       	ldi	r30, 0x02	; 2
     986:	0c 94 76 49 	jmp	0x92ec	; 0x92ec <__epilogue_restores__+0x20>

0000098a <__floatunsisf>:
     98a:	a8 e0       	ldi	r26, 0x08	; 8
     98c:	b0 e0       	ldi	r27, 0x00	; 0
     98e:	eb ec       	ldi	r30, 0xCB	; 203
     990:	f4 e0       	ldi	r31, 0x04	; 4
     992:	0c 94 52 49 	jmp	0x92a4	; 0x92a4 <__prologue_saves__+0x10>
     996:	7b 01       	movw	r14, r22
     998:	8c 01       	movw	r16, r24
     99a:	61 15       	cp	r22, r1
     99c:	71 05       	cpc	r23, r1
     99e:	81 05       	cpc	r24, r1
     9a0:	91 05       	cpc	r25, r1
     9a2:	19 f4       	brne	.+6      	; 0x9aa <__floatunsisf+0x20>
     9a4:	82 e0       	ldi	r24, 0x02	; 2
     9a6:	89 83       	std	Y+1, r24	; 0x01
     9a8:	60 c0       	rjmp	.+192    	; 0xa6a <__floatunsisf+0xe0>
     9aa:	83 e0       	ldi	r24, 0x03	; 3
     9ac:	89 83       	std	Y+1, r24	; 0x01
     9ae:	8e e1       	ldi	r24, 0x1E	; 30
     9b0:	c8 2e       	mov	r12, r24
     9b2:	d1 2c       	mov	r13, r1
     9b4:	dc 82       	std	Y+4, r13	; 0x04
     9b6:	cb 82       	std	Y+3, r12	; 0x03
     9b8:	ed 82       	std	Y+5, r14	; 0x05
     9ba:	fe 82       	std	Y+6, r15	; 0x06
     9bc:	0f 83       	std	Y+7, r16	; 0x07
     9be:	18 87       	std	Y+8, r17	; 0x08
     9c0:	c8 01       	movw	r24, r16
     9c2:	b7 01       	movw	r22, r14
     9c4:	0e 94 3e 05 	call	0xa7c	; 0xa7c <__clzsi2>
     9c8:	fc 01       	movw	r30, r24
     9ca:	31 97       	sbiw	r30, 0x01	; 1
     9cc:	f7 ff       	sbrs	r31, 7
     9ce:	3b c0       	rjmp	.+118    	; 0xa46 <__floatunsisf+0xbc>
     9d0:	22 27       	eor	r18, r18
     9d2:	33 27       	eor	r19, r19
     9d4:	2e 1b       	sub	r18, r30
     9d6:	3f 0b       	sbc	r19, r31
     9d8:	57 01       	movw	r10, r14
     9da:	68 01       	movw	r12, r16
     9dc:	02 2e       	mov	r0, r18
     9de:	04 c0       	rjmp	.+8      	; 0x9e8 <__floatunsisf+0x5e>
     9e0:	d6 94       	lsr	r13
     9e2:	c7 94       	ror	r12
     9e4:	b7 94       	ror	r11
     9e6:	a7 94       	ror	r10
     9e8:	0a 94       	dec	r0
     9ea:	d2 f7       	brpl	.-12     	; 0x9e0 <__floatunsisf+0x56>
     9ec:	40 e0       	ldi	r20, 0x00	; 0
     9ee:	50 e0       	ldi	r21, 0x00	; 0
     9f0:	60 e0       	ldi	r22, 0x00	; 0
     9f2:	70 e0       	ldi	r23, 0x00	; 0
     9f4:	81 e0       	ldi	r24, 0x01	; 1
     9f6:	90 e0       	ldi	r25, 0x00	; 0
     9f8:	a0 e0       	ldi	r26, 0x00	; 0
     9fa:	b0 e0       	ldi	r27, 0x00	; 0
     9fc:	04 c0       	rjmp	.+8      	; 0xa06 <__floatunsisf+0x7c>
     9fe:	88 0f       	add	r24, r24
     a00:	99 1f       	adc	r25, r25
     a02:	aa 1f       	adc	r26, r26
     a04:	bb 1f       	adc	r27, r27
     a06:	2a 95       	dec	r18
     a08:	d2 f7       	brpl	.-12     	; 0x9fe <__floatunsisf+0x74>
     a0a:	01 97       	sbiw	r24, 0x01	; 1
     a0c:	a1 09       	sbc	r26, r1
     a0e:	b1 09       	sbc	r27, r1
     a10:	8e 21       	and	r24, r14
     a12:	9f 21       	and	r25, r15
     a14:	a0 23       	and	r26, r16
     a16:	b1 23       	and	r27, r17
     a18:	00 97       	sbiw	r24, 0x00	; 0
     a1a:	a1 05       	cpc	r26, r1
     a1c:	b1 05       	cpc	r27, r1
     a1e:	21 f0       	breq	.+8      	; 0xa28 <__floatunsisf+0x9e>
     a20:	41 e0       	ldi	r20, 0x01	; 1
     a22:	50 e0       	ldi	r21, 0x00	; 0
     a24:	60 e0       	ldi	r22, 0x00	; 0
     a26:	70 e0       	ldi	r23, 0x00	; 0
     a28:	4a 29       	or	r20, r10
     a2a:	5b 29       	or	r21, r11
     a2c:	6c 29       	or	r22, r12
     a2e:	7d 29       	or	r23, r13
     a30:	4d 83       	std	Y+5, r20	; 0x05
     a32:	5e 83       	std	Y+6, r21	; 0x06
     a34:	6f 83       	std	Y+7, r22	; 0x07
     a36:	78 87       	std	Y+8, r23	; 0x08
     a38:	8e e1       	ldi	r24, 0x1E	; 30
     a3a:	90 e0       	ldi	r25, 0x00	; 0
     a3c:	8e 1b       	sub	r24, r30
     a3e:	9f 0b       	sbc	r25, r31
     a40:	9c 83       	std	Y+4, r25	; 0x04
     a42:	8b 83       	std	Y+3, r24	; 0x03
     a44:	12 c0       	rjmp	.+36     	; 0xa6a <__floatunsisf+0xe0>
     a46:	30 97       	sbiw	r30, 0x00	; 0
     a48:	81 f0       	breq	.+32     	; 0xa6a <__floatunsisf+0xe0>
     a4a:	0e 2e       	mov	r0, r30
     a4c:	04 c0       	rjmp	.+8      	; 0xa56 <__floatunsisf+0xcc>
     a4e:	ee 0c       	add	r14, r14
     a50:	ff 1c       	adc	r15, r15
     a52:	00 1f       	adc	r16, r16
     a54:	11 1f       	adc	r17, r17
     a56:	0a 94       	dec	r0
     a58:	d2 f7       	brpl	.-12     	; 0xa4e <__floatunsisf+0xc4>
     a5a:	ed 82       	std	Y+5, r14	; 0x05
     a5c:	fe 82       	std	Y+6, r15	; 0x06
     a5e:	0f 83       	std	Y+7, r16	; 0x07
     a60:	18 87       	std	Y+8, r17	; 0x08
     a62:	ce 1a       	sub	r12, r30
     a64:	df 0a       	sbc	r13, r31
     a66:	dc 82       	std	Y+4, r13	; 0x04
     a68:	cb 82       	std	Y+3, r12	; 0x03
     a6a:	1a 82       	std	Y+2, r1	; 0x02
     a6c:	ce 01       	movw	r24, r28
     a6e:	01 96       	adiw	r24, 0x01	; 1
     a70:	0e 94 8d 05 	call	0xb1a	; 0xb1a <__pack_f>
     a74:	28 96       	adiw	r28, 0x08	; 8
     a76:	ea e0       	ldi	r30, 0x0A	; 10
     a78:	0c 94 6e 49 	jmp	0x92dc	; 0x92dc <__epilogue_restores__+0x10>

00000a7c <__clzsi2>:
     a7c:	ef 92       	push	r14
     a7e:	ff 92       	push	r15
     a80:	0f 93       	push	r16
     a82:	1f 93       	push	r17
     a84:	7b 01       	movw	r14, r22
     a86:	8c 01       	movw	r16, r24
     a88:	80 e0       	ldi	r24, 0x00	; 0
     a8a:	e8 16       	cp	r14, r24
     a8c:	80 e0       	ldi	r24, 0x00	; 0
     a8e:	f8 06       	cpc	r15, r24
     a90:	81 e0       	ldi	r24, 0x01	; 1
     a92:	08 07       	cpc	r16, r24
     a94:	80 e0       	ldi	r24, 0x00	; 0
     a96:	18 07       	cpc	r17, r24
     a98:	88 f4       	brcc	.+34     	; 0xabc <__clzsi2+0x40>
     a9a:	8f ef       	ldi	r24, 0xFF	; 255
     a9c:	e8 16       	cp	r14, r24
     a9e:	f1 04       	cpc	r15, r1
     aa0:	01 05       	cpc	r16, r1
     aa2:	11 05       	cpc	r17, r1
     aa4:	31 f0       	breq	.+12     	; 0xab2 <__clzsi2+0x36>
     aa6:	28 f0       	brcs	.+10     	; 0xab2 <__clzsi2+0x36>
     aa8:	88 e0       	ldi	r24, 0x08	; 8
     aaa:	90 e0       	ldi	r25, 0x00	; 0
     aac:	a0 e0       	ldi	r26, 0x00	; 0
     aae:	b0 e0       	ldi	r27, 0x00	; 0
     ab0:	17 c0       	rjmp	.+46     	; 0xae0 <__clzsi2+0x64>
     ab2:	80 e0       	ldi	r24, 0x00	; 0
     ab4:	90 e0       	ldi	r25, 0x00	; 0
     ab6:	a0 e0       	ldi	r26, 0x00	; 0
     ab8:	b0 e0       	ldi	r27, 0x00	; 0
     aba:	12 c0       	rjmp	.+36     	; 0xae0 <__clzsi2+0x64>
     abc:	80 e0       	ldi	r24, 0x00	; 0
     abe:	e8 16       	cp	r14, r24
     ac0:	80 e0       	ldi	r24, 0x00	; 0
     ac2:	f8 06       	cpc	r15, r24
     ac4:	80 e0       	ldi	r24, 0x00	; 0
     ac6:	08 07       	cpc	r16, r24
     ac8:	81 e0       	ldi	r24, 0x01	; 1
     aca:	18 07       	cpc	r17, r24
     acc:	28 f0       	brcs	.+10     	; 0xad8 <__clzsi2+0x5c>
     ace:	88 e1       	ldi	r24, 0x18	; 24
     ad0:	90 e0       	ldi	r25, 0x00	; 0
     ad2:	a0 e0       	ldi	r26, 0x00	; 0
     ad4:	b0 e0       	ldi	r27, 0x00	; 0
     ad6:	04 c0       	rjmp	.+8      	; 0xae0 <__clzsi2+0x64>
     ad8:	80 e1       	ldi	r24, 0x10	; 16
     ada:	90 e0       	ldi	r25, 0x00	; 0
     adc:	a0 e0       	ldi	r26, 0x00	; 0
     ade:	b0 e0       	ldi	r27, 0x00	; 0
     ae0:	20 e2       	ldi	r18, 0x20	; 32
     ae2:	30 e0       	ldi	r19, 0x00	; 0
     ae4:	40 e0       	ldi	r20, 0x00	; 0
     ae6:	50 e0       	ldi	r21, 0x00	; 0
     ae8:	28 1b       	sub	r18, r24
     aea:	39 0b       	sbc	r19, r25
     aec:	4a 0b       	sbc	r20, r26
     aee:	5b 0b       	sbc	r21, r27
     af0:	04 c0       	rjmp	.+8      	; 0xafa <__clzsi2+0x7e>
     af2:	16 95       	lsr	r17
     af4:	07 95       	ror	r16
     af6:	f7 94       	ror	r15
     af8:	e7 94       	ror	r14
     afa:	8a 95       	dec	r24
     afc:	d2 f7       	brpl	.-12     	; 0xaf2 <__clzsi2+0x76>
     afe:	f7 01       	movw	r30, r14
     b00:	e9 5c       	subi	r30, 0xC9	; 201
     b02:	fe 4f       	sbci	r31, 0xFE	; 254
     b04:	80 81       	ld	r24, Z
     b06:	28 1b       	sub	r18, r24
     b08:	31 09       	sbc	r19, r1
     b0a:	41 09       	sbc	r20, r1
     b0c:	51 09       	sbc	r21, r1
     b0e:	c9 01       	movw	r24, r18
     b10:	1f 91       	pop	r17
     b12:	0f 91       	pop	r16
     b14:	ff 90       	pop	r15
     b16:	ef 90       	pop	r14
     b18:	08 95       	ret

00000b1a <__pack_f>:
     b1a:	df 92       	push	r13
     b1c:	ef 92       	push	r14
     b1e:	ff 92       	push	r15
     b20:	0f 93       	push	r16
     b22:	1f 93       	push	r17
     b24:	fc 01       	movw	r30, r24
     b26:	e4 80       	ldd	r14, Z+4	; 0x04
     b28:	f5 80       	ldd	r15, Z+5	; 0x05
     b2a:	06 81       	ldd	r16, Z+6	; 0x06
     b2c:	17 81       	ldd	r17, Z+7	; 0x07
     b2e:	d1 80       	ldd	r13, Z+1	; 0x01
     b30:	80 81       	ld	r24, Z
     b32:	82 30       	cpi	r24, 0x02	; 2
     b34:	48 f4       	brcc	.+18     	; 0xb48 <__pack_f+0x2e>
     b36:	80 e0       	ldi	r24, 0x00	; 0
     b38:	90 e0       	ldi	r25, 0x00	; 0
     b3a:	a0 e1       	ldi	r26, 0x10	; 16
     b3c:	b0 e0       	ldi	r27, 0x00	; 0
     b3e:	e8 2a       	or	r14, r24
     b40:	f9 2a       	or	r15, r25
     b42:	0a 2b       	or	r16, r26
     b44:	1b 2b       	or	r17, r27
     b46:	a5 c0       	rjmp	.+330    	; 0xc92 <__pack_f+0x178>
     b48:	84 30       	cpi	r24, 0x04	; 4
     b4a:	09 f4       	brne	.+2      	; 0xb4e <__pack_f+0x34>
     b4c:	9f c0       	rjmp	.+318    	; 0xc8c <__pack_f+0x172>
     b4e:	82 30       	cpi	r24, 0x02	; 2
     b50:	21 f4       	brne	.+8      	; 0xb5a <__pack_f+0x40>
     b52:	ee 24       	eor	r14, r14
     b54:	ff 24       	eor	r15, r15
     b56:	87 01       	movw	r16, r14
     b58:	05 c0       	rjmp	.+10     	; 0xb64 <__pack_f+0x4a>
     b5a:	e1 14       	cp	r14, r1
     b5c:	f1 04       	cpc	r15, r1
     b5e:	01 05       	cpc	r16, r1
     b60:	11 05       	cpc	r17, r1
     b62:	19 f4       	brne	.+6      	; 0xb6a <__pack_f+0x50>
     b64:	e0 e0       	ldi	r30, 0x00	; 0
     b66:	f0 e0       	ldi	r31, 0x00	; 0
     b68:	96 c0       	rjmp	.+300    	; 0xc96 <__pack_f+0x17c>
     b6a:	62 81       	ldd	r22, Z+2	; 0x02
     b6c:	73 81       	ldd	r23, Z+3	; 0x03
     b6e:	9f ef       	ldi	r25, 0xFF	; 255
     b70:	62 38       	cpi	r22, 0x82	; 130
     b72:	79 07       	cpc	r23, r25
     b74:	0c f0       	brlt	.+2      	; 0xb78 <__pack_f+0x5e>
     b76:	5b c0       	rjmp	.+182    	; 0xc2e <__pack_f+0x114>
     b78:	22 e8       	ldi	r18, 0x82	; 130
     b7a:	3f ef       	ldi	r19, 0xFF	; 255
     b7c:	26 1b       	sub	r18, r22
     b7e:	37 0b       	sbc	r19, r23
     b80:	2a 31       	cpi	r18, 0x1A	; 26
     b82:	31 05       	cpc	r19, r1
     b84:	2c f0       	brlt	.+10     	; 0xb90 <__pack_f+0x76>
     b86:	20 e0       	ldi	r18, 0x00	; 0
     b88:	30 e0       	ldi	r19, 0x00	; 0
     b8a:	40 e0       	ldi	r20, 0x00	; 0
     b8c:	50 e0       	ldi	r21, 0x00	; 0
     b8e:	2a c0       	rjmp	.+84     	; 0xbe4 <__pack_f+0xca>
     b90:	b8 01       	movw	r22, r16
     b92:	a7 01       	movw	r20, r14
     b94:	02 2e       	mov	r0, r18
     b96:	04 c0       	rjmp	.+8      	; 0xba0 <__pack_f+0x86>
     b98:	76 95       	lsr	r23
     b9a:	67 95       	ror	r22
     b9c:	57 95       	ror	r21
     b9e:	47 95       	ror	r20
     ba0:	0a 94       	dec	r0
     ba2:	d2 f7       	brpl	.-12     	; 0xb98 <__pack_f+0x7e>
     ba4:	81 e0       	ldi	r24, 0x01	; 1
     ba6:	90 e0       	ldi	r25, 0x00	; 0
     ba8:	a0 e0       	ldi	r26, 0x00	; 0
     baa:	b0 e0       	ldi	r27, 0x00	; 0
     bac:	04 c0       	rjmp	.+8      	; 0xbb6 <__pack_f+0x9c>
     bae:	88 0f       	add	r24, r24
     bb0:	99 1f       	adc	r25, r25
     bb2:	aa 1f       	adc	r26, r26
     bb4:	bb 1f       	adc	r27, r27
     bb6:	2a 95       	dec	r18
     bb8:	d2 f7       	brpl	.-12     	; 0xbae <__pack_f+0x94>
     bba:	01 97       	sbiw	r24, 0x01	; 1
     bbc:	a1 09       	sbc	r26, r1
     bbe:	b1 09       	sbc	r27, r1
     bc0:	8e 21       	and	r24, r14
     bc2:	9f 21       	and	r25, r15
     bc4:	a0 23       	and	r26, r16
     bc6:	b1 23       	and	r27, r17
     bc8:	00 97       	sbiw	r24, 0x00	; 0
     bca:	a1 05       	cpc	r26, r1
     bcc:	b1 05       	cpc	r27, r1
     bce:	21 f0       	breq	.+8      	; 0xbd8 <__pack_f+0xbe>
     bd0:	81 e0       	ldi	r24, 0x01	; 1
     bd2:	90 e0       	ldi	r25, 0x00	; 0
     bd4:	a0 e0       	ldi	r26, 0x00	; 0
     bd6:	b0 e0       	ldi	r27, 0x00	; 0
     bd8:	9a 01       	movw	r18, r20
     bda:	ab 01       	movw	r20, r22
     bdc:	28 2b       	or	r18, r24
     bde:	39 2b       	or	r19, r25
     be0:	4a 2b       	or	r20, r26
     be2:	5b 2b       	or	r21, r27
     be4:	da 01       	movw	r26, r20
     be6:	c9 01       	movw	r24, r18
     be8:	8f 77       	andi	r24, 0x7F	; 127
     bea:	90 70       	andi	r25, 0x00	; 0
     bec:	a0 70       	andi	r26, 0x00	; 0
     bee:	b0 70       	andi	r27, 0x00	; 0
     bf0:	80 34       	cpi	r24, 0x40	; 64
     bf2:	91 05       	cpc	r25, r1
     bf4:	a1 05       	cpc	r26, r1
     bf6:	b1 05       	cpc	r27, r1
     bf8:	39 f4       	brne	.+14     	; 0xc08 <__pack_f+0xee>
     bfa:	27 ff       	sbrs	r18, 7
     bfc:	09 c0       	rjmp	.+18     	; 0xc10 <__pack_f+0xf6>
     bfe:	20 5c       	subi	r18, 0xC0	; 192
     c00:	3f 4f       	sbci	r19, 0xFF	; 255
     c02:	4f 4f       	sbci	r20, 0xFF	; 255
     c04:	5f 4f       	sbci	r21, 0xFF	; 255
     c06:	04 c0       	rjmp	.+8      	; 0xc10 <__pack_f+0xf6>
     c08:	21 5c       	subi	r18, 0xC1	; 193
     c0a:	3f 4f       	sbci	r19, 0xFF	; 255
     c0c:	4f 4f       	sbci	r20, 0xFF	; 255
     c0e:	5f 4f       	sbci	r21, 0xFF	; 255
     c10:	e0 e0       	ldi	r30, 0x00	; 0
     c12:	f0 e0       	ldi	r31, 0x00	; 0
     c14:	20 30       	cpi	r18, 0x00	; 0
     c16:	a0 e0       	ldi	r26, 0x00	; 0
     c18:	3a 07       	cpc	r19, r26
     c1a:	a0 e0       	ldi	r26, 0x00	; 0
     c1c:	4a 07       	cpc	r20, r26
     c1e:	a0 e4       	ldi	r26, 0x40	; 64
     c20:	5a 07       	cpc	r21, r26
     c22:	10 f0       	brcs	.+4      	; 0xc28 <__pack_f+0x10e>
     c24:	e1 e0       	ldi	r30, 0x01	; 1
     c26:	f0 e0       	ldi	r31, 0x00	; 0
     c28:	79 01       	movw	r14, r18
     c2a:	8a 01       	movw	r16, r20
     c2c:	27 c0       	rjmp	.+78     	; 0xc7c <__pack_f+0x162>
     c2e:	60 38       	cpi	r22, 0x80	; 128
     c30:	71 05       	cpc	r23, r1
     c32:	64 f5       	brge	.+88     	; 0xc8c <__pack_f+0x172>
     c34:	fb 01       	movw	r30, r22
     c36:	e1 58       	subi	r30, 0x81	; 129
     c38:	ff 4f       	sbci	r31, 0xFF	; 255
     c3a:	d8 01       	movw	r26, r16
     c3c:	c7 01       	movw	r24, r14
     c3e:	8f 77       	andi	r24, 0x7F	; 127
     c40:	90 70       	andi	r25, 0x00	; 0
     c42:	a0 70       	andi	r26, 0x00	; 0
     c44:	b0 70       	andi	r27, 0x00	; 0
     c46:	80 34       	cpi	r24, 0x40	; 64
     c48:	91 05       	cpc	r25, r1
     c4a:	a1 05       	cpc	r26, r1
     c4c:	b1 05       	cpc	r27, r1
     c4e:	39 f4       	brne	.+14     	; 0xc5e <__pack_f+0x144>
     c50:	e7 fe       	sbrs	r14, 7
     c52:	0d c0       	rjmp	.+26     	; 0xc6e <__pack_f+0x154>
     c54:	80 e4       	ldi	r24, 0x40	; 64
     c56:	90 e0       	ldi	r25, 0x00	; 0
     c58:	a0 e0       	ldi	r26, 0x00	; 0
     c5a:	b0 e0       	ldi	r27, 0x00	; 0
     c5c:	04 c0       	rjmp	.+8      	; 0xc66 <__pack_f+0x14c>
     c5e:	8f e3       	ldi	r24, 0x3F	; 63
     c60:	90 e0       	ldi	r25, 0x00	; 0
     c62:	a0 e0       	ldi	r26, 0x00	; 0
     c64:	b0 e0       	ldi	r27, 0x00	; 0
     c66:	e8 0e       	add	r14, r24
     c68:	f9 1e       	adc	r15, r25
     c6a:	0a 1f       	adc	r16, r26
     c6c:	1b 1f       	adc	r17, r27
     c6e:	17 ff       	sbrs	r17, 7
     c70:	05 c0       	rjmp	.+10     	; 0xc7c <__pack_f+0x162>
     c72:	16 95       	lsr	r17
     c74:	07 95       	ror	r16
     c76:	f7 94       	ror	r15
     c78:	e7 94       	ror	r14
     c7a:	31 96       	adiw	r30, 0x01	; 1
     c7c:	87 e0       	ldi	r24, 0x07	; 7
     c7e:	16 95       	lsr	r17
     c80:	07 95       	ror	r16
     c82:	f7 94       	ror	r15
     c84:	e7 94       	ror	r14
     c86:	8a 95       	dec	r24
     c88:	d1 f7       	brne	.-12     	; 0xc7e <__pack_f+0x164>
     c8a:	05 c0       	rjmp	.+10     	; 0xc96 <__pack_f+0x17c>
     c8c:	ee 24       	eor	r14, r14
     c8e:	ff 24       	eor	r15, r15
     c90:	87 01       	movw	r16, r14
     c92:	ef ef       	ldi	r30, 0xFF	; 255
     c94:	f0 e0       	ldi	r31, 0x00	; 0
     c96:	6e 2f       	mov	r22, r30
     c98:	67 95       	ror	r22
     c9a:	66 27       	eor	r22, r22
     c9c:	67 95       	ror	r22
     c9e:	90 2f       	mov	r25, r16
     ca0:	9f 77       	andi	r25, 0x7F	; 127
     ca2:	d7 94       	ror	r13
     ca4:	dd 24       	eor	r13, r13
     ca6:	d7 94       	ror	r13
     ca8:	8e 2f       	mov	r24, r30
     caa:	86 95       	lsr	r24
     cac:	49 2f       	mov	r20, r25
     cae:	46 2b       	or	r20, r22
     cb0:	58 2f       	mov	r21, r24
     cb2:	5d 29       	or	r21, r13
     cb4:	b7 01       	movw	r22, r14
     cb6:	ca 01       	movw	r24, r20
     cb8:	1f 91       	pop	r17
     cba:	0f 91       	pop	r16
     cbc:	ff 90       	pop	r15
     cbe:	ef 90       	pop	r14
     cc0:	df 90       	pop	r13
     cc2:	08 95       	ret

00000cc4 <__unpack_f>:
     cc4:	fc 01       	movw	r30, r24
     cc6:	db 01       	movw	r26, r22
     cc8:	40 81       	ld	r20, Z
     cca:	51 81       	ldd	r21, Z+1	; 0x01
     ccc:	22 81       	ldd	r18, Z+2	; 0x02
     cce:	62 2f       	mov	r22, r18
     cd0:	6f 77       	andi	r22, 0x7F	; 127
     cd2:	70 e0       	ldi	r23, 0x00	; 0
     cd4:	22 1f       	adc	r18, r18
     cd6:	22 27       	eor	r18, r18
     cd8:	22 1f       	adc	r18, r18
     cda:	93 81       	ldd	r25, Z+3	; 0x03
     cdc:	89 2f       	mov	r24, r25
     cde:	88 0f       	add	r24, r24
     ce0:	82 2b       	or	r24, r18
     ce2:	28 2f       	mov	r18, r24
     ce4:	30 e0       	ldi	r19, 0x00	; 0
     ce6:	99 1f       	adc	r25, r25
     ce8:	99 27       	eor	r25, r25
     cea:	99 1f       	adc	r25, r25
     cec:	11 96       	adiw	r26, 0x01	; 1
     cee:	9c 93       	st	X, r25
     cf0:	11 97       	sbiw	r26, 0x01	; 1
     cf2:	21 15       	cp	r18, r1
     cf4:	31 05       	cpc	r19, r1
     cf6:	a9 f5       	brne	.+106    	; 0xd62 <__unpack_f+0x9e>
     cf8:	41 15       	cp	r20, r1
     cfa:	51 05       	cpc	r21, r1
     cfc:	61 05       	cpc	r22, r1
     cfe:	71 05       	cpc	r23, r1
     d00:	11 f4       	brne	.+4      	; 0xd06 <__unpack_f+0x42>
     d02:	82 e0       	ldi	r24, 0x02	; 2
     d04:	37 c0       	rjmp	.+110    	; 0xd74 <__unpack_f+0xb0>
     d06:	82 e8       	ldi	r24, 0x82	; 130
     d08:	9f ef       	ldi	r25, 0xFF	; 255
     d0a:	13 96       	adiw	r26, 0x03	; 3
     d0c:	9c 93       	st	X, r25
     d0e:	8e 93       	st	-X, r24
     d10:	12 97       	sbiw	r26, 0x02	; 2
     d12:	9a 01       	movw	r18, r20
     d14:	ab 01       	movw	r20, r22
     d16:	67 e0       	ldi	r22, 0x07	; 7
     d18:	22 0f       	add	r18, r18
     d1a:	33 1f       	adc	r19, r19
     d1c:	44 1f       	adc	r20, r20
     d1e:	55 1f       	adc	r21, r21
     d20:	6a 95       	dec	r22
     d22:	d1 f7       	brne	.-12     	; 0xd18 <__unpack_f+0x54>
     d24:	83 e0       	ldi	r24, 0x03	; 3
     d26:	8c 93       	st	X, r24
     d28:	0d c0       	rjmp	.+26     	; 0xd44 <__unpack_f+0x80>
     d2a:	22 0f       	add	r18, r18
     d2c:	33 1f       	adc	r19, r19
     d2e:	44 1f       	adc	r20, r20
     d30:	55 1f       	adc	r21, r21
     d32:	12 96       	adiw	r26, 0x02	; 2
     d34:	8d 91       	ld	r24, X+
     d36:	9c 91       	ld	r25, X
     d38:	13 97       	sbiw	r26, 0x03	; 3
     d3a:	01 97       	sbiw	r24, 0x01	; 1
     d3c:	13 96       	adiw	r26, 0x03	; 3
     d3e:	9c 93       	st	X, r25
     d40:	8e 93       	st	-X, r24
     d42:	12 97       	sbiw	r26, 0x02	; 2
     d44:	20 30       	cpi	r18, 0x00	; 0
     d46:	80 e0       	ldi	r24, 0x00	; 0
     d48:	38 07       	cpc	r19, r24
     d4a:	80 e0       	ldi	r24, 0x00	; 0
     d4c:	48 07       	cpc	r20, r24
     d4e:	80 e4       	ldi	r24, 0x40	; 64
     d50:	58 07       	cpc	r21, r24
     d52:	58 f3       	brcs	.-42     	; 0xd2a <__unpack_f+0x66>
     d54:	14 96       	adiw	r26, 0x04	; 4
     d56:	2d 93       	st	X+, r18
     d58:	3d 93       	st	X+, r19
     d5a:	4d 93       	st	X+, r20
     d5c:	5c 93       	st	X, r21
     d5e:	17 97       	sbiw	r26, 0x07	; 7
     d60:	08 95       	ret
     d62:	2f 3f       	cpi	r18, 0xFF	; 255
     d64:	31 05       	cpc	r19, r1
     d66:	79 f4       	brne	.+30     	; 0xd86 <__unpack_f+0xc2>
     d68:	41 15       	cp	r20, r1
     d6a:	51 05       	cpc	r21, r1
     d6c:	61 05       	cpc	r22, r1
     d6e:	71 05       	cpc	r23, r1
     d70:	19 f4       	brne	.+6      	; 0xd78 <__unpack_f+0xb4>
     d72:	84 e0       	ldi	r24, 0x04	; 4
     d74:	8c 93       	st	X, r24
     d76:	08 95       	ret
     d78:	64 ff       	sbrs	r22, 4
     d7a:	03 c0       	rjmp	.+6      	; 0xd82 <__unpack_f+0xbe>
     d7c:	81 e0       	ldi	r24, 0x01	; 1
     d7e:	8c 93       	st	X, r24
     d80:	12 c0       	rjmp	.+36     	; 0xda6 <__unpack_f+0xe2>
     d82:	1c 92       	st	X, r1
     d84:	10 c0       	rjmp	.+32     	; 0xda6 <__unpack_f+0xe2>
     d86:	2f 57       	subi	r18, 0x7F	; 127
     d88:	30 40       	sbci	r19, 0x00	; 0
     d8a:	13 96       	adiw	r26, 0x03	; 3
     d8c:	3c 93       	st	X, r19
     d8e:	2e 93       	st	-X, r18
     d90:	12 97       	sbiw	r26, 0x02	; 2
     d92:	83 e0       	ldi	r24, 0x03	; 3
     d94:	8c 93       	st	X, r24
     d96:	87 e0       	ldi	r24, 0x07	; 7
     d98:	44 0f       	add	r20, r20
     d9a:	55 1f       	adc	r21, r21
     d9c:	66 1f       	adc	r22, r22
     d9e:	77 1f       	adc	r23, r23
     da0:	8a 95       	dec	r24
     da2:	d1 f7       	brne	.-12     	; 0xd98 <__unpack_f+0xd4>
     da4:	70 64       	ori	r23, 0x40	; 64
     da6:	14 96       	adiw	r26, 0x04	; 4
     da8:	4d 93       	st	X+, r20
     daa:	5d 93       	st	X+, r21
     dac:	6d 93       	st	X+, r22
     dae:	7c 93       	st	X, r23
     db0:	17 97       	sbiw	r26, 0x07	; 7
     db2:	08 95       	ret

00000db4 <__fpcmp_parts_f>:
     db4:	1f 93       	push	r17
     db6:	dc 01       	movw	r26, r24
     db8:	fb 01       	movw	r30, r22
     dba:	9c 91       	ld	r25, X
     dbc:	92 30       	cpi	r25, 0x02	; 2
     dbe:	08 f4       	brcc	.+2      	; 0xdc2 <__fpcmp_parts_f+0xe>
     dc0:	47 c0       	rjmp	.+142    	; 0xe50 <__fpcmp_parts_f+0x9c>
     dc2:	80 81       	ld	r24, Z
     dc4:	82 30       	cpi	r24, 0x02	; 2
     dc6:	08 f4       	brcc	.+2      	; 0xdca <__fpcmp_parts_f+0x16>
     dc8:	43 c0       	rjmp	.+134    	; 0xe50 <__fpcmp_parts_f+0x9c>
     dca:	94 30       	cpi	r25, 0x04	; 4
     dcc:	51 f4       	brne	.+20     	; 0xde2 <__fpcmp_parts_f+0x2e>
     dce:	11 96       	adiw	r26, 0x01	; 1
     dd0:	1c 91       	ld	r17, X
     dd2:	84 30       	cpi	r24, 0x04	; 4
     dd4:	99 f5       	brne	.+102    	; 0xe3c <__fpcmp_parts_f+0x88>
     dd6:	81 81       	ldd	r24, Z+1	; 0x01
     dd8:	68 2f       	mov	r22, r24
     dda:	70 e0       	ldi	r23, 0x00	; 0
     ddc:	61 1b       	sub	r22, r17
     dde:	71 09       	sbc	r23, r1
     de0:	3f c0       	rjmp	.+126    	; 0xe60 <__fpcmp_parts_f+0xac>
     de2:	84 30       	cpi	r24, 0x04	; 4
     de4:	21 f0       	breq	.+8      	; 0xdee <__fpcmp_parts_f+0x3a>
     de6:	92 30       	cpi	r25, 0x02	; 2
     de8:	31 f4       	brne	.+12     	; 0xdf6 <__fpcmp_parts_f+0x42>
     dea:	82 30       	cpi	r24, 0x02	; 2
     dec:	b9 f1       	breq	.+110    	; 0xe5c <__fpcmp_parts_f+0xa8>
     dee:	81 81       	ldd	r24, Z+1	; 0x01
     df0:	88 23       	and	r24, r24
     df2:	89 f1       	breq	.+98     	; 0xe56 <__fpcmp_parts_f+0xa2>
     df4:	2d c0       	rjmp	.+90     	; 0xe50 <__fpcmp_parts_f+0x9c>
     df6:	11 96       	adiw	r26, 0x01	; 1
     df8:	1c 91       	ld	r17, X
     dfa:	11 97       	sbiw	r26, 0x01	; 1
     dfc:	82 30       	cpi	r24, 0x02	; 2
     dfe:	f1 f0       	breq	.+60     	; 0xe3c <__fpcmp_parts_f+0x88>
     e00:	81 81       	ldd	r24, Z+1	; 0x01
     e02:	18 17       	cp	r17, r24
     e04:	d9 f4       	brne	.+54     	; 0xe3c <__fpcmp_parts_f+0x88>
     e06:	12 96       	adiw	r26, 0x02	; 2
     e08:	2d 91       	ld	r18, X+
     e0a:	3c 91       	ld	r19, X
     e0c:	13 97       	sbiw	r26, 0x03	; 3
     e0e:	82 81       	ldd	r24, Z+2	; 0x02
     e10:	93 81       	ldd	r25, Z+3	; 0x03
     e12:	82 17       	cp	r24, r18
     e14:	93 07       	cpc	r25, r19
     e16:	94 f0       	brlt	.+36     	; 0xe3c <__fpcmp_parts_f+0x88>
     e18:	28 17       	cp	r18, r24
     e1a:	39 07       	cpc	r19, r25
     e1c:	bc f0       	brlt	.+46     	; 0xe4c <__fpcmp_parts_f+0x98>
     e1e:	14 96       	adiw	r26, 0x04	; 4
     e20:	8d 91       	ld	r24, X+
     e22:	9d 91       	ld	r25, X+
     e24:	0d 90       	ld	r0, X+
     e26:	bc 91       	ld	r27, X
     e28:	a0 2d       	mov	r26, r0
     e2a:	24 81       	ldd	r18, Z+4	; 0x04
     e2c:	35 81       	ldd	r19, Z+5	; 0x05
     e2e:	46 81       	ldd	r20, Z+6	; 0x06
     e30:	57 81       	ldd	r21, Z+7	; 0x07
     e32:	28 17       	cp	r18, r24
     e34:	39 07       	cpc	r19, r25
     e36:	4a 07       	cpc	r20, r26
     e38:	5b 07       	cpc	r21, r27
     e3a:	18 f4       	brcc	.+6      	; 0xe42 <__fpcmp_parts_f+0x8e>
     e3c:	11 23       	and	r17, r17
     e3e:	41 f0       	breq	.+16     	; 0xe50 <__fpcmp_parts_f+0x9c>
     e40:	0a c0       	rjmp	.+20     	; 0xe56 <__fpcmp_parts_f+0xa2>
     e42:	82 17       	cp	r24, r18
     e44:	93 07       	cpc	r25, r19
     e46:	a4 07       	cpc	r26, r20
     e48:	b5 07       	cpc	r27, r21
     e4a:	40 f4       	brcc	.+16     	; 0xe5c <__fpcmp_parts_f+0xa8>
     e4c:	11 23       	and	r17, r17
     e4e:	19 f0       	breq	.+6      	; 0xe56 <__fpcmp_parts_f+0xa2>
     e50:	61 e0       	ldi	r22, 0x01	; 1
     e52:	70 e0       	ldi	r23, 0x00	; 0
     e54:	05 c0       	rjmp	.+10     	; 0xe60 <__fpcmp_parts_f+0xac>
     e56:	6f ef       	ldi	r22, 0xFF	; 255
     e58:	7f ef       	ldi	r23, 0xFF	; 255
     e5a:	02 c0       	rjmp	.+4      	; 0xe60 <__fpcmp_parts_f+0xac>
     e5c:	60 e0       	ldi	r22, 0x00	; 0
     e5e:	70 e0       	ldi	r23, 0x00	; 0
     e60:	cb 01       	movw	r24, r22
     e62:	1f 91       	pop	r17
     e64:	08 95       	ret

00000e66 <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void * pvPortMalloc( size_t xWantedSize )
{
     e66:	df 93       	push	r29
     e68:	cf 93       	push	r28
     e6a:	00 d0       	rcall	.+0      	; 0xe6c <pvPortMalloc+0x6>
     e6c:	00 d0       	rcall	.+0      	; 0xe6e <pvPortMalloc+0x8>
     e6e:	cd b7       	in	r28, 0x3d	; 61
     e70:	de b7       	in	r29, 0x3e	; 62
     e72:	9c 83       	std	Y+4, r25	; 0x04
     e74:	8b 83       	std	Y+3, r24	; 0x03
    void * pvReturn = NULL;
     e76:	1a 82       	std	Y+2, r1	; 0x02
     e78:	19 82       	std	Y+1, r1	; 0x01
                }
            }
        }
    #endif

    vTaskSuspendAll();
     e7a:	0e 94 88 1e 	call	0x3d10	; 0x3d10 <vTaskSuspendAll>
    {
        if( pucAlignedHeap == NULL )
     e7e:	80 91 52 02 	lds	r24, 0x0252
     e82:	90 91 53 02 	lds	r25, 0x0253
     e86:	00 97       	sbiw	r24, 0x00	; 0
     e88:	31 f4       	brne	.+12     	; 0xe96 <pvPortMalloc+0x30>
        {
            /* Ensure the heap starts on a correctly aligned boundary. */
            pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) & ucHeap[ portBYTE_ALIGNMENT - 1 ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
     e8a:	84 e5       	ldi	r24, 0x54	; 84
     e8c:	92 e0       	ldi	r25, 0x02	; 2
     e8e:	90 93 53 02 	sts	0x0253, r25
     e92:	80 93 52 02 	sts	0x0252, r24
        }

        /* Check there is enough room left for the allocation and. */
        if( ( xWantedSize > 0 ) && /* valid size */
     e96:	8b 81       	ldd	r24, Y+3	; 0x03
     e98:	9c 81       	ldd	r25, Y+4	; 0x04
     e9a:	00 97       	sbiw	r24, 0x00	; 0
     e9c:	99 f1       	breq	.+102    	; 0xf04 <pvPortMalloc+0x9e>
     e9e:	80 91 50 02 	lds	r24, 0x0250
     ea2:	90 91 51 02 	lds	r25, 0x0251
     ea6:	2b 81       	ldd	r18, Y+3	; 0x03
     ea8:	3c 81       	ldd	r19, Y+4	; 0x04
     eaa:	82 0f       	add	r24, r18
     eac:	93 1f       	adc	r25, r19
     eae:	25 e0       	ldi	r18, 0x05	; 5
     eb0:	8b 3d       	cpi	r24, 0xDB	; 219
     eb2:	92 07       	cpc	r25, r18
     eb4:	38 f5       	brcc	.+78     	; 0xf04 <pvPortMalloc+0x9e>
     eb6:	20 91 50 02 	lds	r18, 0x0250
     eba:	30 91 51 02 	lds	r19, 0x0251
     ebe:	8b 81       	ldd	r24, Y+3	; 0x03
     ec0:	9c 81       	ldd	r25, Y+4	; 0x04
     ec2:	28 0f       	add	r18, r24
     ec4:	39 1f       	adc	r19, r25
     ec6:	80 91 50 02 	lds	r24, 0x0250
     eca:	90 91 51 02 	lds	r25, 0x0251
     ece:	82 17       	cp	r24, r18
     ed0:	93 07       	cpc	r25, r19
     ed2:	c0 f4       	brcc	.+48     	; 0xf04 <pvPortMalloc+0x9e>
            ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
            ( ( xNextFreeByte + xWantedSize ) > xNextFreeByte ) ) /* Check for overflow. */
        {
            /* Return the next free byte then increment the index past this
             * block. */
            pvReturn = pucAlignedHeap + xNextFreeByte;
     ed4:	20 91 52 02 	lds	r18, 0x0252
     ed8:	30 91 53 02 	lds	r19, 0x0253
     edc:	80 91 50 02 	lds	r24, 0x0250
     ee0:	90 91 51 02 	lds	r25, 0x0251
     ee4:	82 0f       	add	r24, r18
     ee6:	93 1f       	adc	r25, r19
     ee8:	9a 83       	std	Y+2, r25	; 0x02
     eea:	89 83       	std	Y+1, r24	; 0x01
            xNextFreeByte += xWantedSize;
     eec:	20 91 50 02 	lds	r18, 0x0250
     ef0:	30 91 51 02 	lds	r19, 0x0251
     ef4:	8b 81       	ldd	r24, Y+3	; 0x03
     ef6:	9c 81       	ldd	r25, Y+4	; 0x04
     ef8:	82 0f       	add	r24, r18
     efa:	93 1f       	adc	r25, r19
     efc:	90 93 51 02 	sts	0x0251, r25
     f00:	80 93 50 02 	sts	0x0250, r24
        }

        traceMALLOC( pvReturn, xWantedSize );
    }
    ( void ) xTaskResumeAll();
     f04:	0e 94 94 1e 	call	0x3d28	; 0x3d28 <xTaskResumeAll>
                vApplicationMallocFailedHook();
            }
        }
    #endif

    return pvReturn;
     f08:	89 81       	ldd	r24, Y+1	; 0x01
     f0a:	9a 81       	ldd	r25, Y+2	; 0x02
}
     f0c:	0f 90       	pop	r0
     f0e:	0f 90       	pop	r0
     f10:	0f 90       	pop	r0
     f12:	0f 90       	pop	r0
     f14:	cf 91       	pop	r28
     f16:	df 91       	pop	r29
     f18:	08 95       	ret

00000f1a <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void * pv )
{
     f1a:	df 93       	push	r29
     f1c:	cf 93       	push	r28
     f1e:	00 d0       	rcall	.+0      	; 0xf20 <vPortFree+0x6>
     f20:	cd b7       	in	r28, 0x3d	; 61
     f22:	de b7       	in	r29, 0x3e	; 62
     f24:	9a 83       	std	Y+2, r25	; 0x02
     f26:	89 83       	std	Y+1, r24	; 0x01
     * https://www.FreeRTOS.org for more information. */
    ( void ) pv;

    /* Force an assert as it is invalid to call this function. */
    configASSERT( pv == NULL );
}
     f28:	0f 90       	pop	r0
     f2a:	0f 90       	pop	r0
     f2c:	cf 91       	pop	r28
     f2e:	df 91       	pop	r29
     f30:	08 95       	ret

00000f32 <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
     f32:	df 93       	push	r29
     f34:	cf 93       	push	r28
     f36:	cd b7       	in	r28, 0x3d	; 61
     f38:	de b7       	in	r29, 0x3e	; 62
    /* Only required when static memory is not cleared. */
    xNextFreeByte = ( size_t ) 0;
     f3a:	10 92 51 02 	sts	0x0251, r1
     f3e:	10 92 50 02 	sts	0x0250, r1
}
     f42:	cf 91       	pop	r28
     f44:	df 91       	pop	r29
     f46:	08 95       	ret

00000f48 <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
     f48:	df 93       	push	r29
     f4a:	cf 93       	push	r28
     f4c:	cd b7       	in	r28, 0x3d	; 61
     f4e:	de b7       	in	r29, 0x3e	; 62
    return( configADJUSTED_HEAP_SIZE - xNextFreeByte );
     f50:	20 91 50 02 	lds	r18, 0x0250
     f54:	30 91 51 02 	lds	r19, 0x0251
     f58:	8b ed       	ldi	r24, 0xDB	; 219
     f5a:	95 e0       	ldi	r25, 0x05	; 5
     f5c:	82 1b       	sub	r24, r18
     f5e:	93 0b       	sbc	r25, r19
}
     f60:	cf 91       	pop	r28
     f62:	df 91       	pop	r29
     f64:	08 95       	ret

00000f66 <pxPortInitialiseStack>:

/* 
 * See header file for description. 
 */
StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
{
     f66:	df 93       	push	r29
     f68:	cf 93       	push	r28
     f6a:	cd b7       	in	r28, 0x3d	; 61
     f6c:	de b7       	in	r29, 0x3e	; 62
     f6e:	28 97       	sbiw	r28, 0x08	; 8
     f70:	0f b6       	in	r0, 0x3f	; 63
     f72:	f8 94       	cli
     f74:	de bf       	out	0x3e, r29	; 62
     f76:	0f be       	out	0x3f, r0	; 63
     f78:	cd bf       	out	0x3d, r28	; 61
     f7a:	9c 83       	std	Y+4, r25	; 0x04
     f7c:	8b 83       	std	Y+3, r24	; 0x03
     f7e:	7e 83       	std	Y+6, r23	; 0x06
     f80:	6d 83       	std	Y+5, r22	; 0x05
     f82:	58 87       	std	Y+8, r21	; 0x08
     f84:	4f 83       	std	Y+7, r20	; 0x07
uint16_t usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
     f86:	eb 81       	ldd	r30, Y+3	; 0x03
     f88:	fc 81       	ldd	r31, Y+4	; 0x04
     f8a:	81 e1       	ldi	r24, 0x11	; 17
     f8c:	80 83       	st	Z, r24
	pxTopOfStack--;
     f8e:	8b 81       	ldd	r24, Y+3	; 0x03
     f90:	9c 81       	ldd	r25, Y+4	; 0x04
     f92:	01 97       	sbiw	r24, 0x01	; 1
     f94:	9c 83       	std	Y+4, r25	; 0x04
     f96:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x22;
     f98:	eb 81       	ldd	r30, Y+3	; 0x03
     f9a:	fc 81       	ldd	r31, Y+4	; 0x04
     f9c:	82 e2       	ldi	r24, 0x22	; 34
     f9e:	80 83       	st	Z, r24
	pxTopOfStack--;
     fa0:	8b 81       	ldd	r24, Y+3	; 0x03
     fa2:	9c 81       	ldd	r25, Y+4	; 0x04
     fa4:	01 97       	sbiw	r24, 0x01	; 1
     fa6:	9c 83       	std	Y+4, r25	; 0x04
     fa8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x33;
     faa:	eb 81       	ldd	r30, Y+3	; 0x03
     fac:	fc 81       	ldd	r31, Y+4	; 0x04
     fae:	83 e3       	ldi	r24, 0x33	; 51
     fb0:	80 83       	st	Z, r24
	pxTopOfStack--;
     fb2:	8b 81       	ldd	r24, Y+3	; 0x03
     fb4:	9c 81       	ldd	r25, Y+4	; 0x04
     fb6:	01 97       	sbiw	r24, 0x01	; 1
     fb8:	9c 83       	std	Y+4, r25	; 0x04
     fba:	8b 83       	std	Y+3, r24	; 0x03

	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( uint16_t ) pxCode;
     fbc:	8d 81       	ldd	r24, Y+5	; 0x05
     fbe:	9e 81       	ldd	r25, Y+6	; 0x06
     fc0:	9a 83       	std	Y+2, r25	; 0x02
     fc2:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     fc4:	89 81       	ldd	r24, Y+1	; 0x01
     fc6:	eb 81       	ldd	r30, Y+3	; 0x03
     fc8:	fc 81       	ldd	r31, Y+4	; 0x04
     fca:	80 83       	st	Z, r24
	pxTopOfStack--;
     fcc:	8b 81       	ldd	r24, Y+3	; 0x03
     fce:	9c 81       	ldd	r25, Y+4	; 0x04
     fd0:	01 97       	sbiw	r24, 0x01	; 1
     fd2:	9c 83       	std	Y+4, r25	; 0x04
     fd4:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
     fd6:	89 81       	ldd	r24, Y+1	; 0x01
     fd8:	9a 81       	ldd	r25, Y+2	; 0x02
     fda:	89 2f       	mov	r24, r25
     fdc:	99 27       	eor	r25, r25
     fde:	9a 83       	std	Y+2, r25	; 0x02
     fe0:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     fe2:	89 81       	ldd	r24, Y+1	; 0x01
     fe4:	eb 81       	ldd	r30, Y+3	; 0x03
     fe6:	fc 81       	ldd	r31, Y+4	; 0x04
     fe8:	80 83       	st	Z, r24
	pxTopOfStack--;
     fea:	8b 81       	ldd	r24, Y+3	; 0x03
     fec:	9c 81       	ldd	r25, Y+4	; 0x04
     fee:	01 97       	sbiw	r24, 0x01	; 1
     ff0:	9c 83       	std	Y+4, r25	; 0x04
     ff2:	8b 83       	std	Y+3, r24	; 0x03

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R0 */
     ff4:	eb 81       	ldd	r30, Y+3	; 0x03
     ff6:	fc 81       	ldd	r31, Y+4	; 0x04
     ff8:	10 82       	st	Z, r1
	pxTopOfStack--;
     ffa:	8b 81       	ldd	r24, Y+3	; 0x03
     ffc:	9c 81       	ldd	r25, Y+4	; 0x04
     ffe:	01 97       	sbiw	r24, 0x01	; 1
    1000:	9c 83       	std	Y+4, r25	; 0x04
    1002:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = portFLAGS_INT_ENABLED;
    1004:	eb 81       	ldd	r30, Y+3	; 0x03
    1006:	fc 81       	ldd	r31, Y+4	; 0x04
    1008:	80 e8       	ldi	r24, 0x80	; 128
    100a:	80 83       	st	Z, r24
	pxTopOfStack--;
    100c:	8b 81       	ldd	r24, Y+3	; 0x03
    100e:	9c 81       	ldd	r25, Y+4	; 0x04
    1010:	01 97       	sbiw	r24, 0x01	; 1
    1012:	9c 83       	std	Y+4, r25	; 0x04
    1014:	8b 83       	std	Y+3, r24	; 0x03


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R1 */
    1016:	eb 81       	ldd	r30, Y+3	; 0x03
    1018:	fc 81       	ldd	r31, Y+4	; 0x04
    101a:	10 82       	st	Z, r1
	pxTopOfStack--;
    101c:	8b 81       	ldd	r24, Y+3	; 0x03
    101e:	9c 81       	ldd	r25, Y+4	; 0x04
    1020:	01 97       	sbiw	r24, 0x01	; 1
    1022:	9c 83       	std	Y+4, r25	; 0x04
    1024:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x02;	/* R2 */
    1026:	eb 81       	ldd	r30, Y+3	; 0x03
    1028:	fc 81       	ldd	r31, Y+4	; 0x04
    102a:	82 e0       	ldi	r24, 0x02	; 2
    102c:	80 83       	st	Z, r24
	pxTopOfStack--;
    102e:	8b 81       	ldd	r24, Y+3	; 0x03
    1030:	9c 81       	ldd	r25, Y+4	; 0x04
    1032:	01 97       	sbiw	r24, 0x01	; 1
    1034:	9c 83       	std	Y+4, r25	; 0x04
    1036:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x03;	/* R3 */
    1038:	eb 81       	ldd	r30, Y+3	; 0x03
    103a:	fc 81       	ldd	r31, Y+4	; 0x04
    103c:	83 e0       	ldi	r24, 0x03	; 3
    103e:	80 83       	st	Z, r24
	pxTopOfStack--;
    1040:	8b 81       	ldd	r24, Y+3	; 0x03
    1042:	9c 81       	ldd	r25, Y+4	; 0x04
    1044:	01 97       	sbiw	r24, 0x01	; 1
    1046:	9c 83       	std	Y+4, r25	; 0x04
    1048:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x04;	/* R4 */
    104a:	eb 81       	ldd	r30, Y+3	; 0x03
    104c:	fc 81       	ldd	r31, Y+4	; 0x04
    104e:	84 e0       	ldi	r24, 0x04	; 4
    1050:	80 83       	st	Z, r24
	pxTopOfStack--;
    1052:	8b 81       	ldd	r24, Y+3	; 0x03
    1054:	9c 81       	ldd	r25, Y+4	; 0x04
    1056:	01 97       	sbiw	r24, 0x01	; 1
    1058:	9c 83       	std	Y+4, r25	; 0x04
    105a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x05;	/* R5 */
    105c:	eb 81       	ldd	r30, Y+3	; 0x03
    105e:	fc 81       	ldd	r31, Y+4	; 0x04
    1060:	85 e0       	ldi	r24, 0x05	; 5
    1062:	80 83       	st	Z, r24
	pxTopOfStack--;
    1064:	8b 81       	ldd	r24, Y+3	; 0x03
    1066:	9c 81       	ldd	r25, Y+4	; 0x04
    1068:	01 97       	sbiw	r24, 0x01	; 1
    106a:	9c 83       	std	Y+4, r25	; 0x04
    106c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x06;	/* R6 */
    106e:	eb 81       	ldd	r30, Y+3	; 0x03
    1070:	fc 81       	ldd	r31, Y+4	; 0x04
    1072:	86 e0       	ldi	r24, 0x06	; 6
    1074:	80 83       	st	Z, r24
	pxTopOfStack--;
    1076:	8b 81       	ldd	r24, Y+3	; 0x03
    1078:	9c 81       	ldd	r25, Y+4	; 0x04
    107a:	01 97       	sbiw	r24, 0x01	; 1
    107c:	9c 83       	std	Y+4, r25	; 0x04
    107e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x07;	/* R7 */
    1080:	eb 81       	ldd	r30, Y+3	; 0x03
    1082:	fc 81       	ldd	r31, Y+4	; 0x04
    1084:	87 e0       	ldi	r24, 0x07	; 7
    1086:	80 83       	st	Z, r24
	pxTopOfStack--;
    1088:	8b 81       	ldd	r24, Y+3	; 0x03
    108a:	9c 81       	ldd	r25, Y+4	; 0x04
    108c:	01 97       	sbiw	r24, 0x01	; 1
    108e:	9c 83       	std	Y+4, r25	; 0x04
    1090:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x08;	/* R8 */
    1092:	eb 81       	ldd	r30, Y+3	; 0x03
    1094:	fc 81       	ldd	r31, Y+4	; 0x04
    1096:	88 e0       	ldi	r24, 0x08	; 8
    1098:	80 83       	st	Z, r24
	pxTopOfStack--;
    109a:	8b 81       	ldd	r24, Y+3	; 0x03
    109c:	9c 81       	ldd	r25, Y+4	; 0x04
    109e:	01 97       	sbiw	r24, 0x01	; 1
    10a0:	9c 83       	std	Y+4, r25	; 0x04
    10a2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x09;	/* R9 */
    10a4:	eb 81       	ldd	r30, Y+3	; 0x03
    10a6:	fc 81       	ldd	r31, Y+4	; 0x04
    10a8:	89 e0       	ldi	r24, 0x09	; 9
    10aa:	80 83       	st	Z, r24
	pxTopOfStack--;
    10ac:	8b 81       	ldd	r24, Y+3	; 0x03
    10ae:	9c 81       	ldd	r25, Y+4	; 0x04
    10b0:	01 97       	sbiw	r24, 0x01	; 1
    10b2:	9c 83       	std	Y+4, r25	; 0x04
    10b4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x10;	/* R10 */
    10b6:	eb 81       	ldd	r30, Y+3	; 0x03
    10b8:	fc 81       	ldd	r31, Y+4	; 0x04
    10ba:	80 e1       	ldi	r24, 0x10	; 16
    10bc:	80 83       	st	Z, r24
	pxTopOfStack--;
    10be:	8b 81       	ldd	r24, Y+3	; 0x03
    10c0:	9c 81       	ldd	r25, Y+4	; 0x04
    10c2:	01 97       	sbiw	r24, 0x01	; 1
    10c4:	9c 83       	std	Y+4, r25	; 0x04
    10c6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x11;	/* R11 */
    10c8:	eb 81       	ldd	r30, Y+3	; 0x03
    10ca:	fc 81       	ldd	r31, Y+4	; 0x04
    10cc:	81 e1       	ldi	r24, 0x11	; 17
    10ce:	80 83       	st	Z, r24
	pxTopOfStack--;
    10d0:	8b 81       	ldd	r24, Y+3	; 0x03
    10d2:	9c 81       	ldd	r25, Y+4	; 0x04
    10d4:	01 97       	sbiw	r24, 0x01	; 1
    10d6:	9c 83       	std	Y+4, r25	; 0x04
    10d8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x12;	/* R12 */
    10da:	eb 81       	ldd	r30, Y+3	; 0x03
    10dc:	fc 81       	ldd	r31, Y+4	; 0x04
    10de:	82 e1       	ldi	r24, 0x12	; 18
    10e0:	80 83       	st	Z, r24
	pxTopOfStack--;
    10e2:	8b 81       	ldd	r24, Y+3	; 0x03
    10e4:	9c 81       	ldd	r25, Y+4	; 0x04
    10e6:	01 97       	sbiw	r24, 0x01	; 1
    10e8:	9c 83       	std	Y+4, r25	; 0x04
    10ea:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x13;	/* R13 */
    10ec:	eb 81       	ldd	r30, Y+3	; 0x03
    10ee:	fc 81       	ldd	r31, Y+4	; 0x04
    10f0:	83 e1       	ldi	r24, 0x13	; 19
    10f2:	80 83       	st	Z, r24
	pxTopOfStack--;
    10f4:	8b 81       	ldd	r24, Y+3	; 0x03
    10f6:	9c 81       	ldd	r25, Y+4	; 0x04
    10f8:	01 97       	sbiw	r24, 0x01	; 1
    10fa:	9c 83       	std	Y+4, r25	; 0x04
    10fc:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x14;	/* R14 */
    10fe:	eb 81       	ldd	r30, Y+3	; 0x03
    1100:	fc 81       	ldd	r31, Y+4	; 0x04
    1102:	84 e1       	ldi	r24, 0x14	; 20
    1104:	80 83       	st	Z, r24
	pxTopOfStack--;
    1106:	8b 81       	ldd	r24, Y+3	; 0x03
    1108:	9c 81       	ldd	r25, Y+4	; 0x04
    110a:	01 97       	sbiw	r24, 0x01	; 1
    110c:	9c 83       	std	Y+4, r25	; 0x04
    110e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x15;	/* R15 */
    1110:	eb 81       	ldd	r30, Y+3	; 0x03
    1112:	fc 81       	ldd	r31, Y+4	; 0x04
    1114:	85 e1       	ldi	r24, 0x15	; 21
    1116:	80 83       	st	Z, r24
	pxTopOfStack--;
    1118:	8b 81       	ldd	r24, Y+3	; 0x03
    111a:	9c 81       	ldd	r25, Y+4	; 0x04
    111c:	01 97       	sbiw	r24, 0x01	; 1
    111e:	9c 83       	std	Y+4, r25	; 0x04
    1120:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x16;	/* R16 */
    1122:	eb 81       	ldd	r30, Y+3	; 0x03
    1124:	fc 81       	ldd	r31, Y+4	; 0x04
    1126:	86 e1       	ldi	r24, 0x16	; 22
    1128:	80 83       	st	Z, r24
	pxTopOfStack--;
    112a:	8b 81       	ldd	r24, Y+3	; 0x03
    112c:	9c 81       	ldd	r25, Y+4	; 0x04
    112e:	01 97       	sbiw	r24, 0x01	; 1
    1130:	9c 83       	std	Y+4, r25	; 0x04
    1132:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x17;	/* R17 */
    1134:	eb 81       	ldd	r30, Y+3	; 0x03
    1136:	fc 81       	ldd	r31, Y+4	; 0x04
    1138:	87 e1       	ldi	r24, 0x17	; 23
    113a:	80 83       	st	Z, r24
	pxTopOfStack--;
    113c:	8b 81       	ldd	r24, Y+3	; 0x03
    113e:	9c 81       	ldd	r25, Y+4	; 0x04
    1140:	01 97       	sbiw	r24, 0x01	; 1
    1142:	9c 83       	std	Y+4, r25	; 0x04
    1144:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x18;	/* R18 */
    1146:	eb 81       	ldd	r30, Y+3	; 0x03
    1148:	fc 81       	ldd	r31, Y+4	; 0x04
    114a:	88 e1       	ldi	r24, 0x18	; 24
    114c:	80 83       	st	Z, r24
	pxTopOfStack--;
    114e:	8b 81       	ldd	r24, Y+3	; 0x03
    1150:	9c 81       	ldd	r25, Y+4	; 0x04
    1152:	01 97       	sbiw	r24, 0x01	; 1
    1154:	9c 83       	std	Y+4, r25	; 0x04
    1156:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x19;	/* R19 */
    1158:	eb 81       	ldd	r30, Y+3	; 0x03
    115a:	fc 81       	ldd	r31, Y+4	; 0x04
    115c:	89 e1       	ldi	r24, 0x19	; 25
    115e:	80 83       	st	Z, r24
	pxTopOfStack--;
    1160:	8b 81       	ldd	r24, Y+3	; 0x03
    1162:	9c 81       	ldd	r25, Y+4	; 0x04
    1164:	01 97       	sbiw	r24, 0x01	; 1
    1166:	9c 83       	std	Y+4, r25	; 0x04
    1168:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x20;	/* R20 */
    116a:	eb 81       	ldd	r30, Y+3	; 0x03
    116c:	fc 81       	ldd	r31, Y+4	; 0x04
    116e:	80 e2       	ldi	r24, 0x20	; 32
    1170:	80 83       	st	Z, r24
	pxTopOfStack--;
    1172:	8b 81       	ldd	r24, Y+3	; 0x03
    1174:	9c 81       	ldd	r25, Y+4	; 0x04
    1176:	01 97       	sbiw	r24, 0x01	; 1
    1178:	9c 83       	std	Y+4, r25	; 0x04
    117a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x21;	/* R21 */
    117c:	eb 81       	ldd	r30, Y+3	; 0x03
    117e:	fc 81       	ldd	r31, Y+4	; 0x04
    1180:	81 e2       	ldi	r24, 0x21	; 33
    1182:	80 83       	st	Z, r24
	pxTopOfStack--;
    1184:	8b 81       	ldd	r24, Y+3	; 0x03
    1186:	9c 81       	ldd	r25, Y+4	; 0x04
    1188:	01 97       	sbiw	r24, 0x01	; 1
    118a:	9c 83       	std	Y+4, r25	; 0x04
    118c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x22;	/* R22 */
    118e:	eb 81       	ldd	r30, Y+3	; 0x03
    1190:	fc 81       	ldd	r31, Y+4	; 0x04
    1192:	82 e2       	ldi	r24, 0x22	; 34
    1194:	80 83       	st	Z, r24
	pxTopOfStack--;
    1196:	8b 81       	ldd	r24, Y+3	; 0x03
    1198:	9c 81       	ldd	r25, Y+4	; 0x04
    119a:	01 97       	sbiw	r24, 0x01	; 1
    119c:	9c 83       	std	Y+4, r25	; 0x04
    119e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x23;	/* R23 */
    11a0:	eb 81       	ldd	r30, Y+3	; 0x03
    11a2:	fc 81       	ldd	r31, Y+4	; 0x04
    11a4:	83 e2       	ldi	r24, 0x23	; 35
    11a6:	80 83       	st	Z, r24
	pxTopOfStack--;
    11a8:	8b 81       	ldd	r24, Y+3	; 0x03
    11aa:	9c 81       	ldd	r25, Y+4	; 0x04
    11ac:	01 97       	sbiw	r24, 0x01	; 1
    11ae:	9c 83       	std	Y+4, r25	; 0x04
    11b0:	8b 83       	std	Y+3, r24	; 0x03

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( uint16_t ) pvParameters;
    11b2:	8f 81       	ldd	r24, Y+7	; 0x07
    11b4:	98 85       	ldd	r25, Y+8	; 0x08
    11b6:	9a 83       	std	Y+2, r25	; 0x02
    11b8:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    11ba:	89 81       	ldd	r24, Y+1	; 0x01
    11bc:	eb 81       	ldd	r30, Y+3	; 0x03
    11be:	fc 81       	ldd	r31, Y+4	; 0x04
    11c0:	80 83       	st	Z, r24
	pxTopOfStack--;
    11c2:	8b 81       	ldd	r24, Y+3	; 0x03
    11c4:	9c 81       	ldd	r25, Y+4	; 0x04
    11c6:	01 97       	sbiw	r24, 0x01	; 1
    11c8:	9c 83       	std	Y+4, r25	; 0x04
    11ca:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    11cc:	89 81       	ldd	r24, Y+1	; 0x01
    11ce:	9a 81       	ldd	r25, Y+2	; 0x02
    11d0:	89 2f       	mov	r24, r25
    11d2:	99 27       	eor	r25, r25
    11d4:	9a 83       	std	Y+2, r25	; 0x02
    11d6:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    11d8:	89 81       	ldd	r24, Y+1	; 0x01
    11da:	eb 81       	ldd	r30, Y+3	; 0x03
    11dc:	fc 81       	ldd	r31, Y+4	; 0x04
    11de:	80 83       	st	Z, r24
	pxTopOfStack--;
    11e0:	8b 81       	ldd	r24, Y+3	; 0x03
    11e2:	9c 81       	ldd	r25, Y+4	; 0x04
    11e4:	01 97       	sbiw	r24, 0x01	; 1
    11e6:	9c 83       	std	Y+4, r25	; 0x04
    11e8:	8b 83       	std	Y+3, r24	; 0x03

	*pxTopOfStack = ( StackType_t ) 0x26;	/* R26 X */
    11ea:	eb 81       	ldd	r30, Y+3	; 0x03
    11ec:	fc 81       	ldd	r31, Y+4	; 0x04
    11ee:	86 e2       	ldi	r24, 0x26	; 38
    11f0:	80 83       	st	Z, r24
	pxTopOfStack--;
    11f2:	8b 81       	ldd	r24, Y+3	; 0x03
    11f4:	9c 81       	ldd	r25, Y+4	; 0x04
    11f6:	01 97       	sbiw	r24, 0x01	; 1
    11f8:	9c 83       	std	Y+4, r25	; 0x04
    11fa:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x27;	/* R27 */
    11fc:	eb 81       	ldd	r30, Y+3	; 0x03
    11fe:	fc 81       	ldd	r31, Y+4	; 0x04
    1200:	87 e2       	ldi	r24, 0x27	; 39
    1202:	80 83       	st	Z, r24
	pxTopOfStack--;
    1204:	8b 81       	ldd	r24, Y+3	; 0x03
    1206:	9c 81       	ldd	r25, Y+4	; 0x04
    1208:	01 97       	sbiw	r24, 0x01	; 1
    120a:	9c 83       	std	Y+4, r25	; 0x04
    120c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x28;	/* R28 Y */
    120e:	eb 81       	ldd	r30, Y+3	; 0x03
    1210:	fc 81       	ldd	r31, Y+4	; 0x04
    1212:	88 e2       	ldi	r24, 0x28	; 40
    1214:	80 83       	st	Z, r24
	pxTopOfStack--;
    1216:	8b 81       	ldd	r24, Y+3	; 0x03
    1218:	9c 81       	ldd	r25, Y+4	; 0x04
    121a:	01 97       	sbiw	r24, 0x01	; 1
    121c:	9c 83       	std	Y+4, r25	; 0x04
    121e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x29;	/* R29 */
    1220:	eb 81       	ldd	r30, Y+3	; 0x03
    1222:	fc 81       	ldd	r31, Y+4	; 0x04
    1224:	89 e2       	ldi	r24, 0x29	; 41
    1226:	80 83       	st	Z, r24
	pxTopOfStack--;
    1228:	8b 81       	ldd	r24, Y+3	; 0x03
    122a:	9c 81       	ldd	r25, Y+4	; 0x04
    122c:	01 97       	sbiw	r24, 0x01	; 1
    122e:	9c 83       	std	Y+4, r25	; 0x04
    1230:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x30;	/* R30 Z */
    1232:	eb 81       	ldd	r30, Y+3	; 0x03
    1234:	fc 81       	ldd	r31, Y+4	; 0x04
    1236:	80 e3       	ldi	r24, 0x30	; 48
    1238:	80 83       	st	Z, r24
	pxTopOfStack--;
    123a:	8b 81       	ldd	r24, Y+3	; 0x03
    123c:	9c 81       	ldd	r25, Y+4	; 0x04
    123e:	01 97       	sbiw	r24, 0x01	; 1
    1240:	9c 83       	std	Y+4, r25	; 0x04
    1242:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x031;	/* R31 */
    1244:	eb 81       	ldd	r30, Y+3	; 0x03
    1246:	fc 81       	ldd	r31, Y+4	; 0x04
    1248:	81 e3       	ldi	r24, 0x31	; 49
    124a:	80 83       	st	Z, r24
	pxTopOfStack--;
    124c:	8b 81       	ldd	r24, Y+3	; 0x03
    124e:	9c 81       	ldd	r25, Y+4	; 0x04
    1250:	01 97       	sbiw	r24, 0x01	; 1
    1252:	9c 83       	std	Y+4, r25	; 0x04
    1254:	8b 83       	std	Y+3, r24	; 0x03

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
    1256:	8b 81       	ldd	r24, Y+3	; 0x03
    1258:	9c 81       	ldd	r25, Y+4	; 0x04
}
    125a:	28 96       	adiw	r28, 0x08	; 8
    125c:	0f b6       	in	r0, 0x3f	; 63
    125e:	f8 94       	cli
    1260:	de bf       	out	0x3e, r29	; 62
    1262:	0f be       	out	0x3f, r0	; 63
    1264:	cd bf       	out	0x3d, r28	; 61
    1266:	cf 91       	pop	r28
    1268:	df 91       	pop	r29
    126a:	08 95       	ret

0000126c <xPortStartScheduler>:
/*-----------------------------------------------------------*/

BaseType_t xPortStartScheduler( void )
{
    126c:	df 93       	push	r29
    126e:	cf 93       	push	r28
    1270:	cd b7       	in	r28, 0x3d	; 61
    1272:	de b7       	in	r29, 0x3e	; 62
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();
    1274:	0e 94 28 0a 	call	0x1450	; 0x1450 <prvSetupTimerInterrupt>

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    1278:	a0 91 6a 08 	lds	r26, 0x086A
    127c:	b0 91 6b 08 	lds	r27, 0x086B
    1280:	cd 91       	ld	r28, X+
    1282:	cd bf       	out	0x3d, r28	; 61
    1284:	dd 91       	ld	r29, X+
    1286:	de bf       	out	0x3e, r29	; 62
    1288:	ff 91       	pop	r31
    128a:	ef 91       	pop	r30
    128c:	df 91       	pop	r29
    128e:	cf 91       	pop	r28
    1290:	bf 91       	pop	r27
    1292:	af 91       	pop	r26
    1294:	9f 91       	pop	r25
    1296:	8f 91       	pop	r24
    1298:	7f 91       	pop	r23
    129a:	6f 91       	pop	r22
    129c:	5f 91       	pop	r21
    129e:	4f 91       	pop	r20
    12a0:	3f 91       	pop	r19
    12a2:	2f 91       	pop	r18
    12a4:	1f 91       	pop	r17
    12a6:	0f 91       	pop	r16
    12a8:	ff 90       	pop	r15
    12aa:	ef 90       	pop	r14
    12ac:	df 90       	pop	r13
    12ae:	cf 90       	pop	r12
    12b0:	bf 90       	pop	r11
    12b2:	af 90       	pop	r10
    12b4:	9f 90       	pop	r9
    12b6:	8f 90       	pop	r8
    12b8:	7f 90       	pop	r7
    12ba:	6f 90       	pop	r6
    12bc:	5f 90       	pop	r5
    12be:	4f 90       	pop	r4
    12c0:	3f 90       	pop	r3
    12c2:	2f 90       	pop	r2
    12c4:	1f 90       	pop	r1
    12c6:	0f 90       	pop	r0
    12c8:	0f be       	out	0x3f, r0	; 63
    12ca:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
    12cc:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
    12ce:	81 e0       	ldi	r24, 0x01	; 1
}
    12d0:	cf 91       	pop	r28
    12d2:	df 91       	pop	r29
    12d4:	08 95       	ret

000012d6 <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    12d6:	df 93       	push	r29
    12d8:	cf 93       	push	r28
    12da:	cd b7       	in	r28, 0x3d	; 61
    12dc:	de b7       	in	r29, 0x3e	; 62
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
    12de:	cf 91       	pop	r28
    12e0:	df 91       	pop	r29
    12e2:	08 95       	ret

000012e4 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    12e4:	0f 92       	push	r0
    12e6:	0f b6       	in	r0, 0x3f	; 63
    12e8:	f8 94       	cli
    12ea:	0f 92       	push	r0
    12ec:	1f 92       	push	r1
    12ee:	11 24       	eor	r1, r1
    12f0:	2f 92       	push	r2
    12f2:	3f 92       	push	r3
    12f4:	4f 92       	push	r4
    12f6:	5f 92       	push	r5
    12f8:	6f 92       	push	r6
    12fa:	7f 92       	push	r7
    12fc:	8f 92       	push	r8
    12fe:	9f 92       	push	r9
    1300:	af 92       	push	r10
    1302:	bf 92       	push	r11
    1304:	cf 92       	push	r12
    1306:	df 92       	push	r13
    1308:	ef 92       	push	r14
    130a:	ff 92       	push	r15
    130c:	0f 93       	push	r16
    130e:	1f 93       	push	r17
    1310:	2f 93       	push	r18
    1312:	3f 93       	push	r19
    1314:	4f 93       	push	r20
    1316:	5f 93       	push	r21
    1318:	6f 93       	push	r22
    131a:	7f 93       	push	r23
    131c:	8f 93       	push	r24
    131e:	9f 93       	push	r25
    1320:	af 93       	push	r26
    1322:	bf 93       	push	r27
    1324:	cf 93       	push	r28
    1326:	df 93       	push	r29
    1328:	ef 93       	push	r30
    132a:	ff 93       	push	r31
    132c:	a0 91 6a 08 	lds	r26, 0x086A
    1330:	b0 91 6b 08 	lds	r27, 0x086B
    1334:	0d b6       	in	r0, 0x3d	; 61
    1336:	0d 92       	st	X+, r0
    1338:	0e b6       	in	r0, 0x3e	; 62
    133a:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    133c:	0e 94 f8 21 	call	0x43f0	; 0x43f0 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    1340:	a0 91 6a 08 	lds	r26, 0x086A
    1344:	b0 91 6b 08 	lds	r27, 0x086B
    1348:	cd 91       	ld	r28, X+
    134a:	cd bf       	out	0x3d, r28	; 61
    134c:	dd 91       	ld	r29, X+
    134e:	de bf       	out	0x3e, r29	; 62
    1350:	ff 91       	pop	r31
    1352:	ef 91       	pop	r30
    1354:	df 91       	pop	r29
    1356:	cf 91       	pop	r28
    1358:	bf 91       	pop	r27
    135a:	af 91       	pop	r26
    135c:	9f 91       	pop	r25
    135e:	8f 91       	pop	r24
    1360:	7f 91       	pop	r23
    1362:	6f 91       	pop	r22
    1364:	5f 91       	pop	r21
    1366:	4f 91       	pop	r20
    1368:	3f 91       	pop	r19
    136a:	2f 91       	pop	r18
    136c:	1f 91       	pop	r17
    136e:	0f 91       	pop	r16
    1370:	ff 90       	pop	r15
    1372:	ef 90       	pop	r14
    1374:	df 90       	pop	r13
    1376:	cf 90       	pop	r12
    1378:	bf 90       	pop	r11
    137a:	af 90       	pop	r10
    137c:	9f 90       	pop	r9
    137e:	8f 90       	pop	r8
    1380:	7f 90       	pop	r7
    1382:	6f 90       	pop	r6
    1384:	5f 90       	pop	r5
    1386:	4f 90       	pop	r4
    1388:	3f 90       	pop	r3
    138a:	2f 90       	pop	r2
    138c:	1f 90       	pop	r1
    138e:	0f 90       	pop	r0
    1390:	0f be       	out	0x3f, r0	; 63
    1392:	0f 90       	pop	r0

	asm volatile ( "ret" );
    1394:	08 95       	ret

00001396 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    1396:	0f 92       	push	r0
    1398:	0f b6       	in	r0, 0x3f	; 63
    139a:	f8 94       	cli
    139c:	0f 92       	push	r0
    139e:	1f 92       	push	r1
    13a0:	11 24       	eor	r1, r1
    13a2:	2f 92       	push	r2
    13a4:	3f 92       	push	r3
    13a6:	4f 92       	push	r4
    13a8:	5f 92       	push	r5
    13aa:	6f 92       	push	r6
    13ac:	7f 92       	push	r7
    13ae:	8f 92       	push	r8
    13b0:	9f 92       	push	r9
    13b2:	af 92       	push	r10
    13b4:	bf 92       	push	r11
    13b6:	cf 92       	push	r12
    13b8:	df 92       	push	r13
    13ba:	ef 92       	push	r14
    13bc:	ff 92       	push	r15
    13be:	0f 93       	push	r16
    13c0:	1f 93       	push	r17
    13c2:	2f 93       	push	r18
    13c4:	3f 93       	push	r19
    13c6:	4f 93       	push	r20
    13c8:	5f 93       	push	r21
    13ca:	6f 93       	push	r22
    13cc:	7f 93       	push	r23
    13ce:	8f 93       	push	r24
    13d0:	9f 93       	push	r25
    13d2:	af 93       	push	r26
    13d4:	bf 93       	push	r27
    13d6:	cf 93       	push	r28
    13d8:	df 93       	push	r29
    13da:	ef 93       	push	r30
    13dc:	ff 93       	push	r31
    13de:	a0 91 6a 08 	lds	r26, 0x086A
    13e2:	b0 91 6b 08 	lds	r27, 0x086B
    13e6:	0d b6       	in	r0, 0x3d	; 61
    13e8:	0d 92       	st	X+, r0
    13ea:	0e b6       	in	r0, 0x3e	; 62
    13ec:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
    13ee:	0e 94 61 20 	call	0x40c2	; 0x40c2 <xTaskIncrementTick>
    13f2:	88 23       	and	r24, r24
    13f4:	11 f0       	breq	.+4      	; 0x13fa <vPortYieldFromTick+0x64>
	{
		vTaskSwitchContext();
    13f6:	0e 94 f8 21 	call	0x43f0	; 0x43f0 <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
    13fa:	a0 91 6a 08 	lds	r26, 0x086A
    13fe:	b0 91 6b 08 	lds	r27, 0x086B
    1402:	cd 91       	ld	r28, X+
    1404:	cd bf       	out	0x3d, r28	; 61
    1406:	dd 91       	ld	r29, X+
    1408:	de bf       	out	0x3e, r29	; 62
    140a:	ff 91       	pop	r31
    140c:	ef 91       	pop	r30
    140e:	df 91       	pop	r29
    1410:	cf 91       	pop	r28
    1412:	bf 91       	pop	r27
    1414:	af 91       	pop	r26
    1416:	9f 91       	pop	r25
    1418:	8f 91       	pop	r24
    141a:	7f 91       	pop	r23
    141c:	6f 91       	pop	r22
    141e:	5f 91       	pop	r21
    1420:	4f 91       	pop	r20
    1422:	3f 91       	pop	r19
    1424:	2f 91       	pop	r18
    1426:	1f 91       	pop	r17
    1428:	0f 91       	pop	r16
    142a:	ff 90       	pop	r15
    142c:	ef 90       	pop	r14
    142e:	df 90       	pop	r13
    1430:	cf 90       	pop	r12
    1432:	bf 90       	pop	r11
    1434:	af 90       	pop	r10
    1436:	9f 90       	pop	r9
    1438:	8f 90       	pop	r8
    143a:	7f 90       	pop	r7
    143c:	6f 90       	pop	r6
    143e:	5f 90       	pop	r5
    1440:	4f 90       	pop	r4
    1442:	3f 90       	pop	r3
    1444:	2f 90       	pop	r2
    1446:	1f 90       	pop	r1
    1448:	0f 90       	pop	r0
    144a:	0f be       	out	0x3f, r0	; 63
    144c:	0f 90       	pop	r0

	asm volatile ( "ret" );
    144e:	08 95       	ret

00001450 <prvSetupTimerInterrupt>:

/*
 * Setup timer 1 compare match A to generate a tick interrupt.
 */
static void prvSetupTimerInterrupt( void )
{
    1450:	df 93       	push	r29
    1452:	cf 93       	push	r28
    1454:	00 d0       	rcall	.+0      	; 0x1456 <prvSetupTimerInterrupt+0x6>
    1456:	00 d0       	rcall	.+0      	; 0x1458 <prvSetupTimerInterrupt+0x8>
    1458:	00 d0       	rcall	.+0      	; 0x145a <prvSetupTimerInterrupt+0xa>
    145a:	cd b7       	in	r28, 0x3d	; 61
    145c:	de b7       	in	r29, 0x3e	; 62
uint8_t ucHighByte, ucLowByte;

	/* Using 16bit timer 1 to generate the tick.  Correct fuses must be
	selected for the configCPU_CLOCK_HZ clock. */

	ulCompareMatch = configCPU_CLOCK_HZ / configTICK_RATE_HZ;
    145e:	80 e8       	ldi	r24, 0x80	; 128
    1460:	9e e3       	ldi	r25, 0x3E	; 62
    1462:	a0 e0       	ldi	r26, 0x00	; 0
    1464:	b0 e0       	ldi	r27, 0x00	; 0
    1466:	8b 83       	std	Y+3, r24	; 0x03
    1468:	9c 83       	std	Y+4, r25	; 0x04
    146a:	ad 83       	std	Y+5, r26	; 0x05
    146c:	be 83       	std	Y+6, r27	; 0x06

	/* We only have 16 bits so have to scale to get our required tick rate. */
	ulCompareMatch /= portCLOCK_PRESCALER;
    146e:	8b 81       	ldd	r24, Y+3	; 0x03
    1470:	9c 81       	ldd	r25, Y+4	; 0x04
    1472:	ad 81       	ldd	r26, Y+5	; 0x05
    1474:	be 81       	ldd	r27, Y+6	; 0x06
    1476:	68 94       	set
    1478:	15 f8       	bld	r1, 5
    147a:	b6 95       	lsr	r27
    147c:	a7 95       	ror	r26
    147e:	97 95       	ror	r25
    1480:	87 95       	ror	r24
    1482:	16 94       	lsr	r1
    1484:	d1 f7       	brne	.-12     	; 0x147a <prvSetupTimerInterrupt+0x2a>
    1486:	8b 83       	std	Y+3, r24	; 0x03
    1488:	9c 83       	std	Y+4, r25	; 0x04
    148a:	ad 83       	std	Y+5, r26	; 0x05
    148c:	be 83       	std	Y+6, r27	; 0x06

	/* Adjust for correct value. */
	ulCompareMatch -= ( uint32_t ) 1;
    148e:	8b 81       	ldd	r24, Y+3	; 0x03
    1490:	9c 81       	ldd	r25, Y+4	; 0x04
    1492:	ad 81       	ldd	r26, Y+5	; 0x05
    1494:	be 81       	ldd	r27, Y+6	; 0x06
    1496:	01 97       	sbiw	r24, 0x01	; 1
    1498:	a1 09       	sbc	r26, r1
    149a:	b1 09       	sbc	r27, r1
    149c:	8b 83       	std	Y+3, r24	; 0x03
    149e:	9c 83       	std	Y+4, r25	; 0x04
    14a0:	ad 83       	std	Y+5, r26	; 0x05
    14a2:	be 83       	std	Y+6, r27	; 0x06

	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
    14a4:	8b 81       	ldd	r24, Y+3	; 0x03
    14a6:	89 83       	std	Y+1, r24	; 0x01
	ulCompareMatch >>= 8;
    14a8:	8b 81       	ldd	r24, Y+3	; 0x03
    14aa:	9c 81       	ldd	r25, Y+4	; 0x04
    14ac:	ad 81       	ldd	r26, Y+5	; 0x05
    14ae:	be 81       	ldd	r27, Y+6	; 0x06
    14b0:	89 2f       	mov	r24, r25
    14b2:	9a 2f       	mov	r25, r26
    14b4:	ab 2f       	mov	r26, r27
    14b6:	bb 27       	eor	r27, r27
    14b8:	8b 83       	std	Y+3, r24	; 0x03
    14ba:	9c 83       	std	Y+4, r25	; 0x04
    14bc:	ad 83       	std	Y+5, r26	; 0x05
    14be:	be 83       	std	Y+6, r27	; 0x06
	ucHighByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
    14c0:	8b 81       	ldd	r24, Y+3	; 0x03
    14c2:	8a 83       	std	Y+2, r24	; 0x02
	OCR1AH = ucHighByte;
    14c4:	eb e4       	ldi	r30, 0x4B	; 75
    14c6:	f0 e0       	ldi	r31, 0x00	; 0
    14c8:	8a 81       	ldd	r24, Y+2	; 0x02
    14ca:	80 83       	st	Z, r24
	OCR1AL = ucLowByte;
    14cc:	ea e4       	ldi	r30, 0x4A	; 74
    14ce:	f0 e0       	ldi	r31, 0x00	; 0
    14d0:	89 81       	ldd	r24, Y+1	; 0x01
    14d2:	80 83       	st	Z, r24

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
    14d4:	8b e0       	ldi	r24, 0x0B	; 11
    14d6:	89 83       	std	Y+1, r24	; 0x01
	TCCR1B = ucLowByte;
    14d8:	ee e4       	ldi	r30, 0x4E	; 78
    14da:	f0 e0       	ldi	r31, 0x00	; 0
    14dc:	89 81       	ldd	r24, Y+1	; 0x01
    14de:	80 83       	st	Z, r24

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK;
    14e0:	e7 e5       	ldi	r30, 0x57	; 87
    14e2:	f0 e0       	ldi	r31, 0x00	; 0
    14e4:	80 81       	ld	r24, Z
    14e6:	89 83       	std	Y+1, r24	; 0x01
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    14e8:	89 81       	ldd	r24, Y+1	; 0x01
    14ea:	80 61       	ori	r24, 0x10	; 16
    14ec:	89 83       	std	Y+1, r24	; 0x01
	TIMSK = ucLowByte;
    14ee:	e7 e5       	ldi	r30, 0x57	; 87
    14f0:	f0 e0       	ldi	r31, 0x00	; 0
    14f2:	89 81       	ldd	r24, Y+1	; 0x01
    14f4:	80 83       	st	Z, r24
}
    14f6:	26 96       	adiw	r28, 0x06	; 6
    14f8:	0f b6       	in	r0, 0x3f	; 63
    14fa:	f8 94       	cli
    14fc:	de bf       	out	0x3e, r29	; 62
    14fe:	0f be       	out	0x3f, r0	; 63
    1500:	cd bf       	out	0x3d, r28	; 61
    1502:	cf 91       	pop	r28
    1504:	df 91       	pop	r29
    1506:	08 95       	ret

00001508 <__vector_12>:
	 * count is incremented after the context is saved.
	 */
	void TIMER1_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
	void TIMER1_COMPA_vect( void )
	{
		vPortYieldFromTick();
    1508:	0e 94 cb 09 	call	0x1396	; 0x1396 <vPortYieldFromTick>
		asm volatile ( "reti" );
    150c:	18 95       	reti

0000150e <xCoRoutineCreate>:
/*-----------------------------------------------------------*/

    BaseType_t xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode,
                                 UBaseType_t uxPriority,
                                 UBaseType_t uxIndex )
    {
    150e:	df 93       	push	r29
    1510:	cf 93       	push	r28
    1512:	cd b7       	in	r28, 0x3d	; 61
    1514:	de b7       	in	r29, 0x3e	; 62
    1516:	27 97       	sbiw	r28, 0x07	; 7
    1518:	0f b6       	in	r0, 0x3f	; 63
    151a:	f8 94       	cli
    151c:	de bf       	out	0x3e, r29	; 62
    151e:	0f be       	out	0x3f, r0	; 63
    1520:	cd bf       	out	0x3d, r28	; 61
    1522:	9d 83       	std	Y+5, r25	; 0x05
    1524:	8c 83       	std	Y+4, r24	; 0x04
    1526:	6e 83       	std	Y+6, r22	; 0x06
    1528:	4f 83       	std	Y+7, r20	; 0x07
        BaseType_t xReturn;
        CRCB_t * pxCoRoutine;

        /* Allocate the memory that will store the co-routine control block. */
        pxCoRoutine = ( CRCB_t * ) pvPortMalloc( sizeof( CRCB_t ) );
    152a:	8a e1       	ldi	r24, 0x1A	; 26
    152c:	90 e0       	ldi	r25, 0x00	; 0
    152e:	0e 94 33 07 	call	0xe66	; 0xe66 <pvPortMalloc>
    1532:	9a 83       	std	Y+2, r25	; 0x02
    1534:	89 83       	std	Y+1, r24	; 0x01

        if( pxCoRoutine )
    1536:	89 81       	ldd	r24, Y+1	; 0x01
    1538:	9a 81       	ldd	r25, Y+2	; 0x02
    153a:	00 97       	sbiw	r24, 0x00	; 0
    153c:	09 f4       	brne	.+2      	; 0x1540 <xCoRoutineCreate+0x32>
    153e:	6f c0       	rjmp	.+222    	; 0x161e <xCoRoutineCreate+0x110>
        {
            /* If pxCurrentCoRoutine is NULL then this is the first co-routine to
            * be created and the co-routine data structures need initialising. */
            if( pxCurrentCoRoutine == NULL )
    1540:	80 91 34 08 	lds	r24, 0x0834
    1544:	90 91 35 08 	lds	r25, 0x0835
    1548:	00 97       	sbiw	r24, 0x00	; 0
    154a:	41 f4       	brne	.+16     	; 0x155c <xCoRoutineCreate+0x4e>
            {
                pxCurrentCoRoutine = pxCoRoutine;
    154c:	89 81       	ldd	r24, Y+1	; 0x01
    154e:	9a 81       	ldd	r25, Y+2	; 0x02
    1550:	90 93 35 08 	sts	0x0835, r25
    1554:	80 93 34 08 	sts	0x0834, r24
                prvInitialiseCoRoutineLists();
    1558:	0e 94 f5 0c 	call	0x19ea	; 0x19ea <prvInitialiseCoRoutineLists>
            }

            /* Check the priority is within limits. */
            if( uxPriority >= configMAX_CO_ROUTINE_PRIORITIES )
    155c:	8e 81       	ldd	r24, Y+6	; 0x06
    155e:	82 30       	cpi	r24, 0x02	; 2
    1560:	10 f0       	brcs	.+4      	; 0x1566 <xCoRoutineCreate+0x58>
            {
                uxPriority = configMAX_CO_ROUTINE_PRIORITIES - 1;
    1562:	81 e0       	ldi	r24, 0x01	; 1
    1564:	8e 83       	std	Y+6, r24	; 0x06
            }

            /* Fill out the co-routine control block from the function parameters. */
            pxCoRoutine->uxState = corINITIAL_STATE;
    1566:	e9 81       	ldd	r30, Y+1	; 0x01
    1568:	fa 81       	ldd	r31, Y+2	; 0x02
    156a:	11 8e       	std	Z+25, r1	; 0x19
    156c:	10 8e       	std	Z+24, r1	; 0x18
            pxCoRoutine->uxPriority = uxPriority;
    156e:	e9 81       	ldd	r30, Y+1	; 0x01
    1570:	fa 81       	ldd	r31, Y+2	; 0x02
    1572:	8e 81       	ldd	r24, Y+6	; 0x06
    1574:	86 8b       	std	Z+22, r24	; 0x16
            pxCoRoutine->uxIndex = uxIndex;
    1576:	e9 81       	ldd	r30, Y+1	; 0x01
    1578:	fa 81       	ldd	r31, Y+2	; 0x02
    157a:	8f 81       	ldd	r24, Y+7	; 0x07
    157c:	87 8b       	std	Z+23, r24	; 0x17
            pxCoRoutine->pxCoRoutineFunction = pxCoRoutineCode;
    157e:	e9 81       	ldd	r30, Y+1	; 0x01
    1580:	fa 81       	ldd	r31, Y+2	; 0x02
    1582:	8c 81       	ldd	r24, Y+4	; 0x04
    1584:	9d 81       	ldd	r25, Y+5	; 0x05
    1586:	91 83       	std	Z+1, r25	; 0x01
    1588:	80 83       	st	Z, r24

            /* Initialise all the other co-routine control block parameters. */
            vListInitialiseItem( &( pxCoRoutine->xGenericListItem ) );
    158a:	89 81       	ldd	r24, Y+1	; 0x01
    158c:	9a 81       	ldd	r25, Y+2	; 0x02
    158e:	02 96       	adiw	r24, 0x02	; 2
    1590:	0e 94 d5 10 	call	0x21aa	; 0x21aa <vListInitialiseItem>
            vListInitialiseItem( &( pxCoRoutine->xEventListItem ) );
    1594:	89 81       	ldd	r24, Y+1	; 0x01
    1596:	9a 81       	ldd	r25, Y+2	; 0x02
    1598:	0c 96       	adiw	r24, 0x0c	; 12
    159a:	0e 94 d5 10 	call	0x21aa	; 0x21aa <vListInitialiseItem>

            /* Set the co-routine control block as a link back from the ListItem_t.
             * This is so we can get back to the containing CRCB from a generic item
             * in a list. */
            listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xGenericListItem ), pxCoRoutine );
    159e:	e9 81       	ldd	r30, Y+1	; 0x01
    15a0:	fa 81       	ldd	r31, Y+2	; 0x02
    15a2:	89 81       	ldd	r24, Y+1	; 0x01
    15a4:	9a 81       	ldd	r25, Y+2	; 0x02
    15a6:	91 87       	std	Z+9, r25	; 0x09
    15a8:	80 87       	std	Z+8, r24	; 0x08
            listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xEventListItem ), pxCoRoutine );
    15aa:	e9 81       	ldd	r30, Y+1	; 0x01
    15ac:	fa 81       	ldd	r31, Y+2	; 0x02
    15ae:	89 81       	ldd	r24, Y+1	; 0x01
    15b0:	9a 81       	ldd	r25, Y+2	; 0x02
    15b2:	93 8b       	std	Z+19, r25	; 0x13
    15b4:	82 8b       	std	Z+18, r24	; 0x12

            /* Event lists are always in priority order. */
            listSET_LIST_ITEM_VALUE( &( pxCoRoutine->xEventListItem ), ( ( TickType_t ) configMAX_CO_ROUTINE_PRIORITIES - ( TickType_t ) uxPriority ) );
    15b6:	8e 81       	ldd	r24, Y+6	; 0x06
    15b8:	28 2f       	mov	r18, r24
    15ba:	30 e0       	ldi	r19, 0x00	; 0
    15bc:	82 e0       	ldi	r24, 0x02	; 2
    15be:	90 e0       	ldi	r25, 0x00	; 0
    15c0:	82 1b       	sub	r24, r18
    15c2:	93 0b       	sbc	r25, r19
    15c4:	e9 81       	ldd	r30, Y+1	; 0x01
    15c6:	fa 81       	ldd	r31, Y+2	; 0x02
    15c8:	95 87       	std	Z+13, r25	; 0x0d
    15ca:	84 87       	std	Z+12, r24	; 0x0c

            /* Now the co-routine has been initialised it can be added to the ready
             * list at the correct priority. */
            prvAddCoRoutineToReadyQueue( pxCoRoutine );
    15cc:	e9 81       	ldd	r30, Y+1	; 0x01
    15ce:	fa 81       	ldd	r31, Y+2	; 0x02
    15d0:	96 89       	ldd	r25, Z+22	; 0x16
    15d2:	80 91 36 08 	lds	r24, 0x0836
    15d6:	89 17       	cp	r24, r25
    15d8:	28 f4       	brcc	.+10     	; 0x15e4 <xCoRoutineCreate+0xd6>
    15da:	e9 81       	ldd	r30, Y+1	; 0x01
    15dc:	fa 81       	ldd	r31, Y+2	; 0x02
    15de:	86 89       	ldd	r24, Z+22	; 0x16
    15e0:	80 93 36 08 	sts	0x0836, r24
    15e4:	e9 81       	ldd	r30, Y+1	; 0x01
    15e6:	fa 81       	ldd	r31, Y+2	; 0x02
    15e8:	86 89       	ldd	r24, Z+22	; 0x16
    15ea:	28 2f       	mov	r18, r24
    15ec:	30 e0       	ldi	r19, 0x00	; 0
    15ee:	c9 01       	movw	r24, r18
    15f0:	88 0f       	add	r24, r24
    15f2:	99 1f       	adc	r25, r25
    15f4:	88 0f       	add	r24, r24
    15f6:	99 1f       	adc	r25, r25
    15f8:	88 0f       	add	r24, r24
    15fa:	99 1f       	adc	r25, r25
    15fc:	82 0f       	add	r24, r18
    15fe:	93 1f       	adc	r25, r19
    1600:	ac 01       	movw	r20, r24
    1602:	43 5c       	subi	r20, 0xC3	; 195
    1604:	57 4f       	sbci	r21, 0xF7	; 247
    1606:	89 81       	ldd	r24, Y+1	; 0x01
    1608:	9a 81       	ldd	r25, Y+2	; 0x02
    160a:	9c 01       	movw	r18, r24
    160c:	2e 5f       	subi	r18, 0xFE	; 254
    160e:	3f 4f       	sbci	r19, 0xFF	; 255
    1610:	ca 01       	movw	r24, r20
    1612:	b9 01       	movw	r22, r18
    1614:	0e 94 e5 10 	call	0x21ca	; 0x21ca <vListInsertEnd>

            xReturn = pdPASS;
    1618:	81 e0       	ldi	r24, 0x01	; 1
    161a:	8b 83       	std	Y+3, r24	; 0x03
    161c:	02 c0       	rjmp	.+4      	; 0x1622 <xCoRoutineCreate+0x114>
        }
        else
        {
            xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    161e:	8f ef       	ldi	r24, 0xFF	; 255
    1620:	8b 83       	std	Y+3, r24	; 0x03
        }

        return xReturn;
    1622:	8b 81       	ldd	r24, Y+3	; 0x03
    }
    1624:	27 96       	adiw	r28, 0x07	; 7
    1626:	0f b6       	in	r0, 0x3f	; 63
    1628:	f8 94       	cli
    162a:	de bf       	out	0x3e, r29	; 62
    162c:	0f be       	out	0x3f, r0	; 63
    162e:	cd bf       	out	0x3d, r28	; 61
    1630:	cf 91       	pop	r28
    1632:	df 91       	pop	r29
    1634:	08 95       	ret

00001636 <vCoRoutineAddToDelayedList>:
/*-----------------------------------------------------------*/

    void vCoRoutineAddToDelayedList( TickType_t xTicksToDelay,
                                     List_t * pxEventList )
    {
    1636:	df 93       	push	r29
    1638:	cf 93       	push	r28
    163a:	00 d0       	rcall	.+0      	; 0x163c <vCoRoutineAddToDelayedList+0x6>
    163c:	00 d0       	rcall	.+0      	; 0x163e <vCoRoutineAddToDelayedList+0x8>
    163e:	00 d0       	rcall	.+0      	; 0x1640 <vCoRoutineAddToDelayedList+0xa>
    1640:	cd b7       	in	r28, 0x3d	; 61
    1642:	de b7       	in	r29, 0x3e	; 62
    1644:	9c 83       	std	Y+4, r25	; 0x04
    1646:	8b 83       	std	Y+3, r24	; 0x03
    1648:	7e 83       	std	Y+6, r23	; 0x06
    164a:	6d 83       	std	Y+5, r22	; 0x05
        TickType_t xTimeToWake;

        /* Calculate the time to wake - this may overflow but this is
         * not a problem. */
        xTimeToWake = xCoRoutineTickCount + xTicksToDelay;
    164c:	20 91 37 08 	lds	r18, 0x0837
    1650:	30 91 38 08 	lds	r19, 0x0838
    1654:	8b 81       	ldd	r24, Y+3	; 0x03
    1656:	9c 81       	ldd	r25, Y+4	; 0x04
    1658:	82 0f       	add	r24, r18
    165a:	93 1f       	adc	r25, r19
    165c:	9a 83       	std	Y+2, r25	; 0x02
    165e:	89 83       	std	Y+1, r24	; 0x01

        /* We must remove ourselves from the ready list before adding
         * ourselves to the blocked list as the same list item is used for
         * both lists. */
        ( void ) uxListRemove( ( ListItem_t * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    1660:	80 91 34 08 	lds	r24, 0x0834
    1664:	90 91 35 08 	lds	r25, 0x0835
    1668:	02 96       	adiw	r24, 0x02	; 2
    166a:	0e 94 95 11 	call	0x232a	; 0x232a <uxListRemove>

        /* The list item will be inserted in wake time order. */
        listSET_LIST_ITEM_VALUE( &( pxCurrentCoRoutine->xGenericListItem ), xTimeToWake );
    166e:	e0 91 34 08 	lds	r30, 0x0834
    1672:	f0 91 35 08 	lds	r31, 0x0835
    1676:	89 81       	ldd	r24, Y+1	; 0x01
    1678:	9a 81       	ldd	r25, Y+2	; 0x02
    167a:	93 83       	std	Z+3, r25	; 0x03
    167c:	82 83       	std	Z+2, r24	; 0x02

        if( xTimeToWake < xCoRoutineTickCount )
    167e:	20 91 37 08 	lds	r18, 0x0837
    1682:	30 91 38 08 	lds	r19, 0x0838
    1686:	89 81       	ldd	r24, Y+1	; 0x01
    1688:	9a 81       	ldd	r25, Y+2	; 0x02
    168a:	82 17       	cp	r24, r18
    168c:	93 07       	cpc	r25, r19
    168e:	70 f4       	brcc	.+28     	; 0x16ac <vCoRoutineAddToDelayedList+0x76>
        {
            /* Wake time has overflowed.  Place this item in the
             * overflow list. */
            vListInsert( ( List_t * ) pxOverflowDelayedCoRoutineList, ( ListItem_t * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    1690:	80 91 32 08 	lds	r24, 0x0832
    1694:	90 91 33 08 	lds	r25, 0x0833
    1698:	20 91 34 08 	lds	r18, 0x0834
    169c:	30 91 35 08 	lds	r19, 0x0835
    16a0:	2e 5f       	subi	r18, 0xFE	; 254
    16a2:	3f 4f       	sbci	r19, 0xFF	; 255
    16a4:	b9 01       	movw	r22, r18
    16a6:	0e 94 29 11 	call	0x2252	; 0x2252 <vListInsert>
    16aa:	0d c0       	rjmp	.+26     	; 0x16c6 <vCoRoutineAddToDelayedList+0x90>
        }
        else
        {
            /* The wake time has not overflowed, so we can use the
             * current block list. */
            vListInsert( ( List_t * ) pxDelayedCoRoutineList, ( ListItem_t * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    16ac:	80 91 30 08 	lds	r24, 0x0830
    16b0:	90 91 31 08 	lds	r25, 0x0831
    16b4:	20 91 34 08 	lds	r18, 0x0834
    16b8:	30 91 35 08 	lds	r19, 0x0835
    16bc:	2e 5f       	subi	r18, 0xFE	; 254
    16be:	3f 4f       	sbci	r19, 0xFF	; 255
    16c0:	b9 01       	movw	r22, r18
    16c2:	0e 94 29 11 	call	0x2252	; 0x2252 <vListInsert>
        }

        if( pxEventList )
    16c6:	8d 81       	ldd	r24, Y+5	; 0x05
    16c8:	9e 81       	ldd	r25, Y+6	; 0x06
    16ca:	00 97       	sbiw	r24, 0x00	; 0
    16cc:	61 f0       	breq	.+24     	; 0x16e6 <vCoRoutineAddToDelayedList+0xb0>
        {
            /* Also add the co-routine to an event list.  If this is done then the
             * function must be called with interrupts disabled. */
            vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
    16ce:	80 91 34 08 	lds	r24, 0x0834
    16d2:	90 91 35 08 	lds	r25, 0x0835
    16d6:	9c 01       	movw	r18, r24
    16d8:	24 5f       	subi	r18, 0xF4	; 244
    16da:	3f 4f       	sbci	r19, 0xFF	; 255
    16dc:	8d 81       	ldd	r24, Y+5	; 0x05
    16de:	9e 81       	ldd	r25, Y+6	; 0x06
    16e0:	b9 01       	movw	r22, r18
    16e2:	0e 94 29 11 	call	0x2252	; 0x2252 <vListInsert>
        }
    }
    16e6:	26 96       	adiw	r28, 0x06	; 6
    16e8:	0f b6       	in	r0, 0x3f	; 63
    16ea:	f8 94       	cli
    16ec:	de bf       	out	0x3e, r29	; 62
    16ee:	0f be       	out	0x3f, r0	; 63
    16f0:	cd bf       	out	0x3d, r28	; 61
    16f2:	cf 91       	pop	r28
    16f4:	df 91       	pop	r29
    16f6:	08 95       	ret

000016f8 <prvCheckPendingReadyList>:
/*-----------------------------------------------------------*/

    static void prvCheckPendingReadyList( void )
    {
    16f8:	df 93       	push	r29
    16fa:	cf 93       	push	r28
    16fc:	00 d0       	rcall	.+0      	; 0x16fe <prvCheckPendingReadyList+0x6>
    16fe:	cd b7       	in	r28, 0x3d	; 61
    1700:	de b7       	in	r29, 0x3e	; 62
    1702:	3a c0       	rjmp	.+116    	; 0x1778 <prvCheckPendingReadyList+0x80>
        while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
        {
            CRCB_t * pxUnblockedCRCB;

            /* The pending ready list can be accessed by an ISR. */
            portDISABLE_INTERRUPTS();
    1704:	f8 94       	cli
            {
                pxUnblockedCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyCoRoutineList ) );
    1706:	e0 91 66 08 	lds	r30, 0x0866
    170a:	f0 91 67 08 	lds	r31, 0x0867
    170e:	86 81       	ldd	r24, Z+6	; 0x06
    1710:	97 81       	ldd	r25, Z+7	; 0x07
    1712:	9a 83       	std	Y+2, r25	; 0x02
    1714:	89 83       	std	Y+1, r24	; 0x01
                ( void ) uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    1716:	89 81       	ldd	r24, Y+1	; 0x01
    1718:	9a 81       	ldd	r25, Y+2	; 0x02
    171a:	0c 96       	adiw	r24, 0x0c	; 12
    171c:	0e 94 95 11 	call	0x232a	; 0x232a <uxListRemove>
            }
            portENABLE_INTERRUPTS();
    1720:	78 94       	sei

            ( void ) uxListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
    1722:	89 81       	ldd	r24, Y+1	; 0x01
    1724:	9a 81       	ldd	r25, Y+2	; 0x02
    1726:	02 96       	adiw	r24, 0x02	; 2
    1728:	0e 94 95 11 	call	0x232a	; 0x232a <uxListRemove>
            prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );
    172c:	e9 81       	ldd	r30, Y+1	; 0x01
    172e:	fa 81       	ldd	r31, Y+2	; 0x02
    1730:	96 89       	ldd	r25, Z+22	; 0x16
    1732:	80 91 36 08 	lds	r24, 0x0836
    1736:	89 17       	cp	r24, r25
    1738:	28 f4       	brcc	.+10     	; 0x1744 <prvCheckPendingReadyList+0x4c>
    173a:	e9 81       	ldd	r30, Y+1	; 0x01
    173c:	fa 81       	ldd	r31, Y+2	; 0x02
    173e:	86 89       	ldd	r24, Z+22	; 0x16
    1740:	80 93 36 08 	sts	0x0836, r24
    1744:	e9 81       	ldd	r30, Y+1	; 0x01
    1746:	fa 81       	ldd	r31, Y+2	; 0x02
    1748:	86 89       	ldd	r24, Z+22	; 0x16
    174a:	28 2f       	mov	r18, r24
    174c:	30 e0       	ldi	r19, 0x00	; 0
    174e:	c9 01       	movw	r24, r18
    1750:	88 0f       	add	r24, r24
    1752:	99 1f       	adc	r25, r25
    1754:	88 0f       	add	r24, r24
    1756:	99 1f       	adc	r25, r25
    1758:	88 0f       	add	r24, r24
    175a:	99 1f       	adc	r25, r25
    175c:	82 0f       	add	r24, r18
    175e:	93 1f       	adc	r25, r19
    1760:	ac 01       	movw	r20, r24
    1762:	43 5c       	subi	r20, 0xC3	; 195
    1764:	57 4f       	sbci	r21, 0xF7	; 247
    1766:	89 81       	ldd	r24, Y+1	; 0x01
    1768:	9a 81       	ldd	r25, Y+2	; 0x02
    176a:	9c 01       	movw	r18, r24
    176c:	2e 5f       	subi	r18, 0xFE	; 254
    176e:	3f 4f       	sbci	r19, 0xFF	; 255
    1770:	ca 01       	movw	r24, r20
    1772:	b9 01       	movw	r22, r18
    1774:	0e 94 e5 10 	call	0x21ca	; 0x21ca <vListInsertEnd>
    static void prvCheckPendingReadyList( void )
    {
        /* Are there any co-routines waiting to get moved to the ready list?  These
         * are co-routines that have been readied by an ISR.  The ISR cannot access
         * the ready lists itself. */
        while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
    1778:	80 91 61 08 	lds	r24, 0x0861
    177c:	88 23       	and	r24, r24
    177e:	09 f0       	breq	.+2      	; 0x1782 <prvCheckPendingReadyList+0x8a>
    1780:	c1 cf       	rjmp	.-126    	; 0x1704 <prvCheckPendingReadyList+0xc>
            portENABLE_INTERRUPTS();

            ( void ) uxListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
            prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );
        }
    }
    1782:	0f 90       	pop	r0
    1784:	0f 90       	pop	r0
    1786:	cf 91       	pop	r28
    1788:	df 91       	pop	r29
    178a:	08 95       	ret

0000178c <prvCheckDelayedList>:
/*-----------------------------------------------------------*/

    static void prvCheckDelayedList( void )
    {
    178c:	df 93       	push	r29
    178e:	cf 93       	push	r28
    1790:	00 d0       	rcall	.+0      	; 0x1792 <prvCheckDelayedList+0x6>
    1792:	00 d0       	rcall	.+0      	; 0x1794 <prvCheckDelayedList+0x8>
    1794:	cd b7       	in	r28, 0x3d	; 61
    1796:	de b7       	in	r29, 0x3e	; 62
        CRCB_t * pxCRCB;

        xPassedTicks = xTaskGetTickCount() - xLastTickCount;
    1798:	0e 94 e4 1f 	call	0x3fc8	; 0x3fc8 <xTaskGetTickCount>
    179c:	20 91 39 08 	lds	r18, 0x0839
    17a0:	30 91 3a 08 	lds	r19, 0x083A
    17a4:	82 1b       	sub	r24, r18
    17a6:	93 0b       	sbc	r25, r19
    17a8:	90 93 3c 08 	sts	0x083C, r25
    17ac:	80 93 3b 08 	sts	0x083B, r24
    17b0:	85 c0       	rjmp	.+266    	; 0x18bc <prvCheckDelayedList+0x130>

        while( xPassedTicks )
        {
            xCoRoutineTickCount++;
    17b2:	80 91 37 08 	lds	r24, 0x0837
    17b6:	90 91 38 08 	lds	r25, 0x0838
    17ba:	01 96       	adiw	r24, 0x01	; 1
    17bc:	90 93 38 08 	sts	0x0838, r25
    17c0:	80 93 37 08 	sts	0x0837, r24
            xPassedTicks--;
    17c4:	80 91 3b 08 	lds	r24, 0x083B
    17c8:	90 91 3c 08 	lds	r25, 0x083C
    17cc:	01 97       	sbiw	r24, 0x01	; 1
    17ce:	90 93 3c 08 	sts	0x083C, r25
    17d2:	80 93 3b 08 	sts	0x083B, r24

            /* If the tick count has overflowed we need to swap the ready lists. */
            if( xCoRoutineTickCount == 0 )
    17d6:	80 91 37 08 	lds	r24, 0x0837
    17da:	90 91 38 08 	lds	r25, 0x0838
    17de:	00 97       	sbiw	r24, 0x00	; 0
    17e0:	09 f0       	breq	.+2      	; 0x17e4 <prvCheckDelayedList+0x58>
    17e2:	64 c0       	rjmp	.+200    	; 0x18ac <prvCheckDelayedList+0x120>
            {
                List_t * pxTemp;

                /* Tick count has overflowed so we need to swap the delay lists.  If there are
                 * any items in pxDelayedCoRoutineList here then there is an error! */
                pxTemp = pxDelayedCoRoutineList;
    17e4:	80 91 30 08 	lds	r24, 0x0830
    17e8:	90 91 31 08 	lds	r25, 0x0831
    17ec:	9a 83       	std	Y+2, r25	; 0x02
    17ee:	89 83       	std	Y+1, r24	; 0x01
                pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
    17f0:	80 91 32 08 	lds	r24, 0x0832
    17f4:	90 91 33 08 	lds	r25, 0x0833
    17f8:	90 93 31 08 	sts	0x0831, r25
    17fc:	80 93 30 08 	sts	0x0830, r24
                pxOverflowDelayedCoRoutineList = pxTemp;
    1800:	89 81       	ldd	r24, Y+1	; 0x01
    1802:	9a 81       	ldd	r25, Y+2	; 0x02
    1804:	90 93 33 08 	sts	0x0833, r25
    1808:	80 93 32 08 	sts	0x0832, r24
    180c:	4f c0       	rjmp	.+158    	; 0x18ac <prvCheckDelayedList+0x120>
            }

            /* See if this tick has made a timeout expire. */
            while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
            {
                pxCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList );
    180e:	e0 91 30 08 	lds	r30, 0x0830
    1812:	f0 91 31 08 	lds	r31, 0x0831
    1816:	05 80       	ldd	r0, Z+5	; 0x05
    1818:	f6 81       	ldd	r31, Z+6	; 0x06
    181a:	e0 2d       	mov	r30, r0
    181c:	86 81       	ldd	r24, Z+6	; 0x06
    181e:	97 81       	ldd	r25, Z+7	; 0x07
    1820:	9c 83       	std	Y+4, r25	; 0x04
    1822:	8b 83       	std	Y+3, r24	; 0x03

                if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )
    1824:	eb 81       	ldd	r30, Y+3	; 0x03
    1826:	fc 81       	ldd	r31, Y+4	; 0x04
    1828:	22 81       	ldd	r18, Z+2	; 0x02
    182a:	33 81       	ldd	r19, Z+3	; 0x03
    182c:	80 91 37 08 	lds	r24, 0x0837
    1830:	90 91 38 08 	lds	r25, 0x0838
    1834:	82 17       	cp	r24, r18
    1836:	93 07       	cpc	r25, r19
    1838:	08 f4       	brcc	.+2      	; 0x183c <prvCheckDelayedList+0xb0>
    183a:	40 c0       	rjmp	.+128    	; 0x18bc <prvCheckDelayedList+0x130>
                {
                    /* Timeout not yet expired. */
                    break;
                }

                portDISABLE_INTERRUPTS();
    183c:	f8 94       	cli
                    /* The event could have occurred just before this critical
                     *  section.  If this is the case then the generic list item will
                     *  have been moved to the pending ready list and the following
                     *  line is still valid.  Also the pvContainer parameter will have
                     *  been set to NULL so the following lines are also valid. */
                    ( void ) uxListRemove( &( pxCRCB->xGenericListItem ) );
    183e:	8b 81       	ldd	r24, Y+3	; 0x03
    1840:	9c 81       	ldd	r25, Y+4	; 0x04
    1842:	02 96       	adiw	r24, 0x02	; 2
    1844:	0e 94 95 11 	call	0x232a	; 0x232a <uxListRemove>

                    /* Is the co-routine waiting on an event also? */
                    if( pxCRCB->xEventListItem.pxContainer )
    1848:	eb 81       	ldd	r30, Y+3	; 0x03
    184a:	fc 81       	ldd	r31, Y+4	; 0x04
    184c:	84 89       	ldd	r24, Z+20	; 0x14
    184e:	95 89       	ldd	r25, Z+21	; 0x15
    1850:	00 97       	sbiw	r24, 0x00	; 0
    1852:	29 f0       	breq	.+10     	; 0x185e <prvCheckDelayedList+0xd2>
                    {
                        ( void ) uxListRemove( &( pxCRCB->xEventListItem ) );
    1854:	8b 81       	ldd	r24, Y+3	; 0x03
    1856:	9c 81       	ldd	r25, Y+4	; 0x04
    1858:	0c 96       	adiw	r24, 0x0c	; 12
    185a:	0e 94 95 11 	call	0x232a	; 0x232a <uxListRemove>
                    }
                }
                portENABLE_INTERRUPTS();
    185e:	78 94       	sei

                prvAddCoRoutineToReadyQueue( pxCRCB );
    1860:	eb 81       	ldd	r30, Y+3	; 0x03
    1862:	fc 81       	ldd	r31, Y+4	; 0x04
    1864:	96 89       	ldd	r25, Z+22	; 0x16
    1866:	80 91 36 08 	lds	r24, 0x0836
    186a:	89 17       	cp	r24, r25
    186c:	28 f4       	brcc	.+10     	; 0x1878 <prvCheckDelayedList+0xec>
    186e:	eb 81       	ldd	r30, Y+3	; 0x03
    1870:	fc 81       	ldd	r31, Y+4	; 0x04
    1872:	86 89       	ldd	r24, Z+22	; 0x16
    1874:	80 93 36 08 	sts	0x0836, r24
    1878:	eb 81       	ldd	r30, Y+3	; 0x03
    187a:	fc 81       	ldd	r31, Y+4	; 0x04
    187c:	86 89       	ldd	r24, Z+22	; 0x16
    187e:	28 2f       	mov	r18, r24
    1880:	30 e0       	ldi	r19, 0x00	; 0
    1882:	c9 01       	movw	r24, r18
    1884:	88 0f       	add	r24, r24
    1886:	99 1f       	adc	r25, r25
    1888:	88 0f       	add	r24, r24
    188a:	99 1f       	adc	r25, r25
    188c:	88 0f       	add	r24, r24
    188e:	99 1f       	adc	r25, r25
    1890:	82 0f       	add	r24, r18
    1892:	93 1f       	adc	r25, r19
    1894:	ac 01       	movw	r20, r24
    1896:	43 5c       	subi	r20, 0xC3	; 195
    1898:	57 4f       	sbci	r21, 0xF7	; 247
    189a:	8b 81       	ldd	r24, Y+3	; 0x03
    189c:	9c 81       	ldd	r25, Y+4	; 0x04
    189e:	9c 01       	movw	r18, r24
    18a0:	2e 5f       	subi	r18, 0xFE	; 254
    18a2:	3f 4f       	sbci	r19, 0xFF	; 255
    18a4:	ca 01       	movw	r24, r20
    18a6:	b9 01       	movw	r22, r18
    18a8:	0e 94 e5 10 	call	0x21ca	; 0x21ca <vListInsertEnd>
                pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
                pxOverflowDelayedCoRoutineList = pxTemp;
            }

            /* See if this tick has made a timeout expire. */
            while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
    18ac:	e0 91 30 08 	lds	r30, 0x0830
    18b0:	f0 91 31 08 	lds	r31, 0x0831
    18b4:	80 81       	ld	r24, Z
    18b6:	88 23       	and	r24, r24
    18b8:	09 f0       	breq	.+2      	; 0x18bc <prvCheckDelayedList+0x130>
    18ba:	a9 cf       	rjmp	.-174    	; 0x180e <prvCheckDelayedList+0x82>
    {
        CRCB_t * pxCRCB;

        xPassedTicks = xTaskGetTickCount() - xLastTickCount;

        while( xPassedTicks )
    18bc:	80 91 3b 08 	lds	r24, 0x083B
    18c0:	90 91 3c 08 	lds	r25, 0x083C
    18c4:	00 97       	sbiw	r24, 0x00	; 0
    18c6:	09 f0       	breq	.+2      	; 0x18ca <prvCheckDelayedList+0x13e>
    18c8:	74 cf       	rjmp	.-280    	; 0x17b2 <prvCheckDelayedList+0x26>

                prvAddCoRoutineToReadyQueue( pxCRCB );
            }
        }

        xLastTickCount = xCoRoutineTickCount;
    18ca:	80 91 37 08 	lds	r24, 0x0837
    18ce:	90 91 38 08 	lds	r25, 0x0838
    18d2:	90 93 3a 08 	sts	0x083A, r25
    18d6:	80 93 39 08 	sts	0x0839, r24
    }
    18da:	0f 90       	pop	r0
    18dc:	0f 90       	pop	r0
    18de:	0f 90       	pop	r0
    18e0:	0f 90       	pop	r0
    18e2:	cf 91       	pop	r28
    18e4:	df 91       	pop	r29
    18e6:	08 95       	ret

000018e8 <vCoRoutineSchedule>:
/*-----------------------------------------------------------*/

    void vCoRoutineSchedule( void )
    {
    18e8:	df 93       	push	r29
    18ea:	cf 93       	push	r28
    18ec:	00 d0       	rcall	.+0      	; 0x18ee <vCoRoutineSchedule+0x6>
    18ee:	cd b7       	in	r28, 0x3d	; 61
    18f0:	de b7       	in	r29, 0x3e	; 62
        /* Only run a co-routine after prvInitialiseCoRoutineLists() has been
         * called.  prvInitialiseCoRoutineLists() is called automatically when a
         * co-routine is created. */
        if( pxDelayedCoRoutineList != NULL )
    18f2:	80 91 30 08 	lds	r24, 0x0830
    18f6:	90 91 31 08 	lds	r25, 0x0831
    18fa:	00 97       	sbiw	r24, 0x00	; 0
    18fc:	09 f4       	brne	.+2      	; 0x1900 <vCoRoutineSchedule+0x18>
    18fe:	70 c0       	rjmp	.+224    	; 0x19e0 <vCoRoutineSchedule+0xf8>
        {
            /* See if any co-routines readied by events need moving to the ready lists. */
            prvCheckPendingReadyList();
    1900:	0e 94 7c 0b 	call	0x16f8	; 0x16f8 <prvCheckPendingReadyList>

            /* See if any delayed co-routines have timed out. */
            prvCheckDelayedList();
    1904:	0e 94 c6 0b 	call	0x178c	; 0x178c <prvCheckDelayedList>
    1908:	0a c0       	rjmp	.+20     	; 0x191e <vCoRoutineSchedule+0x36>

            /* Find the highest priority queue that contains ready co-routines. */
            while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
            {
                if( uxTopCoRoutineReadyPriority == 0 )
    190a:	80 91 36 08 	lds	r24, 0x0836
    190e:	88 23       	and	r24, r24
    1910:	09 f4       	brne	.+2      	; 0x1914 <vCoRoutineSchedule+0x2c>
    1912:	66 c0       	rjmp	.+204    	; 0x19e0 <vCoRoutineSchedule+0xf8>
                {
                    /* No more co-routines to check. */
                    return;
                }

                --uxTopCoRoutineReadyPriority;
    1914:	80 91 36 08 	lds	r24, 0x0836
    1918:	81 50       	subi	r24, 0x01	; 1
    191a:	80 93 36 08 	sts	0x0836, r24

            /* See if any delayed co-routines have timed out. */
            prvCheckDelayedList();

            /* Find the highest priority queue that contains ready co-routines. */
            while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
    191e:	80 91 36 08 	lds	r24, 0x0836
    1922:	28 2f       	mov	r18, r24
    1924:	30 e0       	ldi	r19, 0x00	; 0
    1926:	c9 01       	movw	r24, r18
    1928:	88 0f       	add	r24, r24
    192a:	99 1f       	adc	r25, r25
    192c:	88 0f       	add	r24, r24
    192e:	99 1f       	adc	r25, r25
    1930:	88 0f       	add	r24, r24
    1932:	99 1f       	adc	r25, r25
    1934:	82 0f       	add	r24, r18
    1936:	93 1f       	adc	r25, r19
    1938:	fc 01       	movw	r30, r24
    193a:	e3 5c       	subi	r30, 0xC3	; 195
    193c:	f7 4f       	sbci	r31, 0xF7	; 247
    193e:	80 81       	ld	r24, Z
    1940:	88 23       	and	r24, r24
    1942:	19 f3       	breq	.-58     	; 0x190a <vCoRoutineSchedule+0x22>
                --uxTopCoRoutineReadyPriority;
            }

            /* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
             * of the same priority get an equal share of the processor time. */
            listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );
    1944:	80 91 36 08 	lds	r24, 0x0836
    1948:	28 2f       	mov	r18, r24
    194a:	30 e0       	ldi	r19, 0x00	; 0
    194c:	c9 01       	movw	r24, r18
    194e:	88 0f       	add	r24, r24
    1950:	99 1f       	adc	r25, r25
    1952:	88 0f       	add	r24, r24
    1954:	99 1f       	adc	r25, r25
    1956:	88 0f       	add	r24, r24
    1958:	99 1f       	adc	r25, r25
    195a:	82 0f       	add	r24, r18
    195c:	93 1f       	adc	r25, r19
    195e:	83 5c       	subi	r24, 0xC3	; 195
    1960:	97 4f       	sbci	r25, 0xF7	; 247
    1962:	9a 83       	std	Y+2, r25	; 0x02
    1964:	89 83       	std	Y+1, r24	; 0x01
    1966:	e9 81       	ldd	r30, Y+1	; 0x01
    1968:	fa 81       	ldd	r31, Y+2	; 0x02
    196a:	01 80       	ldd	r0, Z+1	; 0x01
    196c:	f2 81       	ldd	r31, Z+2	; 0x02
    196e:	e0 2d       	mov	r30, r0
    1970:	82 81       	ldd	r24, Z+2	; 0x02
    1972:	93 81       	ldd	r25, Z+3	; 0x03
    1974:	e9 81       	ldd	r30, Y+1	; 0x01
    1976:	fa 81       	ldd	r31, Y+2	; 0x02
    1978:	92 83       	std	Z+2, r25	; 0x02
    197a:	81 83       	std	Z+1, r24	; 0x01
    197c:	e9 81       	ldd	r30, Y+1	; 0x01
    197e:	fa 81       	ldd	r31, Y+2	; 0x02
    1980:	21 81       	ldd	r18, Z+1	; 0x01
    1982:	32 81       	ldd	r19, Z+2	; 0x02
    1984:	89 81       	ldd	r24, Y+1	; 0x01
    1986:	9a 81       	ldd	r25, Y+2	; 0x02
    1988:	03 96       	adiw	r24, 0x03	; 3
    198a:	28 17       	cp	r18, r24
    198c:	39 07       	cpc	r19, r25
    198e:	59 f4       	brne	.+22     	; 0x19a6 <vCoRoutineSchedule+0xbe>
    1990:	e9 81       	ldd	r30, Y+1	; 0x01
    1992:	fa 81       	ldd	r31, Y+2	; 0x02
    1994:	01 80       	ldd	r0, Z+1	; 0x01
    1996:	f2 81       	ldd	r31, Z+2	; 0x02
    1998:	e0 2d       	mov	r30, r0
    199a:	82 81       	ldd	r24, Z+2	; 0x02
    199c:	93 81       	ldd	r25, Z+3	; 0x03
    199e:	e9 81       	ldd	r30, Y+1	; 0x01
    19a0:	fa 81       	ldd	r31, Y+2	; 0x02
    19a2:	92 83       	std	Z+2, r25	; 0x02
    19a4:	81 83       	std	Z+1, r24	; 0x01
    19a6:	e9 81       	ldd	r30, Y+1	; 0x01
    19a8:	fa 81       	ldd	r31, Y+2	; 0x02
    19aa:	01 80       	ldd	r0, Z+1	; 0x01
    19ac:	f2 81       	ldd	r31, Z+2	; 0x02
    19ae:	e0 2d       	mov	r30, r0
    19b0:	86 81       	ldd	r24, Z+6	; 0x06
    19b2:	97 81       	ldd	r25, Z+7	; 0x07
    19b4:	90 93 35 08 	sts	0x0835, r25
    19b8:	80 93 34 08 	sts	0x0834, r24

            /* Call the co-routine. */
            ( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
    19bc:	e0 91 34 08 	lds	r30, 0x0834
    19c0:	f0 91 35 08 	lds	r31, 0x0835
    19c4:	40 81       	ld	r20, Z
    19c6:	51 81       	ldd	r21, Z+1	; 0x01
    19c8:	80 91 34 08 	lds	r24, 0x0834
    19cc:	90 91 35 08 	lds	r25, 0x0835
    19d0:	e0 91 34 08 	lds	r30, 0x0834
    19d4:	f0 91 35 08 	lds	r31, 0x0835
    19d8:	27 89       	ldd	r18, Z+23	; 0x17
    19da:	62 2f       	mov	r22, r18
    19dc:	fa 01       	movw	r30, r20
    19de:	09 95       	icall
        }
    }
    19e0:	0f 90       	pop	r0
    19e2:	0f 90       	pop	r0
    19e4:	cf 91       	pop	r28
    19e6:	df 91       	pop	r29
    19e8:	08 95       	ret

000019ea <prvInitialiseCoRoutineLists>:
/*-----------------------------------------------------------*/

    static void prvInitialiseCoRoutineLists( void )
    {
    19ea:	df 93       	push	r29
    19ec:	cf 93       	push	r28
    19ee:	0f 92       	push	r0
    19f0:	cd b7       	in	r28, 0x3d	; 61
    19f2:	de b7       	in	r29, 0x3e	; 62
        UBaseType_t uxPriority;

        for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
    19f4:	19 82       	std	Y+1, r1	; 0x01
    19f6:	13 c0       	rjmp	.+38     	; 0x1a1e <prvInitialiseCoRoutineLists+0x34>
        {
            vListInitialise( ( List_t * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
    19f8:	89 81       	ldd	r24, Y+1	; 0x01
    19fa:	28 2f       	mov	r18, r24
    19fc:	30 e0       	ldi	r19, 0x00	; 0
    19fe:	c9 01       	movw	r24, r18
    1a00:	88 0f       	add	r24, r24
    1a02:	99 1f       	adc	r25, r25
    1a04:	88 0f       	add	r24, r24
    1a06:	99 1f       	adc	r25, r25
    1a08:	88 0f       	add	r24, r24
    1a0a:	99 1f       	adc	r25, r25
    1a0c:	82 0f       	add	r24, r18
    1a0e:	93 1f       	adc	r25, r19
    1a10:	83 5c       	subi	r24, 0xC3	; 195
    1a12:	97 4f       	sbci	r25, 0xF7	; 247
    1a14:	0e 94 ab 10 	call	0x2156	; 0x2156 <vListInitialise>

    static void prvInitialiseCoRoutineLists( void )
    {
        UBaseType_t uxPriority;

        for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
    1a18:	89 81       	ldd	r24, Y+1	; 0x01
    1a1a:	8f 5f       	subi	r24, 0xFF	; 255
    1a1c:	89 83       	std	Y+1, r24	; 0x01
    1a1e:	89 81       	ldd	r24, Y+1	; 0x01
    1a20:	82 30       	cpi	r24, 0x02	; 2
    1a22:	50 f3       	brcs	.-44     	; 0x19f8 <prvInitialiseCoRoutineLists+0xe>
        {
            vListInitialise( ( List_t * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
        }

        vListInitialise( ( List_t * ) &xDelayedCoRoutineList1 );
    1a24:	8f e4       	ldi	r24, 0x4F	; 79
    1a26:	98 e0       	ldi	r25, 0x08	; 8
    1a28:	0e 94 ab 10 	call	0x2156	; 0x2156 <vListInitialise>
        vListInitialise( ( List_t * ) &xDelayedCoRoutineList2 );
    1a2c:	88 e5       	ldi	r24, 0x58	; 88
    1a2e:	98 e0       	ldi	r25, 0x08	; 8
    1a30:	0e 94 ab 10 	call	0x2156	; 0x2156 <vListInitialise>
        vListInitialise( ( List_t * ) &xPendingReadyCoRoutineList );
    1a34:	81 e6       	ldi	r24, 0x61	; 97
    1a36:	98 e0       	ldi	r25, 0x08	; 8
    1a38:	0e 94 ab 10 	call	0x2156	; 0x2156 <vListInitialise>

        /* Start with pxDelayedCoRoutineList using list1 and the
         * pxOverflowDelayedCoRoutineList using list2. */
        pxDelayedCoRoutineList = &xDelayedCoRoutineList1;
    1a3c:	8f e4       	ldi	r24, 0x4F	; 79
    1a3e:	98 e0       	ldi	r25, 0x08	; 8
    1a40:	90 93 31 08 	sts	0x0831, r25
    1a44:	80 93 30 08 	sts	0x0830, r24
        pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
    1a48:	88 e5       	ldi	r24, 0x58	; 88
    1a4a:	98 e0       	ldi	r25, 0x08	; 8
    1a4c:	90 93 33 08 	sts	0x0833, r25
    1a50:	80 93 32 08 	sts	0x0832, r24
    }
    1a54:	0f 90       	pop	r0
    1a56:	cf 91       	pop	r28
    1a58:	df 91       	pop	r29
    1a5a:	08 95       	ret

00001a5c <xCoRoutineRemoveFromEventList>:
/*-----------------------------------------------------------*/

    BaseType_t xCoRoutineRemoveFromEventList( const List_t * pxEventList )
    {
    1a5c:	df 93       	push	r29
    1a5e:	cf 93       	push	r28
    1a60:	00 d0       	rcall	.+0      	; 0x1a62 <xCoRoutineRemoveFromEventList+0x6>
    1a62:	00 d0       	rcall	.+0      	; 0x1a64 <xCoRoutineRemoveFromEventList+0x8>
    1a64:	0f 92       	push	r0
    1a66:	cd b7       	in	r28, 0x3d	; 61
    1a68:	de b7       	in	r29, 0x3e	; 62
    1a6a:	9d 83       	std	Y+5, r25	; 0x05
    1a6c:	8c 83       	std	Y+4, r24	; 0x04
        BaseType_t xReturn;

        /* This function is called from within an interrupt.  It can only access
         * event lists and the pending ready list.  This function assumes that a
         * check has already been made to ensure pxEventList is not empty. */
        pxUnblockedCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    1a6e:	ec 81       	ldd	r30, Y+4	; 0x04
    1a70:	fd 81       	ldd	r31, Y+5	; 0x05
    1a72:	05 80       	ldd	r0, Z+5	; 0x05
    1a74:	f6 81       	ldd	r31, Z+6	; 0x06
    1a76:	e0 2d       	mov	r30, r0
    1a78:	86 81       	ldd	r24, Z+6	; 0x06
    1a7a:	97 81       	ldd	r25, Z+7	; 0x07
    1a7c:	9b 83       	std	Y+3, r25	; 0x03
    1a7e:	8a 83       	std	Y+2, r24	; 0x02
        ( void ) uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    1a80:	8a 81       	ldd	r24, Y+2	; 0x02
    1a82:	9b 81       	ldd	r25, Y+3	; 0x03
    1a84:	0c 96       	adiw	r24, 0x0c	; 12
    1a86:	0e 94 95 11 	call	0x232a	; 0x232a <uxListRemove>
        vListInsertEnd( ( List_t * ) &( xPendingReadyCoRoutineList ), &( pxUnblockedCRCB->xEventListItem ) );
    1a8a:	8a 81       	ldd	r24, Y+2	; 0x02
    1a8c:	9b 81       	ldd	r25, Y+3	; 0x03
    1a8e:	9c 01       	movw	r18, r24
    1a90:	24 5f       	subi	r18, 0xF4	; 244
    1a92:	3f 4f       	sbci	r19, 0xFF	; 255
    1a94:	81 e6       	ldi	r24, 0x61	; 97
    1a96:	98 e0       	ldi	r25, 0x08	; 8
    1a98:	b9 01       	movw	r22, r18
    1a9a:	0e 94 e5 10 	call	0x21ca	; 0x21ca <vListInsertEnd>

        if( pxUnblockedCRCB->uxPriority >= pxCurrentCoRoutine->uxPriority )
    1a9e:	ea 81       	ldd	r30, Y+2	; 0x02
    1aa0:	fb 81       	ldd	r31, Y+3	; 0x03
    1aa2:	96 89       	ldd	r25, Z+22	; 0x16
    1aa4:	e0 91 34 08 	lds	r30, 0x0834
    1aa8:	f0 91 35 08 	lds	r31, 0x0835
    1aac:	86 89       	ldd	r24, Z+22	; 0x16
    1aae:	98 17       	cp	r25, r24
    1ab0:	18 f0       	brcs	.+6      	; 0x1ab8 <xCoRoutineRemoveFromEventList+0x5c>
        {
            xReturn = pdTRUE;
    1ab2:	81 e0       	ldi	r24, 0x01	; 1
    1ab4:	89 83       	std	Y+1, r24	; 0x01
    1ab6:	01 c0       	rjmp	.+2      	; 0x1aba <xCoRoutineRemoveFromEventList+0x5e>
        }
        else
        {
            xReturn = pdFALSE;
    1ab8:	19 82       	std	Y+1, r1	; 0x01
        }

        return xReturn;
    1aba:	89 81       	ldd	r24, Y+1	; 0x01
    }
    1abc:	0f 90       	pop	r0
    1abe:	0f 90       	pop	r0
    1ac0:	0f 90       	pop	r0
    1ac2:	0f 90       	pop	r0
    1ac4:	0f 90       	pop	r0
    1ac6:	cf 91       	pop	r28
    1ac8:	df 91       	pop	r29
    1aca:	08 95       	ret

00001acc <xEventGroupCreate>:
/*-----------------------------------------------------------*/

#if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

    EventGroupHandle_t xEventGroupCreate( void )
    {
    1acc:	df 93       	push	r29
    1ace:	cf 93       	push	r28
    1ad0:	00 d0       	rcall	.+0      	; 0x1ad2 <xEventGroupCreate+0x6>
    1ad2:	cd b7       	in	r28, 0x3d	; 61
    1ad4:	de b7       	in	r29, 0x3e	; 62
         * TickType_t alignment requirements the cast is safe.  In other cases,
         * where the natural word size of the architecture is less than
         * sizeof( TickType_t ), the TickType_t variables will be accessed in two
         * or more reads operations, and the alignment requirements is only that
         * of each individual read. */
        pxEventBits = ( EventGroup_t * ) pvPortMalloc( sizeof( EventGroup_t ) ); /*lint !e9087 !e9079 see comment above. */
    1ad6:	8b e0       	ldi	r24, 0x0B	; 11
    1ad8:	90 e0       	ldi	r25, 0x00	; 0
    1ada:	0e 94 33 07 	call	0xe66	; 0xe66 <pvPortMalloc>
    1ade:	9a 83       	std	Y+2, r25	; 0x02
    1ae0:	89 83       	std	Y+1, r24	; 0x01

        if( pxEventBits != NULL )
    1ae2:	89 81       	ldd	r24, Y+1	; 0x01
    1ae4:	9a 81       	ldd	r25, Y+2	; 0x02
    1ae6:	00 97       	sbiw	r24, 0x00	; 0
    1ae8:	49 f0       	breq	.+18     	; 0x1afc <xEventGroupCreate+0x30>
        {
            pxEventBits->uxEventBits = 0;
    1aea:	e9 81       	ldd	r30, Y+1	; 0x01
    1aec:	fa 81       	ldd	r31, Y+2	; 0x02
    1aee:	11 82       	std	Z+1, r1	; 0x01
    1af0:	10 82       	st	Z, r1
            vListInitialise( &( pxEventBits->xTasksWaitingForBits ) );
    1af2:	89 81       	ldd	r24, Y+1	; 0x01
    1af4:	9a 81       	ldd	r25, Y+2	; 0x02
    1af6:	02 96       	adiw	r24, 0x02	; 2
    1af8:	0e 94 ab 10 	call	0x2156	; 0x2156 <vListInitialise>
        else
        {
            traceEVENT_GROUP_CREATE_FAILED(); /*lint !e9063 Else branch only exists to allow tracing and does not generate code if trace macros are not defined. */
        }

        return pxEventBits;
    1afc:	89 81       	ldd	r24, Y+1	; 0x01
    1afe:	9a 81       	ldd	r25, Y+2	; 0x02
    }
    1b00:	0f 90       	pop	r0
    1b02:	0f 90       	pop	r0
    1b04:	cf 91       	pop	r28
    1b06:	df 91       	pop	r29
    1b08:	08 95       	ret

00001b0a <xEventGroupSync>:

EventBits_t xEventGroupSync( EventGroupHandle_t xEventGroup,
                             const EventBits_t uxBitsToSet,
                             const EventBits_t uxBitsToWaitFor,
                             TickType_t xTicksToWait )
{
    1b0a:	df 93       	push	r29
    1b0c:	cf 93       	push	r28
    1b0e:	cd b7       	in	r28, 0x3d	; 61
    1b10:	de b7       	in	r29, 0x3e	; 62
    1b12:	60 97       	sbiw	r28, 0x10	; 16
    1b14:	0f b6       	in	r0, 0x3f	; 63
    1b16:	f8 94       	cli
    1b18:	de bf       	out	0x3e, r29	; 62
    1b1a:	0f be       	out	0x3f, r0	; 63
    1b1c:	cd bf       	out	0x3d, r28	; 61
    1b1e:	9a 87       	std	Y+10, r25	; 0x0a
    1b20:	89 87       	std	Y+9, r24	; 0x09
    1b22:	7c 87       	std	Y+12, r23	; 0x0c
    1b24:	6b 87       	std	Y+11, r22	; 0x0b
    1b26:	5e 87       	std	Y+14, r21	; 0x0e
    1b28:	4d 87       	std	Y+13, r20	; 0x0d
    1b2a:	38 8b       	std	Y+16, r19	; 0x10
    1b2c:	2f 87       	std	Y+15, r18	; 0x0f
    EventBits_t uxOriginalBitValue, uxReturn;
    EventGroup_t * pxEventBits = xEventGroup;
    1b2e:	89 85       	ldd	r24, Y+9	; 0x09
    1b30:	9a 85       	ldd	r25, Y+10	; 0x0a
    1b32:	9c 83       	std	Y+4, r25	; 0x04
    1b34:	8b 83       	std	Y+3, r24	; 0x03
    BaseType_t xAlreadyYielded;
    BaseType_t xTimeoutOccurred = pdFALSE;
    1b36:	19 82       	std	Y+1, r1	; 0x01
        {
            configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
        }
    #endif

    vTaskSuspendAll();
    1b38:	0e 94 88 1e 	call	0x3d10	; 0x3d10 <vTaskSuspendAll>
    {
        uxOriginalBitValue = pxEventBits->uxEventBits;
    1b3c:	eb 81       	ldd	r30, Y+3	; 0x03
    1b3e:	fc 81       	ldd	r31, Y+4	; 0x04
    1b40:	80 81       	ld	r24, Z
    1b42:	91 81       	ldd	r25, Z+1	; 0x01
    1b44:	98 87       	std	Y+8, r25	; 0x08
    1b46:	8f 83       	std	Y+7, r24	; 0x07

        ( void ) xEventGroupSetBits( xEventGroup, uxBitsToSet );
    1b48:	89 85       	ldd	r24, Y+9	; 0x09
    1b4a:	9a 85       	ldd	r25, Y+10	; 0x0a
    1b4c:	2b 85       	ldd	r18, Y+11	; 0x0b
    1b4e:	3c 85       	ldd	r19, Y+12	; 0x0c
    1b50:	b9 01       	movw	r22, r18
    1b52:	0e 94 5c 0f 	call	0x1eb8	; 0x1eb8 <xEventGroupSetBits>

        if( ( ( uxOriginalBitValue | uxBitsToSet ) & uxBitsToWaitFor ) == uxBitsToWaitFor )
    1b56:	2f 81       	ldd	r18, Y+7	; 0x07
    1b58:	38 85       	ldd	r19, Y+8	; 0x08
    1b5a:	8b 85       	ldd	r24, Y+11	; 0x0b
    1b5c:	9c 85       	ldd	r25, Y+12	; 0x0c
    1b5e:	28 2b       	or	r18, r24
    1b60:	39 2b       	or	r19, r25
    1b62:	8d 85       	ldd	r24, Y+13	; 0x0d
    1b64:	9e 85       	ldd	r25, Y+14	; 0x0e
    1b66:	28 23       	and	r18, r24
    1b68:	39 23       	and	r19, r25
    1b6a:	8d 85       	ldd	r24, Y+13	; 0x0d
    1b6c:	9e 85       	ldd	r25, Y+14	; 0x0e
    1b6e:	28 17       	cp	r18, r24
    1b70:	39 07       	cpc	r19, r25
    1b72:	c9 f4       	brne	.+50     	; 0x1ba6 <xEventGroupSync+0x9c>
        {
            /* All the rendezvous bits are now set - no need to block. */
            uxReturn = ( uxOriginalBitValue | uxBitsToSet );
    1b74:	2f 81       	ldd	r18, Y+7	; 0x07
    1b76:	38 85       	ldd	r19, Y+8	; 0x08
    1b78:	8b 85       	ldd	r24, Y+11	; 0x0b
    1b7a:	9c 85       	ldd	r25, Y+12	; 0x0c
    1b7c:	82 2b       	or	r24, r18
    1b7e:	93 2b       	or	r25, r19
    1b80:	9e 83       	std	Y+6, r25	; 0x06
    1b82:	8d 83       	std	Y+5, r24	; 0x05

            /* Rendezvous always clear the bits.  They will have been cleared
             * already unless this is the only task in the rendezvous. */
            pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    1b84:	eb 81       	ldd	r30, Y+3	; 0x03
    1b86:	fc 81       	ldd	r31, Y+4	; 0x04
    1b88:	20 81       	ld	r18, Z
    1b8a:	31 81       	ldd	r19, Z+1	; 0x01
    1b8c:	8d 85       	ldd	r24, Y+13	; 0x0d
    1b8e:	9e 85       	ldd	r25, Y+14	; 0x0e
    1b90:	80 95       	com	r24
    1b92:	90 95       	com	r25
    1b94:	82 23       	and	r24, r18
    1b96:	93 23       	and	r25, r19
    1b98:	eb 81       	ldd	r30, Y+3	; 0x03
    1b9a:	fc 81       	ldd	r31, Y+4	; 0x04
    1b9c:	91 83       	std	Z+1, r25	; 0x01
    1b9e:	80 83       	st	Z, r24

            xTicksToWait = 0;
    1ba0:	18 8a       	std	Y+16, r1	; 0x10
    1ba2:	1f 86       	std	Y+15, r1	; 0x0f
    1ba4:	1e c0       	rjmp	.+60     	; 0x1be2 <xEventGroupSync+0xd8>
        }
        else
        {
            if( xTicksToWait != ( TickType_t ) 0 )
    1ba6:	8f 85       	ldd	r24, Y+15	; 0x0f
    1ba8:	98 89       	ldd	r25, Y+16	; 0x10
    1baa:	00 97       	sbiw	r24, 0x00	; 0
    1bac:	91 f0       	breq	.+36     	; 0x1bd2 <xEventGroupSync+0xc8>
                traceEVENT_GROUP_SYNC_BLOCK( xEventGroup, uxBitsToSet, uxBitsToWaitFor );

                /* Store the bits that the calling task is waiting for in the
                 * task's event list item so the kernel knows when a match is
                 * found.  Then enter the blocked state. */
                vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | eventCLEAR_EVENTS_ON_EXIT_BIT | eventWAIT_FOR_ALL_BITS ), xTicksToWait );
    1bae:	8b 81       	ldd	r24, Y+3	; 0x03
    1bb0:	9c 81       	ldd	r25, Y+4	; 0x04
    1bb2:	bc 01       	movw	r22, r24
    1bb4:	6e 5f       	subi	r22, 0xFE	; 254
    1bb6:	7f 4f       	sbci	r23, 0xFF	; 255
    1bb8:	8d 85       	ldd	r24, Y+13	; 0x0d
    1bba:	9e 85       	ldd	r25, Y+14	; 0x0e
    1bbc:	9c 01       	movw	r18, r24
    1bbe:	35 60       	ori	r19, 0x05	; 5
    1bc0:	4f 85       	ldd	r20, Y+15	; 0x0f
    1bc2:	58 89       	ldd	r21, Y+16	; 0x10
    1bc4:	cb 01       	movw	r24, r22
    1bc6:	b9 01       	movw	r22, r18
    1bc8:	0e 94 87 22 	call	0x450e	; 0x450e <vTaskPlaceOnUnorderedEventList>

                /* This assignment is obsolete as uxReturn will get set after
                 * the task unblocks, but some compilers mistakenly generate a
                 * warning about uxReturn being returned without being set if the
                 * assignment is omitted. */
                uxReturn = 0;
    1bcc:	1e 82       	std	Y+6, r1	; 0x06
    1bce:	1d 82       	std	Y+5, r1	; 0x05
    1bd0:	08 c0       	rjmp	.+16     	; 0x1be2 <xEventGroupSync+0xd8>
            }
            else
            {
                /* The rendezvous bits were not set, but no block time was
                 * specified - just return the current event bit value. */
                uxReturn = pxEventBits->uxEventBits;
    1bd2:	eb 81       	ldd	r30, Y+3	; 0x03
    1bd4:	fc 81       	ldd	r31, Y+4	; 0x04
    1bd6:	80 81       	ld	r24, Z
    1bd8:	91 81       	ldd	r25, Z+1	; 0x01
    1bda:	9e 83       	std	Y+6, r25	; 0x06
    1bdc:	8d 83       	std	Y+5, r24	; 0x05
                xTimeoutOccurred = pdTRUE;
    1bde:	81 e0       	ldi	r24, 0x01	; 1
    1be0:	89 83       	std	Y+1, r24	; 0x01
            }
        }
    }
    xAlreadyYielded = xTaskResumeAll();
    1be2:	0e 94 94 1e 	call	0x3d28	; 0x3d28 <xTaskResumeAll>
    1be6:	8a 83       	std	Y+2, r24	; 0x02

    if( xTicksToWait != ( TickType_t ) 0 )
    1be8:	8f 85       	ldd	r24, Y+15	; 0x0f
    1bea:	98 89       	ldd	r25, Y+16	; 0x10
    1bec:	00 97       	sbiw	r24, 0x00	; 0
    1bee:	09 f4       	brne	.+2      	; 0x1bf2 <xEventGroupSync+0xe8>
    1bf0:	3a c0       	rjmp	.+116    	; 0x1c66 <xEventGroupSync+0x15c>
    {
        if( xAlreadyYielded == pdFALSE )
    1bf2:	8a 81       	ldd	r24, Y+2	; 0x02
    1bf4:	88 23       	and	r24, r24
    1bf6:	11 f4       	brne	.+4      	; 0x1bfc <xEventGroupSync+0xf2>
        {
            portYIELD_WITHIN_API();
    1bf8:	0e 94 72 09 	call	0x12e4	; 0x12e4 <vPortYield>

        /* The task blocked to wait for its required bits to be set - at this
         * point either the required bits were set or the block time expired.  If
         * the required bits were set they will have been stored in the task's
         * event list item, and they should now be retrieved then cleared. */
        uxReturn = uxTaskResetEventItemValue();
    1bfc:	0e 94 15 27 	call	0x4e2a	; 0x4e2a <uxTaskResetEventItemValue>
    1c00:	9e 83       	std	Y+6, r25	; 0x06
    1c02:	8d 83       	std	Y+5, r24	; 0x05

        if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
    1c04:	8d 81       	ldd	r24, Y+5	; 0x05
    1c06:	9e 81       	ldd	r25, Y+6	; 0x06
    1c08:	80 70       	andi	r24, 0x00	; 0
    1c0a:	92 70       	andi	r25, 0x02	; 2
    1c0c:	00 97       	sbiw	r24, 0x00	; 0
    1c0e:	31 f5       	brne	.+76     	; 0x1c5c <xEventGroupSync+0x152>
        {
            /* The task timed out, just return the current event bit value. */
            taskENTER_CRITICAL();
    1c10:	0f b6       	in	r0, 0x3f	; 63
    1c12:	f8 94       	cli
    1c14:	0f 92       	push	r0
            {
                uxReturn = pxEventBits->uxEventBits;
    1c16:	eb 81       	ldd	r30, Y+3	; 0x03
    1c18:	fc 81       	ldd	r31, Y+4	; 0x04
    1c1a:	80 81       	ld	r24, Z
    1c1c:	91 81       	ldd	r25, Z+1	; 0x01
    1c1e:	9e 83       	std	Y+6, r25	; 0x06
    1c20:	8d 83       	std	Y+5, r24	; 0x05

                /* Although the task got here because it timed out before the
                 * bits it was waiting for were set, it is possible that since it
                 * unblocked another task has set the bits.  If this is the case
                 * then it needs to clear the bits before exiting. */
                if( ( uxReturn & uxBitsToWaitFor ) == uxBitsToWaitFor )
    1c22:	2d 81       	ldd	r18, Y+5	; 0x05
    1c24:	3e 81       	ldd	r19, Y+6	; 0x06
    1c26:	8d 85       	ldd	r24, Y+13	; 0x0d
    1c28:	9e 85       	ldd	r25, Y+14	; 0x0e
    1c2a:	28 23       	and	r18, r24
    1c2c:	39 23       	and	r19, r25
    1c2e:	8d 85       	ldd	r24, Y+13	; 0x0d
    1c30:	9e 85       	ldd	r25, Y+14	; 0x0e
    1c32:	28 17       	cp	r18, r24
    1c34:	39 07       	cpc	r19, r25
    1c36:	71 f4       	brne	.+28     	; 0x1c54 <xEventGroupSync+0x14a>
                {
                    pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    1c38:	eb 81       	ldd	r30, Y+3	; 0x03
    1c3a:	fc 81       	ldd	r31, Y+4	; 0x04
    1c3c:	20 81       	ld	r18, Z
    1c3e:	31 81       	ldd	r19, Z+1	; 0x01
    1c40:	8d 85       	ldd	r24, Y+13	; 0x0d
    1c42:	9e 85       	ldd	r25, Y+14	; 0x0e
    1c44:	80 95       	com	r24
    1c46:	90 95       	com	r25
    1c48:	82 23       	and	r24, r18
    1c4a:	93 23       	and	r25, r19
    1c4c:	eb 81       	ldd	r30, Y+3	; 0x03
    1c4e:	fc 81       	ldd	r31, Y+4	; 0x04
    1c50:	91 83       	std	Z+1, r25	; 0x01
    1c52:	80 83       	st	Z, r24
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }
            }
            taskEXIT_CRITICAL();
    1c54:	0f 90       	pop	r0
    1c56:	0f be       	out	0x3f, r0	; 63

            xTimeoutOccurred = pdTRUE;
    1c58:	81 e0       	ldi	r24, 0x01	; 1
    1c5a:	89 83       	std	Y+1, r24	; 0x01
            /* The task unblocked because the bits were set. */
        }

        /* Control bits might be set as the task had blocked should not be
         * returned. */
        uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
    1c5c:	8d 81       	ldd	r24, Y+5	; 0x05
    1c5e:	9e 81       	ldd	r25, Y+6	; 0x06
    1c60:	90 70       	andi	r25, 0x00	; 0
    1c62:	9e 83       	std	Y+6, r25	; 0x06
    1c64:	8d 83       	std	Y+5, r24	; 0x05
    traceEVENT_GROUP_SYNC_END( xEventGroup, uxBitsToSet, uxBitsToWaitFor, xTimeoutOccurred );

    /* Prevent compiler warnings when trace macros are not used. */
    ( void ) xTimeoutOccurred;

    return uxReturn;
    1c66:	8d 81       	ldd	r24, Y+5	; 0x05
    1c68:	9e 81       	ldd	r25, Y+6	; 0x06
}
    1c6a:	60 96       	adiw	r28, 0x10	; 16
    1c6c:	0f b6       	in	r0, 0x3f	; 63
    1c6e:	f8 94       	cli
    1c70:	de bf       	out	0x3e, r29	; 62
    1c72:	0f be       	out	0x3f, r0	; 63
    1c74:	cd bf       	out	0x3d, r28	; 61
    1c76:	cf 91       	pop	r28
    1c78:	df 91       	pop	r29
    1c7a:	08 95       	ret

00001c7c <xEventGroupWaitBits>:
EventBits_t xEventGroupWaitBits( EventGroupHandle_t xEventGroup,
                                 const EventBits_t uxBitsToWaitFor,
                                 const BaseType_t xClearOnExit,
                                 const BaseType_t xWaitForAllBits,
                                 TickType_t xTicksToWait )
{
    1c7c:	0f 93       	push	r16
    1c7e:	1f 93       	push	r17
    1c80:	df 93       	push	r29
    1c82:	cf 93       	push	r28
    1c84:	cd b7       	in	r28, 0x3d	; 61
    1c86:	de b7       	in	r29, 0x3e	; 62
    1c88:	63 97       	sbiw	r28, 0x13	; 19
    1c8a:	0f b6       	in	r0, 0x3f	; 63
    1c8c:	f8 94       	cli
    1c8e:	de bf       	out	0x3e, r29	; 62
    1c90:	0f be       	out	0x3f, r0	; 63
    1c92:	cd bf       	out	0x3d, r28	; 61
    1c94:	9d 87       	std	Y+13, r25	; 0x0d
    1c96:	8c 87       	std	Y+12, r24	; 0x0c
    1c98:	7f 87       	std	Y+15, r23	; 0x0f
    1c9a:	6e 87       	std	Y+14, r22	; 0x0e
    1c9c:	48 8b       	std	Y+16, r20	; 0x10
    1c9e:	29 8b       	std	Y+17, r18	; 0x11
    1ca0:	1b 8b       	std	Y+19, r17	; 0x13
    1ca2:	0a 8b       	std	Y+18, r16	; 0x12
    EventGroup_t * pxEventBits = xEventGroup;
    1ca4:	8c 85       	ldd	r24, Y+12	; 0x0c
    1ca6:	9d 85       	ldd	r25, Y+13	; 0x0d
    1ca8:	9b 87       	std	Y+11, r25	; 0x0b
    1caa:	8a 87       	std	Y+10, r24	; 0x0a
    EventBits_t uxReturn, uxControlBits = 0;
    1cac:	1f 82       	std	Y+7, r1	; 0x07
    1cae:	1e 82       	std	Y+6, r1	; 0x06
    BaseType_t xWaitConditionMet, xAlreadyYielded;
    BaseType_t xTimeoutOccurred = pdFALSE;
    1cb0:	1b 82       	std	Y+3, r1	; 0x03
        {
            configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
        }
    #endif

    vTaskSuspendAll();
    1cb2:	0e 94 88 1e 	call	0x3d10	; 0x3d10 <vTaskSuspendAll>
    {
        const EventBits_t uxCurrentEventBits = pxEventBits->uxEventBits;
    1cb6:	ea 85       	ldd	r30, Y+10	; 0x0a
    1cb8:	fb 85       	ldd	r31, Y+11	; 0x0b
    1cba:	80 81       	ld	r24, Z
    1cbc:	91 81       	ldd	r25, Z+1	; 0x01
    1cbe:	9a 83       	std	Y+2, r25	; 0x02
    1cc0:	89 83       	std	Y+1, r24	; 0x01

        /* Check to see if the wait condition is already met or not. */
        xWaitConditionMet = prvTestWaitCondition( uxCurrentEventBits, uxBitsToWaitFor, xWaitForAllBits );
    1cc2:	89 81       	ldd	r24, Y+1	; 0x01
    1cc4:	9a 81       	ldd	r25, Y+2	; 0x02
    1cc6:	2e 85       	ldd	r18, Y+14	; 0x0e
    1cc8:	3f 85       	ldd	r19, Y+15	; 0x0f
    1cca:	b9 01       	movw	r22, r18
    1ccc:	49 89       	ldd	r20, Y+17	; 0x11
    1cce:	0e 94 79 10 	call	0x20f2	; 0x20f2 <prvTestWaitCondition>
    1cd2:	8d 83       	std	Y+5, r24	; 0x05

        if( xWaitConditionMet != pdFALSE )
    1cd4:	8d 81       	ldd	r24, Y+5	; 0x05
    1cd6:	88 23       	and	r24, r24
    1cd8:	c1 f0       	breq	.+48     	; 0x1d0a <xEventGroupWaitBits+0x8e>
        {
            /* The wait condition has already been met so there is no need to
             * block. */
            uxReturn = uxCurrentEventBits;
    1cda:	89 81       	ldd	r24, Y+1	; 0x01
    1cdc:	9a 81       	ldd	r25, Y+2	; 0x02
    1cde:	99 87       	std	Y+9, r25	; 0x09
    1ce0:	88 87       	std	Y+8, r24	; 0x08
            xTicksToWait = ( TickType_t ) 0;
    1ce2:	1b 8a       	std	Y+19, r1	; 0x13
    1ce4:	1a 8a       	std	Y+18, r1	; 0x12

            /* Clear the wait bits if requested to do so. */
            if( xClearOnExit != pdFALSE )
    1ce6:	88 89       	ldd	r24, Y+16	; 0x10
    1ce8:	88 23       	and	r24, r24
    1cea:	e9 f1       	breq	.+122    	; 0x1d66 <xEventGroupWaitBits+0xea>
            {
                pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    1cec:	ea 85       	ldd	r30, Y+10	; 0x0a
    1cee:	fb 85       	ldd	r31, Y+11	; 0x0b
    1cf0:	20 81       	ld	r18, Z
    1cf2:	31 81       	ldd	r19, Z+1	; 0x01
    1cf4:	8e 85       	ldd	r24, Y+14	; 0x0e
    1cf6:	9f 85       	ldd	r25, Y+15	; 0x0f
    1cf8:	80 95       	com	r24
    1cfa:	90 95       	com	r25
    1cfc:	82 23       	and	r24, r18
    1cfe:	93 23       	and	r25, r19
    1d00:	ea 85       	ldd	r30, Y+10	; 0x0a
    1d02:	fb 85       	ldd	r31, Y+11	; 0x0b
    1d04:	91 83       	std	Z+1, r25	; 0x01
    1d06:	80 83       	st	Z, r24
    1d08:	2e c0       	rjmp	.+92     	; 0x1d66 <xEventGroupWaitBits+0xea>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        else if( xTicksToWait == ( TickType_t ) 0 )
    1d0a:	8a 89       	ldd	r24, Y+18	; 0x12
    1d0c:	9b 89       	ldd	r25, Y+19	; 0x13
    1d0e:	00 97       	sbiw	r24, 0x00	; 0
    1d10:	39 f4       	brne	.+14     	; 0x1d20 <xEventGroupWaitBits+0xa4>
        {
            /* The wait condition has not been met, but no block time was
             * specified, so just return the current value. */
            uxReturn = uxCurrentEventBits;
    1d12:	89 81       	ldd	r24, Y+1	; 0x01
    1d14:	9a 81       	ldd	r25, Y+2	; 0x02
    1d16:	99 87       	std	Y+9, r25	; 0x09
    1d18:	88 87       	std	Y+8, r24	; 0x08
            xTimeoutOccurred = pdTRUE;
    1d1a:	81 e0       	ldi	r24, 0x01	; 1
    1d1c:	8b 83       	std	Y+3, r24	; 0x03
    1d1e:	23 c0       	rjmp	.+70     	; 0x1d66 <xEventGroupWaitBits+0xea>
        {
            /* The task is going to block to wait for its required bits to be
             * set.  uxControlBits are used to remember the specified behaviour of
             * this call to xEventGroupWaitBits() - for use when the event bits
             * unblock the task. */
            if( xClearOnExit != pdFALSE )
    1d20:	88 89       	ldd	r24, Y+16	; 0x10
    1d22:	88 23       	and	r24, r24
    1d24:	29 f0       	breq	.+10     	; 0x1d30 <xEventGroupWaitBits+0xb4>
            {
                uxControlBits |= eventCLEAR_EVENTS_ON_EXIT_BIT;
    1d26:	8e 81       	ldd	r24, Y+6	; 0x06
    1d28:	9f 81       	ldd	r25, Y+7	; 0x07
    1d2a:	91 60       	ori	r25, 0x01	; 1
    1d2c:	9f 83       	std	Y+7, r25	; 0x07
    1d2e:	8e 83       	std	Y+6, r24	; 0x06
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }

            if( xWaitForAllBits != pdFALSE )
    1d30:	89 89       	ldd	r24, Y+17	; 0x11
    1d32:	88 23       	and	r24, r24
    1d34:	29 f0       	breq	.+10     	; 0x1d40 <xEventGroupWaitBits+0xc4>
            {
                uxControlBits |= eventWAIT_FOR_ALL_BITS;
    1d36:	8e 81       	ldd	r24, Y+6	; 0x06
    1d38:	9f 81       	ldd	r25, Y+7	; 0x07
    1d3a:	94 60       	ori	r25, 0x04	; 4
    1d3c:	9f 83       	std	Y+7, r25	; 0x07
    1d3e:	8e 83       	std	Y+6, r24	; 0x06
            }

            /* Store the bits that the calling task is waiting for in the
             * task's event list item so the kernel knows when a match is
             * found.  Then enter the blocked state. */
            vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | uxControlBits ), xTicksToWait );
    1d40:	8a 85       	ldd	r24, Y+10	; 0x0a
    1d42:	9b 85       	ldd	r25, Y+11	; 0x0b
    1d44:	bc 01       	movw	r22, r24
    1d46:	6e 5f       	subi	r22, 0xFE	; 254
    1d48:	7f 4f       	sbci	r23, 0xFF	; 255
    1d4a:	2e 85       	ldd	r18, Y+14	; 0x0e
    1d4c:	3f 85       	ldd	r19, Y+15	; 0x0f
    1d4e:	8e 81       	ldd	r24, Y+6	; 0x06
    1d50:	9f 81       	ldd	r25, Y+7	; 0x07
    1d52:	28 2b       	or	r18, r24
    1d54:	39 2b       	or	r19, r25
    1d56:	4a 89       	ldd	r20, Y+18	; 0x12
    1d58:	5b 89       	ldd	r21, Y+19	; 0x13
    1d5a:	cb 01       	movw	r24, r22
    1d5c:	b9 01       	movw	r22, r18
    1d5e:	0e 94 87 22 	call	0x450e	; 0x450e <vTaskPlaceOnUnorderedEventList>

            /* This is obsolete as it will get set after the task unblocks, but
             * some compilers mistakenly generate a warning about the variable
             * being returned without being set if it is not done. */
            uxReturn = 0;
    1d62:	19 86       	std	Y+9, r1	; 0x09
    1d64:	18 86       	std	Y+8, r1	; 0x08

            traceEVENT_GROUP_WAIT_BITS_BLOCK( xEventGroup, uxBitsToWaitFor );
        }
    }
    xAlreadyYielded = xTaskResumeAll();
    1d66:	0e 94 94 1e 	call	0x3d28	; 0x3d28 <xTaskResumeAll>
    1d6a:	8c 83       	std	Y+4, r24	; 0x04

    if( xTicksToWait != ( TickType_t ) 0 )
    1d6c:	8a 89       	ldd	r24, Y+18	; 0x12
    1d6e:	9b 89       	ldd	r25, Y+19	; 0x13
    1d70:	00 97       	sbiw	r24, 0x00	; 0
    1d72:	09 f4       	brne	.+2      	; 0x1d76 <xEventGroupWaitBits+0xfa>
    1d74:	3c c0       	rjmp	.+120    	; 0x1dee <xEventGroupWaitBits+0x172>
    {
        if( xAlreadyYielded == pdFALSE )
    1d76:	8c 81       	ldd	r24, Y+4	; 0x04
    1d78:	88 23       	and	r24, r24
    1d7a:	11 f4       	brne	.+4      	; 0x1d80 <xEventGroupWaitBits+0x104>
        {
            portYIELD_WITHIN_API();
    1d7c:	0e 94 72 09 	call	0x12e4	; 0x12e4 <vPortYield>

        /* The task blocked to wait for its required bits to be set - at this
         * point either the required bits were set or the block time expired.  If
         * the required bits were set they will have been stored in the task's
         * event list item, and they should now be retrieved then cleared. */
        uxReturn = uxTaskResetEventItemValue();
    1d80:	0e 94 15 27 	call	0x4e2a	; 0x4e2a <uxTaskResetEventItemValue>
    1d84:	99 87       	std	Y+9, r25	; 0x09
    1d86:	88 87       	std	Y+8, r24	; 0x08

        if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
    1d88:	88 85       	ldd	r24, Y+8	; 0x08
    1d8a:	99 85       	ldd	r25, Y+9	; 0x09
    1d8c:	80 70       	andi	r24, 0x00	; 0
    1d8e:	92 70       	andi	r25, 0x02	; 2
    1d90:	00 97       	sbiw	r24, 0x00	; 0
    1d92:	41 f5       	brne	.+80     	; 0x1de4 <xEventGroupWaitBits+0x168>
        {
            taskENTER_CRITICAL();
    1d94:	0f b6       	in	r0, 0x3f	; 63
    1d96:	f8 94       	cli
    1d98:	0f 92       	push	r0
            {
                /* The task timed out, just return the current event bit value. */
                uxReturn = pxEventBits->uxEventBits;
    1d9a:	ea 85       	ldd	r30, Y+10	; 0x0a
    1d9c:	fb 85       	ldd	r31, Y+11	; 0x0b
    1d9e:	80 81       	ld	r24, Z
    1da0:	91 81       	ldd	r25, Z+1	; 0x01
    1da2:	99 87       	std	Y+9, r25	; 0x09
    1da4:	88 87       	std	Y+8, r24	; 0x08

                /* It is possible that the event bits were updated between this
                 * task leaving the Blocked state and running again. */
                if( prvTestWaitCondition( uxReturn, uxBitsToWaitFor, xWaitForAllBits ) != pdFALSE )
    1da6:	88 85       	ldd	r24, Y+8	; 0x08
    1da8:	99 85       	ldd	r25, Y+9	; 0x09
    1daa:	2e 85       	ldd	r18, Y+14	; 0x0e
    1dac:	3f 85       	ldd	r19, Y+15	; 0x0f
    1dae:	b9 01       	movw	r22, r18
    1db0:	49 89       	ldd	r20, Y+17	; 0x11
    1db2:	0e 94 79 10 	call	0x20f2	; 0x20f2 <prvTestWaitCondition>
    1db6:	88 23       	and	r24, r24
    1db8:	89 f0       	breq	.+34     	; 0x1ddc <xEventGroupWaitBits+0x160>
                {
                    if( xClearOnExit != pdFALSE )
    1dba:	88 89       	ldd	r24, Y+16	; 0x10
    1dbc:	88 23       	and	r24, r24
    1dbe:	71 f0       	breq	.+28     	; 0x1ddc <xEventGroupWaitBits+0x160>
                    {
                        pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    1dc0:	ea 85       	ldd	r30, Y+10	; 0x0a
    1dc2:	fb 85       	ldd	r31, Y+11	; 0x0b
    1dc4:	20 81       	ld	r18, Z
    1dc6:	31 81       	ldd	r19, Z+1	; 0x01
    1dc8:	8e 85       	ldd	r24, Y+14	; 0x0e
    1dca:	9f 85       	ldd	r25, Y+15	; 0x0f
    1dcc:	80 95       	com	r24
    1dce:	90 95       	com	r25
    1dd0:	82 23       	and	r24, r18
    1dd2:	93 23       	and	r25, r19
    1dd4:	ea 85       	ldd	r30, Y+10	; 0x0a
    1dd6:	fb 85       	ldd	r31, Y+11	; 0x0b
    1dd8:	91 83       	std	Z+1, r25	; 0x01
    1dda:	80 83       	st	Z, r24
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                xTimeoutOccurred = pdTRUE;
    1ddc:	81 e0       	ldi	r24, 0x01	; 1
    1dde:	8b 83       	std	Y+3, r24	; 0x03
            }
            taskEXIT_CRITICAL();
    1de0:	0f 90       	pop	r0
    1de2:	0f be       	out	0x3f, r0	; 63
        {
            /* The task unblocked because the bits were set. */
        }

        /* The task blocked so control bits may have been set. */
        uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
    1de4:	88 85       	ldd	r24, Y+8	; 0x08
    1de6:	99 85       	ldd	r25, Y+9	; 0x09
    1de8:	90 70       	andi	r25, 0x00	; 0
    1dea:	99 87       	std	Y+9, r25	; 0x09
    1dec:	88 87       	std	Y+8, r24	; 0x08
    traceEVENT_GROUP_WAIT_BITS_END( xEventGroup, uxBitsToWaitFor, xTimeoutOccurred );

    /* Prevent compiler warnings when trace macros are not used. */
    ( void ) xTimeoutOccurred;

    return uxReturn;
    1dee:	88 85       	ldd	r24, Y+8	; 0x08
    1df0:	99 85       	ldd	r25, Y+9	; 0x09
}
    1df2:	63 96       	adiw	r28, 0x13	; 19
    1df4:	0f b6       	in	r0, 0x3f	; 63
    1df6:	f8 94       	cli
    1df8:	de bf       	out	0x3e, r29	; 62
    1dfa:	0f be       	out	0x3f, r0	; 63
    1dfc:	cd bf       	out	0x3d, r28	; 61
    1dfe:	cf 91       	pop	r28
    1e00:	df 91       	pop	r29
    1e02:	1f 91       	pop	r17
    1e04:	0f 91       	pop	r16
    1e06:	08 95       	ret

00001e08 <xEventGroupClearBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupClearBits( EventGroupHandle_t xEventGroup,
                                  const EventBits_t uxBitsToClear )
{
    1e08:	df 93       	push	r29
    1e0a:	cf 93       	push	r28
    1e0c:	cd b7       	in	r28, 0x3d	; 61
    1e0e:	de b7       	in	r29, 0x3e	; 62
    1e10:	28 97       	sbiw	r28, 0x08	; 8
    1e12:	0f b6       	in	r0, 0x3f	; 63
    1e14:	f8 94       	cli
    1e16:	de bf       	out	0x3e, r29	; 62
    1e18:	0f be       	out	0x3f, r0	; 63
    1e1a:	cd bf       	out	0x3d, r28	; 61
    1e1c:	9e 83       	std	Y+6, r25	; 0x06
    1e1e:	8d 83       	std	Y+5, r24	; 0x05
    1e20:	78 87       	std	Y+8, r23	; 0x08
    1e22:	6f 83       	std	Y+7, r22	; 0x07
    EventGroup_t * pxEventBits = xEventGroup;
    1e24:	8d 81       	ldd	r24, Y+5	; 0x05
    1e26:	9e 81       	ldd	r25, Y+6	; 0x06
    1e28:	9c 83       	std	Y+4, r25	; 0x04
    1e2a:	8b 83       	std	Y+3, r24	; 0x03
    /* Check the user is not attempting to clear the bits used by the kernel
     * itself. */
    configASSERT( xEventGroup );
    configASSERT( ( uxBitsToClear & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

    taskENTER_CRITICAL();
    1e2c:	0f b6       	in	r0, 0x3f	; 63
    1e2e:	f8 94       	cli
    1e30:	0f 92       	push	r0
    {
        traceEVENT_GROUP_CLEAR_BITS( xEventGroup, uxBitsToClear );

        /* The value returned is the event group value prior to the bits being
         * cleared. */
        uxReturn = pxEventBits->uxEventBits;
    1e32:	eb 81       	ldd	r30, Y+3	; 0x03
    1e34:	fc 81       	ldd	r31, Y+4	; 0x04
    1e36:	80 81       	ld	r24, Z
    1e38:	91 81       	ldd	r25, Z+1	; 0x01
    1e3a:	9a 83       	std	Y+2, r25	; 0x02
    1e3c:	89 83       	std	Y+1, r24	; 0x01

        /* Clear the bits. */
        pxEventBits->uxEventBits &= ~uxBitsToClear;
    1e3e:	eb 81       	ldd	r30, Y+3	; 0x03
    1e40:	fc 81       	ldd	r31, Y+4	; 0x04
    1e42:	20 81       	ld	r18, Z
    1e44:	31 81       	ldd	r19, Z+1	; 0x01
    1e46:	8f 81       	ldd	r24, Y+7	; 0x07
    1e48:	98 85       	ldd	r25, Y+8	; 0x08
    1e4a:	80 95       	com	r24
    1e4c:	90 95       	com	r25
    1e4e:	82 23       	and	r24, r18
    1e50:	93 23       	and	r25, r19
    1e52:	eb 81       	ldd	r30, Y+3	; 0x03
    1e54:	fc 81       	ldd	r31, Y+4	; 0x04
    1e56:	91 83       	std	Z+1, r25	; 0x01
    1e58:	80 83       	st	Z, r24
    }
    taskEXIT_CRITICAL();
    1e5a:	0f 90       	pop	r0
    1e5c:	0f be       	out	0x3f, r0	; 63

    return uxReturn;
    1e5e:	89 81       	ldd	r24, Y+1	; 0x01
    1e60:	9a 81       	ldd	r25, Y+2	; 0x02
}
    1e62:	28 96       	adiw	r28, 0x08	; 8
    1e64:	0f b6       	in	r0, 0x3f	; 63
    1e66:	f8 94       	cli
    1e68:	de bf       	out	0x3e, r29	; 62
    1e6a:	0f be       	out	0x3f, r0	; 63
    1e6c:	cd bf       	out	0x3d, r28	; 61
    1e6e:	cf 91       	pop	r28
    1e70:	df 91       	pop	r29
    1e72:	08 95       	ret

00001e74 <xEventGroupGetBitsFromISR>:

#endif /* if ( ( configUSE_TRACE_FACILITY == 1 ) && ( INCLUDE_xTimerPendFunctionCall == 1 ) && ( configUSE_TIMERS == 1 ) ) */
/*-----------------------------------------------------------*/

EventBits_t xEventGroupGetBitsFromISR( EventGroupHandle_t xEventGroup )
{
    1e74:	df 93       	push	r29
    1e76:	cf 93       	push	r28
    1e78:	cd b7       	in	r28, 0x3d	; 61
    1e7a:	de b7       	in	r29, 0x3e	; 62
    1e7c:	27 97       	sbiw	r28, 0x07	; 7
    1e7e:	0f b6       	in	r0, 0x3f	; 63
    1e80:	f8 94       	cli
    1e82:	de bf       	out	0x3e, r29	; 62
    1e84:	0f be       	out	0x3f, r0	; 63
    1e86:	cd bf       	out	0x3d, r28	; 61
    1e88:	9f 83       	std	Y+7, r25	; 0x07
    1e8a:	8e 83       	std	Y+6, r24	; 0x06
    UBaseType_t uxSavedInterruptStatus;
    EventGroup_t const * const pxEventBits = xEventGroup;
    1e8c:	8e 81       	ldd	r24, Y+6	; 0x06
    1e8e:	9f 81       	ldd	r25, Y+7	; 0x07
    1e90:	9c 83       	std	Y+4, r25	; 0x04
    1e92:	8b 83       	std	Y+3, r24	; 0x03
    EventBits_t uxReturn;

    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    1e94:	1d 82       	std	Y+5, r1	; 0x05
    {
        uxReturn = pxEventBits->uxEventBits;
    1e96:	eb 81       	ldd	r30, Y+3	; 0x03
    1e98:	fc 81       	ldd	r31, Y+4	; 0x04
    1e9a:	80 81       	ld	r24, Z
    1e9c:	91 81       	ldd	r25, Z+1	; 0x01
    1e9e:	9a 83       	std	Y+2, r25	; 0x02
    1ea0:	89 83       	std	Y+1, r24	; 0x01
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return uxReturn;
    1ea2:	89 81       	ldd	r24, Y+1	; 0x01
    1ea4:	9a 81       	ldd	r25, Y+2	; 0x02
} /*lint !e818 EventGroupHandle_t is a typedef used in other functions to so can't be pointer to const. */
    1ea6:	27 96       	adiw	r28, 0x07	; 7
    1ea8:	0f b6       	in	r0, 0x3f	; 63
    1eaa:	f8 94       	cli
    1eac:	de bf       	out	0x3e, r29	; 62
    1eae:	0f be       	out	0x3f, r0	; 63
    1eb0:	cd bf       	out	0x3d, r28	; 61
    1eb2:	cf 91       	pop	r28
    1eb4:	df 91       	pop	r29
    1eb6:	08 95       	ret

00001eb8 <xEventGroupSetBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup,
                                const EventBits_t uxBitsToSet )
{
    1eb8:	df 93       	push	r29
    1eba:	cf 93       	push	r28
    1ebc:	cd b7       	in	r28, 0x3d	; 61
    1ebe:	de b7       	in	r29, 0x3e	; 62
    1ec0:	65 97       	sbiw	r28, 0x15	; 21
    1ec2:	0f b6       	in	r0, 0x3f	; 63
    1ec4:	f8 94       	cli
    1ec6:	de bf       	out	0x3e, r29	; 62
    1ec8:	0f be       	out	0x3f, r0	; 63
    1eca:	cd bf       	out	0x3d, r28	; 61
    1ecc:	9b 8b       	std	Y+19, r25	; 0x13
    1ece:	8a 8b       	std	Y+18, r24	; 0x12
    1ed0:	7d 8b       	std	Y+21, r23	; 0x15
    1ed2:	6c 8b       	std	Y+20, r22	; 0x14
    ListItem_t * pxListItem, * pxNext;
    ListItem_t const * pxListEnd;
    List_t const * pxList;
    EventBits_t uxBitsToClear = 0, uxBitsWaitedFor, uxControlBits;
    1ed4:	19 86       	std	Y+9, r1	; 0x09
    1ed6:	18 86       	std	Y+8, r1	; 0x08
    EventGroup_t * pxEventBits = xEventGroup;
    1ed8:	8a 89       	ldd	r24, Y+18	; 0x12
    1eda:	9b 89       	ldd	r25, Y+19	; 0x13
    1edc:	9b 83       	std	Y+3, r25	; 0x03
    1ede:	8a 83       	std	Y+2, r24	; 0x02
    BaseType_t xMatchFound = pdFALSE;
    1ee0:	19 82       	std	Y+1, r1	; 0x01
    /* Check the user is not attempting to set the bits used by the kernel
     * itself. */
    configASSERT( xEventGroup );
    configASSERT( ( uxBitsToSet & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

    pxList = &( pxEventBits->xTasksWaitingForBits );
    1ee2:	8a 81       	ldd	r24, Y+2	; 0x02
    1ee4:	9b 81       	ldd	r25, Y+3	; 0x03
    1ee6:	02 96       	adiw	r24, 0x02	; 2
    1ee8:	9b 87       	std	Y+11, r25	; 0x0b
    1eea:	8a 87       	std	Y+10, r24	; 0x0a
    pxListEnd = listGET_END_MARKER( pxList ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1eec:	8a 85       	ldd	r24, Y+10	; 0x0a
    1eee:	9b 85       	ldd	r25, Y+11	; 0x0b
    1ef0:	03 96       	adiw	r24, 0x03	; 3
    1ef2:	9d 87       	std	Y+13, r25	; 0x0d
    1ef4:	8c 87       	std	Y+12, r24	; 0x0c
    vTaskSuspendAll();
    1ef6:	0e 94 88 1e 	call	0x3d10	; 0x3d10 <vTaskSuspendAll>
    {
        traceEVENT_GROUP_SET_BITS( xEventGroup, uxBitsToSet );

        pxListItem = listGET_HEAD_ENTRY( pxList );
    1efa:	ea 85       	ldd	r30, Y+10	; 0x0a
    1efc:	fb 85       	ldd	r31, Y+11	; 0x0b
    1efe:	85 81       	ldd	r24, Z+5	; 0x05
    1f00:	96 81       	ldd	r25, Z+6	; 0x06
    1f02:	99 8b       	std	Y+17, r25	; 0x11
    1f04:	88 8b       	std	Y+16, r24	; 0x10

        /* Set the bits. */
        pxEventBits->uxEventBits |= uxBitsToSet;
    1f06:	ea 81       	ldd	r30, Y+2	; 0x02
    1f08:	fb 81       	ldd	r31, Y+3	; 0x03
    1f0a:	20 81       	ld	r18, Z
    1f0c:	31 81       	ldd	r19, Z+1	; 0x01
    1f0e:	8c 89       	ldd	r24, Y+20	; 0x14
    1f10:	9d 89       	ldd	r25, Y+21	; 0x15
    1f12:	82 2b       	or	r24, r18
    1f14:	93 2b       	or	r25, r19
    1f16:	ea 81       	ldd	r30, Y+2	; 0x02
    1f18:	fb 81       	ldd	r31, Y+3	; 0x03
    1f1a:	91 83       	std	Z+1, r25	; 0x01
    1f1c:	80 83       	st	Z, r24
    1f1e:	59 c0       	rjmp	.+178    	; 0x1fd2 <xEventGroupSetBits+0x11a>

        /* See if the new bit value should unblock any tasks. */
        while( pxListItem != pxListEnd )
        {
            pxNext = listGET_NEXT( pxListItem );
    1f20:	e8 89       	ldd	r30, Y+16	; 0x10
    1f22:	f9 89       	ldd	r31, Y+17	; 0x11
    1f24:	82 81       	ldd	r24, Z+2	; 0x02
    1f26:	93 81       	ldd	r25, Z+3	; 0x03
    1f28:	9f 87       	std	Y+15, r25	; 0x0f
    1f2a:	8e 87       	std	Y+14, r24	; 0x0e
            uxBitsWaitedFor = listGET_LIST_ITEM_VALUE( pxListItem );
    1f2c:	e8 89       	ldd	r30, Y+16	; 0x10
    1f2e:	f9 89       	ldd	r31, Y+17	; 0x11
    1f30:	80 81       	ld	r24, Z
    1f32:	91 81       	ldd	r25, Z+1	; 0x01
    1f34:	9f 83       	std	Y+7, r25	; 0x07
    1f36:	8e 83       	std	Y+6, r24	; 0x06
            xMatchFound = pdFALSE;
    1f38:	19 82       	std	Y+1, r1	; 0x01

            /* Split the bits waited for from the control bits. */
            uxControlBits = uxBitsWaitedFor & eventEVENT_BITS_CONTROL_BYTES;
    1f3a:	8e 81       	ldd	r24, Y+6	; 0x06
    1f3c:	9f 81       	ldd	r25, Y+7	; 0x07
    1f3e:	80 70       	andi	r24, 0x00	; 0
    1f40:	9d 83       	std	Y+5, r25	; 0x05
    1f42:	8c 83       	std	Y+4, r24	; 0x04
            uxBitsWaitedFor &= ~eventEVENT_BITS_CONTROL_BYTES;
    1f44:	8e 81       	ldd	r24, Y+6	; 0x06
    1f46:	9f 81       	ldd	r25, Y+7	; 0x07
    1f48:	90 70       	andi	r25, 0x00	; 0
    1f4a:	9f 83       	std	Y+7, r25	; 0x07
    1f4c:	8e 83       	std	Y+6, r24	; 0x06

            if( ( uxControlBits & eventWAIT_FOR_ALL_BITS ) == ( EventBits_t ) 0 )
    1f4e:	8c 81       	ldd	r24, Y+4	; 0x04
    1f50:	9d 81       	ldd	r25, Y+5	; 0x05
    1f52:	80 70       	andi	r24, 0x00	; 0
    1f54:	94 70       	andi	r25, 0x04	; 4
    1f56:	00 97       	sbiw	r24, 0x00	; 0
    1f58:	69 f4       	brne	.+26     	; 0x1f74 <xEventGroupSetBits+0xbc>
            {
                /* Just looking for single bit being set. */
                if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) != ( EventBits_t ) 0 )
    1f5a:	ea 81       	ldd	r30, Y+2	; 0x02
    1f5c:	fb 81       	ldd	r31, Y+3	; 0x03
    1f5e:	20 81       	ld	r18, Z
    1f60:	31 81       	ldd	r19, Z+1	; 0x01
    1f62:	8e 81       	ldd	r24, Y+6	; 0x06
    1f64:	9f 81       	ldd	r25, Y+7	; 0x07
    1f66:	82 23       	and	r24, r18
    1f68:	93 23       	and	r25, r19
    1f6a:	00 97       	sbiw	r24, 0x00	; 0
    1f6c:	91 f0       	breq	.+36     	; 0x1f92 <xEventGroupSetBits+0xda>
                {
                    xMatchFound = pdTRUE;
    1f6e:	81 e0       	ldi	r24, 0x01	; 1
    1f70:	89 83       	std	Y+1, r24	; 0x01
    1f72:	0f c0       	rjmp	.+30     	; 0x1f92 <xEventGroupSetBits+0xda>
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }
            }
            else if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) == uxBitsWaitedFor )
    1f74:	ea 81       	ldd	r30, Y+2	; 0x02
    1f76:	fb 81       	ldd	r31, Y+3	; 0x03
    1f78:	20 81       	ld	r18, Z
    1f7a:	31 81       	ldd	r19, Z+1	; 0x01
    1f7c:	8e 81       	ldd	r24, Y+6	; 0x06
    1f7e:	9f 81       	ldd	r25, Y+7	; 0x07
    1f80:	28 23       	and	r18, r24
    1f82:	39 23       	and	r19, r25
    1f84:	8e 81       	ldd	r24, Y+6	; 0x06
    1f86:	9f 81       	ldd	r25, Y+7	; 0x07
    1f88:	28 17       	cp	r18, r24
    1f8a:	39 07       	cpc	r19, r25
    1f8c:	11 f4       	brne	.+4      	; 0x1f92 <xEventGroupSetBits+0xda>
            {
                /* All bits are set. */
                xMatchFound = pdTRUE;
    1f8e:	81 e0       	ldi	r24, 0x01	; 1
    1f90:	89 83       	std	Y+1, r24	; 0x01
            else
            {
                /* Need all bits to be set, but not all the bits were set. */
            }

            if( xMatchFound != pdFALSE )
    1f92:	89 81       	ldd	r24, Y+1	; 0x01
    1f94:	88 23       	and	r24, r24
    1f96:	c9 f0       	breq	.+50     	; 0x1fca <xEventGroupSetBits+0x112>
            {
                /* The bits match.  Should the bits be cleared on exit? */
                if( ( uxControlBits & eventCLEAR_EVENTS_ON_EXIT_BIT ) != ( EventBits_t ) 0 )
    1f98:	8c 81       	ldd	r24, Y+4	; 0x04
    1f9a:	9d 81       	ldd	r25, Y+5	; 0x05
    1f9c:	80 70       	andi	r24, 0x00	; 0
    1f9e:	91 70       	andi	r25, 0x01	; 1
    1fa0:	00 97       	sbiw	r24, 0x00	; 0
    1fa2:	41 f0       	breq	.+16     	; 0x1fb4 <xEventGroupSetBits+0xfc>
                {
                    uxBitsToClear |= uxBitsWaitedFor;
    1fa4:	88 85       	ldd	r24, Y+8	; 0x08
    1fa6:	99 85       	ldd	r25, Y+9	; 0x09
    1fa8:	2e 81       	ldd	r18, Y+6	; 0x06
    1faa:	3f 81       	ldd	r19, Y+7	; 0x07
    1fac:	82 2b       	or	r24, r18
    1fae:	93 2b       	or	r25, r19
    1fb0:	99 87       	std	Y+9, r25	; 0x09
    1fb2:	88 87       	std	Y+8, r24	; 0x08
                /* Store the actual event flag value in the task's event list
                 * item before removing the task from the event list.  The
                 * eventUNBLOCKED_DUE_TO_BIT_SET bit is set so the task knows
                 * that is was unblocked due to its required bits matching, rather
                 * than because it timed out. */
                vTaskRemoveFromUnorderedEventList( pxListItem, pxEventBits->uxEventBits | eventUNBLOCKED_DUE_TO_BIT_SET );
    1fb4:	ea 81       	ldd	r30, Y+2	; 0x02
    1fb6:	fb 81       	ldd	r31, Y+3	; 0x03
    1fb8:	80 81       	ld	r24, Z
    1fba:	91 81       	ldd	r25, Z+1	; 0x01
    1fbc:	9c 01       	movw	r18, r24
    1fbe:	32 60       	ori	r19, 0x02	; 2
    1fc0:	88 89       	ldd	r24, Y+16	; 0x10
    1fc2:	99 89       	ldd	r25, Y+17	; 0x11
    1fc4:	b9 01       	movw	r22, r18
    1fc6:	0e 94 92 24 	call	0x4924	; 0x4924 <vTaskRemoveFromUnorderedEventList>
            }

            /* Move onto the next list item.  Note pxListItem->pxNext is not
             * used here as the list item may have been removed from the event list
             * and inserted into the ready/pending reading list. */
            pxListItem = pxNext;
    1fca:	8e 85       	ldd	r24, Y+14	; 0x0e
    1fcc:	9f 85       	ldd	r25, Y+15	; 0x0f
    1fce:	99 8b       	std	Y+17, r25	; 0x11
    1fd0:	88 8b       	std	Y+16, r24	; 0x10

        /* Set the bits. */
        pxEventBits->uxEventBits |= uxBitsToSet;

        /* See if the new bit value should unblock any tasks. */
        while( pxListItem != pxListEnd )
    1fd2:	28 89       	ldd	r18, Y+16	; 0x10
    1fd4:	39 89       	ldd	r19, Y+17	; 0x11
    1fd6:	8c 85       	ldd	r24, Y+12	; 0x0c
    1fd8:	9d 85       	ldd	r25, Y+13	; 0x0d
    1fda:	28 17       	cp	r18, r24
    1fdc:	39 07       	cpc	r19, r25
    1fde:	09 f0       	breq	.+2      	; 0x1fe2 <xEventGroupSetBits+0x12a>
    1fe0:	9f cf       	rjmp	.-194    	; 0x1f20 <xEventGroupSetBits+0x68>
            pxListItem = pxNext;
        }

        /* Clear any bits that matched when the eventCLEAR_EVENTS_ON_EXIT_BIT
         * bit was set in the control word. */
        pxEventBits->uxEventBits &= ~uxBitsToClear;
    1fe2:	ea 81       	ldd	r30, Y+2	; 0x02
    1fe4:	fb 81       	ldd	r31, Y+3	; 0x03
    1fe6:	20 81       	ld	r18, Z
    1fe8:	31 81       	ldd	r19, Z+1	; 0x01
    1fea:	88 85       	ldd	r24, Y+8	; 0x08
    1fec:	99 85       	ldd	r25, Y+9	; 0x09
    1fee:	80 95       	com	r24
    1ff0:	90 95       	com	r25
    1ff2:	82 23       	and	r24, r18
    1ff4:	93 23       	and	r25, r19
    1ff6:	ea 81       	ldd	r30, Y+2	; 0x02
    1ff8:	fb 81       	ldd	r31, Y+3	; 0x03
    1ffa:	91 83       	std	Z+1, r25	; 0x01
    1ffc:	80 83       	st	Z, r24
    }
    ( void ) xTaskResumeAll();
    1ffe:	0e 94 94 1e 	call	0x3d28	; 0x3d28 <xTaskResumeAll>

    return pxEventBits->uxEventBits;
    2002:	ea 81       	ldd	r30, Y+2	; 0x02
    2004:	fb 81       	ldd	r31, Y+3	; 0x03
    2006:	80 81       	ld	r24, Z
    2008:	91 81       	ldd	r25, Z+1	; 0x01
}
    200a:	65 96       	adiw	r28, 0x15	; 21
    200c:	0f b6       	in	r0, 0x3f	; 63
    200e:	f8 94       	cli
    2010:	de bf       	out	0x3e, r29	; 62
    2012:	0f be       	out	0x3f, r0	; 63
    2014:	cd bf       	out	0x3d, r28	; 61
    2016:	cf 91       	pop	r28
    2018:	df 91       	pop	r29
    201a:	08 95       	ret

0000201c <vEventGroupDelete>:
/*-----------------------------------------------------------*/

void vEventGroupDelete( EventGroupHandle_t xEventGroup )
{
    201c:	df 93       	push	r29
    201e:	cf 93       	push	r28
    2020:	00 d0       	rcall	.+0      	; 0x2022 <vEventGroupDelete+0x6>
    2022:	00 d0       	rcall	.+0      	; 0x2024 <vEventGroupDelete+0x8>
    2024:	00 d0       	rcall	.+0      	; 0x2026 <vEventGroupDelete+0xa>
    2026:	cd b7       	in	r28, 0x3d	; 61
    2028:	de b7       	in	r29, 0x3e	; 62
    202a:	9e 83       	std	Y+6, r25	; 0x06
    202c:	8d 83       	std	Y+5, r24	; 0x05
    EventGroup_t * pxEventBits = xEventGroup;
    202e:	8d 81       	ldd	r24, Y+5	; 0x05
    2030:	9e 81       	ldd	r25, Y+6	; 0x06
    2032:	9c 83       	std	Y+4, r25	; 0x04
    2034:	8b 83       	std	Y+3, r24	; 0x03
    const List_t * pxTasksWaitingForBits;

    configASSERT( pxEventBits );

    pxTasksWaitingForBits = &( pxEventBits->xTasksWaitingForBits );
    2036:	8b 81       	ldd	r24, Y+3	; 0x03
    2038:	9c 81       	ldd	r25, Y+4	; 0x04
    203a:	02 96       	adiw	r24, 0x02	; 2
    203c:	9a 83       	std	Y+2, r25	; 0x02
    203e:	89 83       	std	Y+1, r24	; 0x01

    vTaskSuspendAll();
    2040:	0e 94 88 1e 	call	0x3d10	; 0x3d10 <vTaskSuspendAll>
    2044:	08 c0       	rjmp	.+16     	; 0x2056 <vEventGroupDelete+0x3a>
        while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
        {
            /* Unblock the task, returning 0 as the event list is being deleted
             * and cannot therefore have any bits set. */
            configASSERT( pxTasksWaitingForBits->xListEnd.pxNext != ( const ListItem_t * ) &( pxTasksWaitingForBits->xListEnd ) );
            vTaskRemoveFromUnorderedEventList( pxTasksWaitingForBits->xListEnd.pxNext, eventUNBLOCKED_DUE_TO_BIT_SET );
    2046:	e9 81       	ldd	r30, Y+1	; 0x01
    2048:	fa 81       	ldd	r31, Y+2	; 0x02
    204a:	85 81       	ldd	r24, Z+5	; 0x05
    204c:	96 81       	ldd	r25, Z+6	; 0x06
    204e:	60 e0       	ldi	r22, 0x00	; 0
    2050:	72 e0       	ldi	r23, 0x02	; 2
    2052:	0e 94 92 24 	call	0x4924	; 0x4924 <vTaskRemoveFromUnorderedEventList>

    vTaskSuspendAll();
    {
        traceEVENT_GROUP_DELETE( xEventGroup );

        while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
    2056:	e9 81       	ldd	r30, Y+1	; 0x01
    2058:	fa 81       	ldd	r31, Y+2	; 0x02
    205a:	80 81       	ld	r24, Z
    205c:	88 23       	and	r24, r24
    205e:	99 f7       	brne	.-26     	; 0x2046 <vEventGroupDelete+0x2a>

        #if ( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
            {
                /* The event group can only have been allocated dynamically - free
                 * it again. */
                vPortFree( pxEventBits );
    2060:	8b 81       	ldd	r24, Y+3	; 0x03
    2062:	9c 81       	ldd	r25, Y+4	; 0x04
    2064:	0e 94 8d 07 	call	0xf1a	; 0xf1a <vPortFree>
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        #endif /* configSUPPORT_DYNAMIC_ALLOCATION */
    }
    ( void ) xTaskResumeAll();
    2068:	0e 94 94 1e 	call	0x3d28	; 0x3d28 <xTaskResumeAll>
}
    206c:	26 96       	adiw	r28, 0x06	; 6
    206e:	0f b6       	in	r0, 0x3f	; 63
    2070:	f8 94       	cli
    2072:	de bf       	out	0x3e, r29	; 62
    2074:	0f be       	out	0x3f, r0	; 63
    2076:	cd bf       	out	0x3d, r28	; 61
    2078:	cf 91       	pop	r28
    207a:	df 91       	pop	r29
    207c:	08 95       	ret

0000207e <vEventGroupSetBitsCallback>:

/* For internal use only - execute a 'set bits' command that was pended from
 * an interrupt. */
void vEventGroupSetBitsCallback( void * pvEventGroup,
                                 const uint32_t ulBitsToSet )
{
    207e:	df 93       	push	r29
    2080:	cf 93       	push	r28
    2082:	00 d0       	rcall	.+0      	; 0x2084 <vEventGroupSetBitsCallback+0x6>
    2084:	00 d0       	rcall	.+0      	; 0x2086 <vEventGroupSetBitsCallback+0x8>
    2086:	00 d0       	rcall	.+0      	; 0x2088 <vEventGroupSetBitsCallback+0xa>
    2088:	cd b7       	in	r28, 0x3d	; 61
    208a:	de b7       	in	r29, 0x3e	; 62
    208c:	9a 83       	std	Y+2, r25	; 0x02
    208e:	89 83       	std	Y+1, r24	; 0x01
    2090:	4b 83       	std	Y+3, r20	; 0x03
    2092:	5c 83       	std	Y+4, r21	; 0x04
    2094:	6d 83       	std	Y+5, r22	; 0x05
    2096:	7e 83       	std	Y+6, r23	; 0x06
    ( void ) xEventGroupSetBits( pvEventGroup, ( EventBits_t ) ulBitsToSet ); /*lint !e9079 Can't avoid cast to void* as a generic timer callback prototype. Callback casts back to original type so safe. */
    2098:	89 81       	ldd	r24, Y+1	; 0x01
    209a:	9a 81       	ldd	r25, Y+2	; 0x02
    209c:	2b 81       	ldd	r18, Y+3	; 0x03
    209e:	3c 81       	ldd	r19, Y+4	; 0x04
    20a0:	b9 01       	movw	r22, r18
    20a2:	0e 94 5c 0f 	call	0x1eb8	; 0x1eb8 <xEventGroupSetBits>
}
    20a6:	26 96       	adiw	r28, 0x06	; 6
    20a8:	0f b6       	in	r0, 0x3f	; 63
    20aa:	f8 94       	cli
    20ac:	de bf       	out	0x3e, r29	; 62
    20ae:	0f be       	out	0x3f, r0	; 63
    20b0:	cd bf       	out	0x3d, r28	; 61
    20b2:	cf 91       	pop	r28
    20b4:	df 91       	pop	r29
    20b6:	08 95       	ret

000020b8 <vEventGroupClearBitsCallback>:

/* For internal use only - execute a 'clear bits' command that was pended from
 * an interrupt. */
void vEventGroupClearBitsCallback( void * pvEventGroup,
                                   const uint32_t ulBitsToClear )
{
    20b8:	df 93       	push	r29
    20ba:	cf 93       	push	r28
    20bc:	00 d0       	rcall	.+0      	; 0x20be <vEventGroupClearBitsCallback+0x6>
    20be:	00 d0       	rcall	.+0      	; 0x20c0 <vEventGroupClearBitsCallback+0x8>
    20c0:	00 d0       	rcall	.+0      	; 0x20c2 <vEventGroupClearBitsCallback+0xa>
    20c2:	cd b7       	in	r28, 0x3d	; 61
    20c4:	de b7       	in	r29, 0x3e	; 62
    20c6:	9a 83       	std	Y+2, r25	; 0x02
    20c8:	89 83       	std	Y+1, r24	; 0x01
    20ca:	4b 83       	std	Y+3, r20	; 0x03
    20cc:	5c 83       	std	Y+4, r21	; 0x04
    20ce:	6d 83       	std	Y+5, r22	; 0x05
    20d0:	7e 83       	std	Y+6, r23	; 0x06
    ( void ) xEventGroupClearBits( pvEventGroup, ( EventBits_t ) ulBitsToClear ); /*lint !e9079 Can't avoid cast to void* as a generic timer callback prototype. Callback casts back to original type so safe. */
    20d2:	89 81       	ldd	r24, Y+1	; 0x01
    20d4:	9a 81       	ldd	r25, Y+2	; 0x02
    20d6:	2b 81       	ldd	r18, Y+3	; 0x03
    20d8:	3c 81       	ldd	r19, Y+4	; 0x04
    20da:	b9 01       	movw	r22, r18
    20dc:	0e 94 04 0f 	call	0x1e08	; 0x1e08 <xEventGroupClearBits>
}
    20e0:	26 96       	adiw	r28, 0x06	; 6
    20e2:	0f b6       	in	r0, 0x3f	; 63
    20e4:	f8 94       	cli
    20e6:	de bf       	out	0x3e, r29	; 62
    20e8:	0f be       	out	0x3f, r0	; 63
    20ea:	cd bf       	out	0x3d, r28	; 61
    20ec:	cf 91       	pop	r28
    20ee:	df 91       	pop	r29
    20f0:	08 95       	ret

000020f2 <prvTestWaitCondition>:
/*-----------------------------------------------------------*/

static BaseType_t prvTestWaitCondition( const EventBits_t uxCurrentEventBits,
                                        const EventBits_t uxBitsToWaitFor,
                                        const BaseType_t xWaitForAllBits )
{
    20f2:	df 93       	push	r29
    20f4:	cf 93       	push	r28
    20f6:	00 d0       	rcall	.+0      	; 0x20f8 <prvTestWaitCondition+0x6>
    20f8:	00 d0       	rcall	.+0      	; 0x20fa <prvTestWaitCondition+0x8>
    20fa:	00 d0       	rcall	.+0      	; 0x20fc <prvTestWaitCondition+0xa>
    20fc:	cd b7       	in	r28, 0x3d	; 61
    20fe:	de b7       	in	r29, 0x3e	; 62
    2100:	9b 83       	std	Y+3, r25	; 0x03
    2102:	8a 83       	std	Y+2, r24	; 0x02
    2104:	7d 83       	std	Y+5, r23	; 0x05
    2106:	6c 83       	std	Y+4, r22	; 0x04
    2108:	4e 83       	std	Y+6, r20	; 0x06
    BaseType_t xWaitConditionMet = pdFALSE;
    210a:	19 82       	std	Y+1, r1	; 0x01

    if( xWaitForAllBits == pdFALSE )
    210c:	8e 81       	ldd	r24, Y+6	; 0x06
    210e:	88 23       	and	r24, r24
    2110:	59 f4       	brne	.+22     	; 0x2128 <prvTestWaitCondition+0x36>
    {
        /* Task only has to wait for one bit within uxBitsToWaitFor to be
         * set.  Is one already set? */
        if( ( uxCurrentEventBits & uxBitsToWaitFor ) != ( EventBits_t ) 0 )
    2112:	8a 81       	ldd	r24, Y+2	; 0x02
    2114:	9b 81       	ldd	r25, Y+3	; 0x03
    2116:	2c 81       	ldd	r18, Y+4	; 0x04
    2118:	3d 81       	ldd	r19, Y+5	; 0x05
    211a:	82 23       	and	r24, r18
    211c:	93 23       	and	r25, r19
    211e:	00 97       	sbiw	r24, 0x00	; 0
    2120:	81 f0       	breq	.+32     	; 0x2142 <prvTestWaitCondition+0x50>
        {
            xWaitConditionMet = pdTRUE;
    2122:	81 e0       	ldi	r24, 0x01	; 1
    2124:	89 83       	std	Y+1, r24	; 0x01
    2126:	0d c0       	rjmp	.+26     	; 0x2142 <prvTestWaitCondition+0x50>
    }
    else
    {
        /* Task has to wait for all the bits in uxBitsToWaitFor to be set.
         * Are they set already? */
        if( ( uxCurrentEventBits & uxBitsToWaitFor ) == uxBitsToWaitFor )
    2128:	2a 81       	ldd	r18, Y+2	; 0x02
    212a:	3b 81       	ldd	r19, Y+3	; 0x03
    212c:	8c 81       	ldd	r24, Y+4	; 0x04
    212e:	9d 81       	ldd	r25, Y+5	; 0x05
    2130:	28 23       	and	r18, r24
    2132:	39 23       	and	r19, r25
    2134:	8c 81       	ldd	r24, Y+4	; 0x04
    2136:	9d 81       	ldd	r25, Y+5	; 0x05
    2138:	28 17       	cp	r18, r24
    213a:	39 07       	cpc	r19, r25
    213c:	11 f4       	brne	.+4      	; 0x2142 <prvTestWaitCondition+0x50>
        {
            xWaitConditionMet = pdTRUE;
    213e:	81 e0       	ldi	r24, 0x01	; 1
    2140:	89 83       	std	Y+1, r24	; 0x01
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }

    return xWaitConditionMet;
    2142:	89 81       	ldd	r24, Y+1	; 0x01
}
    2144:	26 96       	adiw	r28, 0x06	; 6
    2146:	0f b6       	in	r0, 0x3f	; 63
    2148:	f8 94       	cli
    214a:	de bf       	out	0x3e, r29	; 62
    214c:	0f be       	out	0x3f, r0	; 63
    214e:	cd bf       	out	0x3d, r28	; 61
    2150:	cf 91       	pop	r28
    2152:	df 91       	pop	r29
    2154:	08 95       	ret

00002156 <vListInitialise>:
/*-----------------------------------------------------------
* PUBLIC LIST API documented in list.h
*----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
    2156:	df 93       	push	r29
    2158:	cf 93       	push	r28
    215a:	00 d0       	rcall	.+0      	; 0x215c <vListInitialise+0x6>
    215c:	cd b7       	in	r28, 0x3d	; 61
    215e:	de b7       	in	r29, 0x3e	; 62
    2160:	9a 83       	std	Y+2, r25	; 0x02
    2162:	89 83       	std	Y+1, r24	; 0x01
    /* The list structure contains a list item which is used to mark the
     * end of the list.  To initialise the list the list end is inserted
     * as the only list entry. */
    pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    2164:	89 81       	ldd	r24, Y+1	; 0x01
    2166:	9a 81       	ldd	r25, Y+2	; 0x02
    2168:	03 96       	adiw	r24, 0x03	; 3
    216a:	e9 81       	ldd	r30, Y+1	; 0x01
    216c:	fa 81       	ldd	r31, Y+2	; 0x02
    216e:	92 83       	std	Z+2, r25	; 0x02
    2170:	81 83       	std	Z+1, r24	; 0x01

    /* The list end value is the highest possible value in the list to
     * ensure it remains at the end of the list. */
    pxList->xListEnd.xItemValue = portMAX_DELAY;
    2172:	e9 81       	ldd	r30, Y+1	; 0x01
    2174:	fa 81       	ldd	r31, Y+2	; 0x02
    2176:	8f ef       	ldi	r24, 0xFF	; 255
    2178:	9f ef       	ldi	r25, 0xFF	; 255
    217a:	94 83       	std	Z+4, r25	; 0x04
    217c:	83 83       	std	Z+3, r24	; 0x03

    /* The list end next and previous pointers point to itself so we know
     * when the list is empty. */
    pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );     /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    217e:	89 81       	ldd	r24, Y+1	; 0x01
    2180:	9a 81       	ldd	r25, Y+2	; 0x02
    2182:	03 96       	adiw	r24, 0x03	; 3
    2184:	e9 81       	ldd	r30, Y+1	; 0x01
    2186:	fa 81       	ldd	r31, Y+2	; 0x02
    2188:	96 83       	std	Z+6, r25	; 0x06
    218a:	85 83       	std	Z+5, r24	; 0x05
    pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    218c:	89 81       	ldd	r24, Y+1	; 0x01
    218e:	9a 81       	ldd	r25, Y+2	; 0x02
    2190:	03 96       	adiw	r24, 0x03	; 3
    2192:	e9 81       	ldd	r30, Y+1	; 0x01
    2194:	fa 81       	ldd	r31, Y+2	; 0x02
    2196:	90 87       	std	Z+8, r25	; 0x08
    2198:	87 83       	std	Z+7, r24	; 0x07

    pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    219a:	e9 81       	ldd	r30, Y+1	; 0x01
    219c:	fa 81       	ldd	r31, Y+2	; 0x02
    219e:	10 82       	st	Z, r1

    /* Write known values into the list if
     * configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
    listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
    listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
    21a0:	0f 90       	pop	r0
    21a2:	0f 90       	pop	r0
    21a4:	cf 91       	pop	r28
    21a6:	df 91       	pop	r29
    21a8:	08 95       	ret

000021aa <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
    21aa:	df 93       	push	r29
    21ac:	cf 93       	push	r28
    21ae:	00 d0       	rcall	.+0      	; 0x21b0 <vListInitialiseItem+0x6>
    21b0:	cd b7       	in	r28, 0x3d	; 61
    21b2:	de b7       	in	r29, 0x3e	; 62
    21b4:	9a 83       	std	Y+2, r25	; 0x02
    21b6:	89 83       	std	Y+1, r24	; 0x01
    /* Make sure the list item is not recorded as being on a list. */
    pxItem->pxContainer = NULL;
    21b8:	e9 81       	ldd	r30, Y+1	; 0x01
    21ba:	fa 81       	ldd	r31, Y+2	; 0x02
    21bc:	11 86       	std	Z+9, r1	; 0x09
    21be:	10 86       	std	Z+8, r1	; 0x08

    /* Write known values into the list item if
     * configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
    listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
    listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
    21c0:	0f 90       	pop	r0
    21c2:	0f 90       	pop	r0
    21c4:	cf 91       	pop	r28
    21c6:	df 91       	pop	r29
    21c8:	08 95       	ret

000021ca <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList,
                     ListItem_t * const pxNewListItem )
{
    21ca:	df 93       	push	r29
    21cc:	cf 93       	push	r28
    21ce:	00 d0       	rcall	.+0      	; 0x21d0 <vListInsertEnd+0x6>
    21d0:	00 d0       	rcall	.+0      	; 0x21d2 <vListInsertEnd+0x8>
    21d2:	00 d0       	rcall	.+0      	; 0x21d4 <vListInsertEnd+0xa>
    21d4:	cd b7       	in	r28, 0x3d	; 61
    21d6:	de b7       	in	r29, 0x3e	; 62
    21d8:	9c 83       	std	Y+4, r25	; 0x04
    21da:	8b 83       	std	Y+3, r24	; 0x03
    21dc:	7e 83       	std	Y+6, r23	; 0x06
    21de:	6d 83       	std	Y+5, r22	; 0x05
    ListItem_t * const pxIndex = pxList->pxIndex;
    21e0:	eb 81       	ldd	r30, Y+3	; 0x03
    21e2:	fc 81       	ldd	r31, Y+4	; 0x04
    21e4:	81 81       	ldd	r24, Z+1	; 0x01
    21e6:	92 81       	ldd	r25, Z+2	; 0x02
    21e8:	9a 83       	std	Y+2, r25	; 0x02
    21ea:	89 83       	std	Y+1, r24	; 0x01
    listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

    /* Insert a new list item into pxList, but rather than sort the list,
     * makes the new list item the last item to be removed by a call to
     * listGET_OWNER_OF_NEXT_ENTRY(). */
    pxNewListItem->pxNext = pxIndex;
    21ec:	ed 81       	ldd	r30, Y+5	; 0x05
    21ee:	fe 81       	ldd	r31, Y+6	; 0x06
    21f0:	89 81       	ldd	r24, Y+1	; 0x01
    21f2:	9a 81       	ldd	r25, Y+2	; 0x02
    21f4:	93 83       	std	Z+3, r25	; 0x03
    21f6:	82 83       	std	Z+2, r24	; 0x02
    pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    21f8:	e9 81       	ldd	r30, Y+1	; 0x01
    21fa:	fa 81       	ldd	r31, Y+2	; 0x02
    21fc:	84 81       	ldd	r24, Z+4	; 0x04
    21fe:	95 81       	ldd	r25, Z+5	; 0x05
    2200:	ed 81       	ldd	r30, Y+5	; 0x05
    2202:	fe 81       	ldd	r31, Y+6	; 0x06
    2204:	95 83       	std	Z+5, r25	; 0x05
    2206:	84 83       	std	Z+4, r24	; 0x04

    /* Only used during decision coverage testing. */
    mtCOVERAGE_TEST_DELAY();

    pxIndex->pxPrevious->pxNext = pxNewListItem;
    2208:	e9 81       	ldd	r30, Y+1	; 0x01
    220a:	fa 81       	ldd	r31, Y+2	; 0x02
    220c:	04 80       	ldd	r0, Z+4	; 0x04
    220e:	f5 81       	ldd	r31, Z+5	; 0x05
    2210:	e0 2d       	mov	r30, r0
    2212:	8d 81       	ldd	r24, Y+5	; 0x05
    2214:	9e 81       	ldd	r25, Y+6	; 0x06
    2216:	93 83       	std	Z+3, r25	; 0x03
    2218:	82 83       	std	Z+2, r24	; 0x02
    pxIndex->pxPrevious = pxNewListItem;
    221a:	e9 81       	ldd	r30, Y+1	; 0x01
    221c:	fa 81       	ldd	r31, Y+2	; 0x02
    221e:	8d 81       	ldd	r24, Y+5	; 0x05
    2220:	9e 81       	ldd	r25, Y+6	; 0x06
    2222:	95 83       	std	Z+5, r25	; 0x05
    2224:	84 83       	std	Z+4, r24	; 0x04

    /* Remember which list the item is in. */
    pxNewListItem->pxContainer = pxList;
    2226:	ed 81       	ldd	r30, Y+5	; 0x05
    2228:	fe 81       	ldd	r31, Y+6	; 0x06
    222a:	8b 81       	ldd	r24, Y+3	; 0x03
    222c:	9c 81       	ldd	r25, Y+4	; 0x04
    222e:	91 87       	std	Z+9, r25	; 0x09
    2230:	80 87       	std	Z+8, r24	; 0x08

    ( pxList->uxNumberOfItems )++;
    2232:	eb 81       	ldd	r30, Y+3	; 0x03
    2234:	fc 81       	ldd	r31, Y+4	; 0x04
    2236:	80 81       	ld	r24, Z
    2238:	8f 5f       	subi	r24, 0xFF	; 255
    223a:	eb 81       	ldd	r30, Y+3	; 0x03
    223c:	fc 81       	ldd	r31, Y+4	; 0x04
    223e:	80 83       	st	Z, r24
}
    2240:	26 96       	adiw	r28, 0x06	; 6
    2242:	0f b6       	in	r0, 0x3f	; 63
    2244:	f8 94       	cli
    2246:	de bf       	out	0x3e, r29	; 62
    2248:	0f be       	out	0x3f, r0	; 63
    224a:	cd bf       	out	0x3d, r28	; 61
    224c:	cf 91       	pop	r28
    224e:	df 91       	pop	r29
    2250:	08 95       	ret

00002252 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList,
                  ListItem_t * const pxNewListItem )
{
    2252:	df 93       	push	r29
    2254:	cf 93       	push	r28
    2256:	cd b7       	in	r28, 0x3d	; 61
    2258:	de b7       	in	r29, 0x3e	; 62
    225a:	28 97       	sbiw	r28, 0x08	; 8
    225c:	0f b6       	in	r0, 0x3f	; 63
    225e:	f8 94       	cli
    2260:	de bf       	out	0x3e, r29	; 62
    2262:	0f be       	out	0x3f, r0	; 63
    2264:	cd bf       	out	0x3d, r28	; 61
    2266:	9e 83       	std	Y+6, r25	; 0x06
    2268:	8d 83       	std	Y+5, r24	; 0x05
    226a:	78 87       	std	Y+8, r23	; 0x08
    226c:	6f 83       	std	Y+7, r22	; 0x07
    ListItem_t * pxIterator;
    const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    226e:	ef 81       	ldd	r30, Y+7	; 0x07
    2270:	f8 85       	ldd	r31, Y+8	; 0x08
    2272:	80 81       	ld	r24, Z
    2274:	91 81       	ldd	r25, Z+1	; 0x01
    2276:	9a 83       	std	Y+2, r25	; 0x02
    2278:	89 83       	std	Y+1, r24	; 0x01
     * new list item should be placed after it.  This ensures that TCBs which are
     * stored in ready lists (all of which have the same xItemValue value) get a
     * share of the CPU.  However, if the xItemValue is the same as the back marker
     * the iteration loop below will not end.  Therefore the value is checked
     * first, and the algorithm slightly modified if necessary. */
    if( xValueOfInsertion == portMAX_DELAY )
    227a:	89 81       	ldd	r24, Y+1	; 0x01
    227c:	9a 81       	ldd	r25, Y+2	; 0x02
    227e:	2f ef       	ldi	r18, 0xFF	; 255
    2280:	8f 3f       	cpi	r24, 0xFF	; 255
    2282:	92 07       	cpc	r25, r18
    2284:	39 f4       	brne	.+14     	; 0x2294 <vListInsert+0x42>
    {
        pxIterator = pxList->xListEnd.pxPrevious;
    2286:	ed 81       	ldd	r30, Y+5	; 0x05
    2288:	fe 81       	ldd	r31, Y+6	; 0x06
    228a:	87 81       	ldd	r24, Z+7	; 0x07
    228c:	90 85       	ldd	r25, Z+8	; 0x08
    228e:	9c 83       	std	Y+4, r25	; 0x04
    2290:	8b 83       	std	Y+3, r24	; 0x03
    2292:	18 c0       	rjmp	.+48     	; 0x22c4 <vListInsert+0x72>
        *   5) If the FreeRTOS port supports interrupt nesting then ensure that
        *      the priority of the tick interrupt is at or below
        *      configMAX_SYSCALL_INTERRUPT_PRIORITY.
        **********************************************************************/

        for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
    2294:	8d 81       	ldd	r24, Y+5	; 0x05
    2296:	9e 81       	ldd	r25, Y+6	; 0x06
    2298:	03 96       	adiw	r24, 0x03	; 3
    229a:	9c 83       	std	Y+4, r25	; 0x04
    229c:	8b 83       	std	Y+3, r24	; 0x03
    229e:	06 c0       	rjmp	.+12     	; 0x22ac <vListInsert+0x5a>
    22a0:	eb 81       	ldd	r30, Y+3	; 0x03
    22a2:	fc 81       	ldd	r31, Y+4	; 0x04
    22a4:	82 81       	ldd	r24, Z+2	; 0x02
    22a6:	93 81       	ldd	r25, Z+3	; 0x03
    22a8:	9c 83       	std	Y+4, r25	; 0x04
    22aa:	8b 83       	std	Y+3, r24	; 0x03
    22ac:	eb 81       	ldd	r30, Y+3	; 0x03
    22ae:	fc 81       	ldd	r31, Y+4	; 0x04
    22b0:	02 80       	ldd	r0, Z+2	; 0x02
    22b2:	f3 81       	ldd	r31, Z+3	; 0x03
    22b4:	e0 2d       	mov	r30, r0
    22b6:	20 81       	ld	r18, Z
    22b8:	31 81       	ldd	r19, Z+1	; 0x01
    22ba:	89 81       	ldd	r24, Y+1	; 0x01
    22bc:	9a 81       	ldd	r25, Y+2	; 0x02
    22be:	82 17       	cp	r24, r18
    22c0:	93 07       	cpc	r25, r19
    22c2:	70 f7       	brcc	.-36     	; 0x22a0 <vListInsert+0x4e>
            /* There is nothing to do here, just iterating to the wanted
             * insertion position. */
        }
    }

    pxNewListItem->pxNext = pxIterator->pxNext;
    22c4:	eb 81       	ldd	r30, Y+3	; 0x03
    22c6:	fc 81       	ldd	r31, Y+4	; 0x04
    22c8:	82 81       	ldd	r24, Z+2	; 0x02
    22ca:	93 81       	ldd	r25, Z+3	; 0x03
    22cc:	ef 81       	ldd	r30, Y+7	; 0x07
    22ce:	f8 85       	ldd	r31, Y+8	; 0x08
    22d0:	93 83       	std	Z+3, r25	; 0x03
    22d2:	82 83       	std	Z+2, r24	; 0x02
    pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    22d4:	ef 81       	ldd	r30, Y+7	; 0x07
    22d6:	f8 85       	ldd	r31, Y+8	; 0x08
    22d8:	02 80       	ldd	r0, Z+2	; 0x02
    22da:	f3 81       	ldd	r31, Z+3	; 0x03
    22dc:	e0 2d       	mov	r30, r0
    22de:	8f 81       	ldd	r24, Y+7	; 0x07
    22e0:	98 85       	ldd	r25, Y+8	; 0x08
    22e2:	95 83       	std	Z+5, r25	; 0x05
    22e4:	84 83       	std	Z+4, r24	; 0x04
    pxNewListItem->pxPrevious = pxIterator;
    22e6:	ef 81       	ldd	r30, Y+7	; 0x07
    22e8:	f8 85       	ldd	r31, Y+8	; 0x08
    22ea:	8b 81       	ldd	r24, Y+3	; 0x03
    22ec:	9c 81       	ldd	r25, Y+4	; 0x04
    22ee:	95 83       	std	Z+5, r25	; 0x05
    22f0:	84 83       	std	Z+4, r24	; 0x04
    pxIterator->pxNext = pxNewListItem;
    22f2:	eb 81       	ldd	r30, Y+3	; 0x03
    22f4:	fc 81       	ldd	r31, Y+4	; 0x04
    22f6:	8f 81       	ldd	r24, Y+7	; 0x07
    22f8:	98 85       	ldd	r25, Y+8	; 0x08
    22fa:	93 83       	std	Z+3, r25	; 0x03
    22fc:	82 83       	std	Z+2, r24	; 0x02

    /* Remember which list the item is in.  This allows fast removal of the
     * item later. */
    pxNewListItem->pxContainer = pxList;
    22fe:	ef 81       	ldd	r30, Y+7	; 0x07
    2300:	f8 85       	ldd	r31, Y+8	; 0x08
    2302:	8d 81       	ldd	r24, Y+5	; 0x05
    2304:	9e 81       	ldd	r25, Y+6	; 0x06
    2306:	91 87       	std	Z+9, r25	; 0x09
    2308:	80 87       	std	Z+8, r24	; 0x08

    ( pxList->uxNumberOfItems )++;
    230a:	ed 81       	ldd	r30, Y+5	; 0x05
    230c:	fe 81       	ldd	r31, Y+6	; 0x06
    230e:	80 81       	ld	r24, Z
    2310:	8f 5f       	subi	r24, 0xFF	; 255
    2312:	ed 81       	ldd	r30, Y+5	; 0x05
    2314:	fe 81       	ldd	r31, Y+6	; 0x06
    2316:	80 83       	st	Z, r24
}
    2318:	28 96       	adiw	r28, 0x08	; 8
    231a:	0f b6       	in	r0, 0x3f	; 63
    231c:	f8 94       	cli
    231e:	de bf       	out	0x3e, r29	; 62
    2320:	0f be       	out	0x3f, r0	; 63
    2322:	cd bf       	out	0x3d, r28	; 61
    2324:	cf 91       	pop	r28
    2326:	df 91       	pop	r29
    2328:	08 95       	ret

0000232a <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    232a:	df 93       	push	r29
    232c:	cf 93       	push	r28
    232e:	00 d0       	rcall	.+0      	; 0x2330 <uxListRemove+0x6>
    2330:	00 d0       	rcall	.+0      	; 0x2332 <uxListRemove+0x8>
    2332:	cd b7       	in	r28, 0x3d	; 61
    2334:	de b7       	in	r29, 0x3e	; 62
    2336:	9c 83       	std	Y+4, r25	; 0x04
    2338:	8b 83       	std	Y+3, r24	; 0x03
/* The list item knows which list it is in.  Obtain the list from the list
 * item. */
    List_t * const pxList = pxItemToRemove->pxContainer;
    233a:	eb 81       	ldd	r30, Y+3	; 0x03
    233c:	fc 81       	ldd	r31, Y+4	; 0x04
    233e:	80 85       	ldd	r24, Z+8	; 0x08
    2340:	91 85       	ldd	r25, Z+9	; 0x09
    2342:	9a 83       	std	Y+2, r25	; 0x02
    2344:	89 83       	std	Y+1, r24	; 0x01

    pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    2346:	eb 81       	ldd	r30, Y+3	; 0x03
    2348:	fc 81       	ldd	r31, Y+4	; 0x04
    234a:	a2 81       	ldd	r26, Z+2	; 0x02
    234c:	b3 81       	ldd	r27, Z+3	; 0x03
    234e:	eb 81       	ldd	r30, Y+3	; 0x03
    2350:	fc 81       	ldd	r31, Y+4	; 0x04
    2352:	84 81       	ldd	r24, Z+4	; 0x04
    2354:	95 81       	ldd	r25, Z+5	; 0x05
    2356:	15 96       	adiw	r26, 0x05	; 5
    2358:	9c 93       	st	X, r25
    235a:	8e 93       	st	-X, r24
    235c:	14 97       	sbiw	r26, 0x04	; 4
    pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    235e:	eb 81       	ldd	r30, Y+3	; 0x03
    2360:	fc 81       	ldd	r31, Y+4	; 0x04
    2362:	a4 81       	ldd	r26, Z+4	; 0x04
    2364:	b5 81       	ldd	r27, Z+5	; 0x05
    2366:	eb 81       	ldd	r30, Y+3	; 0x03
    2368:	fc 81       	ldd	r31, Y+4	; 0x04
    236a:	82 81       	ldd	r24, Z+2	; 0x02
    236c:	93 81       	ldd	r25, Z+3	; 0x03
    236e:	13 96       	adiw	r26, 0x03	; 3
    2370:	9c 93       	st	X, r25
    2372:	8e 93       	st	-X, r24
    2374:	12 97       	sbiw	r26, 0x02	; 2

    /* Only used during decision coverage testing. */
    mtCOVERAGE_TEST_DELAY();

    /* Make sure the index is left pointing to a valid item. */
    if( pxList->pxIndex == pxItemToRemove )
    2376:	e9 81       	ldd	r30, Y+1	; 0x01
    2378:	fa 81       	ldd	r31, Y+2	; 0x02
    237a:	21 81       	ldd	r18, Z+1	; 0x01
    237c:	32 81       	ldd	r19, Z+2	; 0x02
    237e:	8b 81       	ldd	r24, Y+3	; 0x03
    2380:	9c 81       	ldd	r25, Y+4	; 0x04
    2382:	28 17       	cp	r18, r24
    2384:	39 07       	cpc	r19, r25
    2386:	41 f4       	brne	.+16     	; 0x2398 <uxListRemove+0x6e>
    {
        pxList->pxIndex = pxItemToRemove->pxPrevious;
    2388:	eb 81       	ldd	r30, Y+3	; 0x03
    238a:	fc 81       	ldd	r31, Y+4	; 0x04
    238c:	84 81       	ldd	r24, Z+4	; 0x04
    238e:	95 81       	ldd	r25, Z+5	; 0x05
    2390:	e9 81       	ldd	r30, Y+1	; 0x01
    2392:	fa 81       	ldd	r31, Y+2	; 0x02
    2394:	92 83       	std	Z+2, r25	; 0x02
    2396:	81 83       	std	Z+1, r24	; 0x01
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    pxItemToRemove->pxContainer = NULL;
    2398:	eb 81       	ldd	r30, Y+3	; 0x03
    239a:	fc 81       	ldd	r31, Y+4	; 0x04
    239c:	11 86       	std	Z+9, r1	; 0x09
    239e:	10 86       	std	Z+8, r1	; 0x08
    ( pxList->uxNumberOfItems )--;
    23a0:	e9 81       	ldd	r30, Y+1	; 0x01
    23a2:	fa 81       	ldd	r31, Y+2	; 0x02
    23a4:	80 81       	ld	r24, Z
    23a6:	81 50       	subi	r24, 0x01	; 1
    23a8:	e9 81       	ldd	r30, Y+1	; 0x01
    23aa:	fa 81       	ldd	r31, Y+2	; 0x02
    23ac:	80 83       	st	Z, r24

    return pxList->uxNumberOfItems;
    23ae:	e9 81       	ldd	r30, Y+1	; 0x01
    23b0:	fa 81       	ldd	r31, Y+2	; 0x02
    23b2:	80 81       	ld	r24, Z
}
    23b4:	0f 90       	pop	r0
    23b6:	0f 90       	pop	r0
    23b8:	0f 90       	pop	r0
    23ba:	0f 90       	pop	r0
    23bc:	cf 91       	pop	r28
    23be:	df 91       	pop	r29
    23c0:	08 95       	ret

000023c2 <xQueueGenericReset>:
    taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue,
                               BaseType_t xNewQueue )
{
    23c2:	df 93       	push	r29
    23c4:	cf 93       	push	r28
    23c6:	00 d0       	rcall	.+0      	; 0x23c8 <xQueueGenericReset+0x6>
    23c8:	00 d0       	rcall	.+0      	; 0x23ca <xQueueGenericReset+0x8>
    23ca:	00 d0       	rcall	.+0      	; 0x23cc <xQueueGenericReset+0xa>
    23cc:	cd b7       	in	r28, 0x3d	; 61
    23ce:	de b7       	in	r29, 0x3e	; 62
    23d0:	9d 83       	std	Y+5, r25	; 0x05
    23d2:	8c 83       	std	Y+4, r24	; 0x04
    23d4:	6e 83       	std	Y+6, r22	; 0x06
    BaseType_t xReturn = pdPASS;
    23d6:	81 e0       	ldi	r24, 0x01	; 1
    23d8:	8b 83       	std	Y+3, r24	; 0x03
    Queue_t * const pxQueue = xQueue;
    23da:	8c 81       	ldd	r24, Y+4	; 0x04
    23dc:	9d 81       	ldd	r25, Y+5	; 0x05
    23de:	9a 83       	std	Y+2, r25	; 0x02
    23e0:	89 83       	std	Y+1, r24	; 0x01

    configASSERT( pxQueue );

    if( ( pxQueue != NULL ) &&
    23e2:	89 81       	ldd	r24, Y+1	; 0x01
    23e4:	9a 81       	ldd	r25, Y+2	; 0x02
    23e6:	00 97       	sbiw	r24, 0x00	; 0
    23e8:	09 f4       	brne	.+2      	; 0x23ec <xQueueGenericReset+0x2a>
    23ea:	8b c0       	rjmp	.+278    	; 0x2502 <xQueueGenericReset+0x140>
    23ec:	e9 81       	ldd	r30, Y+1	; 0x01
    23ee:	fa 81       	ldd	r31, Y+2	; 0x02
    23f0:	83 8d       	ldd	r24, Z+27	; 0x1b
    23f2:	88 23       	and	r24, r24
    23f4:	09 f4       	brne	.+2      	; 0x23f8 <xQueueGenericReset+0x36>
    23f6:	85 c0       	rjmp	.+266    	; 0x2502 <xQueueGenericReset+0x140>
    23f8:	e9 81       	ldd	r30, Y+1	; 0x01
    23fa:	fa 81       	ldd	r31, Y+2	; 0x02
    23fc:	83 8d       	ldd	r24, Z+27	; 0x1b
    23fe:	28 2f       	mov	r18, r24
    2400:	30 e0       	ldi	r19, 0x00	; 0
    2402:	8f ef       	ldi	r24, 0xFF	; 255
    2404:	9f e7       	ldi	r25, 0x7F	; 127
    2406:	b9 01       	movw	r22, r18
    2408:	0e 94 23 49 	call	0x9246	; 0x9246 <__udivmodhi4>
    240c:	cb 01       	movw	r24, r22
    240e:	9c 01       	movw	r18, r24
    2410:	e9 81       	ldd	r30, Y+1	; 0x01
    2412:	fa 81       	ldd	r31, Y+2	; 0x02
    2414:	84 8d       	ldd	r24, Z+28	; 0x1c
    2416:	88 2f       	mov	r24, r24
    2418:	90 e0       	ldi	r25, 0x00	; 0
    241a:	28 17       	cp	r18, r24
    241c:	39 07       	cpc	r19, r25
    241e:	08 f4       	brcc	.+2      	; 0x2422 <xQueueGenericReset+0x60>
    2420:	70 c0       	rjmp	.+224    	; 0x2502 <xQueueGenericReset+0x140>
        ( pxQueue->uxLength >= 1U ) &&
        /* Check for multiplication overflow. */
        ( ( SIZE_MAX / pxQueue->uxLength ) >= pxQueue->uxItemSize ) )
    {
        taskENTER_CRITICAL();
    2422:	0f b6       	in	r0, 0x3f	; 63
    2424:	f8 94       	cli
    2426:	0f 92       	push	r0
        {
            pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    2428:	e9 81       	ldd	r30, Y+1	; 0x01
    242a:	fa 81       	ldd	r31, Y+2	; 0x02
    242c:	40 81       	ld	r20, Z
    242e:	51 81       	ldd	r21, Z+1	; 0x01
    2430:	e9 81       	ldd	r30, Y+1	; 0x01
    2432:	fa 81       	ldd	r31, Y+2	; 0x02
    2434:	83 8d       	ldd	r24, Z+27	; 0x1b
    2436:	28 2f       	mov	r18, r24
    2438:	30 e0       	ldi	r19, 0x00	; 0
    243a:	e9 81       	ldd	r30, Y+1	; 0x01
    243c:	fa 81       	ldd	r31, Y+2	; 0x02
    243e:	84 8d       	ldd	r24, Z+28	; 0x1c
    2440:	88 2f       	mov	r24, r24
    2442:	90 e0       	ldi	r25, 0x00	; 0
    2444:	bc 01       	movw	r22, r24
    2446:	26 9f       	mul	r18, r22
    2448:	c0 01       	movw	r24, r0
    244a:	27 9f       	mul	r18, r23
    244c:	90 0d       	add	r25, r0
    244e:	36 9f       	mul	r19, r22
    2450:	90 0d       	add	r25, r0
    2452:	11 24       	eor	r1, r1
    2454:	84 0f       	add	r24, r20
    2456:	95 1f       	adc	r25, r21
    2458:	e9 81       	ldd	r30, Y+1	; 0x01
    245a:	fa 81       	ldd	r31, Y+2	; 0x02
    245c:	95 83       	std	Z+5, r25	; 0x05
    245e:	84 83       	std	Z+4, r24	; 0x04
            pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    2460:	e9 81       	ldd	r30, Y+1	; 0x01
    2462:	fa 81       	ldd	r31, Y+2	; 0x02
    2464:	12 8e       	std	Z+26, r1	; 0x1a
            pxQueue->pcWriteTo = pxQueue->pcHead;
    2466:	e9 81       	ldd	r30, Y+1	; 0x01
    2468:	fa 81       	ldd	r31, Y+2	; 0x02
    246a:	80 81       	ld	r24, Z
    246c:	91 81       	ldd	r25, Z+1	; 0x01
    246e:	e9 81       	ldd	r30, Y+1	; 0x01
    2470:	fa 81       	ldd	r31, Y+2	; 0x02
    2472:	93 83       	std	Z+3, r25	; 0x03
    2474:	82 83       	std	Z+2, r24	; 0x02
            pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    2476:	e9 81       	ldd	r30, Y+1	; 0x01
    2478:	fa 81       	ldd	r31, Y+2	; 0x02
    247a:	40 81       	ld	r20, Z
    247c:	51 81       	ldd	r21, Z+1	; 0x01
    247e:	e9 81       	ldd	r30, Y+1	; 0x01
    2480:	fa 81       	ldd	r31, Y+2	; 0x02
    2482:	83 8d       	ldd	r24, Z+27	; 0x1b
    2484:	88 2f       	mov	r24, r24
    2486:	90 e0       	ldi	r25, 0x00	; 0
    2488:	9c 01       	movw	r18, r24
    248a:	21 50       	subi	r18, 0x01	; 1
    248c:	30 40       	sbci	r19, 0x00	; 0
    248e:	e9 81       	ldd	r30, Y+1	; 0x01
    2490:	fa 81       	ldd	r31, Y+2	; 0x02
    2492:	84 8d       	ldd	r24, Z+28	; 0x1c
    2494:	88 2f       	mov	r24, r24
    2496:	90 e0       	ldi	r25, 0x00	; 0
    2498:	bc 01       	movw	r22, r24
    249a:	26 9f       	mul	r18, r22
    249c:	c0 01       	movw	r24, r0
    249e:	27 9f       	mul	r18, r23
    24a0:	90 0d       	add	r25, r0
    24a2:	36 9f       	mul	r19, r22
    24a4:	90 0d       	add	r25, r0
    24a6:	11 24       	eor	r1, r1
    24a8:	84 0f       	add	r24, r20
    24aa:	95 1f       	adc	r25, r21
    24ac:	e9 81       	ldd	r30, Y+1	; 0x01
    24ae:	fa 81       	ldd	r31, Y+2	; 0x02
    24b0:	97 83       	std	Z+7, r25	; 0x07
    24b2:	86 83       	std	Z+6, r24	; 0x06
            pxQueue->cRxLock = queueUNLOCKED;
    24b4:	e9 81       	ldd	r30, Y+1	; 0x01
    24b6:	fa 81       	ldd	r31, Y+2	; 0x02
    24b8:	8f ef       	ldi	r24, 0xFF	; 255
    24ba:	85 8f       	std	Z+29, r24	; 0x1d
            pxQueue->cTxLock = queueUNLOCKED;
    24bc:	e9 81       	ldd	r30, Y+1	; 0x01
    24be:	fa 81       	ldd	r31, Y+2	; 0x02
    24c0:	8f ef       	ldi	r24, 0xFF	; 255
    24c2:	86 8f       	std	Z+30, r24	; 0x1e

            if( xNewQueue == pdFALSE )
    24c4:	8e 81       	ldd	r24, Y+6	; 0x06
    24c6:	88 23       	and	r24, r24
    24c8:	79 f4       	brne	.+30     	; 0x24e8 <xQueueGenericReset+0x126>
                /* If there are tasks blocked waiting to read from the queue, then
                 * the tasks will remain blocked as after this function exits the queue
                 * will still be empty.  If there are tasks blocked waiting to write to
                 * the queue, then one should be unblocked as after this function exits
                 * it will be possible to write to it. */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    24ca:	e9 81       	ldd	r30, Y+1	; 0x01
    24cc:	fa 81       	ldd	r31, Y+2	; 0x02
    24ce:	80 85       	ldd	r24, Z+8	; 0x08
    24d0:	88 23       	and	r24, r24
    24d2:	a1 f0       	breq	.+40     	; 0x24fc <xQueueGenericReset+0x13a>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    24d4:	89 81       	ldd	r24, Y+1	; 0x01
    24d6:	9a 81       	ldd	r25, Y+2	; 0x02
    24d8:	08 96       	adiw	r24, 0x08	; 8
    24da:	0e 94 4e 23 	call	0x469c	; 0x469c <xTaskRemoveFromEventList>
    24de:	88 23       	and	r24, r24
    24e0:	69 f0       	breq	.+26     	; 0x24fc <xQueueGenericReset+0x13a>
                    {
                        queueYIELD_IF_USING_PREEMPTION();
    24e2:	0e 94 72 09 	call	0x12e4	; 0x12e4 <vPortYield>
    24e6:	0a c0       	rjmp	.+20     	; 0x24fc <xQueueGenericReset+0x13a>
                }
            }
            else
            {
                /* Ensure the event queues start in the correct state. */
                vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    24e8:	89 81       	ldd	r24, Y+1	; 0x01
    24ea:	9a 81       	ldd	r25, Y+2	; 0x02
    24ec:	08 96       	adiw	r24, 0x08	; 8
    24ee:	0e 94 ab 10 	call	0x2156	; 0x2156 <vListInitialise>
                vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
    24f2:	89 81       	ldd	r24, Y+1	; 0x01
    24f4:	9a 81       	ldd	r25, Y+2	; 0x02
    24f6:	41 96       	adiw	r24, 0x11	; 17
    24f8:	0e 94 ab 10 	call	0x2156	; 0x2156 <vListInitialise>
            }
        }
        taskEXIT_CRITICAL();
    24fc:	0f 90       	pop	r0
    24fe:	0f be       	out	0x3f, r0	; 63
    2500:	01 c0       	rjmp	.+2      	; 0x2504 <xQueueGenericReset+0x142>
    }
    else
    {
        xReturn = pdFAIL;
    2502:	1b 82       	std	Y+3, r1	; 0x03

    configASSERT( xReturn != pdFAIL );

    /* A value is returned for calling semantic consistency with previous
     * versions. */
    return xReturn;
    2504:	8b 81       	ldd	r24, Y+3	; 0x03
}
    2506:	26 96       	adiw	r28, 0x06	; 6
    2508:	0f b6       	in	r0, 0x3f	; 63
    250a:	f8 94       	cli
    250c:	de bf       	out	0x3e, r29	; 62
    250e:	0f be       	out	0x3f, r0	; 63
    2510:	cd bf       	out	0x3d, r28	; 61
    2512:	cf 91       	pop	r28
    2514:	df 91       	pop	r29
    2516:	08 95       	ret

00002518 <xQueueGenericCreate>:
#if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

    QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength,
                                       const UBaseType_t uxItemSize,
                                       const uint8_t ucQueueType )
    {
    2518:	0f 93       	push	r16
    251a:	1f 93       	push	r17
    251c:	df 93       	push	r29
    251e:	cf 93       	push	r28
    2520:	cd b7       	in	r28, 0x3d	; 61
    2522:	de b7       	in	r29, 0x3e	; 62
    2524:	29 97       	sbiw	r28, 0x09	; 9
    2526:	0f b6       	in	r0, 0x3f	; 63
    2528:	f8 94       	cli
    252a:	de bf       	out	0x3e, r29	; 62
    252c:	0f be       	out	0x3f, r0	; 63
    252e:	cd bf       	out	0x3d, r28	; 61
    2530:	8f 83       	std	Y+7, r24	; 0x07
    2532:	68 87       	std	Y+8, r22	; 0x08
    2534:	49 87       	std	Y+9, r20	; 0x09
        Queue_t * pxNewQueue = NULL;
    2536:	1e 82       	std	Y+6, r1	; 0x06
    2538:	1d 82       	std	Y+5, r1	; 0x05
        size_t xQueueSizeInBytes;
        uint8_t * pucQueueStorage;

        if( ( uxQueueLength > ( UBaseType_t ) 0 ) &&
    253a:	8f 81       	ldd	r24, Y+7	; 0x07
    253c:	88 23       	and	r24, r24
    253e:	09 f4       	brne	.+2      	; 0x2542 <xQueueGenericCreate+0x2a>
    2540:	52 c0       	rjmp	.+164    	; 0x25e6 <xQueueGenericCreate+0xce>
    2542:	8f 81       	ldd	r24, Y+7	; 0x07
    2544:	28 2f       	mov	r18, r24
    2546:	30 e0       	ldi	r19, 0x00	; 0
    2548:	8f ef       	ldi	r24, 0xFF	; 255
    254a:	9f e7       	ldi	r25, 0x7F	; 127
    254c:	b9 01       	movw	r22, r18
    254e:	0e 94 23 49 	call	0x9246	; 0x9246 <__udivmodhi4>
    2552:	cb 01       	movw	r24, r22
    2554:	9c 01       	movw	r18, r24
    2556:	88 85       	ldd	r24, Y+8	; 0x08
    2558:	88 2f       	mov	r24, r24
    255a:	90 e0       	ldi	r25, 0x00	; 0
    255c:	28 17       	cp	r18, r24
    255e:	39 07       	cpc	r19, r25
    2560:	08 f4       	brcc	.+2      	; 0x2564 <xQueueGenericCreate+0x4c>
    2562:	41 c0       	rjmp	.+130    	; 0x25e6 <xQueueGenericCreate+0xce>
    2564:	8f 81       	ldd	r24, Y+7	; 0x07
    2566:	28 2f       	mov	r18, r24
    2568:	30 e0       	ldi	r19, 0x00	; 0
    256a:	88 85       	ldd	r24, Y+8	; 0x08
    256c:	88 2f       	mov	r24, r24
    256e:	90 e0       	ldi	r25, 0x00	; 0
    2570:	ac 01       	movw	r20, r24
    2572:	24 9f       	mul	r18, r20
    2574:	c0 01       	movw	r24, r0
    2576:	25 9f       	mul	r18, r21
    2578:	90 0d       	add	r25, r0
    257a:	34 9f       	mul	r19, r20
    257c:	90 0d       	add	r25, r0
    257e:	11 24       	eor	r1, r1
    2580:	5f e7       	ldi	r21, 0x7F	; 127
    2582:	81 3e       	cpi	r24, 0xE1	; 225
    2584:	95 07       	cpc	r25, r21
    2586:	78 f5       	brcc	.+94     	; 0x25e6 <xQueueGenericCreate+0xce>
            ( ( SIZE_MAX - sizeof( Queue_t ) ) >= ( uxQueueLength * uxItemSize ) ) )
        {
            /* Allocate enough space to hold the maximum number of items that
             * can be in the queue at any time.  It is valid for uxItemSize to be
             * zero in the case the queue is used as a semaphore. */
            xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    2588:	8f 81       	ldd	r24, Y+7	; 0x07
    258a:	28 2f       	mov	r18, r24
    258c:	30 e0       	ldi	r19, 0x00	; 0
    258e:	88 85       	ldd	r24, Y+8	; 0x08
    2590:	88 2f       	mov	r24, r24
    2592:	90 e0       	ldi	r25, 0x00	; 0
    2594:	ac 01       	movw	r20, r24
    2596:	24 9f       	mul	r18, r20
    2598:	c0 01       	movw	r24, r0
    259a:	25 9f       	mul	r18, r21
    259c:	90 0d       	add	r25, r0
    259e:	34 9f       	mul	r19, r20
    25a0:	90 0d       	add	r25, r0
    25a2:	11 24       	eor	r1, r1
    25a4:	9c 83       	std	Y+4, r25	; 0x04
    25a6:	8b 83       	std	Y+3, r24	; 0x03
             * alignment requirements of the Queue_t structure - which in this case
             * is an int8_t *.  Therefore, whenever the stack alignment requirements
             * are greater than or equal to the pointer to char requirements the cast
             * is safe.  In other cases alignment requirements are not strict (one or
             * two bytes). */
            pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !e9079 see comment above. */
    25a8:	8b 81       	ldd	r24, Y+3	; 0x03
    25aa:	9c 81       	ldd	r25, Y+4	; 0x04
    25ac:	4f 96       	adiw	r24, 0x1f	; 31
    25ae:	0e 94 33 07 	call	0xe66	; 0xe66 <pvPortMalloc>
    25b2:	9e 83       	std	Y+6, r25	; 0x06
    25b4:	8d 83       	std	Y+5, r24	; 0x05

            if( pxNewQueue != NULL )
    25b6:	8d 81       	ldd	r24, Y+5	; 0x05
    25b8:	9e 81       	ldd	r25, Y+6	; 0x06
    25ba:	00 97       	sbiw	r24, 0x00	; 0
    25bc:	a1 f0       	breq	.+40     	; 0x25e6 <xQueueGenericCreate+0xce>
            {
                /* Jump past the queue structure to find the location of the queue
                 * storage area. */
                pucQueueStorage = ( uint8_t * ) pxNewQueue;
    25be:	8d 81       	ldd	r24, Y+5	; 0x05
    25c0:	9e 81       	ldd	r25, Y+6	; 0x06
    25c2:	9a 83       	std	Y+2, r25	; 0x02
    25c4:	89 83       	std	Y+1, r24	; 0x01
                pucQueueStorage += sizeof( Queue_t ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    25c6:	89 81       	ldd	r24, Y+1	; 0x01
    25c8:	9a 81       	ldd	r25, Y+2	; 0x02
    25ca:	4f 96       	adiw	r24, 0x1f	; 31
    25cc:	9a 83       	std	Y+2, r25	; 0x02
    25ce:	89 83       	std	Y+1, r24	; 0x01
                         * deleted. */
                        pxNewQueue->ucStaticallyAllocated = pdFALSE;
                    }
                #endif /* configSUPPORT_STATIC_ALLOCATION */

                prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
    25d0:	29 81       	ldd	r18, Y+1	; 0x01
    25d2:	3a 81       	ldd	r19, Y+2	; 0x02
    25d4:	ed 81       	ldd	r30, Y+5	; 0x05
    25d6:	fe 81       	ldd	r31, Y+6	; 0x06
    25d8:	8f 81       	ldd	r24, Y+7	; 0x07
    25da:	68 85       	ldd	r22, Y+8	; 0x08
    25dc:	a9 01       	movw	r20, r18
    25de:	29 85       	ldd	r18, Y+9	; 0x09
    25e0:	8f 01       	movw	r16, r30
    25e2:	0e 94 00 13 	call	0x2600	; 0x2600 <prvInitialiseNewQueue>
        {
            configASSERT( pxNewQueue );
            mtCOVERAGE_TEST_MARKER();
        }

        return pxNewQueue;
    25e6:	8d 81       	ldd	r24, Y+5	; 0x05
    25e8:	9e 81       	ldd	r25, Y+6	; 0x06
    }
    25ea:	29 96       	adiw	r28, 0x09	; 9
    25ec:	0f b6       	in	r0, 0x3f	; 63
    25ee:	f8 94       	cli
    25f0:	de bf       	out	0x3e, r29	; 62
    25f2:	0f be       	out	0x3f, r0	; 63
    25f4:	cd bf       	out	0x3d, r28	; 61
    25f6:	cf 91       	pop	r28
    25f8:	df 91       	pop	r29
    25fa:	1f 91       	pop	r17
    25fc:	0f 91       	pop	r16
    25fe:	08 95       	ret

00002600 <prvInitialiseNewQueue>:
static void prvInitialiseNewQueue( const UBaseType_t uxQueueLength,
                                   const UBaseType_t uxItemSize,
                                   uint8_t * pucQueueStorage,
                                   const uint8_t ucQueueType,
                                   Queue_t * pxNewQueue )
{
    2600:	0f 93       	push	r16
    2602:	1f 93       	push	r17
    2604:	df 93       	push	r29
    2606:	cf 93       	push	r28
    2608:	cd b7       	in	r28, 0x3d	; 61
    260a:	de b7       	in	r29, 0x3e	; 62
    260c:	27 97       	sbiw	r28, 0x07	; 7
    260e:	0f b6       	in	r0, 0x3f	; 63
    2610:	f8 94       	cli
    2612:	de bf       	out	0x3e, r29	; 62
    2614:	0f be       	out	0x3f, r0	; 63
    2616:	cd bf       	out	0x3d, r28	; 61
    2618:	89 83       	std	Y+1, r24	; 0x01
    261a:	6a 83       	std	Y+2, r22	; 0x02
    261c:	5c 83       	std	Y+4, r21	; 0x04
    261e:	4b 83       	std	Y+3, r20	; 0x03
    2620:	2d 83       	std	Y+5, r18	; 0x05
    2622:	1f 83       	std	Y+7, r17	; 0x07
    2624:	0e 83       	std	Y+6, r16	; 0x06
    /* Remove compiler warnings about unused parameters should
     * configUSE_TRACE_FACILITY not be set to 1. */
    ( void ) ucQueueType;

    if( uxItemSize == ( UBaseType_t ) 0 )
    2626:	8a 81       	ldd	r24, Y+2	; 0x02
    2628:	88 23       	and	r24, r24
    262a:	39 f4       	brne	.+14     	; 0x263a <prvInitialiseNewQueue+0x3a>
    {
        /* No RAM was allocated for the queue storage area, but PC head cannot
         * be set to NULL because NULL is used as a key to say the queue is used as
         * a mutex.  Therefore just set pcHead to point to the queue as a benign
         * value that is known to be within the memory map. */
        pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
    262c:	8e 81       	ldd	r24, Y+6	; 0x06
    262e:	9f 81       	ldd	r25, Y+7	; 0x07
    2630:	ee 81       	ldd	r30, Y+6	; 0x06
    2632:	ff 81       	ldd	r31, Y+7	; 0x07
    2634:	91 83       	std	Z+1, r25	; 0x01
    2636:	80 83       	st	Z, r24
    2638:	06 c0       	rjmp	.+12     	; 0x2646 <prvInitialiseNewQueue+0x46>
    }
    else
    {
        /* Set the head to the start of the queue storage area. */
        pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
    263a:	8b 81       	ldd	r24, Y+3	; 0x03
    263c:	9c 81       	ldd	r25, Y+4	; 0x04
    263e:	ee 81       	ldd	r30, Y+6	; 0x06
    2640:	ff 81       	ldd	r31, Y+7	; 0x07
    2642:	91 83       	std	Z+1, r25	; 0x01
    2644:	80 83       	st	Z, r24
    }

    /* Initialise the queue members as described where the queue type is
     * defined. */
    pxNewQueue->uxLength = uxQueueLength;
    2646:	ee 81       	ldd	r30, Y+6	; 0x06
    2648:	ff 81       	ldd	r31, Y+7	; 0x07
    264a:	89 81       	ldd	r24, Y+1	; 0x01
    264c:	83 8f       	std	Z+27, r24	; 0x1b
    pxNewQueue->uxItemSize = uxItemSize;
    264e:	ee 81       	ldd	r30, Y+6	; 0x06
    2650:	ff 81       	ldd	r31, Y+7	; 0x07
    2652:	8a 81       	ldd	r24, Y+2	; 0x02
    2654:	84 8f       	std	Z+28, r24	; 0x1c
    ( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
    2656:	8e 81       	ldd	r24, Y+6	; 0x06
    2658:	9f 81       	ldd	r25, Y+7	; 0x07
    265a:	61 e0       	ldi	r22, 0x01	; 1
    265c:	0e 94 e1 11 	call	0x23c2	; 0x23c2 <xQueueGenericReset>
            pxNewQueue->pxQueueSetContainer = NULL;
        }
    #endif /* configUSE_QUEUE_SETS */

    traceQUEUE_CREATE( pxNewQueue );
}
    2660:	27 96       	adiw	r28, 0x07	; 7
    2662:	0f b6       	in	r0, 0x3f	; 63
    2664:	f8 94       	cli
    2666:	de bf       	out	0x3e, r29	; 62
    2668:	0f be       	out	0x3f, r0	; 63
    266a:	cd bf       	out	0x3d, r28	; 61
    266c:	cf 91       	pop	r28
    266e:	df 91       	pop	r29
    2670:	1f 91       	pop	r17
    2672:	0f 91       	pop	r16
    2674:	08 95       	ret

00002676 <xQueueGenericSend>:

BaseType_t xQueueGenericSend( QueueHandle_t xQueue,
                              const void * const pvItemToQueue,
                              TickType_t xTicksToWait,
                              const BaseType_t xCopyPosition )
{
    2676:	df 93       	push	r29
    2678:	cf 93       	push	r28
    267a:	cd b7       	in	r28, 0x3d	; 61
    267c:	de b7       	in	r29, 0x3e	; 62
    267e:	2f 97       	sbiw	r28, 0x0f	; 15
    2680:	0f b6       	in	r0, 0x3f	; 63
    2682:	f8 94       	cli
    2684:	de bf       	out	0x3e, r29	; 62
    2686:	0f be       	out	0x3f, r0	; 63
    2688:	cd bf       	out	0x3d, r28	; 61
    268a:	99 87       	std	Y+9, r25	; 0x09
    268c:	88 87       	std	Y+8, r24	; 0x08
    268e:	7b 87       	std	Y+11, r23	; 0x0b
    2690:	6a 87       	std	Y+10, r22	; 0x0a
    2692:	5d 87       	std	Y+13, r21	; 0x0d
    2694:	4c 87       	std	Y+12, r20	; 0x0c
    2696:	2e 87       	std	Y+14, r18	; 0x0e
    BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
    2698:	1c 82       	std	Y+4, r1	; 0x04
    TimeOut_t xTimeOut;
    Queue_t * const pxQueue = xQueue;
    269a:	88 85       	ldd	r24, Y+8	; 0x08
    269c:	99 85       	ldd	r25, Y+9	; 0x09
    269e:	9a 83       	std	Y+2, r25	; 0x02
    26a0:	89 83       	std	Y+1, r24	; 0x01
    /*lint -save -e904 This function relaxes the coding standard somewhat to
     * allow return statements within the function itself.  This is done in the
     * interest of execution time efficiency. */
    for( ; ; )
    {
        taskENTER_CRITICAL();
    26a2:	0f b6       	in	r0, 0x3f	; 63
    26a4:	f8 94       	cli
    26a6:	0f 92       	push	r0
        {
            /* Is there room on the queue now?  The running task must be the
             * highest priority task wanting to access the queue.  If the head item
             * in the queue is to be overwritten then it does not matter if the
             * queue is full. */
            if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    26a8:	e9 81       	ldd	r30, Y+1	; 0x01
    26aa:	fa 81       	ldd	r31, Y+2	; 0x02
    26ac:	92 8d       	ldd	r25, Z+26	; 0x1a
    26ae:	e9 81       	ldd	r30, Y+1	; 0x01
    26b0:	fa 81       	ldd	r31, Y+2	; 0x02
    26b2:	83 8d       	ldd	r24, Z+27	; 0x1b
    26b4:	98 17       	cp	r25, r24
    26b6:	18 f0       	brcs	.+6      	; 0x26be <xQueueGenericSend+0x48>
    26b8:	8e 85       	ldd	r24, Y+14	; 0x0e
    26ba:	82 30       	cpi	r24, 0x02	; 2
    26bc:	11 f5       	brne	.+68     	; 0x2702 <xQueueGenericSend+0x8c>
                            }
                        }
                    }
                #else /* configUSE_QUEUE_SETS */
                    {
                        xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    26be:	89 81       	ldd	r24, Y+1	; 0x01
    26c0:	9a 81       	ldd	r25, Y+2	; 0x02
    26c2:	2a 85       	ldd	r18, Y+10	; 0x0a
    26c4:	3b 85       	ldd	r19, Y+11	; 0x0b
    26c6:	b9 01       	movw	r22, r18
    26c8:	4e 85       	ldd	r20, Y+14	; 0x0e
    26ca:	0e 94 91 17 	call	0x2f22	; 0x2f22 <prvCopyDataToQueue>
    26ce:	8b 83       	std	Y+3, r24	; 0x03

                        /* If there was a task waiting for data to arrive on the
                         * queue then unblock it now. */
                        if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    26d0:	e9 81       	ldd	r30, Y+1	; 0x01
    26d2:	fa 81       	ldd	r31, Y+2	; 0x02
    26d4:	81 89       	ldd	r24, Z+17	; 0x11
    26d6:	88 23       	and	r24, r24
    26d8:	51 f0       	breq	.+20     	; 0x26ee <xQueueGenericSend+0x78>
                        {
                            if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    26da:	89 81       	ldd	r24, Y+1	; 0x01
    26dc:	9a 81       	ldd	r25, Y+2	; 0x02
    26de:	41 96       	adiw	r24, 0x11	; 17
    26e0:	0e 94 4e 23 	call	0x469c	; 0x469c <xTaskRemoveFromEventList>
    26e4:	88 23       	and	r24, r24
    26e6:	41 f0       	breq	.+16     	; 0x26f8 <xQueueGenericSend+0x82>
                            {
                                /* The unblocked task has a priority higher than
                                 * our own so yield immediately.  Yes it is ok to do
                                 * this from within the critical section - the kernel
                                 * takes care of that. */
                                queueYIELD_IF_USING_PREEMPTION();
    26e8:	0e 94 72 09 	call	0x12e4	; 0x12e4 <vPortYield>
    26ec:	05 c0       	rjmp	.+10     	; 0x26f8 <xQueueGenericSend+0x82>
                            else
                            {
                                mtCOVERAGE_TEST_MARKER();
                            }
                        }
                        else if( xYieldRequired != pdFALSE )
    26ee:	8b 81       	ldd	r24, Y+3	; 0x03
    26f0:	88 23       	and	r24, r24
    26f2:	11 f0       	breq	.+4      	; 0x26f8 <xQueueGenericSend+0x82>
                        {
                            /* This path is a special case that will only get
                             * executed if the task was holding multiple mutexes and
                             * the mutexes were given back in an order that is
                             * different to that in which they were taken. */
                            queueYIELD_IF_USING_PREEMPTION();
    26f4:	0e 94 72 09 	call	0x12e4	; 0x12e4 <vPortYield>
                            mtCOVERAGE_TEST_MARKER();
                        }
                    }
                #endif /* configUSE_QUEUE_SETS */

                taskEXIT_CRITICAL();
    26f8:	0f 90       	pop	r0
    26fa:	0f be       	out	0x3f, r0	; 63
                return pdPASS;
    26fc:	81 e0       	ldi	r24, 0x01	; 1
    26fe:	8f 87       	std	Y+15, r24	; 0x0f
    2700:	5c c0       	rjmp	.+184    	; 0x27ba <xQueueGenericSend+0x144>
            }
            else
            {
                if( xTicksToWait == ( TickType_t ) 0 )
    2702:	8c 85       	ldd	r24, Y+12	; 0x0c
    2704:	9d 85       	ldd	r25, Y+13	; 0x0d
    2706:	00 97       	sbiw	r24, 0x00	; 0
    2708:	21 f4       	brne	.+8      	; 0x2712 <xQueueGenericSend+0x9c>
                {
                    /* The queue was full and no block time is specified (or
                     * the block time has expired) so leave now. */
                    taskEXIT_CRITICAL();
    270a:	0f 90       	pop	r0
    270c:	0f be       	out	0x3f, r0	; 63

                    /* Return to the original privilege level before exiting
                     * the function. */
                    traceQUEUE_SEND_FAILED( pxQueue );
                    return errQUEUE_FULL;
    270e:	1f 86       	std	Y+15, r1	; 0x0f
    2710:	54 c0       	rjmp	.+168    	; 0x27ba <xQueueGenericSend+0x144>
                }
                else if( xEntryTimeSet == pdFALSE )
    2712:	8c 81       	ldd	r24, Y+4	; 0x04
    2714:	88 23       	and	r24, r24
    2716:	31 f4       	brne	.+12     	; 0x2724 <xQueueGenericSend+0xae>
                {
                    /* The queue was full and a block time was specified so
                     * configure the timeout structure. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
    2718:	ce 01       	movw	r24, r28
    271a:	05 96       	adiw	r24, 0x05	; 5
    271c:	0e 94 be 25 	call	0x4b7c	; 0x4b7c <vTaskInternalSetTimeOutState>
                    xEntryTimeSet = pdTRUE;
    2720:	81 e0       	ldi	r24, 0x01	; 1
    2722:	8c 83       	std	Y+4, r24	; 0x04
                    /* Entry time was already set. */
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        taskEXIT_CRITICAL();
    2724:	0f 90       	pop	r0
    2726:	0f be       	out	0x3f, r0	; 63

        /* Interrupts and other tasks can send to and receive from the queue
         * now the critical section has been exited. */

        vTaskSuspendAll();
    2728:	0e 94 88 1e 	call	0x3d10	; 0x3d10 <vTaskSuspendAll>
        prvLockQueue( pxQueue );
    272c:	0f b6       	in	r0, 0x3f	; 63
    272e:	f8 94       	cli
    2730:	0f 92       	push	r0
    2732:	e9 81       	ldd	r30, Y+1	; 0x01
    2734:	fa 81       	ldd	r31, Y+2	; 0x02
    2736:	85 8d       	ldd	r24, Z+29	; 0x1d
    2738:	8f 3f       	cpi	r24, 0xFF	; 255
    273a:	19 f4       	brne	.+6      	; 0x2742 <xQueueGenericSend+0xcc>
    273c:	e9 81       	ldd	r30, Y+1	; 0x01
    273e:	fa 81       	ldd	r31, Y+2	; 0x02
    2740:	15 8e       	std	Z+29, r1	; 0x1d
    2742:	e9 81       	ldd	r30, Y+1	; 0x01
    2744:	fa 81       	ldd	r31, Y+2	; 0x02
    2746:	86 8d       	ldd	r24, Z+30	; 0x1e
    2748:	8f 3f       	cpi	r24, 0xFF	; 255
    274a:	19 f4       	brne	.+6      	; 0x2752 <xQueueGenericSend+0xdc>
    274c:	e9 81       	ldd	r30, Y+1	; 0x01
    274e:	fa 81       	ldd	r31, Y+2	; 0x02
    2750:	16 8e       	std	Z+30, r1	; 0x1e
    2752:	0f 90       	pop	r0
    2754:	0f be       	out	0x3f, r0	; 63

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    2756:	ce 01       	movw	r24, r28
    2758:	05 96       	adiw	r24, 0x05	; 5
    275a:	9e 01       	movw	r18, r28
    275c:	24 5f       	subi	r18, 0xF4	; 244
    275e:	3f 4f       	sbci	r19, 0xFF	; 255
    2760:	b9 01       	movw	r22, r18
    2762:	0e 94 d7 25 	call	0x4bae	; 0x4bae <xTaskCheckForTimeOut>
    2766:	88 23       	and	r24, r24
    2768:	09 f5       	brne	.+66     	; 0x27ac <xQueueGenericSend+0x136>
        {
            if( prvIsQueueFull( pxQueue ) != pdFALSE )
    276a:	89 81       	ldd	r24, Y+1	; 0x01
    276c:	9a 81       	ldd	r25, Y+2	; 0x02
    276e:	0e 94 0d 19 	call	0x321a	; 0x321a <prvIsQueueFull>
    2772:	88 23       	and	r24, r24
    2774:	a1 f0       	breq	.+40     	; 0x279e <xQueueGenericSend+0x128>
            {
                traceBLOCKING_ON_QUEUE_SEND( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    2776:	89 81       	ldd	r24, Y+1	; 0x01
    2778:	9a 81       	ldd	r25, Y+2	; 0x02
    277a:	08 96       	adiw	r24, 0x08	; 8
    277c:	2c 85       	ldd	r18, Y+12	; 0x0c
    277e:	3d 85       	ldd	r19, Y+13	; 0x0d
    2780:	b9 01       	movw	r22, r18
    2782:	0e 94 65 22 	call	0x44ca	; 0x44ca <vTaskPlaceOnEventList>
                /* Unlocking the queue means queue events can effect the
                 * event list. It is possible that interrupts occurring now
                 * remove this task from the event list again - but as the
                 * scheduler is suspended the task will go onto the pending
                 * ready list instead of the actual ready list. */
                prvUnlockQueue( pxQueue );
    2786:	89 81       	ldd	r24, Y+1	; 0x01
    2788:	9a 81       	ldd	r25, Y+2	; 0x02
    278a:	0e 94 7e 18 	call	0x30fc	; 0x30fc <prvUnlockQueue>
                /* Resuming the scheduler will move tasks from the pending
                 * ready list into the ready list - so it is feasible that this
                 * task is already in the ready list before it yields - in which
                 * case the yield will not cause a context switch unless there
                 * is also a higher priority task in the pending ready list. */
                if( xTaskResumeAll() == pdFALSE )
    278e:	0e 94 94 1e 	call	0x3d28	; 0x3d28 <xTaskResumeAll>
    2792:	88 23       	and	r24, r24
    2794:	09 f0       	breq	.+2      	; 0x2798 <xQueueGenericSend+0x122>
    2796:	85 cf       	rjmp	.-246    	; 0x26a2 <xQueueGenericSend+0x2c>
                {
                    portYIELD_WITHIN_API();
    2798:	0e 94 72 09 	call	0x12e4	; 0x12e4 <vPortYield>
    279c:	82 cf       	rjmp	.-252    	; 0x26a2 <xQueueGenericSend+0x2c>
                }
            }
            else
            {
                /* Try again. */
                prvUnlockQueue( pxQueue );
    279e:	89 81       	ldd	r24, Y+1	; 0x01
    27a0:	9a 81       	ldd	r25, Y+2	; 0x02
    27a2:	0e 94 7e 18 	call	0x30fc	; 0x30fc <prvUnlockQueue>
                ( void ) xTaskResumeAll();
    27a6:	0e 94 94 1e 	call	0x3d28	; 0x3d28 <xTaskResumeAll>
    27aa:	7b cf       	rjmp	.-266    	; 0x26a2 <xQueueGenericSend+0x2c>
            }
        }
        else
        {
            /* The timeout has expired. */
            prvUnlockQueue( pxQueue );
    27ac:	89 81       	ldd	r24, Y+1	; 0x01
    27ae:	9a 81       	ldd	r25, Y+2	; 0x02
    27b0:	0e 94 7e 18 	call	0x30fc	; 0x30fc <prvUnlockQueue>
            ( void ) xTaskResumeAll();
    27b4:	0e 94 94 1e 	call	0x3d28	; 0x3d28 <xTaskResumeAll>

            traceQUEUE_SEND_FAILED( pxQueue );
            return errQUEUE_FULL;
    27b8:	1f 86       	std	Y+15, r1	; 0x0f
    27ba:	8f 85       	ldd	r24, Y+15	; 0x0f
        }
    } /*lint -restore */
}
    27bc:	2f 96       	adiw	r28, 0x0f	; 15
    27be:	0f b6       	in	r0, 0x3f	; 63
    27c0:	f8 94       	cli
    27c2:	de bf       	out	0x3e, r29	; 62
    27c4:	0f be       	out	0x3f, r0	; 63
    27c6:	cd bf       	out	0x3d, r28	; 61
    27c8:	cf 91       	pop	r28
    27ca:	df 91       	pop	r29
    27cc:	08 95       	ret

000027ce <xQueueGenericSendFromISR>:

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue,
                                     const void * const pvItemToQueue,
                                     BaseType_t * const pxHigherPriorityTaskWoken,
                                     const BaseType_t xCopyPosition )
{
    27ce:	df 93       	push	r29
    27d0:	cf 93       	push	r28
    27d2:	cd b7       	in	r28, 0x3d	; 61
    27d4:	de b7       	in	r29, 0x3e	; 62
    27d6:	2d 97       	sbiw	r28, 0x0d	; 13
    27d8:	0f b6       	in	r0, 0x3f	; 63
    27da:	f8 94       	cli
    27dc:	de bf       	out	0x3e, r29	; 62
    27de:	0f be       	out	0x3f, r0	; 63
    27e0:	cd bf       	out	0x3d, r28	; 61
    27e2:	98 87       	std	Y+8, r25	; 0x08
    27e4:	8f 83       	std	Y+7, r24	; 0x07
    27e6:	7a 87       	std	Y+10, r23	; 0x0a
    27e8:	69 87       	std	Y+9, r22	; 0x09
    27ea:	5c 87       	std	Y+12, r21	; 0x0c
    27ec:	4b 87       	std	Y+11, r20	; 0x0b
    27ee:	2d 87       	std	Y+13, r18	; 0x0d
    BaseType_t xReturn;
    UBaseType_t uxSavedInterruptStatus;
    Queue_t * const pxQueue = xQueue;
    27f0:	8f 81       	ldd	r24, Y+7	; 0x07
    27f2:	98 85       	ldd	r25, Y+8	; 0x08
    27f4:	9c 83       	std	Y+4, r25	; 0x04
    27f6:	8b 83       	std	Y+3, r24	; 0x03
    /* Similar to xQueueGenericSend, except without blocking if there is no room
     * in the queue.  Also don't directly wake a task that was blocked on a queue
     * read, instead return a flag to say whether a context switch is required or
     * not (i.e. has a task with a higher priority than us been woken by this
     * post). */
    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    27f8:	1d 82       	std	Y+5, r1	; 0x05
    {
        if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    27fa:	eb 81       	ldd	r30, Y+3	; 0x03
    27fc:	fc 81       	ldd	r31, Y+4	; 0x04
    27fe:	92 8d       	ldd	r25, Z+26	; 0x1a
    2800:	eb 81       	ldd	r30, Y+3	; 0x03
    2802:	fc 81       	ldd	r31, Y+4	; 0x04
    2804:	83 8d       	ldd	r24, Z+27	; 0x1b
    2806:	98 17       	cp	r25, r24
    2808:	18 f0       	brcs	.+6      	; 0x2810 <xQueueGenericSendFromISR+0x42>
    280a:	8d 85       	ldd	r24, Y+13	; 0x0d
    280c:	82 30       	cpi	r24, 0x02	; 2
    280e:	81 f5       	brne	.+96     	; 0x2870 <xQueueGenericSendFromISR+0xa2>
        {
            const int8_t cTxLock = pxQueue->cTxLock;
    2810:	eb 81       	ldd	r30, Y+3	; 0x03
    2812:	fc 81       	ldd	r31, Y+4	; 0x04
    2814:	86 8d       	ldd	r24, Z+30	; 0x1e
    2816:	8a 83       	std	Y+2, r24	; 0x02
            const UBaseType_t uxPreviousMessagesWaiting = pxQueue->uxMessagesWaiting;
    2818:	eb 81       	ldd	r30, Y+3	; 0x03
    281a:	fc 81       	ldd	r31, Y+4	; 0x04
    281c:	82 8d       	ldd	r24, Z+26	; 0x1a
    281e:	89 83       	std	Y+1, r24	; 0x01
            /* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
             *  semaphore or mutex.  That means prvCopyDataToQueue() cannot result
             *  in a task disinheriting a priority and prvCopyDataToQueue() can be
             *  called here even though the disinherit function does not check if
             *  the scheduler is suspended before accessing the ready lists. */
            ( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    2820:	8b 81       	ldd	r24, Y+3	; 0x03
    2822:	9c 81       	ldd	r25, Y+4	; 0x04
    2824:	29 85       	ldd	r18, Y+9	; 0x09
    2826:	3a 85       	ldd	r19, Y+10	; 0x0a
    2828:	b9 01       	movw	r22, r18
    282a:	4d 85       	ldd	r20, Y+13	; 0x0d
    282c:	0e 94 91 17 	call	0x2f22	; 0x2f22 <prvCopyDataToQueue>

            /* The event list is not altered if the queue is locked.  This will
             * be done when the queue is unlocked later. */
            if( cTxLock == queueUNLOCKED )
    2830:	8a 81       	ldd	r24, Y+2	; 0x02
    2832:	8f 3f       	cpi	r24, 0xFF	; 255
    2834:	a9 f4       	brne	.+42     	; 0x2860 <xQueueGenericSendFromISR+0x92>
                            }
                        }
                    }
                #else /* configUSE_QUEUE_SETS */
                    {
                        if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    2836:	eb 81       	ldd	r30, Y+3	; 0x03
    2838:	fc 81       	ldd	r31, Y+4	; 0x04
    283a:	81 89       	ldd	r24, Z+17	; 0x11
    283c:	88 23       	and	r24, r24
    283e:	a9 f0       	breq	.+42     	; 0x286a <xQueueGenericSendFromISR+0x9c>
                        {
                            if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    2840:	8b 81       	ldd	r24, Y+3	; 0x03
    2842:	9c 81       	ldd	r25, Y+4	; 0x04
    2844:	41 96       	adiw	r24, 0x11	; 17
    2846:	0e 94 4e 23 	call	0x469c	; 0x469c <xTaskRemoveFromEventList>
    284a:	88 23       	and	r24, r24
    284c:	71 f0       	breq	.+28     	; 0x286a <xQueueGenericSendFromISR+0x9c>
                            {
                                /* The task waiting has a higher priority so record that a
                                 * context switch is required. */
                                if( pxHigherPriorityTaskWoken != NULL )
    284e:	8b 85       	ldd	r24, Y+11	; 0x0b
    2850:	9c 85       	ldd	r25, Y+12	; 0x0c
    2852:	00 97       	sbiw	r24, 0x00	; 0
    2854:	51 f0       	breq	.+20     	; 0x286a <xQueueGenericSendFromISR+0x9c>
                                {
                                    *pxHigherPriorityTaskWoken = pdTRUE;
    2856:	eb 85       	ldd	r30, Y+11	; 0x0b
    2858:	fc 85       	ldd	r31, Y+12	; 0x0c
    285a:	81 e0       	ldi	r24, 0x01	; 1
    285c:	80 83       	st	Z, r24
    285e:	05 c0       	rjmp	.+10     	; 0x286a <xQueueGenericSendFromISR+0x9c>
            {
                /* Increment the lock count so the task that unlocks the queue
                 * knows that data was posted while it was locked. */
                configASSERT( cTxLock != queueINT8_MAX );

                pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    2860:	8a 81       	ldd	r24, Y+2	; 0x02
    2862:	8f 5f       	subi	r24, 0xFF	; 255
    2864:	eb 81       	ldd	r30, Y+3	; 0x03
    2866:	fc 81       	ldd	r31, Y+4	; 0x04
    2868:	86 8f       	std	Z+30, r24	; 0x1e
            }

            xReturn = pdPASS;
    286a:	81 e0       	ldi	r24, 0x01	; 1
    286c:	8e 83       	std	Y+6, r24	; 0x06
    286e:	01 c0       	rjmp	.+2      	; 0x2872 <xQueueGenericSendFromISR+0xa4>
        }
        else
        {
            traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
            xReturn = errQUEUE_FULL;
    2870:	1e 82       	std	Y+6, r1	; 0x06
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
    2872:	8e 81       	ldd	r24, Y+6	; 0x06
}
    2874:	2d 96       	adiw	r28, 0x0d	; 13
    2876:	0f b6       	in	r0, 0x3f	; 63
    2878:	f8 94       	cli
    287a:	de bf       	out	0x3e, r29	; 62
    287c:	0f be       	out	0x3f, r0	; 63
    287e:	cd bf       	out	0x3d, r28	; 61
    2880:	cf 91       	pop	r28
    2882:	df 91       	pop	r29
    2884:	08 95       	ret

00002886 <xQueueGiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue,
                              BaseType_t * const pxHigherPriorityTaskWoken )
{
    2886:	df 93       	push	r29
    2888:	cf 93       	push	r28
    288a:	cd b7       	in	r28, 0x3d	; 61
    288c:	de b7       	in	r29, 0x3e	; 62
    288e:	2a 97       	sbiw	r28, 0x0a	; 10
    2890:	0f b6       	in	r0, 0x3f	; 63
    2892:	f8 94       	cli
    2894:	de bf       	out	0x3e, r29	; 62
    2896:	0f be       	out	0x3f, r0	; 63
    2898:	cd bf       	out	0x3d, r28	; 61
    289a:	98 87       	std	Y+8, r25	; 0x08
    289c:	8f 83       	std	Y+7, r24	; 0x07
    289e:	7a 87       	std	Y+10, r23	; 0x0a
    28a0:	69 87       	std	Y+9, r22	; 0x09
    BaseType_t xReturn;
    UBaseType_t uxSavedInterruptStatus;
    Queue_t * const pxQueue = xQueue;
    28a2:	8f 81       	ldd	r24, Y+7	; 0x07
    28a4:	98 85       	ldd	r25, Y+8	; 0x08
    28a6:	9c 83       	std	Y+4, r25	; 0x04
    28a8:	8b 83       	std	Y+3, r24	; 0x03
     * safe API to ensure interrupt entry is as fast and as simple as possible.
     * More information (albeit Cortex-M specific) is provided on the following
     * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    28aa:	1d 82       	std	Y+5, r1	; 0x05
    {
        const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    28ac:	eb 81       	ldd	r30, Y+3	; 0x03
    28ae:	fc 81       	ldd	r31, Y+4	; 0x04
    28b0:	82 8d       	ldd	r24, Z+26	; 0x1a
    28b2:	8a 83       	std	Y+2, r24	; 0x02

        /* When the queue is used to implement a semaphore no data is ever
         * moved through the queue but it is still valid to see if the queue 'has
         * space'. */
        if( uxMessagesWaiting < pxQueue->uxLength )
    28b4:	eb 81       	ldd	r30, Y+3	; 0x03
    28b6:	fc 81       	ldd	r31, Y+4	; 0x04
    28b8:	93 8d       	ldd	r25, Z+27	; 0x1b
    28ba:	8a 81       	ldd	r24, Y+2	; 0x02
    28bc:	89 17       	cp	r24, r25
    28be:	48 f5       	brcc	.+82     	; 0x2912 <xQueueGiveFromISR+0x8c>
        {
            const int8_t cTxLock = pxQueue->cTxLock;
    28c0:	eb 81       	ldd	r30, Y+3	; 0x03
    28c2:	fc 81       	ldd	r31, Y+4	; 0x04
    28c4:	86 8d       	ldd	r24, Z+30	; 0x1e
    28c6:	89 83       	std	Y+1, r24	; 0x01
             * holder - and if there is a mutex holder then the mutex cannot be
             * given from an ISR.  As this is the ISR version of the function it
             * can be assumed there is no mutex holder and no need to determine if
             * priority disinheritance is needed.  Simply increase the count of
             * messages (semaphores) available. */
            pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
    28c8:	8a 81       	ldd	r24, Y+2	; 0x02
    28ca:	8f 5f       	subi	r24, 0xFF	; 255
    28cc:	eb 81       	ldd	r30, Y+3	; 0x03
    28ce:	fc 81       	ldd	r31, Y+4	; 0x04
    28d0:	82 8f       	std	Z+26, r24	; 0x1a

            /* The event list is not altered if the queue is locked.  This will
             * be done when the queue is unlocked later. */
            if( cTxLock == queueUNLOCKED )
    28d2:	89 81       	ldd	r24, Y+1	; 0x01
    28d4:	8f 3f       	cpi	r24, 0xFF	; 255
    28d6:	a9 f4       	brne	.+42     	; 0x2902 <xQueueGiveFromISR+0x7c>
                            }
                        }
                    }
                #else /* configUSE_QUEUE_SETS */
                    {
                        if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    28d8:	eb 81       	ldd	r30, Y+3	; 0x03
    28da:	fc 81       	ldd	r31, Y+4	; 0x04
    28dc:	81 89       	ldd	r24, Z+17	; 0x11
    28de:	88 23       	and	r24, r24
    28e0:	a9 f0       	breq	.+42     	; 0x290c <xQueueGiveFromISR+0x86>
                        {
                            if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    28e2:	8b 81       	ldd	r24, Y+3	; 0x03
    28e4:	9c 81       	ldd	r25, Y+4	; 0x04
    28e6:	41 96       	adiw	r24, 0x11	; 17
    28e8:	0e 94 4e 23 	call	0x469c	; 0x469c <xTaskRemoveFromEventList>
    28ec:	88 23       	and	r24, r24
    28ee:	71 f0       	breq	.+28     	; 0x290c <xQueueGiveFromISR+0x86>
                            {
                                /* The task waiting has a higher priority so record that a
                                 * context switch is required. */
                                if( pxHigherPriorityTaskWoken != NULL )
    28f0:	89 85       	ldd	r24, Y+9	; 0x09
    28f2:	9a 85       	ldd	r25, Y+10	; 0x0a
    28f4:	00 97       	sbiw	r24, 0x00	; 0
    28f6:	51 f0       	breq	.+20     	; 0x290c <xQueueGiveFromISR+0x86>
                                {
                                    *pxHigherPriorityTaskWoken = pdTRUE;
    28f8:	e9 85       	ldd	r30, Y+9	; 0x09
    28fa:	fa 85       	ldd	r31, Y+10	; 0x0a
    28fc:	81 e0       	ldi	r24, 0x01	; 1
    28fe:	80 83       	st	Z, r24
    2900:	05 c0       	rjmp	.+10     	; 0x290c <xQueueGiveFromISR+0x86>
            {
                /* Increment the lock count so the task that unlocks the queue
                 * knows that data was posted while it was locked. */
                configASSERT( cTxLock != queueINT8_MAX );

                pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    2902:	89 81       	ldd	r24, Y+1	; 0x01
    2904:	8f 5f       	subi	r24, 0xFF	; 255
    2906:	eb 81       	ldd	r30, Y+3	; 0x03
    2908:	fc 81       	ldd	r31, Y+4	; 0x04
    290a:	86 8f       	std	Z+30, r24	; 0x1e
            }

            xReturn = pdPASS;
    290c:	81 e0       	ldi	r24, 0x01	; 1
    290e:	8e 83       	std	Y+6, r24	; 0x06
    2910:	01 c0       	rjmp	.+2      	; 0x2914 <xQueueGiveFromISR+0x8e>
        }
        else
        {
            traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
            xReturn = errQUEUE_FULL;
    2912:	1e 82       	std	Y+6, r1	; 0x06
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
    2914:	8e 81       	ldd	r24, Y+6	; 0x06
}
    2916:	2a 96       	adiw	r28, 0x0a	; 10
    2918:	0f b6       	in	r0, 0x3f	; 63
    291a:	f8 94       	cli
    291c:	de bf       	out	0x3e, r29	; 62
    291e:	0f be       	out	0x3f, r0	; 63
    2920:	cd bf       	out	0x3d, r28	; 61
    2922:	cf 91       	pop	r28
    2924:	df 91       	pop	r29
    2926:	08 95       	ret

00002928 <xQueueReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceive( QueueHandle_t xQueue,
                          void * const pvBuffer,
                          TickType_t xTicksToWait )
{
    2928:	df 93       	push	r29
    292a:	cf 93       	push	r28
    292c:	cd b7       	in	r28, 0x3d	; 61
    292e:	de b7       	in	r29, 0x3e	; 62
    2930:	2e 97       	sbiw	r28, 0x0e	; 14
    2932:	0f b6       	in	r0, 0x3f	; 63
    2934:	f8 94       	cli
    2936:	de bf       	out	0x3e, r29	; 62
    2938:	0f be       	out	0x3f, r0	; 63
    293a:	cd bf       	out	0x3d, r28	; 61
    293c:	99 87       	std	Y+9, r25	; 0x09
    293e:	88 87       	std	Y+8, r24	; 0x08
    2940:	7b 87       	std	Y+11, r23	; 0x0b
    2942:	6a 87       	std	Y+10, r22	; 0x0a
    2944:	5d 87       	std	Y+13, r21	; 0x0d
    2946:	4c 87       	std	Y+12, r20	; 0x0c
    BaseType_t xEntryTimeSet = pdFALSE;
    2948:	1c 82       	std	Y+4, r1	; 0x04
    TimeOut_t xTimeOut;
    Queue_t * const pxQueue = xQueue;
    294a:	88 85       	ldd	r24, Y+8	; 0x08
    294c:	99 85       	ldd	r25, Y+9	; 0x09
    294e:	9b 83       	std	Y+3, r25	; 0x03
    2950:	8a 83       	std	Y+2, r24	; 0x02
    /*lint -save -e904  This function relaxes the coding standard somewhat to
     * allow return statements within the function itself.  This is done in the
     * interest of execution time efficiency. */
    for( ; ; )
    {
        taskENTER_CRITICAL();
    2952:	0f b6       	in	r0, 0x3f	; 63
    2954:	f8 94       	cli
    2956:	0f 92       	push	r0
        {
            const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    2958:	ea 81       	ldd	r30, Y+2	; 0x02
    295a:	fb 81       	ldd	r31, Y+3	; 0x03
    295c:	82 8d       	ldd	r24, Z+26	; 0x1a
    295e:	89 83       	std	Y+1, r24	; 0x01

            /* Is there data in the queue now?  To be running the calling task
             * must be the highest priority task wanting to access the queue. */
            if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    2960:	89 81       	ldd	r24, Y+1	; 0x01
    2962:	88 23       	and	r24, r24
    2964:	f9 f0       	breq	.+62     	; 0x29a4 <xQueueReceive+0x7c>
            {
                /* Data available, remove one item. */
                prvCopyDataFromQueue( pxQueue, pvBuffer );
    2966:	8a 81       	ldd	r24, Y+2	; 0x02
    2968:	9b 81       	ldd	r25, Y+3	; 0x03
    296a:	2a 85       	ldd	r18, Y+10	; 0x0a
    296c:	3b 85       	ldd	r19, Y+11	; 0x0b
    296e:	b9 01       	movw	r22, r18
    2970:	0e 94 37 18 	call	0x306e	; 0x306e <prvCopyDataFromQueue>
                traceQUEUE_RECEIVE( pxQueue );
                pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
    2974:	89 81       	ldd	r24, Y+1	; 0x01
    2976:	81 50       	subi	r24, 0x01	; 1
    2978:	ea 81       	ldd	r30, Y+2	; 0x02
    297a:	fb 81       	ldd	r31, Y+3	; 0x03
    297c:	82 8f       	std	Z+26, r24	; 0x1a

                /* There is now space in the queue, were any tasks waiting to
                 * post to the queue?  If so, unblock the highest priority waiting
                 * task. */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    297e:	ea 81       	ldd	r30, Y+2	; 0x02
    2980:	fb 81       	ldd	r31, Y+3	; 0x03
    2982:	80 85       	ldd	r24, Z+8	; 0x08
    2984:	88 23       	and	r24, r24
    2986:	49 f0       	breq	.+18     	; 0x299a <xQueueReceive+0x72>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    2988:	8a 81       	ldd	r24, Y+2	; 0x02
    298a:	9b 81       	ldd	r25, Y+3	; 0x03
    298c:	08 96       	adiw	r24, 0x08	; 8
    298e:	0e 94 4e 23 	call	0x469c	; 0x469c <xTaskRemoveFromEventList>
    2992:	88 23       	and	r24, r24
    2994:	11 f0       	breq	.+4      	; 0x299a <xQueueReceive+0x72>
                    {
                        queueYIELD_IF_USING_PREEMPTION();
    2996:	0e 94 72 09 	call	0x12e4	; 0x12e4 <vPortYield>
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                taskEXIT_CRITICAL();
    299a:	0f 90       	pop	r0
    299c:	0f be       	out	0x3f, r0	; 63
                return pdPASS;
    299e:	81 e0       	ldi	r24, 0x01	; 1
    29a0:	8e 87       	std	Y+14, r24	; 0x0e
    29a2:	63 c0       	rjmp	.+198    	; 0x2a6a <xQueueReceive+0x142>
            }
            else
            {
                if( xTicksToWait == ( TickType_t ) 0 )
    29a4:	8c 85       	ldd	r24, Y+12	; 0x0c
    29a6:	9d 85       	ldd	r25, Y+13	; 0x0d
    29a8:	00 97       	sbiw	r24, 0x00	; 0
    29aa:	21 f4       	brne	.+8      	; 0x29b4 <xQueueReceive+0x8c>
                {
                    /* The queue was empty and no block time is specified (or
                     * the block time has expired) so leave now. */
                    taskEXIT_CRITICAL();
    29ac:	0f 90       	pop	r0
    29ae:	0f be       	out	0x3f, r0	; 63
                    traceQUEUE_RECEIVE_FAILED( pxQueue );
                    return errQUEUE_EMPTY;
    29b0:	1e 86       	std	Y+14, r1	; 0x0e
    29b2:	5b c0       	rjmp	.+182    	; 0x2a6a <xQueueReceive+0x142>
                }
                else if( xEntryTimeSet == pdFALSE )
    29b4:	8c 81       	ldd	r24, Y+4	; 0x04
    29b6:	88 23       	and	r24, r24
    29b8:	31 f4       	brne	.+12     	; 0x29c6 <xQueueReceive+0x9e>
                {
                    /* The queue was empty and a block time was specified so
                     * configure the timeout structure. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
    29ba:	ce 01       	movw	r24, r28
    29bc:	05 96       	adiw	r24, 0x05	; 5
    29be:	0e 94 be 25 	call	0x4b7c	; 0x4b7c <vTaskInternalSetTimeOutState>
                    xEntryTimeSet = pdTRUE;
    29c2:	81 e0       	ldi	r24, 0x01	; 1
    29c4:	8c 83       	std	Y+4, r24	; 0x04
                    /* Entry time was already set. */
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        taskEXIT_CRITICAL();
    29c6:	0f 90       	pop	r0
    29c8:	0f be       	out	0x3f, r0	; 63

        /* Interrupts and other tasks can send to and receive from the queue
         * now the critical section has been exited. */

        vTaskSuspendAll();
    29ca:	0e 94 88 1e 	call	0x3d10	; 0x3d10 <vTaskSuspendAll>
        prvLockQueue( pxQueue );
    29ce:	0f b6       	in	r0, 0x3f	; 63
    29d0:	f8 94       	cli
    29d2:	0f 92       	push	r0
    29d4:	ea 81       	ldd	r30, Y+2	; 0x02
    29d6:	fb 81       	ldd	r31, Y+3	; 0x03
    29d8:	85 8d       	ldd	r24, Z+29	; 0x1d
    29da:	8f 3f       	cpi	r24, 0xFF	; 255
    29dc:	19 f4       	brne	.+6      	; 0x29e4 <xQueueReceive+0xbc>
    29de:	ea 81       	ldd	r30, Y+2	; 0x02
    29e0:	fb 81       	ldd	r31, Y+3	; 0x03
    29e2:	15 8e       	std	Z+29, r1	; 0x1d
    29e4:	ea 81       	ldd	r30, Y+2	; 0x02
    29e6:	fb 81       	ldd	r31, Y+3	; 0x03
    29e8:	86 8d       	ldd	r24, Z+30	; 0x1e
    29ea:	8f 3f       	cpi	r24, 0xFF	; 255
    29ec:	19 f4       	brne	.+6      	; 0x29f4 <xQueueReceive+0xcc>
    29ee:	ea 81       	ldd	r30, Y+2	; 0x02
    29f0:	fb 81       	ldd	r31, Y+3	; 0x03
    29f2:	16 8e       	std	Z+30, r1	; 0x1e
    29f4:	0f 90       	pop	r0
    29f6:	0f be       	out	0x3f, r0	; 63

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    29f8:	ce 01       	movw	r24, r28
    29fa:	05 96       	adiw	r24, 0x05	; 5
    29fc:	9e 01       	movw	r18, r28
    29fe:	24 5f       	subi	r18, 0xF4	; 244
    2a00:	3f 4f       	sbci	r19, 0xFF	; 255
    2a02:	b9 01       	movw	r22, r18
    2a04:	0e 94 d7 25 	call	0x4bae	; 0x4bae <xTaskCheckForTimeOut>
    2a08:	88 23       	and	r24, r24
    2a0a:	09 f5       	brne	.+66     	; 0x2a4e <xQueueReceive+0x126>
        {
            /* The timeout has not expired.  If the queue is still empty place
             * the task on the list of tasks waiting to receive from the queue. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    2a0c:	8a 81       	ldd	r24, Y+2	; 0x02
    2a0e:	9b 81       	ldd	r25, Y+3	; 0x03
    2a10:	0e 94 d1 18 	call	0x31a2	; 0x31a2 <prvIsQueueEmpty>
    2a14:	88 23       	and	r24, r24
    2a16:	a1 f0       	breq	.+40     	; 0x2a40 <xQueueReceive+0x118>
            {
                traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    2a18:	8a 81       	ldd	r24, Y+2	; 0x02
    2a1a:	9b 81       	ldd	r25, Y+3	; 0x03
    2a1c:	41 96       	adiw	r24, 0x11	; 17
    2a1e:	2c 85       	ldd	r18, Y+12	; 0x0c
    2a20:	3d 85       	ldd	r19, Y+13	; 0x0d
    2a22:	b9 01       	movw	r22, r18
    2a24:	0e 94 65 22 	call	0x44ca	; 0x44ca <vTaskPlaceOnEventList>
                prvUnlockQueue( pxQueue );
    2a28:	8a 81       	ldd	r24, Y+2	; 0x02
    2a2a:	9b 81       	ldd	r25, Y+3	; 0x03
    2a2c:	0e 94 7e 18 	call	0x30fc	; 0x30fc <prvUnlockQueue>

                if( xTaskResumeAll() == pdFALSE )
    2a30:	0e 94 94 1e 	call	0x3d28	; 0x3d28 <xTaskResumeAll>
    2a34:	88 23       	and	r24, r24
    2a36:	09 f0       	breq	.+2      	; 0x2a3a <xQueueReceive+0x112>
    2a38:	8c cf       	rjmp	.-232    	; 0x2952 <xQueueReceive+0x2a>
                {
                    portYIELD_WITHIN_API();
    2a3a:	0e 94 72 09 	call	0x12e4	; 0x12e4 <vPortYield>
    2a3e:	89 cf       	rjmp	.-238    	; 0x2952 <xQueueReceive+0x2a>
            }
            else
            {
                /* The queue contains data again.  Loop back to try and read the
                 * data. */
                prvUnlockQueue( pxQueue );
    2a40:	8a 81       	ldd	r24, Y+2	; 0x02
    2a42:	9b 81       	ldd	r25, Y+3	; 0x03
    2a44:	0e 94 7e 18 	call	0x30fc	; 0x30fc <prvUnlockQueue>
                ( void ) xTaskResumeAll();
    2a48:	0e 94 94 1e 	call	0x3d28	; 0x3d28 <xTaskResumeAll>
    2a4c:	82 cf       	rjmp	.-252    	; 0x2952 <xQueueReceive+0x2a>
        }
        else
        {
            /* Timed out.  If there is no data in the queue exit, otherwise loop
             * back and attempt to read the data. */
            prvUnlockQueue( pxQueue );
    2a4e:	8a 81       	ldd	r24, Y+2	; 0x02
    2a50:	9b 81       	ldd	r25, Y+3	; 0x03
    2a52:	0e 94 7e 18 	call	0x30fc	; 0x30fc <prvUnlockQueue>
            ( void ) xTaskResumeAll();
    2a56:	0e 94 94 1e 	call	0x3d28	; 0x3d28 <xTaskResumeAll>

            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    2a5a:	8a 81       	ldd	r24, Y+2	; 0x02
    2a5c:	9b 81       	ldd	r25, Y+3	; 0x03
    2a5e:	0e 94 d1 18 	call	0x31a2	; 0x31a2 <prvIsQueueEmpty>
    2a62:	88 23       	and	r24, r24
    2a64:	09 f4       	brne	.+2      	; 0x2a68 <xQueueReceive+0x140>
    2a66:	75 cf       	rjmp	.-278    	; 0x2952 <xQueueReceive+0x2a>
            {
                traceQUEUE_RECEIVE_FAILED( pxQueue );
                return errQUEUE_EMPTY;
    2a68:	1e 86       	std	Y+14, r1	; 0x0e
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
    } /*lint -restore */
    2a6a:	8e 85       	ldd	r24, Y+14	; 0x0e
}
    2a6c:	2e 96       	adiw	r28, 0x0e	; 14
    2a6e:	0f b6       	in	r0, 0x3f	; 63
    2a70:	f8 94       	cli
    2a72:	de bf       	out	0x3e, r29	; 62
    2a74:	0f be       	out	0x3f, r0	; 63
    2a76:	cd bf       	out	0x3d, r28	; 61
    2a78:	cf 91       	pop	r28
    2a7a:	df 91       	pop	r29
    2a7c:	08 95       	ret

00002a7e <xQueueSemaphoreTake>:
/*-----------------------------------------------------------*/

BaseType_t xQueueSemaphoreTake( QueueHandle_t xQueue,
                                TickType_t xTicksToWait )
{
    2a7e:	df 93       	push	r29
    2a80:	cf 93       	push	r28
    2a82:	cd b7       	in	r28, 0x3d	; 61
    2a84:	de b7       	in	r29, 0x3e	; 62
    2a86:	2c 97       	sbiw	r28, 0x0c	; 12
    2a88:	0f b6       	in	r0, 0x3f	; 63
    2a8a:	f8 94       	cli
    2a8c:	de bf       	out	0x3e, r29	; 62
    2a8e:	0f be       	out	0x3f, r0	; 63
    2a90:	cd bf       	out	0x3d, r28	; 61
    2a92:	99 87       	std	Y+9, r25	; 0x09
    2a94:	88 87       	std	Y+8, r24	; 0x08
    2a96:	7b 87       	std	Y+11, r23	; 0x0b
    2a98:	6a 87       	std	Y+10, r22	; 0x0a
    BaseType_t xEntryTimeSet = pdFALSE;
    2a9a:	1c 82       	std	Y+4, r1	; 0x04
    TimeOut_t xTimeOut;
    Queue_t * const pxQueue = xQueue;
    2a9c:	88 85       	ldd	r24, Y+8	; 0x08
    2a9e:	99 85       	ldd	r25, Y+9	; 0x09
    2aa0:	9b 83       	std	Y+3, r25	; 0x03
    2aa2:	8a 83       	std	Y+2, r24	; 0x02
    /*lint -save -e904 This function relaxes the coding standard somewhat to allow return
     * statements within the function itself.  This is done in the interest
     * of execution time efficiency. */
    for( ; ; )
    {
        taskENTER_CRITICAL();
    2aa4:	0f b6       	in	r0, 0x3f	; 63
    2aa6:	f8 94       	cli
    2aa8:	0f 92       	push	r0
        {
            /* Semaphores are queues with an item size of 0, and where the
             * number of messages in the queue is the semaphore's count value. */
            const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;
    2aaa:	ea 81       	ldd	r30, Y+2	; 0x02
    2aac:	fb 81       	ldd	r31, Y+3	; 0x03
    2aae:	82 8d       	ldd	r24, Z+26	; 0x1a
    2ab0:	89 83       	std	Y+1, r24	; 0x01

            /* Is there data in the queue now?  To be running the calling task
             * must be the highest priority task wanting to access the queue. */
            if( uxSemaphoreCount > ( UBaseType_t ) 0 )
    2ab2:	89 81       	ldd	r24, Y+1	; 0x01
    2ab4:	88 23       	and	r24, r24
    2ab6:	c1 f0       	breq	.+48     	; 0x2ae8 <xQueueSemaphoreTake+0x6a>
            {
                traceQUEUE_RECEIVE( pxQueue );

                /* Semaphores are queues with a data size of zero and where the
                 * messages waiting is the semaphore's count.  Reduce the count. */
                pxQueue->uxMessagesWaiting = uxSemaphoreCount - ( UBaseType_t ) 1;
    2ab8:	89 81       	ldd	r24, Y+1	; 0x01
    2aba:	81 50       	subi	r24, 0x01	; 1
    2abc:	ea 81       	ldd	r30, Y+2	; 0x02
    2abe:	fb 81       	ldd	r31, Y+3	; 0x03
    2ac0:	82 8f       	std	Z+26, r24	; 0x1a
                    }
                #endif /* configUSE_MUTEXES */

                /* Check to see if other tasks are blocked waiting to give the
                 * semaphore, and if so, unblock the highest priority such task. */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    2ac2:	ea 81       	ldd	r30, Y+2	; 0x02
    2ac4:	fb 81       	ldd	r31, Y+3	; 0x03
    2ac6:	80 85       	ldd	r24, Z+8	; 0x08
    2ac8:	88 23       	and	r24, r24
    2aca:	49 f0       	breq	.+18     	; 0x2ade <xQueueSemaphoreTake+0x60>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    2acc:	8a 81       	ldd	r24, Y+2	; 0x02
    2ace:	9b 81       	ldd	r25, Y+3	; 0x03
    2ad0:	08 96       	adiw	r24, 0x08	; 8
    2ad2:	0e 94 4e 23 	call	0x469c	; 0x469c <xTaskRemoveFromEventList>
    2ad6:	88 23       	and	r24, r24
    2ad8:	11 f0       	breq	.+4      	; 0x2ade <xQueueSemaphoreTake+0x60>
                    {
                        queueYIELD_IF_USING_PREEMPTION();
    2ada:	0e 94 72 09 	call	0x12e4	; 0x12e4 <vPortYield>
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                taskEXIT_CRITICAL();
    2ade:	0f 90       	pop	r0
    2ae0:	0f be       	out	0x3f, r0	; 63
                return pdPASS;
    2ae2:	81 e0       	ldi	r24, 0x01	; 1
    2ae4:	8c 87       	std	Y+12, r24	; 0x0c
    2ae6:	63 c0       	rjmp	.+198    	; 0x2bae <xQueueSemaphoreTake+0x130>
            }
            else
            {
                if( xTicksToWait == ( TickType_t ) 0 )
    2ae8:	8a 85       	ldd	r24, Y+10	; 0x0a
    2aea:	9b 85       	ldd	r25, Y+11	; 0x0b
    2aec:	00 97       	sbiw	r24, 0x00	; 0
    2aee:	21 f4       	brne	.+8      	; 0x2af8 <xQueueSemaphoreTake+0x7a>
                        }
                    #endif /* configUSE_MUTEXES */

                    /* The semaphore count was 0 and no block time is specified
                     * (or the block time has expired) so exit now. */
                    taskEXIT_CRITICAL();
    2af0:	0f 90       	pop	r0
    2af2:	0f be       	out	0x3f, r0	; 63
                    traceQUEUE_RECEIVE_FAILED( pxQueue );
                    return errQUEUE_EMPTY;
    2af4:	1c 86       	std	Y+12, r1	; 0x0c
    2af6:	5b c0       	rjmp	.+182    	; 0x2bae <xQueueSemaphoreTake+0x130>
                }
                else if( xEntryTimeSet == pdFALSE )
    2af8:	8c 81       	ldd	r24, Y+4	; 0x04
    2afa:	88 23       	and	r24, r24
    2afc:	31 f4       	brne	.+12     	; 0x2b0a <xQueueSemaphoreTake+0x8c>
                {
                    /* The semaphore count was 0 and a block time was specified
                     * so configure the timeout structure ready to block. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
    2afe:	ce 01       	movw	r24, r28
    2b00:	05 96       	adiw	r24, 0x05	; 5
    2b02:	0e 94 be 25 	call	0x4b7c	; 0x4b7c <vTaskInternalSetTimeOutState>
                    xEntryTimeSet = pdTRUE;
    2b06:	81 e0       	ldi	r24, 0x01	; 1
    2b08:	8c 83       	std	Y+4, r24	; 0x04
                    /* Entry time was already set. */
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        taskEXIT_CRITICAL();
    2b0a:	0f 90       	pop	r0
    2b0c:	0f be       	out	0x3f, r0	; 63

        /* Interrupts and other tasks can give to and take from the semaphore
         * now the critical section has been exited. */

        vTaskSuspendAll();
    2b0e:	0e 94 88 1e 	call	0x3d10	; 0x3d10 <vTaskSuspendAll>
        prvLockQueue( pxQueue );
    2b12:	0f b6       	in	r0, 0x3f	; 63
    2b14:	f8 94       	cli
    2b16:	0f 92       	push	r0
    2b18:	ea 81       	ldd	r30, Y+2	; 0x02
    2b1a:	fb 81       	ldd	r31, Y+3	; 0x03
    2b1c:	85 8d       	ldd	r24, Z+29	; 0x1d
    2b1e:	8f 3f       	cpi	r24, 0xFF	; 255
    2b20:	19 f4       	brne	.+6      	; 0x2b28 <xQueueSemaphoreTake+0xaa>
    2b22:	ea 81       	ldd	r30, Y+2	; 0x02
    2b24:	fb 81       	ldd	r31, Y+3	; 0x03
    2b26:	15 8e       	std	Z+29, r1	; 0x1d
    2b28:	ea 81       	ldd	r30, Y+2	; 0x02
    2b2a:	fb 81       	ldd	r31, Y+3	; 0x03
    2b2c:	86 8d       	ldd	r24, Z+30	; 0x1e
    2b2e:	8f 3f       	cpi	r24, 0xFF	; 255
    2b30:	19 f4       	brne	.+6      	; 0x2b38 <xQueueSemaphoreTake+0xba>
    2b32:	ea 81       	ldd	r30, Y+2	; 0x02
    2b34:	fb 81       	ldd	r31, Y+3	; 0x03
    2b36:	16 8e       	std	Z+30, r1	; 0x1e
    2b38:	0f 90       	pop	r0
    2b3a:	0f be       	out	0x3f, r0	; 63

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    2b3c:	ce 01       	movw	r24, r28
    2b3e:	05 96       	adiw	r24, 0x05	; 5
    2b40:	9e 01       	movw	r18, r28
    2b42:	26 5f       	subi	r18, 0xF6	; 246
    2b44:	3f 4f       	sbci	r19, 0xFF	; 255
    2b46:	b9 01       	movw	r22, r18
    2b48:	0e 94 d7 25 	call	0x4bae	; 0x4bae <xTaskCheckForTimeOut>
    2b4c:	88 23       	and	r24, r24
    2b4e:	09 f5       	brne	.+66     	; 0x2b92 <xQueueSemaphoreTake+0x114>
        {
            /* A block time is specified and not expired.  If the semaphore
             * count is 0 then enter the Blocked state to wait for a semaphore to
             * become available.  As semaphores are implemented with queues the
             * queue being empty is equivalent to the semaphore count being 0. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    2b50:	8a 81       	ldd	r24, Y+2	; 0x02
    2b52:	9b 81       	ldd	r25, Y+3	; 0x03
    2b54:	0e 94 d1 18 	call	0x31a2	; 0x31a2 <prvIsQueueEmpty>
    2b58:	88 23       	and	r24, r24
    2b5a:	a1 f0       	breq	.+40     	; 0x2b84 <xQueueSemaphoreTake+0x106>
                            mtCOVERAGE_TEST_MARKER();
                        }
                    }
                #endif /* if ( configUSE_MUTEXES == 1 ) */

                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    2b5c:	8a 81       	ldd	r24, Y+2	; 0x02
    2b5e:	9b 81       	ldd	r25, Y+3	; 0x03
    2b60:	41 96       	adiw	r24, 0x11	; 17
    2b62:	2a 85       	ldd	r18, Y+10	; 0x0a
    2b64:	3b 85       	ldd	r19, Y+11	; 0x0b
    2b66:	b9 01       	movw	r22, r18
    2b68:	0e 94 65 22 	call	0x44ca	; 0x44ca <vTaskPlaceOnEventList>
                prvUnlockQueue( pxQueue );
    2b6c:	8a 81       	ldd	r24, Y+2	; 0x02
    2b6e:	9b 81       	ldd	r25, Y+3	; 0x03
    2b70:	0e 94 7e 18 	call	0x30fc	; 0x30fc <prvUnlockQueue>

                if( xTaskResumeAll() == pdFALSE )
    2b74:	0e 94 94 1e 	call	0x3d28	; 0x3d28 <xTaskResumeAll>
    2b78:	88 23       	and	r24, r24
    2b7a:	09 f0       	breq	.+2      	; 0x2b7e <xQueueSemaphoreTake+0x100>
    2b7c:	93 cf       	rjmp	.-218    	; 0x2aa4 <xQueueSemaphoreTake+0x26>
                {
                    portYIELD_WITHIN_API();
    2b7e:	0e 94 72 09 	call	0x12e4	; 0x12e4 <vPortYield>
    2b82:	90 cf       	rjmp	.-224    	; 0x2aa4 <xQueueSemaphoreTake+0x26>
            }
            else
            {
                /* There was no timeout and the semaphore count was not 0, so
                 * attempt to take the semaphore again. */
                prvUnlockQueue( pxQueue );
    2b84:	8a 81       	ldd	r24, Y+2	; 0x02
    2b86:	9b 81       	ldd	r25, Y+3	; 0x03
    2b88:	0e 94 7e 18 	call	0x30fc	; 0x30fc <prvUnlockQueue>
                ( void ) xTaskResumeAll();
    2b8c:	0e 94 94 1e 	call	0x3d28	; 0x3d28 <xTaskResumeAll>
    2b90:	89 cf       	rjmp	.-238    	; 0x2aa4 <xQueueSemaphoreTake+0x26>
            }
        }
        else
        {
            /* Timed out. */
            prvUnlockQueue( pxQueue );
    2b92:	8a 81       	ldd	r24, Y+2	; 0x02
    2b94:	9b 81       	ldd	r25, Y+3	; 0x03
    2b96:	0e 94 7e 18 	call	0x30fc	; 0x30fc <prvUnlockQueue>
            ( void ) xTaskResumeAll();
    2b9a:	0e 94 94 1e 	call	0x3d28	; 0x3d28 <xTaskResumeAll>

            /* If the semaphore count is 0 exit now as the timeout has
             * expired.  Otherwise return to attempt to take the semaphore that is
             * known to be available.  As semaphores are implemented by queues the
             * queue being empty is equivalent to the semaphore count being 0. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    2b9e:	8a 81       	ldd	r24, Y+2	; 0x02
    2ba0:	9b 81       	ldd	r25, Y+3	; 0x03
    2ba2:	0e 94 d1 18 	call	0x31a2	; 0x31a2 <prvIsQueueEmpty>
    2ba6:	88 23       	and	r24, r24
    2ba8:	09 f4       	brne	.+2      	; 0x2bac <xQueueSemaphoreTake+0x12e>
    2baa:	7c cf       	rjmp	.-264    	; 0x2aa4 <xQueueSemaphoreTake+0x26>
                        }
                    }
                #endif /* configUSE_MUTEXES */

                traceQUEUE_RECEIVE_FAILED( pxQueue );
                return errQUEUE_EMPTY;
    2bac:	1c 86       	std	Y+12, r1	; 0x0c
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
    } /*lint -restore */
    2bae:	8c 85       	ldd	r24, Y+12	; 0x0c
}
    2bb0:	2c 96       	adiw	r28, 0x0c	; 12
    2bb2:	0f b6       	in	r0, 0x3f	; 63
    2bb4:	f8 94       	cli
    2bb6:	de bf       	out	0x3e, r29	; 62
    2bb8:	0f be       	out	0x3f, r0	; 63
    2bba:	cd bf       	out	0x3d, r28	; 61
    2bbc:	cf 91       	pop	r28
    2bbe:	df 91       	pop	r29
    2bc0:	08 95       	ret

00002bc2 <xQueuePeek>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeek( QueueHandle_t xQueue,
                       void * const pvBuffer,
                       TickType_t xTicksToWait )
{
    2bc2:	df 93       	push	r29
    2bc4:	cf 93       	push	r28
    2bc6:	cd b7       	in	r28, 0x3d	; 61
    2bc8:	de b7       	in	r29, 0x3e	; 62
    2bca:	60 97       	sbiw	r28, 0x10	; 16
    2bcc:	0f b6       	in	r0, 0x3f	; 63
    2bce:	f8 94       	cli
    2bd0:	de bf       	out	0x3e, r29	; 62
    2bd2:	0f be       	out	0x3f, r0	; 63
    2bd4:	cd bf       	out	0x3d, r28	; 61
    2bd6:	9b 87       	std	Y+11, r25	; 0x0b
    2bd8:	8a 87       	std	Y+10, r24	; 0x0a
    2bda:	7d 87       	std	Y+13, r23	; 0x0d
    2bdc:	6c 87       	std	Y+12, r22	; 0x0c
    2bde:	5f 87       	std	Y+15, r21	; 0x0f
    2be0:	4e 87       	std	Y+14, r20	; 0x0e
    BaseType_t xEntryTimeSet = pdFALSE;
    2be2:	1e 82       	std	Y+6, r1	; 0x06
    TimeOut_t xTimeOut;
    int8_t * pcOriginalReadPosition;
    Queue_t * const pxQueue = xQueue;
    2be4:	8a 85       	ldd	r24, Y+10	; 0x0a
    2be6:	9b 85       	ldd	r25, Y+11	; 0x0b
    2be8:	9b 83       	std	Y+3, r25	; 0x03
    2bea:	8a 83       	std	Y+2, r24	; 0x02
    /*lint -save -e904  This function relaxes the coding standard somewhat to
     * allow return statements within the function itself.  This is done in the
     * interest of execution time efficiency. */
    for( ; ; )
    {
        taskENTER_CRITICAL();
    2bec:	0f b6       	in	r0, 0x3f	; 63
    2bee:	f8 94       	cli
    2bf0:	0f 92       	push	r0
        {
            const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    2bf2:	ea 81       	ldd	r30, Y+2	; 0x02
    2bf4:	fb 81       	ldd	r31, Y+3	; 0x03
    2bf6:	82 8d       	ldd	r24, Z+26	; 0x1a
    2bf8:	89 83       	std	Y+1, r24	; 0x01

            /* Is there data in the queue now?  To be running the calling task
             * must be the highest priority task wanting to access the queue. */
            if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    2bfa:	89 81       	ldd	r24, Y+1	; 0x01
    2bfc:	88 23       	and	r24, r24
    2bfe:	31 f1       	breq	.+76     	; 0x2c4c <xQueuePeek+0x8a>
            {
                /* Remember the read position so it can be reset after the data
                 * is read from the queue as this function is only peeking the
                 * data, not removing it. */
                pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
    2c00:	ea 81       	ldd	r30, Y+2	; 0x02
    2c02:	fb 81       	ldd	r31, Y+3	; 0x03
    2c04:	86 81       	ldd	r24, Z+6	; 0x06
    2c06:	97 81       	ldd	r25, Z+7	; 0x07
    2c08:	9d 83       	std	Y+5, r25	; 0x05
    2c0a:	8c 83       	std	Y+4, r24	; 0x04

                prvCopyDataFromQueue( pxQueue, pvBuffer );
    2c0c:	8a 81       	ldd	r24, Y+2	; 0x02
    2c0e:	9b 81       	ldd	r25, Y+3	; 0x03
    2c10:	2c 85       	ldd	r18, Y+12	; 0x0c
    2c12:	3d 85       	ldd	r19, Y+13	; 0x0d
    2c14:	b9 01       	movw	r22, r18
    2c16:	0e 94 37 18 	call	0x306e	; 0x306e <prvCopyDataFromQueue>
                traceQUEUE_PEEK( pxQueue );

                /* The data is not being removed, so reset the read pointer. */
                pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
    2c1a:	ea 81       	ldd	r30, Y+2	; 0x02
    2c1c:	fb 81       	ldd	r31, Y+3	; 0x03
    2c1e:	8c 81       	ldd	r24, Y+4	; 0x04
    2c20:	9d 81       	ldd	r25, Y+5	; 0x05
    2c22:	97 83       	std	Z+7, r25	; 0x07
    2c24:	86 83       	std	Z+6, r24	; 0x06

                /* The data is being left in the queue, so see if there are
                 * any other tasks waiting for the data. */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    2c26:	ea 81       	ldd	r30, Y+2	; 0x02
    2c28:	fb 81       	ldd	r31, Y+3	; 0x03
    2c2a:	81 89       	ldd	r24, Z+17	; 0x11
    2c2c:	88 23       	and	r24, r24
    2c2e:	49 f0       	breq	.+18     	; 0x2c42 <xQueuePeek+0x80>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    2c30:	8a 81       	ldd	r24, Y+2	; 0x02
    2c32:	9b 81       	ldd	r25, Y+3	; 0x03
    2c34:	41 96       	adiw	r24, 0x11	; 17
    2c36:	0e 94 4e 23 	call	0x469c	; 0x469c <xTaskRemoveFromEventList>
    2c3a:	88 23       	and	r24, r24
    2c3c:	11 f0       	breq	.+4      	; 0x2c42 <xQueuePeek+0x80>
                    {
                        /* The task waiting has a higher priority than this task. */
                        queueYIELD_IF_USING_PREEMPTION();
    2c3e:	0e 94 72 09 	call	0x12e4	; 0x12e4 <vPortYield>
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                taskEXIT_CRITICAL();
    2c42:	0f 90       	pop	r0
    2c44:	0f be       	out	0x3f, r0	; 63
                return pdPASS;
    2c46:	81 e0       	ldi	r24, 0x01	; 1
    2c48:	88 8b       	std	Y+16, r24	; 0x10
    2c4a:	63 c0       	rjmp	.+198    	; 0x2d12 <xQueuePeek+0x150>
            }
            else
            {
                if( xTicksToWait == ( TickType_t ) 0 )
    2c4c:	8e 85       	ldd	r24, Y+14	; 0x0e
    2c4e:	9f 85       	ldd	r25, Y+15	; 0x0f
    2c50:	00 97       	sbiw	r24, 0x00	; 0
    2c52:	21 f4       	brne	.+8      	; 0x2c5c <xQueuePeek+0x9a>
                {
                    /* The queue was empty and no block time is specified (or
                     * the block time has expired) so leave now. */
                    taskEXIT_CRITICAL();
    2c54:	0f 90       	pop	r0
    2c56:	0f be       	out	0x3f, r0	; 63
                    traceQUEUE_PEEK_FAILED( pxQueue );
                    return errQUEUE_EMPTY;
    2c58:	18 8a       	std	Y+16, r1	; 0x10
    2c5a:	5b c0       	rjmp	.+182    	; 0x2d12 <xQueuePeek+0x150>
                }
                else if( xEntryTimeSet == pdFALSE )
    2c5c:	8e 81       	ldd	r24, Y+6	; 0x06
    2c5e:	88 23       	and	r24, r24
    2c60:	31 f4       	brne	.+12     	; 0x2c6e <xQueuePeek+0xac>
                {
                    /* The queue was empty and a block time was specified so
                     * configure the timeout structure ready to enter the blocked
                     * state. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
    2c62:	ce 01       	movw	r24, r28
    2c64:	07 96       	adiw	r24, 0x07	; 7
    2c66:	0e 94 be 25 	call	0x4b7c	; 0x4b7c <vTaskInternalSetTimeOutState>
                    xEntryTimeSet = pdTRUE;
    2c6a:	81 e0       	ldi	r24, 0x01	; 1
    2c6c:	8e 83       	std	Y+6, r24	; 0x06
                    /* Entry time was already set. */
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        taskEXIT_CRITICAL();
    2c6e:	0f 90       	pop	r0
    2c70:	0f be       	out	0x3f, r0	; 63

        /* Interrupts and other tasks can send to and receive from the queue
         * now that the critical section has been exited. */

        vTaskSuspendAll();
    2c72:	0e 94 88 1e 	call	0x3d10	; 0x3d10 <vTaskSuspendAll>
        prvLockQueue( pxQueue );
    2c76:	0f b6       	in	r0, 0x3f	; 63
    2c78:	f8 94       	cli
    2c7a:	0f 92       	push	r0
    2c7c:	ea 81       	ldd	r30, Y+2	; 0x02
    2c7e:	fb 81       	ldd	r31, Y+3	; 0x03
    2c80:	85 8d       	ldd	r24, Z+29	; 0x1d
    2c82:	8f 3f       	cpi	r24, 0xFF	; 255
    2c84:	19 f4       	brne	.+6      	; 0x2c8c <xQueuePeek+0xca>
    2c86:	ea 81       	ldd	r30, Y+2	; 0x02
    2c88:	fb 81       	ldd	r31, Y+3	; 0x03
    2c8a:	15 8e       	std	Z+29, r1	; 0x1d
    2c8c:	ea 81       	ldd	r30, Y+2	; 0x02
    2c8e:	fb 81       	ldd	r31, Y+3	; 0x03
    2c90:	86 8d       	ldd	r24, Z+30	; 0x1e
    2c92:	8f 3f       	cpi	r24, 0xFF	; 255
    2c94:	19 f4       	brne	.+6      	; 0x2c9c <xQueuePeek+0xda>
    2c96:	ea 81       	ldd	r30, Y+2	; 0x02
    2c98:	fb 81       	ldd	r31, Y+3	; 0x03
    2c9a:	16 8e       	std	Z+30, r1	; 0x1e
    2c9c:	0f 90       	pop	r0
    2c9e:	0f be       	out	0x3f, r0	; 63

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    2ca0:	ce 01       	movw	r24, r28
    2ca2:	07 96       	adiw	r24, 0x07	; 7
    2ca4:	9e 01       	movw	r18, r28
    2ca6:	22 5f       	subi	r18, 0xF2	; 242
    2ca8:	3f 4f       	sbci	r19, 0xFF	; 255
    2caa:	b9 01       	movw	r22, r18
    2cac:	0e 94 d7 25 	call	0x4bae	; 0x4bae <xTaskCheckForTimeOut>
    2cb0:	88 23       	and	r24, r24
    2cb2:	09 f5       	brne	.+66     	; 0x2cf6 <xQueuePeek+0x134>
        {
            /* Timeout has not expired yet, check to see if there is data in the
            * queue now, and if not enter the Blocked state to wait for data. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    2cb4:	8a 81       	ldd	r24, Y+2	; 0x02
    2cb6:	9b 81       	ldd	r25, Y+3	; 0x03
    2cb8:	0e 94 d1 18 	call	0x31a2	; 0x31a2 <prvIsQueueEmpty>
    2cbc:	88 23       	and	r24, r24
    2cbe:	a1 f0       	breq	.+40     	; 0x2ce8 <xQueuePeek+0x126>
            {
                traceBLOCKING_ON_QUEUE_PEEK( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    2cc0:	8a 81       	ldd	r24, Y+2	; 0x02
    2cc2:	9b 81       	ldd	r25, Y+3	; 0x03
    2cc4:	41 96       	adiw	r24, 0x11	; 17
    2cc6:	2e 85       	ldd	r18, Y+14	; 0x0e
    2cc8:	3f 85       	ldd	r19, Y+15	; 0x0f
    2cca:	b9 01       	movw	r22, r18
    2ccc:	0e 94 65 22 	call	0x44ca	; 0x44ca <vTaskPlaceOnEventList>
                prvUnlockQueue( pxQueue );
    2cd0:	8a 81       	ldd	r24, Y+2	; 0x02
    2cd2:	9b 81       	ldd	r25, Y+3	; 0x03
    2cd4:	0e 94 7e 18 	call	0x30fc	; 0x30fc <prvUnlockQueue>

                if( xTaskResumeAll() == pdFALSE )
    2cd8:	0e 94 94 1e 	call	0x3d28	; 0x3d28 <xTaskResumeAll>
    2cdc:	88 23       	and	r24, r24
    2cde:	09 f0       	breq	.+2      	; 0x2ce2 <xQueuePeek+0x120>
    2ce0:	85 cf       	rjmp	.-246    	; 0x2bec <xQueuePeek+0x2a>
                {
                    portYIELD_WITHIN_API();
    2ce2:	0e 94 72 09 	call	0x12e4	; 0x12e4 <vPortYield>
    2ce6:	82 cf       	rjmp	.-252    	; 0x2bec <xQueuePeek+0x2a>
            }
            else
            {
                /* There is data in the queue now, so don't enter the blocked
                 * state, instead return to try and obtain the data. */
                prvUnlockQueue( pxQueue );
    2ce8:	8a 81       	ldd	r24, Y+2	; 0x02
    2cea:	9b 81       	ldd	r25, Y+3	; 0x03
    2cec:	0e 94 7e 18 	call	0x30fc	; 0x30fc <prvUnlockQueue>
                ( void ) xTaskResumeAll();
    2cf0:	0e 94 94 1e 	call	0x3d28	; 0x3d28 <xTaskResumeAll>
    2cf4:	7b cf       	rjmp	.-266    	; 0x2bec <xQueuePeek+0x2a>
        }
        else
        {
            /* The timeout has expired.  If there is still no data in the queue
             * exit, otherwise go back and try to read the data again. */
            prvUnlockQueue( pxQueue );
    2cf6:	8a 81       	ldd	r24, Y+2	; 0x02
    2cf8:	9b 81       	ldd	r25, Y+3	; 0x03
    2cfa:	0e 94 7e 18 	call	0x30fc	; 0x30fc <prvUnlockQueue>
            ( void ) xTaskResumeAll();
    2cfe:	0e 94 94 1e 	call	0x3d28	; 0x3d28 <xTaskResumeAll>

            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    2d02:	8a 81       	ldd	r24, Y+2	; 0x02
    2d04:	9b 81       	ldd	r25, Y+3	; 0x03
    2d06:	0e 94 d1 18 	call	0x31a2	; 0x31a2 <prvIsQueueEmpty>
    2d0a:	88 23       	and	r24, r24
    2d0c:	09 f4       	brne	.+2      	; 0x2d10 <xQueuePeek+0x14e>
    2d0e:	6e cf       	rjmp	.-292    	; 0x2bec <xQueuePeek+0x2a>
            {
                traceQUEUE_PEEK_FAILED( pxQueue );
                return errQUEUE_EMPTY;
    2d10:	18 8a       	std	Y+16, r1	; 0x10
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
    } /*lint -restore */
    2d12:	88 89       	ldd	r24, Y+16	; 0x10
}
    2d14:	60 96       	adiw	r28, 0x10	; 16
    2d16:	0f b6       	in	r0, 0x3f	; 63
    2d18:	f8 94       	cli
    2d1a:	de bf       	out	0x3e, r29	; 62
    2d1c:	0f be       	out	0x3f, r0	; 63
    2d1e:	cd bf       	out	0x3d, r28	; 61
    2d20:	cf 91       	pop	r28
    2d22:	df 91       	pop	r29
    2d24:	08 95       	ret

00002d26 <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue,
                                 void * const pvBuffer,
                                 BaseType_t * const pxHigherPriorityTaskWoken )
{
    2d26:	df 93       	push	r29
    2d28:	cf 93       	push	r28
    2d2a:	cd b7       	in	r28, 0x3d	; 61
    2d2c:	de b7       	in	r29, 0x3e	; 62
    2d2e:	2c 97       	sbiw	r28, 0x0c	; 12
    2d30:	0f b6       	in	r0, 0x3f	; 63
    2d32:	f8 94       	cli
    2d34:	de bf       	out	0x3e, r29	; 62
    2d36:	0f be       	out	0x3f, r0	; 63
    2d38:	cd bf       	out	0x3d, r28	; 61
    2d3a:	98 87       	std	Y+8, r25	; 0x08
    2d3c:	8f 83       	std	Y+7, r24	; 0x07
    2d3e:	7a 87       	std	Y+10, r23	; 0x0a
    2d40:	69 87       	std	Y+9, r22	; 0x09
    2d42:	5c 87       	std	Y+12, r21	; 0x0c
    2d44:	4b 87       	std	Y+11, r20	; 0x0b
    BaseType_t xReturn;
    UBaseType_t uxSavedInterruptStatus;
    Queue_t * const pxQueue = xQueue;
    2d46:	8f 81       	ldd	r24, Y+7	; 0x07
    2d48:	98 85       	ldd	r25, Y+8	; 0x08
    2d4a:	9c 83       	std	Y+4, r25	; 0x04
    2d4c:	8b 83       	std	Y+3, r24	; 0x03
     * safe API to ensure interrupt entry is as fast and as simple as possible.
     * More information (albeit Cortex-M specific) is provided on the following
     * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    2d4e:	1d 82       	std	Y+5, r1	; 0x05
    {
        const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    2d50:	eb 81       	ldd	r30, Y+3	; 0x03
    2d52:	fc 81       	ldd	r31, Y+4	; 0x04
    2d54:	82 8d       	ldd	r24, Z+26	; 0x1a
    2d56:	8a 83       	std	Y+2, r24	; 0x02

        /* Cannot block in an ISR, so check there is data available. */
        if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    2d58:	8a 81       	ldd	r24, Y+2	; 0x02
    2d5a:	88 23       	and	r24, r24
    2d5c:	81 f1       	breq	.+96     	; 0x2dbe <xQueueReceiveFromISR+0x98>
        {
            const int8_t cRxLock = pxQueue->cRxLock;
    2d5e:	eb 81       	ldd	r30, Y+3	; 0x03
    2d60:	fc 81       	ldd	r31, Y+4	; 0x04
    2d62:	85 8d       	ldd	r24, Z+29	; 0x1d
    2d64:	89 83       	std	Y+1, r24	; 0x01

            traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

            prvCopyDataFromQueue( pxQueue, pvBuffer );
    2d66:	8b 81       	ldd	r24, Y+3	; 0x03
    2d68:	9c 81       	ldd	r25, Y+4	; 0x04
    2d6a:	29 85       	ldd	r18, Y+9	; 0x09
    2d6c:	3a 85       	ldd	r19, Y+10	; 0x0a
    2d6e:	b9 01       	movw	r22, r18
    2d70:	0e 94 37 18 	call	0x306e	; 0x306e <prvCopyDataFromQueue>
            pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
    2d74:	8a 81       	ldd	r24, Y+2	; 0x02
    2d76:	81 50       	subi	r24, 0x01	; 1
    2d78:	eb 81       	ldd	r30, Y+3	; 0x03
    2d7a:	fc 81       	ldd	r31, Y+4	; 0x04
    2d7c:	82 8f       	std	Z+26, r24	; 0x1a

            /* If the queue is locked the event list will not be modified.
             * Instead update the lock count so the task that unlocks the queue
             * will know that an ISR has removed data while the queue was
             * locked. */
            if( cRxLock == queueUNLOCKED )
    2d7e:	89 81       	ldd	r24, Y+1	; 0x01
    2d80:	8f 3f       	cpi	r24, 0xFF	; 255
    2d82:	a9 f4       	brne	.+42     	; 0x2dae <xQueueReceiveFromISR+0x88>
            {
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    2d84:	eb 81       	ldd	r30, Y+3	; 0x03
    2d86:	fc 81       	ldd	r31, Y+4	; 0x04
    2d88:	80 85       	ldd	r24, Z+8	; 0x08
    2d8a:	88 23       	and	r24, r24
    2d8c:	a9 f0       	breq	.+42     	; 0x2db8 <xQueueReceiveFromISR+0x92>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    2d8e:	8b 81       	ldd	r24, Y+3	; 0x03
    2d90:	9c 81       	ldd	r25, Y+4	; 0x04
    2d92:	08 96       	adiw	r24, 0x08	; 8
    2d94:	0e 94 4e 23 	call	0x469c	; 0x469c <xTaskRemoveFromEventList>
    2d98:	88 23       	and	r24, r24
    2d9a:	71 f0       	breq	.+28     	; 0x2db8 <xQueueReceiveFromISR+0x92>
                    {
                        /* The task waiting has a higher priority than us so
                         * force a context switch. */
                        if( pxHigherPriorityTaskWoken != NULL )
    2d9c:	8b 85       	ldd	r24, Y+11	; 0x0b
    2d9e:	9c 85       	ldd	r25, Y+12	; 0x0c
    2da0:	00 97       	sbiw	r24, 0x00	; 0
    2da2:	51 f0       	breq	.+20     	; 0x2db8 <xQueueReceiveFromISR+0x92>
                        {
                            *pxHigherPriorityTaskWoken = pdTRUE;
    2da4:	eb 85       	ldd	r30, Y+11	; 0x0b
    2da6:	fc 85       	ldd	r31, Y+12	; 0x0c
    2da8:	81 e0       	ldi	r24, 0x01	; 1
    2daa:	80 83       	st	Z, r24
    2dac:	05 c0       	rjmp	.+10     	; 0x2db8 <xQueueReceiveFromISR+0x92>
            {
                /* Increment the lock count so the task that unlocks the queue
                 * knows that data was removed while it was locked. */
                configASSERT( cRxLock != queueINT8_MAX );

                pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
    2dae:	89 81       	ldd	r24, Y+1	; 0x01
    2db0:	8f 5f       	subi	r24, 0xFF	; 255
    2db2:	eb 81       	ldd	r30, Y+3	; 0x03
    2db4:	fc 81       	ldd	r31, Y+4	; 0x04
    2db6:	85 8f       	std	Z+29, r24	; 0x1d
            }

            xReturn = pdPASS;
    2db8:	81 e0       	ldi	r24, 0x01	; 1
    2dba:	8e 83       	std	Y+6, r24	; 0x06
    2dbc:	01 c0       	rjmp	.+2      	; 0x2dc0 <xQueueReceiveFromISR+0x9a>
        }
        else
        {
            xReturn = pdFAIL;
    2dbe:	1e 82       	std	Y+6, r1	; 0x06
            traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
    2dc0:	8e 81       	ldd	r24, Y+6	; 0x06
}
    2dc2:	2c 96       	adiw	r28, 0x0c	; 12
    2dc4:	0f b6       	in	r0, 0x3f	; 63
    2dc6:	f8 94       	cli
    2dc8:	de bf       	out	0x3e, r29	; 62
    2dca:	0f be       	out	0x3f, r0	; 63
    2dcc:	cd bf       	out	0x3d, r28	; 61
    2dce:	cf 91       	pop	r28
    2dd0:	df 91       	pop	r29
    2dd2:	08 95       	ret

00002dd4 <xQueuePeekFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,
                              void * const pvBuffer )
{
    2dd4:	df 93       	push	r29
    2dd6:	cf 93       	push	r28
    2dd8:	cd b7       	in	r28, 0x3d	; 61
    2dda:	de b7       	in	r29, 0x3e	; 62
    2ddc:	2a 97       	sbiw	r28, 0x0a	; 10
    2dde:	0f b6       	in	r0, 0x3f	; 63
    2de0:	f8 94       	cli
    2de2:	de bf       	out	0x3e, r29	; 62
    2de4:	0f be       	out	0x3f, r0	; 63
    2de6:	cd bf       	out	0x3d, r28	; 61
    2de8:	98 87       	std	Y+8, r25	; 0x08
    2dea:	8f 83       	std	Y+7, r24	; 0x07
    2dec:	7a 87       	std	Y+10, r23	; 0x0a
    2dee:	69 87       	std	Y+9, r22	; 0x09
    BaseType_t xReturn;
    UBaseType_t uxSavedInterruptStatus;
    int8_t * pcOriginalReadPosition;
    Queue_t * const pxQueue = xQueue;
    2df0:	8f 81       	ldd	r24, Y+7	; 0x07
    2df2:	98 85       	ldd	r25, Y+8	; 0x08
    2df4:	9a 83       	std	Y+2, r25	; 0x02
    2df6:	89 83       	std	Y+1, r24	; 0x01
     * safe API to ensure interrupt entry is as fast and as simple as possible.
     * More information (albeit Cortex-M specific) is provided on the following
     * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    2df8:	1d 82       	std	Y+5, r1	; 0x05
    {
        /* Cannot block in an ISR, so check there is data available. */
        if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    2dfa:	e9 81       	ldd	r30, Y+1	; 0x01
    2dfc:	fa 81       	ldd	r31, Y+2	; 0x02
    2dfe:	82 8d       	ldd	r24, Z+26	; 0x1a
    2e00:	88 23       	and	r24, r24
    2e02:	b1 f0       	breq	.+44     	; 0x2e30 <xQueuePeekFromISR+0x5c>
        {
            traceQUEUE_PEEK_FROM_ISR( pxQueue );

            /* Remember the read position so it can be reset as nothing is
             * actually being removed from the queue. */
            pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
    2e04:	e9 81       	ldd	r30, Y+1	; 0x01
    2e06:	fa 81       	ldd	r31, Y+2	; 0x02
    2e08:	86 81       	ldd	r24, Z+6	; 0x06
    2e0a:	97 81       	ldd	r25, Z+7	; 0x07
    2e0c:	9c 83       	std	Y+4, r25	; 0x04
    2e0e:	8b 83       	std	Y+3, r24	; 0x03
            prvCopyDataFromQueue( pxQueue, pvBuffer );
    2e10:	89 81       	ldd	r24, Y+1	; 0x01
    2e12:	9a 81       	ldd	r25, Y+2	; 0x02
    2e14:	29 85       	ldd	r18, Y+9	; 0x09
    2e16:	3a 85       	ldd	r19, Y+10	; 0x0a
    2e18:	b9 01       	movw	r22, r18
    2e1a:	0e 94 37 18 	call	0x306e	; 0x306e <prvCopyDataFromQueue>
            pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
    2e1e:	e9 81       	ldd	r30, Y+1	; 0x01
    2e20:	fa 81       	ldd	r31, Y+2	; 0x02
    2e22:	8b 81       	ldd	r24, Y+3	; 0x03
    2e24:	9c 81       	ldd	r25, Y+4	; 0x04
    2e26:	97 83       	std	Z+7, r25	; 0x07
    2e28:	86 83       	std	Z+6, r24	; 0x06

            xReturn = pdPASS;
    2e2a:	81 e0       	ldi	r24, 0x01	; 1
    2e2c:	8e 83       	std	Y+6, r24	; 0x06
    2e2e:	01 c0       	rjmp	.+2      	; 0x2e32 <xQueuePeekFromISR+0x5e>
        }
        else
        {
            xReturn = pdFAIL;
    2e30:	1e 82       	std	Y+6, r1	; 0x06
            traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue );
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
    2e32:	8e 81       	ldd	r24, Y+6	; 0x06
}
    2e34:	2a 96       	adiw	r28, 0x0a	; 10
    2e36:	0f b6       	in	r0, 0x3f	; 63
    2e38:	f8 94       	cli
    2e3a:	de bf       	out	0x3e, r29	; 62
    2e3c:	0f be       	out	0x3f, r0	; 63
    2e3e:	cd bf       	out	0x3d, r28	; 61
    2e40:	cf 91       	pop	r28
    2e42:	df 91       	pop	r29
    2e44:	08 95       	ret

00002e46 <uxQueueMessagesWaiting>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue )
{
    2e46:	df 93       	push	r29
    2e48:	cf 93       	push	r28
    2e4a:	00 d0       	rcall	.+0      	; 0x2e4c <uxQueueMessagesWaiting+0x6>
    2e4c:	0f 92       	push	r0
    2e4e:	cd b7       	in	r28, 0x3d	; 61
    2e50:	de b7       	in	r29, 0x3e	; 62
    2e52:	9b 83       	std	Y+3, r25	; 0x03
    2e54:	8a 83       	std	Y+2, r24	; 0x02
    UBaseType_t uxReturn;

    configASSERT( xQueue );

    taskENTER_CRITICAL();
    2e56:	0f b6       	in	r0, 0x3f	; 63
    2e58:	f8 94       	cli
    2e5a:	0f 92       	push	r0
    {
        uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
    2e5c:	ea 81       	ldd	r30, Y+2	; 0x02
    2e5e:	fb 81       	ldd	r31, Y+3	; 0x03
    2e60:	82 8d       	ldd	r24, Z+26	; 0x1a
    2e62:	89 83       	std	Y+1, r24	; 0x01
    }
    taskEXIT_CRITICAL();
    2e64:	0f 90       	pop	r0
    2e66:	0f be       	out	0x3f, r0	; 63

    return uxReturn;
    2e68:	89 81       	ldd	r24, Y+1	; 0x01
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    2e6a:	0f 90       	pop	r0
    2e6c:	0f 90       	pop	r0
    2e6e:	0f 90       	pop	r0
    2e70:	cf 91       	pop	r28
    2e72:	df 91       	pop	r29
    2e74:	08 95       	ret

00002e76 <uxQueueSpacesAvailable>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )
{
    2e76:	df 93       	push	r29
    2e78:	cf 93       	push	r28
    2e7a:	00 d0       	rcall	.+0      	; 0x2e7c <uxQueueSpacesAvailable+0x6>
    2e7c:	00 d0       	rcall	.+0      	; 0x2e7e <uxQueueSpacesAvailable+0x8>
    2e7e:	0f 92       	push	r0
    2e80:	cd b7       	in	r28, 0x3d	; 61
    2e82:	de b7       	in	r29, 0x3e	; 62
    2e84:	9d 83       	std	Y+5, r25	; 0x05
    2e86:	8c 83       	std	Y+4, r24	; 0x04
    UBaseType_t uxReturn;
    Queue_t * const pxQueue = xQueue;
    2e88:	8c 81       	ldd	r24, Y+4	; 0x04
    2e8a:	9d 81       	ldd	r25, Y+5	; 0x05
    2e8c:	9a 83       	std	Y+2, r25	; 0x02
    2e8e:	89 83       	std	Y+1, r24	; 0x01

    configASSERT( pxQueue );

    taskENTER_CRITICAL();
    2e90:	0f b6       	in	r0, 0x3f	; 63
    2e92:	f8 94       	cli
    2e94:	0f 92       	push	r0
    {
        uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
    2e96:	e9 81       	ldd	r30, Y+1	; 0x01
    2e98:	fa 81       	ldd	r31, Y+2	; 0x02
    2e9a:	93 8d       	ldd	r25, Z+27	; 0x1b
    2e9c:	e9 81       	ldd	r30, Y+1	; 0x01
    2e9e:	fa 81       	ldd	r31, Y+2	; 0x02
    2ea0:	82 8d       	ldd	r24, Z+26	; 0x1a
    2ea2:	29 2f       	mov	r18, r25
    2ea4:	28 1b       	sub	r18, r24
    2ea6:	82 2f       	mov	r24, r18
    2ea8:	8b 83       	std	Y+3, r24	; 0x03
    }
    taskEXIT_CRITICAL();
    2eaa:	0f 90       	pop	r0
    2eac:	0f be       	out	0x3f, r0	; 63

    return uxReturn;
    2eae:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    2eb0:	0f 90       	pop	r0
    2eb2:	0f 90       	pop	r0
    2eb4:	0f 90       	pop	r0
    2eb6:	0f 90       	pop	r0
    2eb8:	0f 90       	pop	r0
    2eba:	cf 91       	pop	r28
    2ebc:	df 91       	pop	r29
    2ebe:	08 95       	ret

00002ec0 <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue )
{
    2ec0:	df 93       	push	r29
    2ec2:	cf 93       	push	r28
    2ec4:	00 d0       	rcall	.+0      	; 0x2ec6 <uxQueueMessagesWaitingFromISR+0x6>
    2ec6:	00 d0       	rcall	.+0      	; 0x2ec8 <uxQueueMessagesWaitingFromISR+0x8>
    2ec8:	0f 92       	push	r0
    2eca:	cd b7       	in	r28, 0x3d	; 61
    2ecc:	de b7       	in	r29, 0x3e	; 62
    2ece:	9d 83       	std	Y+5, r25	; 0x05
    2ed0:	8c 83       	std	Y+4, r24	; 0x04
    UBaseType_t uxReturn;
    Queue_t * const pxQueue = xQueue;
    2ed2:	8c 81       	ldd	r24, Y+4	; 0x04
    2ed4:	9d 81       	ldd	r25, Y+5	; 0x05
    2ed6:	9a 83       	std	Y+2, r25	; 0x02
    2ed8:	89 83       	std	Y+1, r24	; 0x01

    configASSERT( pxQueue );
    uxReturn = pxQueue->uxMessagesWaiting;
    2eda:	e9 81       	ldd	r30, Y+1	; 0x01
    2edc:	fa 81       	ldd	r31, Y+2	; 0x02
    2ede:	82 8d       	ldd	r24, Z+26	; 0x1a
    2ee0:	8b 83       	std	Y+3, r24	; 0x03

    return uxReturn;
    2ee2:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    2ee4:	0f 90       	pop	r0
    2ee6:	0f 90       	pop	r0
    2ee8:	0f 90       	pop	r0
    2eea:	0f 90       	pop	r0
    2eec:	0f 90       	pop	r0
    2eee:	cf 91       	pop	r28
    2ef0:	df 91       	pop	r29
    2ef2:	08 95       	ret

00002ef4 <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( QueueHandle_t xQueue )
{
    2ef4:	df 93       	push	r29
    2ef6:	cf 93       	push	r28
    2ef8:	00 d0       	rcall	.+0      	; 0x2efa <vQueueDelete+0x6>
    2efa:	00 d0       	rcall	.+0      	; 0x2efc <vQueueDelete+0x8>
    2efc:	cd b7       	in	r28, 0x3d	; 61
    2efe:	de b7       	in	r29, 0x3e	; 62
    2f00:	9c 83       	std	Y+4, r25	; 0x04
    2f02:	8b 83       	std	Y+3, r24	; 0x03
    Queue_t * const pxQueue = xQueue;
    2f04:	8b 81       	ldd	r24, Y+3	; 0x03
    2f06:	9c 81       	ldd	r25, Y+4	; 0x04
    2f08:	9a 83       	std	Y+2, r25	; 0x02
    2f0a:	89 83       	std	Y+1, r24	; 0x01

    #if ( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
        {
            /* The queue can only have been allocated dynamically - free it
             * again. */
            vPortFree( pxQueue );
    2f0c:	89 81       	ldd	r24, Y+1	; 0x01
    2f0e:	9a 81       	ldd	r25, Y+2	; 0x02
    2f10:	0e 94 8d 07 	call	0xf1a	; 0xf1a <vPortFree>
            /* The queue must have been statically allocated, so is not going to be
             * deleted.  Avoid compiler warnings about the unused parameter. */
            ( void ) pxQueue;
        }
    #endif /* configSUPPORT_DYNAMIC_ALLOCATION */
}
    2f14:	0f 90       	pop	r0
    2f16:	0f 90       	pop	r0
    2f18:	0f 90       	pop	r0
    2f1a:	0f 90       	pop	r0
    2f1c:	cf 91       	pop	r28
    2f1e:	df 91       	pop	r29
    2f20:	08 95       	ret

00002f22 <prvCopyDataToQueue>:
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue,
                                      const void * pvItemToQueue,
                                      const BaseType_t xPosition )
{
    2f22:	df 93       	push	r29
    2f24:	cf 93       	push	r28
    2f26:	cd b7       	in	r28, 0x3d	; 61
    2f28:	de b7       	in	r29, 0x3e	; 62
    2f2a:	27 97       	sbiw	r28, 0x07	; 7
    2f2c:	0f b6       	in	r0, 0x3f	; 63
    2f2e:	f8 94       	cli
    2f30:	de bf       	out	0x3e, r29	; 62
    2f32:	0f be       	out	0x3f, r0	; 63
    2f34:	cd bf       	out	0x3d, r28	; 61
    2f36:	9c 83       	std	Y+4, r25	; 0x04
    2f38:	8b 83       	std	Y+3, r24	; 0x03
    2f3a:	7e 83       	std	Y+6, r23	; 0x06
    2f3c:	6d 83       	std	Y+5, r22	; 0x05
    2f3e:	4f 83       	std	Y+7, r20	; 0x07
    BaseType_t xReturn = pdFALSE;
    2f40:	1a 82       	std	Y+2, r1	; 0x02
    UBaseType_t uxMessagesWaiting;

    /* This function is called from a critical section. */

    uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    2f42:	eb 81       	ldd	r30, Y+3	; 0x03
    2f44:	fc 81       	ldd	r31, Y+4	; 0x04
    2f46:	82 8d       	ldd	r24, Z+26	; 0x1a
    2f48:	89 83       	std	Y+1, r24	; 0x01

    if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
    2f4a:	eb 81       	ldd	r30, Y+3	; 0x03
    2f4c:	fc 81       	ldd	r31, Y+4	; 0x04
    2f4e:	84 8d       	ldd	r24, Z+28	; 0x1c
    2f50:	88 23       	and	r24, r24
    2f52:	09 f4       	brne	.+2      	; 0x2f56 <prvCopyDataToQueue+0x34>
    2f54:	7d c0       	rjmp	.+250    	; 0x3050 <prvCopyDataToQueue+0x12e>
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        #endif /* configUSE_MUTEXES */
    }
    else if( xPosition == queueSEND_TO_BACK )
    2f56:	8f 81       	ldd	r24, Y+7	; 0x07
    2f58:	88 23       	and	r24, r24
    2f5a:	99 f5       	brne	.+102    	; 0x2fc2 <prvCopyDataToQueue+0xa0>
    {
        ( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
    2f5c:	eb 81       	ldd	r30, Y+3	; 0x03
    2f5e:	fc 81       	ldd	r31, Y+4	; 0x04
    2f60:	62 81       	ldd	r22, Z+2	; 0x02
    2f62:	73 81       	ldd	r23, Z+3	; 0x03
    2f64:	eb 81       	ldd	r30, Y+3	; 0x03
    2f66:	fc 81       	ldd	r31, Y+4	; 0x04
    2f68:	84 8d       	ldd	r24, Z+28	; 0x1c
    2f6a:	48 2f       	mov	r20, r24
    2f6c:	50 e0       	ldi	r21, 0x00	; 0
    2f6e:	2d 81       	ldd	r18, Y+5	; 0x05
    2f70:	3e 81       	ldd	r19, Y+6	; 0x06
    2f72:	cb 01       	movw	r24, r22
    2f74:	b9 01       	movw	r22, r18
    2f76:	0e 94 81 49 	call	0x9302	; 0x9302 <memcpy>
        pxQueue->pcWriteTo += pxQueue->uxItemSize;                                                       /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
    2f7a:	eb 81       	ldd	r30, Y+3	; 0x03
    2f7c:	fc 81       	ldd	r31, Y+4	; 0x04
    2f7e:	22 81       	ldd	r18, Z+2	; 0x02
    2f80:	33 81       	ldd	r19, Z+3	; 0x03
    2f82:	eb 81       	ldd	r30, Y+3	; 0x03
    2f84:	fc 81       	ldd	r31, Y+4	; 0x04
    2f86:	84 8d       	ldd	r24, Z+28	; 0x1c
    2f88:	88 2f       	mov	r24, r24
    2f8a:	90 e0       	ldi	r25, 0x00	; 0
    2f8c:	82 0f       	add	r24, r18
    2f8e:	93 1f       	adc	r25, r19
    2f90:	eb 81       	ldd	r30, Y+3	; 0x03
    2f92:	fc 81       	ldd	r31, Y+4	; 0x04
    2f94:	93 83       	std	Z+3, r25	; 0x03
    2f96:	82 83       	std	Z+2, r24	; 0x02

        if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail )                                             /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    2f98:	eb 81       	ldd	r30, Y+3	; 0x03
    2f9a:	fc 81       	ldd	r31, Y+4	; 0x04
    2f9c:	22 81       	ldd	r18, Z+2	; 0x02
    2f9e:	33 81       	ldd	r19, Z+3	; 0x03
    2fa0:	eb 81       	ldd	r30, Y+3	; 0x03
    2fa2:	fc 81       	ldd	r31, Y+4	; 0x04
    2fa4:	84 81       	ldd	r24, Z+4	; 0x04
    2fa6:	95 81       	ldd	r25, Z+5	; 0x05
    2fa8:	28 17       	cp	r18, r24
    2faa:	39 07       	cpc	r19, r25
    2fac:	08 f4       	brcc	.+2      	; 0x2fb0 <prvCopyDataToQueue+0x8e>
    2fae:	50 c0       	rjmp	.+160    	; 0x3050 <prvCopyDataToQueue+0x12e>
        {
            pxQueue->pcWriteTo = pxQueue->pcHead;
    2fb0:	eb 81       	ldd	r30, Y+3	; 0x03
    2fb2:	fc 81       	ldd	r31, Y+4	; 0x04
    2fb4:	80 81       	ld	r24, Z
    2fb6:	91 81       	ldd	r25, Z+1	; 0x01
    2fb8:	eb 81       	ldd	r30, Y+3	; 0x03
    2fba:	fc 81       	ldd	r31, Y+4	; 0x04
    2fbc:	93 83       	std	Z+3, r25	; 0x03
    2fbe:	82 83       	std	Z+2, r24	; 0x02
    2fc0:	47 c0       	rjmp	.+142    	; 0x3050 <prvCopyDataToQueue+0x12e>
            mtCOVERAGE_TEST_MARKER();
        }
    }
    else
    {
        ( void ) memcpy( ( void * ) pxQueue->u.xQueue.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e9087 !e418 MISRA exception as the casts are only redundant for some ports.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes.  Assert checks null pointer only used when length is 0. */
    2fc2:	eb 81       	ldd	r30, Y+3	; 0x03
    2fc4:	fc 81       	ldd	r31, Y+4	; 0x04
    2fc6:	66 81       	ldd	r22, Z+6	; 0x06
    2fc8:	77 81       	ldd	r23, Z+7	; 0x07
    2fca:	eb 81       	ldd	r30, Y+3	; 0x03
    2fcc:	fc 81       	ldd	r31, Y+4	; 0x04
    2fce:	84 8d       	ldd	r24, Z+28	; 0x1c
    2fd0:	48 2f       	mov	r20, r24
    2fd2:	50 e0       	ldi	r21, 0x00	; 0
    2fd4:	2d 81       	ldd	r18, Y+5	; 0x05
    2fd6:	3e 81       	ldd	r19, Y+6	; 0x06
    2fd8:	cb 01       	movw	r24, r22
    2fda:	b9 01       	movw	r22, r18
    2fdc:	0e 94 81 49 	call	0x9302	; 0x9302 <memcpy>
        pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
    2fe0:	eb 81       	ldd	r30, Y+3	; 0x03
    2fe2:	fc 81       	ldd	r31, Y+4	; 0x04
    2fe4:	26 81       	ldd	r18, Z+6	; 0x06
    2fe6:	37 81       	ldd	r19, Z+7	; 0x07
    2fe8:	eb 81       	ldd	r30, Y+3	; 0x03
    2fea:	fc 81       	ldd	r31, Y+4	; 0x04
    2fec:	84 8d       	ldd	r24, Z+28	; 0x1c
    2fee:	88 2f       	mov	r24, r24
    2ff0:	90 e0       	ldi	r25, 0x00	; 0
    2ff2:	90 95       	com	r25
    2ff4:	81 95       	neg	r24
    2ff6:	9f 4f       	sbci	r25, 0xFF	; 255
    2ff8:	82 0f       	add	r24, r18
    2ffa:	93 1f       	adc	r25, r19
    2ffc:	eb 81       	ldd	r30, Y+3	; 0x03
    2ffe:	fc 81       	ldd	r31, Y+4	; 0x04
    3000:	97 83       	std	Z+7, r25	; 0x07
    3002:	86 83       	std	Z+6, r24	; 0x06

        if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    3004:	eb 81       	ldd	r30, Y+3	; 0x03
    3006:	fc 81       	ldd	r31, Y+4	; 0x04
    3008:	26 81       	ldd	r18, Z+6	; 0x06
    300a:	37 81       	ldd	r19, Z+7	; 0x07
    300c:	eb 81       	ldd	r30, Y+3	; 0x03
    300e:	fc 81       	ldd	r31, Y+4	; 0x04
    3010:	80 81       	ld	r24, Z
    3012:	91 81       	ldd	r25, Z+1	; 0x01
    3014:	28 17       	cp	r18, r24
    3016:	39 07       	cpc	r19, r25
    3018:	90 f4       	brcc	.+36     	; 0x303e <prvCopyDataToQueue+0x11c>
        {
            pxQueue->u.xQueue.pcReadFrom = ( pxQueue->u.xQueue.pcTail - pxQueue->uxItemSize );
    301a:	eb 81       	ldd	r30, Y+3	; 0x03
    301c:	fc 81       	ldd	r31, Y+4	; 0x04
    301e:	24 81       	ldd	r18, Z+4	; 0x04
    3020:	35 81       	ldd	r19, Z+5	; 0x05
    3022:	eb 81       	ldd	r30, Y+3	; 0x03
    3024:	fc 81       	ldd	r31, Y+4	; 0x04
    3026:	84 8d       	ldd	r24, Z+28	; 0x1c
    3028:	88 2f       	mov	r24, r24
    302a:	90 e0       	ldi	r25, 0x00	; 0
    302c:	90 95       	com	r25
    302e:	81 95       	neg	r24
    3030:	9f 4f       	sbci	r25, 0xFF	; 255
    3032:	82 0f       	add	r24, r18
    3034:	93 1f       	adc	r25, r19
    3036:	eb 81       	ldd	r30, Y+3	; 0x03
    3038:	fc 81       	ldd	r31, Y+4	; 0x04
    303a:	97 83       	std	Z+7, r25	; 0x07
    303c:	86 83       	std	Z+6, r24	; 0x06
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        if( xPosition == queueOVERWRITE )
    303e:	8f 81       	ldd	r24, Y+7	; 0x07
    3040:	82 30       	cpi	r24, 0x02	; 2
    3042:	31 f4       	brne	.+12     	; 0x3050 <prvCopyDataToQueue+0x12e>
        {
            if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    3044:	89 81       	ldd	r24, Y+1	; 0x01
    3046:	88 23       	and	r24, r24
    3048:	19 f0       	breq	.+6      	; 0x3050 <prvCopyDataToQueue+0x12e>
            {
                /* An item is not being added but overwritten, so subtract
                 * one from the recorded number of items in the queue so when
                 * one is added again below the number of recorded items remains
                 * correct. */
                --uxMessagesWaiting;
    304a:	89 81       	ldd	r24, Y+1	; 0x01
    304c:	81 50       	subi	r24, 0x01	; 1
    304e:	89 83       	std	Y+1, r24	; 0x01
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }

    pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
    3050:	89 81       	ldd	r24, Y+1	; 0x01
    3052:	8f 5f       	subi	r24, 0xFF	; 255
    3054:	eb 81       	ldd	r30, Y+3	; 0x03
    3056:	fc 81       	ldd	r31, Y+4	; 0x04
    3058:	82 8f       	std	Z+26, r24	; 0x1a

    return xReturn;
    305a:	8a 81       	ldd	r24, Y+2	; 0x02
}
    305c:	27 96       	adiw	r28, 0x07	; 7
    305e:	0f b6       	in	r0, 0x3f	; 63
    3060:	f8 94       	cli
    3062:	de bf       	out	0x3e, r29	; 62
    3064:	0f be       	out	0x3f, r0	; 63
    3066:	cd bf       	out	0x3d, r28	; 61
    3068:	cf 91       	pop	r28
    306a:	df 91       	pop	r29
    306c:	08 95       	ret

0000306e <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue,
                                  void * const pvBuffer )
{
    306e:	df 93       	push	r29
    3070:	cf 93       	push	r28
    3072:	00 d0       	rcall	.+0      	; 0x3074 <prvCopyDataFromQueue+0x6>
    3074:	00 d0       	rcall	.+0      	; 0x3076 <prvCopyDataFromQueue+0x8>
    3076:	cd b7       	in	r28, 0x3d	; 61
    3078:	de b7       	in	r29, 0x3e	; 62
    307a:	9a 83       	std	Y+2, r25	; 0x02
    307c:	89 83       	std	Y+1, r24	; 0x01
    307e:	7c 83       	std	Y+4, r23	; 0x04
    3080:	6b 83       	std	Y+3, r22	; 0x03
    if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
    3082:	e9 81       	ldd	r30, Y+1	; 0x01
    3084:	fa 81       	ldd	r31, Y+2	; 0x02
    3086:	84 8d       	ldd	r24, Z+28	; 0x1c
    3088:	88 23       	and	r24, r24
    308a:	89 f1       	breq	.+98     	; 0x30ee <prvCopyDataFromQueue+0x80>
    {
        pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;           /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
    308c:	e9 81       	ldd	r30, Y+1	; 0x01
    308e:	fa 81       	ldd	r31, Y+2	; 0x02
    3090:	26 81       	ldd	r18, Z+6	; 0x06
    3092:	37 81       	ldd	r19, Z+7	; 0x07
    3094:	e9 81       	ldd	r30, Y+1	; 0x01
    3096:	fa 81       	ldd	r31, Y+2	; 0x02
    3098:	84 8d       	ldd	r24, Z+28	; 0x1c
    309a:	88 2f       	mov	r24, r24
    309c:	90 e0       	ldi	r25, 0x00	; 0
    309e:	82 0f       	add	r24, r18
    30a0:	93 1f       	adc	r25, r19
    30a2:	e9 81       	ldd	r30, Y+1	; 0x01
    30a4:	fa 81       	ldd	r31, Y+2	; 0x02
    30a6:	97 83       	std	Z+7, r25	; 0x07
    30a8:	86 83       	std	Z+6, r24	; 0x06

        if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
    30aa:	e9 81       	ldd	r30, Y+1	; 0x01
    30ac:	fa 81       	ldd	r31, Y+2	; 0x02
    30ae:	26 81       	ldd	r18, Z+6	; 0x06
    30b0:	37 81       	ldd	r19, Z+7	; 0x07
    30b2:	e9 81       	ldd	r30, Y+1	; 0x01
    30b4:	fa 81       	ldd	r31, Y+2	; 0x02
    30b6:	84 81       	ldd	r24, Z+4	; 0x04
    30b8:	95 81       	ldd	r25, Z+5	; 0x05
    30ba:	28 17       	cp	r18, r24
    30bc:	39 07       	cpc	r19, r25
    30be:	40 f0       	brcs	.+16     	; 0x30d0 <prvCopyDataFromQueue+0x62>
        {
            pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
    30c0:	e9 81       	ldd	r30, Y+1	; 0x01
    30c2:	fa 81       	ldd	r31, Y+2	; 0x02
    30c4:	80 81       	ld	r24, Z
    30c6:	91 81       	ldd	r25, Z+1	; 0x01
    30c8:	e9 81       	ldd	r30, Y+1	; 0x01
    30ca:	fa 81       	ldd	r31, Y+2	; 0x02
    30cc:	97 83       	std	Z+7, r25	; 0x07
    30ce:	86 83       	std	Z+6, r24	; 0x06
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        ( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
    30d0:	e9 81       	ldd	r30, Y+1	; 0x01
    30d2:	fa 81       	ldd	r31, Y+2	; 0x02
    30d4:	46 81       	ldd	r20, Z+6	; 0x06
    30d6:	57 81       	ldd	r21, Z+7	; 0x07
    30d8:	e9 81       	ldd	r30, Y+1	; 0x01
    30da:	fa 81       	ldd	r31, Y+2	; 0x02
    30dc:	84 8d       	ldd	r24, Z+28	; 0x1c
    30de:	28 2f       	mov	r18, r24
    30e0:	30 e0       	ldi	r19, 0x00	; 0
    30e2:	8b 81       	ldd	r24, Y+3	; 0x03
    30e4:	9c 81       	ldd	r25, Y+4	; 0x04
    30e6:	ba 01       	movw	r22, r20
    30e8:	a9 01       	movw	r20, r18
    30ea:	0e 94 81 49 	call	0x9302	; 0x9302 <memcpy>
    }
}
    30ee:	0f 90       	pop	r0
    30f0:	0f 90       	pop	r0
    30f2:	0f 90       	pop	r0
    30f4:	0f 90       	pop	r0
    30f6:	cf 91       	pop	r28
    30f8:	df 91       	pop	r29
    30fa:	08 95       	ret

000030fc <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
    30fc:	df 93       	push	r29
    30fe:	cf 93       	push	r28
    3100:	00 d0       	rcall	.+0      	; 0x3102 <prvUnlockQueue+0x6>
    3102:	00 d0       	rcall	.+0      	; 0x3104 <prvUnlockQueue+0x8>
    3104:	cd b7       	in	r28, 0x3d	; 61
    3106:	de b7       	in	r29, 0x3e	; 62
    3108:	9c 83       	std	Y+4, r25	; 0x04
    310a:	8b 83       	std	Y+3, r24	; 0x03

    /* The lock counts contains the number of extra data items placed or
     * removed from the queue while the queue was locked.  When a queue is
     * locked items can be added or removed, but the event lists cannot be
     * updated. */
    taskENTER_CRITICAL();
    310c:	0f b6       	in	r0, 0x3f	; 63
    310e:	f8 94       	cli
    3110:	0f 92       	push	r0
    {
        int8_t cTxLock = pxQueue->cTxLock;
    3112:	eb 81       	ldd	r30, Y+3	; 0x03
    3114:	fc 81       	ldd	r31, Y+4	; 0x04
    3116:	86 8d       	ldd	r24, Z+30	; 0x1e
    3118:	8a 83       	std	Y+2, r24	; 0x02
    311a:	11 c0       	rjmp	.+34     	; 0x313e <prvUnlockQueue+0x42>
                }
            #else /* configUSE_QUEUE_SETS */
                {
                    /* Tasks that are removed from the event list will get added to
                     * the pending ready list as the scheduler is still suspended. */
                    if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    311c:	eb 81       	ldd	r30, Y+3	; 0x03
    311e:	fc 81       	ldd	r31, Y+4	; 0x04
    3120:	81 89       	ldd	r24, Z+17	; 0x11
    3122:	88 23       	and	r24, r24
    3124:	79 f0       	breq	.+30     	; 0x3144 <prvUnlockQueue+0x48>
                    {
                        if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    3126:	8b 81       	ldd	r24, Y+3	; 0x03
    3128:	9c 81       	ldd	r25, Y+4	; 0x04
    312a:	41 96       	adiw	r24, 0x11	; 17
    312c:	0e 94 4e 23 	call	0x469c	; 0x469c <xTaskRemoveFromEventList>
    3130:	88 23       	and	r24, r24
    3132:	11 f0       	breq	.+4      	; 0x3138 <prvUnlockQueue+0x3c>
                        {
                            /* The task waiting has a higher priority so record that
                             * a context switch is required. */
                            vTaskMissedYield();
    3134:	0e 94 3e 26 	call	0x4c7c	; 0x4c7c <vTaskMissedYield>
                        break;
                    }
                }
            #endif /* configUSE_QUEUE_SETS */

            --cTxLock;
    3138:	8a 81       	ldd	r24, Y+2	; 0x02
    313a:	81 50       	subi	r24, 0x01	; 1
    313c:	8a 83       	std	Y+2, r24	; 0x02
    taskENTER_CRITICAL();
    {
        int8_t cTxLock = pxQueue->cTxLock;

        /* See if data was added to the queue while it was locked. */
        while( cTxLock > queueLOCKED_UNMODIFIED )
    313e:	8a 81       	ldd	r24, Y+2	; 0x02
    3140:	18 16       	cp	r1, r24
    3142:	64 f3       	brlt	.-40     	; 0x311c <prvUnlockQueue+0x20>
            #endif /* configUSE_QUEUE_SETS */

            --cTxLock;
        }

        pxQueue->cTxLock = queueUNLOCKED;
    3144:	eb 81       	ldd	r30, Y+3	; 0x03
    3146:	fc 81       	ldd	r31, Y+4	; 0x04
    3148:	8f ef       	ldi	r24, 0xFF	; 255
    314a:	86 8f       	std	Z+30, r24	; 0x1e
    }
    taskEXIT_CRITICAL();
    314c:	0f 90       	pop	r0
    314e:	0f be       	out	0x3f, r0	; 63

    /* Do the same for the Rx lock. */
    taskENTER_CRITICAL();
    3150:	0f b6       	in	r0, 0x3f	; 63
    3152:	f8 94       	cli
    3154:	0f 92       	push	r0
    {
        int8_t cRxLock = pxQueue->cRxLock;
    3156:	eb 81       	ldd	r30, Y+3	; 0x03
    3158:	fc 81       	ldd	r31, Y+4	; 0x04
    315a:	85 8d       	ldd	r24, Z+29	; 0x1d
    315c:	89 83       	std	Y+1, r24	; 0x01
    315e:	11 c0       	rjmp	.+34     	; 0x3182 <prvUnlockQueue+0x86>

        while( cRxLock > queueLOCKED_UNMODIFIED )
        {
            if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    3160:	eb 81       	ldd	r30, Y+3	; 0x03
    3162:	fc 81       	ldd	r31, Y+4	; 0x04
    3164:	80 85       	ldd	r24, Z+8	; 0x08
    3166:	88 23       	and	r24, r24
    3168:	79 f0       	breq	.+30     	; 0x3188 <prvUnlockQueue+0x8c>
            {
                if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    316a:	8b 81       	ldd	r24, Y+3	; 0x03
    316c:	9c 81       	ldd	r25, Y+4	; 0x04
    316e:	08 96       	adiw	r24, 0x08	; 8
    3170:	0e 94 4e 23 	call	0x469c	; 0x469c <xTaskRemoveFromEventList>
    3174:	88 23       	and	r24, r24
    3176:	11 f0       	breq	.+4      	; 0x317c <prvUnlockQueue+0x80>
                {
                    vTaskMissedYield();
    3178:	0e 94 3e 26 	call	0x4c7c	; 0x4c7c <vTaskMissedYield>
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                --cRxLock;
    317c:	89 81       	ldd	r24, Y+1	; 0x01
    317e:	81 50       	subi	r24, 0x01	; 1
    3180:	89 83       	std	Y+1, r24	; 0x01
    /* Do the same for the Rx lock. */
    taskENTER_CRITICAL();
    {
        int8_t cRxLock = pxQueue->cRxLock;

        while( cRxLock > queueLOCKED_UNMODIFIED )
    3182:	89 81       	ldd	r24, Y+1	; 0x01
    3184:	18 16       	cp	r1, r24
    3186:	64 f3       	brlt	.-40     	; 0x3160 <prvUnlockQueue+0x64>
            {
                break;
            }
        }

        pxQueue->cRxLock = queueUNLOCKED;
    3188:	eb 81       	ldd	r30, Y+3	; 0x03
    318a:	fc 81       	ldd	r31, Y+4	; 0x04
    318c:	8f ef       	ldi	r24, 0xFF	; 255
    318e:	85 8f       	std	Z+29, r24	; 0x1d
    }
    taskEXIT_CRITICAL();
    3190:	0f 90       	pop	r0
    3192:	0f be       	out	0x3f, r0	; 63
}
    3194:	0f 90       	pop	r0
    3196:	0f 90       	pop	r0
    3198:	0f 90       	pop	r0
    319a:	0f 90       	pop	r0
    319c:	cf 91       	pop	r28
    319e:	df 91       	pop	r29
    31a0:	08 95       	ret

000031a2 <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueEmpty( const Queue_t * pxQueue )
{
    31a2:	df 93       	push	r29
    31a4:	cf 93       	push	r28
    31a6:	00 d0       	rcall	.+0      	; 0x31a8 <prvIsQueueEmpty+0x6>
    31a8:	0f 92       	push	r0
    31aa:	cd b7       	in	r28, 0x3d	; 61
    31ac:	de b7       	in	r29, 0x3e	; 62
    31ae:	9b 83       	std	Y+3, r25	; 0x03
    31b0:	8a 83       	std	Y+2, r24	; 0x02
    BaseType_t xReturn;

    taskENTER_CRITICAL();
    31b2:	0f b6       	in	r0, 0x3f	; 63
    31b4:	f8 94       	cli
    31b6:	0f 92       	push	r0
    {
        if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    31b8:	ea 81       	ldd	r30, Y+2	; 0x02
    31ba:	fb 81       	ldd	r31, Y+3	; 0x03
    31bc:	82 8d       	ldd	r24, Z+26	; 0x1a
    31be:	88 23       	and	r24, r24
    31c0:	19 f4       	brne	.+6      	; 0x31c8 <prvIsQueueEmpty+0x26>
        {
            xReturn = pdTRUE;
    31c2:	81 e0       	ldi	r24, 0x01	; 1
    31c4:	89 83       	std	Y+1, r24	; 0x01
    31c6:	01 c0       	rjmp	.+2      	; 0x31ca <prvIsQueueEmpty+0x28>
        }
        else
        {
            xReturn = pdFALSE;
    31c8:	19 82       	std	Y+1, r1	; 0x01
        }
    }
    taskEXIT_CRITICAL();
    31ca:	0f 90       	pop	r0
    31cc:	0f be       	out	0x3f, r0	; 63

    return xReturn;
    31ce:	89 81       	ldd	r24, Y+1	; 0x01
}
    31d0:	0f 90       	pop	r0
    31d2:	0f 90       	pop	r0
    31d4:	0f 90       	pop	r0
    31d6:	cf 91       	pop	r28
    31d8:	df 91       	pop	r29
    31da:	08 95       	ret

000031dc <xQueueIsQueueEmptyFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )
{
    31dc:	df 93       	push	r29
    31de:	cf 93       	push	r28
    31e0:	00 d0       	rcall	.+0      	; 0x31e2 <xQueueIsQueueEmptyFromISR+0x6>
    31e2:	00 d0       	rcall	.+0      	; 0x31e4 <xQueueIsQueueEmptyFromISR+0x8>
    31e4:	0f 92       	push	r0
    31e6:	cd b7       	in	r28, 0x3d	; 61
    31e8:	de b7       	in	r29, 0x3e	; 62
    31ea:	9d 83       	std	Y+5, r25	; 0x05
    31ec:	8c 83       	std	Y+4, r24	; 0x04
    BaseType_t xReturn;
    Queue_t * const pxQueue = xQueue;
    31ee:	8c 81       	ldd	r24, Y+4	; 0x04
    31f0:	9d 81       	ldd	r25, Y+5	; 0x05
    31f2:	9a 83       	std	Y+2, r25	; 0x02
    31f4:	89 83       	std	Y+1, r24	; 0x01

    configASSERT( pxQueue );

    if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    31f6:	e9 81       	ldd	r30, Y+1	; 0x01
    31f8:	fa 81       	ldd	r31, Y+2	; 0x02
    31fa:	82 8d       	ldd	r24, Z+26	; 0x1a
    31fc:	88 23       	and	r24, r24
    31fe:	19 f4       	brne	.+6      	; 0x3206 <xQueueIsQueueEmptyFromISR+0x2a>
    {
        xReturn = pdTRUE;
    3200:	81 e0       	ldi	r24, 0x01	; 1
    3202:	8b 83       	std	Y+3, r24	; 0x03
    3204:	01 c0       	rjmp	.+2      	; 0x3208 <xQueueIsQueueEmptyFromISR+0x2c>
    }
    else
    {
        xReturn = pdFALSE;
    3206:	1b 82       	std	Y+3, r1	; 0x03
    }

    return xReturn;
    3208:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    320a:	0f 90       	pop	r0
    320c:	0f 90       	pop	r0
    320e:	0f 90       	pop	r0
    3210:	0f 90       	pop	r0
    3212:	0f 90       	pop	r0
    3214:	cf 91       	pop	r28
    3216:	df 91       	pop	r29
    3218:	08 95       	ret

0000321a <prvIsQueueFull>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueFull( const Queue_t * pxQueue )
{
    321a:	df 93       	push	r29
    321c:	cf 93       	push	r28
    321e:	00 d0       	rcall	.+0      	; 0x3220 <prvIsQueueFull+0x6>
    3220:	0f 92       	push	r0
    3222:	cd b7       	in	r28, 0x3d	; 61
    3224:	de b7       	in	r29, 0x3e	; 62
    3226:	9b 83       	std	Y+3, r25	; 0x03
    3228:	8a 83       	std	Y+2, r24	; 0x02
    BaseType_t xReturn;

    taskENTER_CRITICAL();
    322a:	0f b6       	in	r0, 0x3f	; 63
    322c:	f8 94       	cli
    322e:	0f 92       	push	r0
    {
        if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    3230:	ea 81       	ldd	r30, Y+2	; 0x02
    3232:	fb 81       	ldd	r31, Y+3	; 0x03
    3234:	92 8d       	ldd	r25, Z+26	; 0x1a
    3236:	ea 81       	ldd	r30, Y+2	; 0x02
    3238:	fb 81       	ldd	r31, Y+3	; 0x03
    323a:	83 8d       	ldd	r24, Z+27	; 0x1b
    323c:	98 17       	cp	r25, r24
    323e:	19 f4       	brne	.+6      	; 0x3246 <prvIsQueueFull+0x2c>
        {
            xReturn = pdTRUE;
    3240:	81 e0       	ldi	r24, 0x01	; 1
    3242:	89 83       	std	Y+1, r24	; 0x01
    3244:	01 c0       	rjmp	.+2      	; 0x3248 <prvIsQueueFull+0x2e>
        }
        else
        {
            xReturn = pdFALSE;
    3246:	19 82       	std	Y+1, r1	; 0x01
        }
    }
    taskEXIT_CRITICAL();
    3248:	0f 90       	pop	r0
    324a:	0f be       	out	0x3f, r0	; 63

    return xReturn;
    324c:	89 81       	ldd	r24, Y+1	; 0x01
}
    324e:	0f 90       	pop	r0
    3250:	0f 90       	pop	r0
    3252:	0f 90       	pop	r0
    3254:	cf 91       	pop	r28
    3256:	df 91       	pop	r29
    3258:	08 95       	ret

0000325a <xQueueIsQueueFullFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
{
    325a:	df 93       	push	r29
    325c:	cf 93       	push	r28
    325e:	00 d0       	rcall	.+0      	; 0x3260 <xQueueIsQueueFullFromISR+0x6>
    3260:	00 d0       	rcall	.+0      	; 0x3262 <xQueueIsQueueFullFromISR+0x8>
    3262:	0f 92       	push	r0
    3264:	cd b7       	in	r28, 0x3d	; 61
    3266:	de b7       	in	r29, 0x3e	; 62
    3268:	9d 83       	std	Y+5, r25	; 0x05
    326a:	8c 83       	std	Y+4, r24	; 0x04
    BaseType_t xReturn;
    Queue_t * const pxQueue = xQueue;
    326c:	8c 81       	ldd	r24, Y+4	; 0x04
    326e:	9d 81       	ldd	r25, Y+5	; 0x05
    3270:	9a 83       	std	Y+2, r25	; 0x02
    3272:	89 83       	std	Y+1, r24	; 0x01

    configASSERT( pxQueue );

    if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    3274:	e9 81       	ldd	r30, Y+1	; 0x01
    3276:	fa 81       	ldd	r31, Y+2	; 0x02
    3278:	92 8d       	ldd	r25, Z+26	; 0x1a
    327a:	e9 81       	ldd	r30, Y+1	; 0x01
    327c:	fa 81       	ldd	r31, Y+2	; 0x02
    327e:	83 8d       	ldd	r24, Z+27	; 0x1b
    3280:	98 17       	cp	r25, r24
    3282:	19 f4       	brne	.+6      	; 0x328a <xQueueIsQueueFullFromISR+0x30>
    {
        xReturn = pdTRUE;
    3284:	81 e0       	ldi	r24, 0x01	; 1
    3286:	8b 83       	std	Y+3, r24	; 0x03
    3288:	01 c0       	rjmp	.+2      	; 0x328c <xQueueIsQueueFullFromISR+0x32>
    }
    else
    {
        xReturn = pdFALSE;
    328a:	1b 82       	std	Y+3, r1	; 0x03
    }

    return xReturn;
    328c:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    328e:	0f 90       	pop	r0
    3290:	0f 90       	pop	r0
    3292:	0f 90       	pop	r0
    3294:	0f 90       	pop	r0
    3296:	0f 90       	pop	r0
    3298:	cf 91       	pop	r28
    329a:	df 91       	pop	r29
    329c:	08 95       	ret

0000329e <xQueueCRSend>:
#if ( configUSE_CO_ROUTINES == 1 )

    BaseType_t xQueueCRSend( QueueHandle_t xQueue,
                             const void * pvItemToQueue,
                             TickType_t xTicksToWait )
    {
    329e:	df 93       	push	r29
    32a0:	cf 93       	push	r28
    32a2:	cd b7       	in	r28, 0x3d	; 61
    32a4:	de b7       	in	r29, 0x3e	; 62
    32a6:	2a 97       	sbiw	r28, 0x0a	; 10
    32a8:	0f b6       	in	r0, 0x3f	; 63
    32aa:	f8 94       	cli
    32ac:	de bf       	out	0x3e, r29	; 62
    32ae:	0f be       	out	0x3f, r0	; 63
    32b0:	cd bf       	out	0x3d, r28	; 61
    32b2:	9d 83       	std	Y+5, r25	; 0x05
    32b4:	8c 83       	std	Y+4, r24	; 0x04
    32b6:	7f 83       	std	Y+7, r23	; 0x07
    32b8:	6e 83       	std	Y+6, r22	; 0x06
    32ba:	59 87       	std	Y+9, r21	; 0x09
    32bc:	48 87       	std	Y+8, r20	; 0x08
        BaseType_t xReturn;
        Queue_t * const pxQueue = xQueue;
    32be:	8c 81       	ldd	r24, Y+4	; 0x04
    32c0:	9d 81       	ldd	r25, Y+5	; 0x05
    32c2:	9a 83       	std	Y+2, r25	; 0x02
    32c4:	89 83       	std	Y+1, r24	; 0x01

        /* If the queue is already full we may have to block.  A critical section
         * is required to prevent an interrupt removing something from the queue
         * between the check to see if the queue is full and blocking on the queue. */
        portDISABLE_INTERRUPTS();
    32c6:	f8 94       	cli
        {
            if( prvIsQueueFull( pxQueue ) != pdFALSE )
    32c8:	89 81       	ldd	r24, Y+1	; 0x01
    32ca:	9a 81       	ldd	r25, Y+2	; 0x02
    32cc:	0e 94 0d 19 	call	0x321a	; 0x321a <prvIsQueueFull>
    32d0:	88 23       	and	r24, r24
    32d2:	a9 f0       	breq	.+42     	; 0x32fe <xQueueCRSend+0x60>
            {
                /* The queue is full - do we want to block or just leave without
                 * posting? */
                if( xTicksToWait > ( TickType_t ) 0 )
    32d4:	88 85       	ldd	r24, Y+8	; 0x08
    32d6:	99 85       	ldd	r25, Y+9	; 0x09
    32d8:	00 97       	sbiw	r24, 0x00	; 0
    32da:	71 f0       	breq	.+28     	; 0x32f8 <xQueueCRSend+0x5a>
                {
                    /* As this is called from a coroutine we cannot block directly, but
                     * return indicating that we need to block. */
                    vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToSend ) );
    32dc:	89 81       	ldd	r24, Y+1	; 0x01
    32de:	9a 81       	ldd	r25, Y+2	; 0x02
    32e0:	9c 01       	movw	r18, r24
    32e2:	28 5f       	subi	r18, 0xF8	; 248
    32e4:	3f 4f       	sbci	r19, 0xFF	; 255
    32e6:	88 85       	ldd	r24, Y+8	; 0x08
    32e8:	99 85       	ldd	r25, Y+9	; 0x09
    32ea:	b9 01       	movw	r22, r18
    32ec:	0e 94 1b 0b 	call	0x1636	; 0x1636 <vCoRoutineAddToDelayedList>
                    portENABLE_INTERRUPTS();
    32f0:	78 94       	sei
                    return errQUEUE_BLOCKED;
    32f2:	8c ef       	ldi	r24, 0xFC	; 252
    32f4:	8a 87       	std	Y+10, r24	; 0x0a
    32f6:	2a c0       	rjmp	.+84     	; 0x334c <xQueueCRSend+0xae>
                }
                else
                {
                    portENABLE_INTERRUPTS();
    32f8:	78 94       	sei
                    return errQUEUE_FULL;
    32fa:	1a 86       	std	Y+10, r1	; 0x0a
    32fc:	27 c0       	rjmp	.+78     	; 0x334c <xQueueCRSend+0xae>
                }
            }
        }
        portENABLE_INTERRUPTS();
    32fe:	78 94       	sei

        portDISABLE_INTERRUPTS();
    3300:	f8 94       	cli
        {
            if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    3302:	e9 81       	ldd	r30, Y+1	; 0x01
    3304:	fa 81       	ldd	r31, Y+2	; 0x02
    3306:	92 8d       	ldd	r25, Z+26	; 0x1a
    3308:	e9 81       	ldd	r30, Y+1	; 0x01
    330a:	fa 81       	ldd	r31, Y+2	; 0x02
    330c:	83 8d       	ldd	r24, Z+27	; 0x1b
    330e:	98 17       	cp	r25, r24
    3310:	c8 f4       	brcc	.+50     	; 0x3344 <xQueueCRSend+0xa6>
            {
                /* There is room in the queue, copy the data into the queue. */
                prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
    3312:	89 81       	ldd	r24, Y+1	; 0x01
    3314:	9a 81       	ldd	r25, Y+2	; 0x02
    3316:	2e 81       	ldd	r18, Y+6	; 0x06
    3318:	3f 81       	ldd	r19, Y+7	; 0x07
    331a:	b9 01       	movw	r22, r18
    331c:	40 e0       	ldi	r20, 0x00	; 0
    331e:	0e 94 91 17 	call	0x2f22	; 0x2f22 <prvCopyDataToQueue>
                xReturn = pdPASS;
    3322:	81 e0       	ldi	r24, 0x01	; 1
    3324:	8b 83       	std	Y+3, r24	; 0x03

                /* Were any co-routines waiting for data to become available? */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    3326:	e9 81       	ldd	r30, Y+1	; 0x01
    3328:	fa 81       	ldd	r31, Y+2	; 0x02
    332a:	81 89       	ldd	r24, Z+17	; 0x11
    332c:	88 23       	and	r24, r24
    332e:	59 f0       	breq	.+22     	; 0x3346 <xQueueCRSend+0xa8>
                {
                    /* In this instance the co-routine could be placed directly
                     * into the ready list as we are within a critical section.
                     * Instead the same pending ready list mechanism is used as if
                     * the event were caused from within an interrupt. */
                    if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    3330:	89 81       	ldd	r24, Y+1	; 0x01
    3332:	9a 81       	ldd	r25, Y+2	; 0x02
    3334:	41 96       	adiw	r24, 0x11	; 17
    3336:	0e 94 2e 0d 	call	0x1a5c	; 0x1a5c <xCoRoutineRemoveFromEventList>
    333a:	88 23       	and	r24, r24
    333c:	21 f0       	breq	.+8      	; 0x3346 <xQueueCRSend+0xa8>
                    {
                        /* The co-routine waiting has a higher priority so record
                         * that a yield might be appropriate. */
                        xReturn = errQUEUE_YIELD;
    333e:	8b ef       	ldi	r24, 0xFB	; 251
    3340:	8b 83       	std	Y+3, r24	; 0x03
    3342:	01 c0       	rjmp	.+2      	; 0x3346 <xQueueCRSend+0xa8>
                    mtCOVERAGE_TEST_MARKER();
                }
            }
            else
            {
                xReturn = errQUEUE_FULL;
    3344:	1b 82       	std	Y+3, r1	; 0x03
            }
        }
        portENABLE_INTERRUPTS();
    3346:	78 94       	sei

        return xReturn;
    3348:	8b 81       	ldd	r24, Y+3	; 0x03
    334a:	8a 87       	std	Y+10, r24	; 0x0a
    334c:	8a 85       	ldd	r24, Y+10	; 0x0a
    }
    334e:	2a 96       	adiw	r28, 0x0a	; 10
    3350:	0f b6       	in	r0, 0x3f	; 63
    3352:	f8 94       	cli
    3354:	de bf       	out	0x3e, r29	; 62
    3356:	0f be       	out	0x3f, r0	; 63
    3358:	cd bf       	out	0x3d, r28	; 61
    335a:	cf 91       	pop	r28
    335c:	df 91       	pop	r29
    335e:	08 95       	ret

00003360 <xQueueCRReceive>:
#if ( configUSE_CO_ROUTINES == 1 )

    BaseType_t xQueueCRReceive( QueueHandle_t xQueue,
                                void * pvBuffer,
                                TickType_t xTicksToWait )
    {
    3360:	df 93       	push	r29
    3362:	cf 93       	push	r28
    3364:	cd b7       	in	r28, 0x3d	; 61
    3366:	de b7       	in	r29, 0x3e	; 62
    3368:	2a 97       	sbiw	r28, 0x0a	; 10
    336a:	0f b6       	in	r0, 0x3f	; 63
    336c:	f8 94       	cli
    336e:	de bf       	out	0x3e, r29	; 62
    3370:	0f be       	out	0x3f, r0	; 63
    3372:	cd bf       	out	0x3d, r28	; 61
    3374:	9d 83       	std	Y+5, r25	; 0x05
    3376:	8c 83       	std	Y+4, r24	; 0x04
    3378:	7f 83       	std	Y+7, r23	; 0x07
    337a:	6e 83       	std	Y+6, r22	; 0x06
    337c:	59 87       	std	Y+9, r21	; 0x09
    337e:	48 87       	std	Y+8, r20	; 0x08
        BaseType_t xReturn;
        Queue_t * const pxQueue = xQueue;
    3380:	8c 81       	ldd	r24, Y+4	; 0x04
    3382:	9d 81       	ldd	r25, Y+5	; 0x05
    3384:	9a 83       	std	Y+2, r25	; 0x02
    3386:	89 83       	std	Y+1, r24	; 0x01

        /* If the queue is already empty we may have to block.  A critical section
         * is required to prevent an interrupt adding something to the queue
         * between the check to see if the queue is empty and blocking on the queue. */
        portDISABLE_INTERRUPTS();
    3388:	f8 94       	cli
        {
            if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    338a:	e9 81       	ldd	r30, Y+1	; 0x01
    338c:	fa 81       	ldd	r31, Y+2	; 0x02
    338e:	82 8d       	ldd	r24, Z+26	; 0x1a
    3390:	88 23       	and	r24, r24
    3392:	a9 f4       	brne	.+42     	; 0x33be <xQueueCRReceive+0x5e>
            {
                /* There are no messages in the queue, do we want to block or just
                 * leave with nothing? */
                if( xTicksToWait > ( TickType_t ) 0 )
    3394:	88 85       	ldd	r24, Y+8	; 0x08
    3396:	99 85       	ldd	r25, Y+9	; 0x09
    3398:	00 97       	sbiw	r24, 0x00	; 0
    339a:	71 f0       	breq	.+28     	; 0x33b8 <xQueueCRReceive+0x58>
                {
                    /* As this is a co-routine we cannot block directly, but return
                     * indicating that we need to block. */
                    vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToReceive ) );
    339c:	89 81       	ldd	r24, Y+1	; 0x01
    339e:	9a 81       	ldd	r25, Y+2	; 0x02
    33a0:	9c 01       	movw	r18, r24
    33a2:	2f 5e       	subi	r18, 0xEF	; 239
    33a4:	3f 4f       	sbci	r19, 0xFF	; 255
    33a6:	88 85       	ldd	r24, Y+8	; 0x08
    33a8:	99 85       	ldd	r25, Y+9	; 0x09
    33aa:	b9 01       	movw	r22, r18
    33ac:	0e 94 1b 0b 	call	0x1636	; 0x1636 <vCoRoutineAddToDelayedList>
                    portENABLE_INTERRUPTS();
    33b0:	78 94       	sei
                    return errQUEUE_BLOCKED;
    33b2:	8c ef       	ldi	r24, 0xFC	; 252
    33b4:	8a 87       	std	Y+10, r24	; 0x0a
    33b6:	58 c0       	rjmp	.+176    	; 0x3468 <xQueueCRReceive+0x108>
                }
                else
                {
                    portENABLE_INTERRUPTS();
    33b8:	78 94       	sei
                    return errQUEUE_FULL;
    33ba:	1a 86       	std	Y+10, r1	; 0x0a
    33bc:	55 c0       	rjmp	.+170    	; 0x3468 <xQueueCRReceive+0x108>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        portENABLE_INTERRUPTS();
    33be:	78 94       	sei

        portDISABLE_INTERRUPTS();
    33c0:	f8 94       	cli
        {
            if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    33c2:	e9 81       	ldd	r30, Y+1	; 0x01
    33c4:	fa 81       	ldd	r31, Y+2	; 0x02
    33c6:	82 8d       	ldd	r24, Z+26	; 0x1a
    33c8:	88 23       	and	r24, r24
    33ca:	09 f4       	brne	.+2      	; 0x33ce <xQueueCRReceive+0x6e>
    33cc:	49 c0       	rjmp	.+146    	; 0x3460 <xQueueCRReceive+0x100>
            {
                /* Data is available from the queue. */
                pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;
    33ce:	e9 81       	ldd	r30, Y+1	; 0x01
    33d0:	fa 81       	ldd	r31, Y+2	; 0x02
    33d2:	26 81       	ldd	r18, Z+6	; 0x06
    33d4:	37 81       	ldd	r19, Z+7	; 0x07
    33d6:	e9 81       	ldd	r30, Y+1	; 0x01
    33d8:	fa 81       	ldd	r31, Y+2	; 0x02
    33da:	84 8d       	ldd	r24, Z+28	; 0x1c
    33dc:	88 2f       	mov	r24, r24
    33de:	90 e0       	ldi	r25, 0x00	; 0
    33e0:	82 0f       	add	r24, r18
    33e2:	93 1f       	adc	r25, r19
    33e4:	e9 81       	ldd	r30, Y+1	; 0x01
    33e6:	fa 81       	ldd	r31, Y+2	; 0x02
    33e8:	97 83       	std	Z+7, r25	; 0x07
    33ea:	86 83       	std	Z+6, r24	; 0x06

                if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail )
    33ec:	e9 81       	ldd	r30, Y+1	; 0x01
    33ee:	fa 81       	ldd	r31, Y+2	; 0x02
    33f0:	26 81       	ldd	r18, Z+6	; 0x06
    33f2:	37 81       	ldd	r19, Z+7	; 0x07
    33f4:	e9 81       	ldd	r30, Y+1	; 0x01
    33f6:	fa 81       	ldd	r31, Y+2	; 0x02
    33f8:	84 81       	ldd	r24, Z+4	; 0x04
    33fa:	95 81       	ldd	r25, Z+5	; 0x05
    33fc:	28 17       	cp	r18, r24
    33fe:	39 07       	cpc	r19, r25
    3400:	40 f0       	brcs	.+16     	; 0x3412 <xQueueCRReceive+0xb2>
                {
                    pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
    3402:	e9 81       	ldd	r30, Y+1	; 0x01
    3404:	fa 81       	ldd	r31, Y+2	; 0x02
    3406:	80 81       	ld	r24, Z
    3408:	91 81       	ldd	r25, Z+1	; 0x01
    340a:	e9 81       	ldd	r30, Y+1	; 0x01
    340c:	fa 81       	ldd	r31, Y+2	; 0x02
    340e:	97 83       	std	Z+7, r25	; 0x07
    3410:	86 83       	std	Z+6, r24	; 0x06
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                --( pxQueue->uxMessagesWaiting );
    3412:	e9 81       	ldd	r30, Y+1	; 0x01
    3414:	fa 81       	ldd	r31, Y+2	; 0x02
    3416:	82 8d       	ldd	r24, Z+26	; 0x1a
    3418:	81 50       	subi	r24, 0x01	; 1
    341a:	e9 81       	ldd	r30, Y+1	; 0x01
    341c:	fa 81       	ldd	r31, Y+2	; 0x02
    341e:	82 8f       	std	Z+26, r24	; 0x1a
                ( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    3420:	e9 81       	ldd	r30, Y+1	; 0x01
    3422:	fa 81       	ldd	r31, Y+2	; 0x02
    3424:	46 81       	ldd	r20, Z+6	; 0x06
    3426:	57 81       	ldd	r21, Z+7	; 0x07
    3428:	e9 81       	ldd	r30, Y+1	; 0x01
    342a:	fa 81       	ldd	r31, Y+2	; 0x02
    342c:	84 8d       	ldd	r24, Z+28	; 0x1c
    342e:	28 2f       	mov	r18, r24
    3430:	30 e0       	ldi	r19, 0x00	; 0
    3432:	8e 81       	ldd	r24, Y+6	; 0x06
    3434:	9f 81       	ldd	r25, Y+7	; 0x07
    3436:	ba 01       	movw	r22, r20
    3438:	a9 01       	movw	r20, r18
    343a:	0e 94 81 49 	call	0x9302	; 0x9302 <memcpy>

                xReturn = pdPASS;
    343e:	81 e0       	ldi	r24, 0x01	; 1
    3440:	8b 83       	std	Y+3, r24	; 0x03

                /* Were any co-routines waiting for space to become available? */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    3442:	e9 81       	ldd	r30, Y+1	; 0x01
    3444:	fa 81       	ldd	r31, Y+2	; 0x02
    3446:	80 85       	ldd	r24, Z+8	; 0x08
    3448:	88 23       	and	r24, r24
    344a:	59 f0       	breq	.+22     	; 0x3462 <xQueueCRReceive+0x102>
                {
                    /* In this instance the co-routine could be placed directly
                     * into the ready list as we are within a critical section.
                     * Instead the same pending ready list mechanism is used as if
                     * the event were caused from within an interrupt. */
                    if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    344c:	89 81       	ldd	r24, Y+1	; 0x01
    344e:	9a 81       	ldd	r25, Y+2	; 0x02
    3450:	08 96       	adiw	r24, 0x08	; 8
    3452:	0e 94 2e 0d 	call	0x1a5c	; 0x1a5c <xCoRoutineRemoveFromEventList>
    3456:	88 23       	and	r24, r24
    3458:	21 f0       	breq	.+8      	; 0x3462 <xQueueCRReceive+0x102>
                    {
                        xReturn = errQUEUE_YIELD;
    345a:	8b ef       	ldi	r24, 0xFB	; 251
    345c:	8b 83       	std	Y+3, r24	; 0x03
    345e:	01 c0       	rjmp	.+2      	; 0x3462 <xQueueCRReceive+0x102>
                    mtCOVERAGE_TEST_MARKER();
                }
            }
            else
            {
                xReturn = pdFAIL;
    3460:	1b 82       	std	Y+3, r1	; 0x03
            }
        }
        portENABLE_INTERRUPTS();
    3462:	78 94       	sei

        return xReturn;
    3464:	8b 81       	ldd	r24, Y+3	; 0x03
    3466:	8a 87       	std	Y+10, r24	; 0x0a
    3468:	8a 85       	ldd	r24, Y+10	; 0x0a
    }
    346a:	2a 96       	adiw	r28, 0x0a	; 10
    346c:	0f b6       	in	r0, 0x3f	; 63
    346e:	f8 94       	cli
    3470:	de bf       	out	0x3e, r29	; 62
    3472:	0f be       	out	0x3f, r0	; 63
    3474:	cd bf       	out	0x3d, r28	; 61
    3476:	cf 91       	pop	r28
    3478:	df 91       	pop	r29
    347a:	08 95       	ret

0000347c <xQueueCRSendFromISR>:
#if ( configUSE_CO_ROUTINES == 1 )

    BaseType_t xQueueCRSendFromISR( QueueHandle_t xQueue,
                                    const void * pvItemToQueue,
                                    BaseType_t xCoRoutinePreviouslyWoken )
    {
    347c:	df 93       	push	r29
    347e:	cf 93       	push	r28
    3480:	cd b7       	in	r28, 0x3d	; 61
    3482:	de b7       	in	r29, 0x3e	; 62
    3484:	28 97       	sbiw	r28, 0x08	; 8
    3486:	0f b6       	in	r0, 0x3f	; 63
    3488:	f8 94       	cli
    348a:	de bf       	out	0x3e, r29	; 62
    348c:	0f be       	out	0x3f, r0	; 63
    348e:	cd bf       	out	0x3d, r28	; 61
    3490:	9c 83       	std	Y+4, r25	; 0x04
    3492:	8b 83       	std	Y+3, r24	; 0x03
    3494:	7e 83       	std	Y+6, r23	; 0x06
    3496:	6d 83       	std	Y+5, r22	; 0x05
    3498:	4f 83       	std	Y+7, r20	; 0x07
        Queue_t * const pxQueue = xQueue;
    349a:	8b 81       	ldd	r24, Y+3	; 0x03
    349c:	9c 81       	ldd	r25, Y+4	; 0x04
    349e:	9a 83       	std	Y+2, r25	; 0x02
    34a0:	89 83       	std	Y+1, r24	; 0x01

        /* Cannot block within an ISR so if there is no space on the queue then
         * exit without doing anything. */
        if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    34a2:	e9 81       	ldd	r30, Y+1	; 0x01
    34a4:	fa 81       	ldd	r31, Y+2	; 0x02
    34a6:	92 8d       	ldd	r25, Z+26	; 0x1a
    34a8:	e9 81       	ldd	r30, Y+1	; 0x01
    34aa:	fa 81       	ldd	r31, Y+2	; 0x02
    34ac:	83 8d       	ldd	r24, Z+27	; 0x1b
    34ae:	98 17       	cp	r25, r24
    34b0:	d0 f4       	brcc	.+52     	; 0x34e6 <xQueueCRSendFromISR+0x6a>
        {
            prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
    34b2:	89 81       	ldd	r24, Y+1	; 0x01
    34b4:	9a 81       	ldd	r25, Y+2	; 0x02
    34b6:	2d 81       	ldd	r18, Y+5	; 0x05
    34b8:	3e 81       	ldd	r19, Y+6	; 0x06
    34ba:	b9 01       	movw	r22, r18
    34bc:	40 e0       	ldi	r20, 0x00	; 0
    34be:	0e 94 91 17 	call	0x2f22	; 0x2f22 <prvCopyDataToQueue>

            /* We only want to wake one co-routine per ISR, so check that a
             * co-routine has not already been woken. */
            if( xCoRoutinePreviouslyWoken == pdFALSE )
    34c2:	8f 81       	ldd	r24, Y+7	; 0x07
    34c4:	88 23       	and	r24, r24
    34c6:	79 f4       	brne	.+30     	; 0x34e6 <xQueueCRSendFromISR+0x6a>
            {
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    34c8:	e9 81       	ldd	r30, Y+1	; 0x01
    34ca:	fa 81       	ldd	r31, Y+2	; 0x02
    34cc:	81 89       	ldd	r24, Z+17	; 0x11
    34ce:	88 23       	and	r24, r24
    34d0:	51 f0       	breq	.+20     	; 0x34e6 <xQueueCRSendFromISR+0x6a>
                {
                    if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    34d2:	89 81       	ldd	r24, Y+1	; 0x01
    34d4:	9a 81       	ldd	r25, Y+2	; 0x02
    34d6:	41 96       	adiw	r24, 0x11	; 17
    34d8:	0e 94 2e 0d 	call	0x1a5c	; 0x1a5c <xCoRoutineRemoveFromEventList>
    34dc:	88 23       	and	r24, r24
    34de:	19 f0       	breq	.+6      	; 0x34e6 <xQueueCRSendFromISR+0x6a>
                    {
                        return pdTRUE;
    34e0:	81 e0       	ldi	r24, 0x01	; 1
    34e2:	88 87       	std	Y+8, r24	; 0x08
    34e4:	02 c0       	rjmp	.+4      	; 0x34ea <xQueueCRSendFromISR+0x6e>
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        return xCoRoutinePreviouslyWoken;
    34e6:	8f 81       	ldd	r24, Y+7	; 0x07
    34e8:	88 87       	std	Y+8, r24	; 0x08
    34ea:	88 85       	ldd	r24, Y+8	; 0x08
    }
    34ec:	28 96       	adiw	r28, 0x08	; 8
    34ee:	0f b6       	in	r0, 0x3f	; 63
    34f0:	f8 94       	cli
    34f2:	de bf       	out	0x3e, r29	; 62
    34f4:	0f be       	out	0x3f, r0	; 63
    34f6:	cd bf       	out	0x3d, r28	; 61
    34f8:	cf 91       	pop	r28
    34fa:	df 91       	pop	r29
    34fc:	08 95       	ret

000034fe <xQueueCRReceiveFromISR>:
#if ( configUSE_CO_ROUTINES == 1 )

    BaseType_t xQueueCRReceiveFromISR( QueueHandle_t xQueue,
                                       void * pvBuffer,
                                       BaseType_t * pxCoRoutineWoken )
    {
    34fe:	df 93       	push	r29
    3500:	cf 93       	push	r28
    3502:	cd b7       	in	r28, 0x3d	; 61
    3504:	de b7       	in	r29, 0x3e	; 62
    3506:	29 97       	sbiw	r28, 0x09	; 9
    3508:	0f b6       	in	r0, 0x3f	; 63
    350a:	f8 94       	cli
    350c:	de bf       	out	0x3e, r29	; 62
    350e:	0f be       	out	0x3f, r0	; 63
    3510:	cd bf       	out	0x3d, r28	; 61
    3512:	9d 83       	std	Y+5, r25	; 0x05
    3514:	8c 83       	std	Y+4, r24	; 0x04
    3516:	7f 83       	std	Y+7, r23	; 0x07
    3518:	6e 83       	std	Y+6, r22	; 0x06
    351a:	59 87       	std	Y+9, r21	; 0x09
    351c:	48 87       	std	Y+8, r20	; 0x08
        BaseType_t xReturn;
        Queue_t * const pxQueue = xQueue;
    351e:	8c 81       	ldd	r24, Y+4	; 0x04
    3520:	9d 81       	ldd	r25, Y+5	; 0x05
    3522:	9a 83       	std	Y+2, r25	; 0x02
    3524:	89 83       	std	Y+1, r24	; 0x01

        /* We cannot block from an ISR, so check there is data available. If
         * not then just leave without doing anything. */
        if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    3526:	e9 81       	ldd	r30, Y+1	; 0x01
    3528:	fa 81       	ldd	r31, Y+2	; 0x02
    352a:	82 8d       	ldd	r24, Z+26	; 0x1a
    352c:	88 23       	and	r24, r24
    352e:	09 f4       	brne	.+2      	; 0x3532 <xQueueCRReceiveFromISR+0x34>
    3530:	50 c0       	rjmp	.+160    	; 0x35d2 <xQueueCRReceiveFromISR+0xd4>
        {
            /* Copy the data from the queue. */
            pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;
    3532:	e9 81       	ldd	r30, Y+1	; 0x01
    3534:	fa 81       	ldd	r31, Y+2	; 0x02
    3536:	26 81       	ldd	r18, Z+6	; 0x06
    3538:	37 81       	ldd	r19, Z+7	; 0x07
    353a:	e9 81       	ldd	r30, Y+1	; 0x01
    353c:	fa 81       	ldd	r31, Y+2	; 0x02
    353e:	84 8d       	ldd	r24, Z+28	; 0x1c
    3540:	88 2f       	mov	r24, r24
    3542:	90 e0       	ldi	r25, 0x00	; 0
    3544:	82 0f       	add	r24, r18
    3546:	93 1f       	adc	r25, r19
    3548:	e9 81       	ldd	r30, Y+1	; 0x01
    354a:	fa 81       	ldd	r31, Y+2	; 0x02
    354c:	97 83       	std	Z+7, r25	; 0x07
    354e:	86 83       	std	Z+6, r24	; 0x06

            if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail )
    3550:	e9 81       	ldd	r30, Y+1	; 0x01
    3552:	fa 81       	ldd	r31, Y+2	; 0x02
    3554:	26 81       	ldd	r18, Z+6	; 0x06
    3556:	37 81       	ldd	r19, Z+7	; 0x07
    3558:	e9 81       	ldd	r30, Y+1	; 0x01
    355a:	fa 81       	ldd	r31, Y+2	; 0x02
    355c:	84 81       	ldd	r24, Z+4	; 0x04
    355e:	95 81       	ldd	r25, Z+5	; 0x05
    3560:	28 17       	cp	r18, r24
    3562:	39 07       	cpc	r19, r25
    3564:	40 f0       	brcs	.+16     	; 0x3576 <xQueueCRReceiveFromISR+0x78>
            {
                pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
    3566:	e9 81       	ldd	r30, Y+1	; 0x01
    3568:	fa 81       	ldd	r31, Y+2	; 0x02
    356a:	80 81       	ld	r24, Z
    356c:	91 81       	ldd	r25, Z+1	; 0x01
    356e:	e9 81       	ldd	r30, Y+1	; 0x01
    3570:	fa 81       	ldd	r31, Y+2	; 0x02
    3572:	97 83       	std	Z+7, r25	; 0x07
    3574:	86 83       	std	Z+6, r24	; 0x06
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }

            --( pxQueue->uxMessagesWaiting );
    3576:	e9 81       	ldd	r30, Y+1	; 0x01
    3578:	fa 81       	ldd	r31, Y+2	; 0x02
    357a:	82 8d       	ldd	r24, Z+26	; 0x1a
    357c:	81 50       	subi	r24, 0x01	; 1
    357e:	e9 81       	ldd	r30, Y+1	; 0x01
    3580:	fa 81       	ldd	r31, Y+2	; 0x02
    3582:	82 8f       	std	Z+26, r24	; 0x1a
            ( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    3584:	e9 81       	ldd	r30, Y+1	; 0x01
    3586:	fa 81       	ldd	r31, Y+2	; 0x02
    3588:	46 81       	ldd	r20, Z+6	; 0x06
    358a:	57 81       	ldd	r21, Z+7	; 0x07
    358c:	e9 81       	ldd	r30, Y+1	; 0x01
    358e:	fa 81       	ldd	r31, Y+2	; 0x02
    3590:	84 8d       	ldd	r24, Z+28	; 0x1c
    3592:	28 2f       	mov	r18, r24
    3594:	30 e0       	ldi	r19, 0x00	; 0
    3596:	8e 81       	ldd	r24, Y+6	; 0x06
    3598:	9f 81       	ldd	r25, Y+7	; 0x07
    359a:	ba 01       	movw	r22, r20
    359c:	a9 01       	movw	r20, r18
    359e:	0e 94 81 49 	call	0x9302	; 0x9302 <memcpy>

            if( ( *pxCoRoutineWoken ) == pdFALSE )
    35a2:	e8 85       	ldd	r30, Y+8	; 0x08
    35a4:	f9 85       	ldd	r31, Y+9	; 0x09
    35a6:	80 81       	ld	r24, Z
    35a8:	88 23       	and	r24, r24
    35aa:	81 f4       	brne	.+32     	; 0x35cc <xQueueCRReceiveFromISR+0xce>
            {
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    35ac:	e9 81       	ldd	r30, Y+1	; 0x01
    35ae:	fa 81       	ldd	r31, Y+2	; 0x02
    35b0:	80 85       	ldd	r24, Z+8	; 0x08
    35b2:	88 23       	and	r24, r24
    35b4:	59 f0       	breq	.+22     	; 0x35cc <xQueueCRReceiveFromISR+0xce>
                {
                    if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    35b6:	89 81       	ldd	r24, Y+1	; 0x01
    35b8:	9a 81       	ldd	r25, Y+2	; 0x02
    35ba:	08 96       	adiw	r24, 0x08	; 8
    35bc:	0e 94 2e 0d 	call	0x1a5c	; 0x1a5c <xCoRoutineRemoveFromEventList>
    35c0:	88 23       	and	r24, r24
    35c2:	21 f0       	breq	.+8      	; 0x35cc <xQueueCRReceiveFromISR+0xce>
                    {
                        *pxCoRoutineWoken = pdTRUE;
    35c4:	e8 85       	ldd	r30, Y+8	; 0x08
    35c6:	f9 85       	ldd	r31, Y+9	; 0x09
    35c8:	81 e0       	ldi	r24, 0x01	; 1
    35ca:	80 83       	st	Z, r24
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }

            xReturn = pdPASS;
    35cc:	81 e0       	ldi	r24, 0x01	; 1
    35ce:	8b 83       	std	Y+3, r24	; 0x03
    35d0:	01 c0       	rjmp	.+2      	; 0x35d4 <xQueueCRReceiveFromISR+0xd6>
        }
        else
        {
            xReturn = pdFAIL;
    35d2:	1b 82       	std	Y+3, r1	; 0x03
        }

        return xReturn;
    35d4:	8b 81       	ldd	r24, Y+3	; 0x03
    }
    35d6:	29 96       	adiw	r28, 0x09	; 9
    35d8:	0f b6       	in	r0, 0x3f	; 63
    35da:	f8 94       	cli
    35dc:	de bf       	out	0x3e, r29	; 62
    35de:	0f be       	out	0x3f, r0	; 63
    35e0:	cd bf       	out	0x3d, r28	; 61
    35e2:	cf 91       	pop	r28
    35e4:	df 91       	pop	r29
    35e6:	08 95       	ret

000035e8 <vQueueWaitForMessageRestricted>:
#if ( configUSE_TIMERS == 1 )

    void vQueueWaitForMessageRestricted( QueueHandle_t xQueue,
                                         TickType_t xTicksToWait,
                                         const BaseType_t xWaitIndefinitely )
    {
    35e8:	df 93       	push	r29
    35ea:	cf 93       	push	r28
    35ec:	cd b7       	in	r28, 0x3d	; 61
    35ee:	de b7       	in	r29, 0x3e	; 62
    35f0:	27 97       	sbiw	r28, 0x07	; 7
    35f2:	0f b6       	in	r0, 0x3f	; 63
    35f4:	f8 94       	cli
    35f6:	de bf       	out	0x3e, r29	; 62
    35f8:	0f be       	out	0x3f, r0	; 63
    35fa:	cd bf       	out	0x3d, r28	; 61
    35fc:	9c 83       	std	Y+4, r25	; 0x04
    35fe:	8b 83       	std	Y+3, r24	; 0x03
    3600:	7e 83       	std	Y+6, r23	; 0x06
    3602:	6d 83       	std	Y+5, r22	; 0x05
    3604:	4f 83       	std	Y+7, r20	; 0x07
        Queue_t * const pxQueue = xQueue;
    3606:	8b 81       	ldd	r24, Y+3	; 0x03
    3608:	9c 81       	ldd	r25, Y+4	; 0x04
    360a:	9a 83       	std	Y+2, r25	; 0x02
    360c:	89 83       	std	Y+1, r24	; 0x01
         *  will not actually cause the task to block, just place it on a blocked
         *  list.  It will not block until the scheduler is unlocked - at which
         *  time a yield will be performed.  If an item is added to the queue while
         *  the queue is locked, and the calling task blocks on the queue, then the
         *  calling task will be immediately unblocked when the queue is unlocked. */
        prvLockQueue( pxQueue );
    360e:	0f b6       	in	r0, 0x3f	; 63
    3610:	f8 94       	cli
    3612:	0f 92       	push	r0
    3614:	e9 81       	ldd	r30, Y+1	; 0x01
    3616:	fa 81       	ldd	r31, Y+2	; 0x02
    3618:	85 8d       	ldd	r24, Z+29	; 0x1d
    361a:	8f 3f       	cpi	r24, 0xFF	; 255
    361c:	19 f4       	brne	.+6      	; 0x3624 <vQueueWaitForMessageRestricted+0x3c>
    361e:	e9 81       	ldd	r30, Y+1	; 0x01
    3620:	fa 81       	ldd	r31, Y+2	; 0x02
    3622:	15 8e       	std	Z+29, r1	; 0x1d
    3624:	e9 81       	ldd	r30, Y+1	; 0x01
    3626:	fa 81       	ldd	r31, Y+2	; 0x02
    3628:	86 8d       	ldd	r24, Z+30	; 0x1e
    362a:	8f 3f       	cpi	r24, 0xFF	; 255
    362c:	19 f4       	brne	.+6      	; 0x3634 <vQueueWaitForMessageRestricted+0x4c>
    362e:	e9 81       	ldd	r30, Y+1	; 0x01
    3630:	fa 81       	ldd	r31, Y+2	; 0x02
    3632:	16 8e       	std	Z+30, r1	; 0x1e
    3634:	0f 90       	pop	r0
    3636:	0f be       	out	0x3f, r0	; 63

        if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
    3638:	e9 81       	ldd	r30, Y+1	; 0x01
    363a:	fa 81       	ldd	r31, Y+2	; 0x02
    363c:	82 8d       	ldd	r24, Z+26	; 0x1a
    363e:	88 23       	and	r24, r24
    3640:	49 f4       	brne	.+18     	; 0x3654 <vQueueWaitForMessageRestricted+0x6c>
        {
            /* There is nothing in the queue, block for the specified period. */
            vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait, xWaitIndefinitely );
    3642:	89 81       	ldd	r24, Y+1	; 0x01
    3644:	9a 81       	ldd	r25, Y+2	; 0x02
    3646:	41 96       	adiw	r24, 0x11	; 17
    3648:	2d 81       	ldd	r18, Y+5	; 0x05
    364a:	3e 81       	ldd	r19, Y+6	; 0x06
    364c:	b9 01       	movw	r22, r18
    364e:	4f 81       	ldd	r20, Y+7	; 0x07
    3650:	0e 94 ec 22 	call	0x45d8	; 0x45d8 <vTaskPlaceOnEventListRestricted>
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        prvUnlockQueue( pxQueue );
    3654:	89 81       	ldd	r24, Y+1	; 0x01
    3656:	9a 81       	ldd	r25, Y+2	; 0x02
    3658:	0e 94 7e 18 	call	0x30fc	; 0x30fc <prvUnlockQueue>
    }
    365c:	27 96       	adiw	r28, 0x07	; 7
    365e:	0f b6       	in	r0, 0x3f	; 63
    3660:	f8 94       	cli
    3662:	de bf       	out	0x3e, r29	; 62
    3664:	0f be       	out	0x3f, r0	; 63
    3666:	cd bf       	out	0x3d, r28	; 61
    3668:	cf 91       	pop	r28
    366a:	df 91       	pop	r29
    366c:	08 95       	ret

0000366e <xTaskCreate>:
                            const char * const pcName, /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
                            const configSTACK_DEPTH_TYPE usStackDepth,
                            void * const pvParameters,
                            UBaseType_t uxPriority,
                            TaskHandle_t * const pxCreatedTask )
    {
    366e:	8f 92       	push	r8
    3670:	9f 92       	push	r9
    3672:	af 92       	push	r10
    3674:	bf 92       	push	r11
    3676:	cf 92       	push	r12
    3678:	df 92       	push	r13
    367a:	ef 92       	push	r14
    367c:	ff 92       	push	r15
    367e:	0f 93       	push	r16
    3680:	1f 93       	push	r17
    3682:	df 93       	push	r29
    3684:	cf 93       	push	r28
    3686:	cd b7       	in	r28, 0x3d	; 61
    3688:	de b7       	in	r29, 0x3e	; 62
    368a:	60 97       	sbiw	r28, 0x10	; 16
    368c:	0f b6       	in	r0, 0x3f	; 63
    368e:	f8 94       	cli
    3690:	de bf       	out	0x3e, r29	; 62
    3692:	0f be       	out	0x3f, r0	; 63
    3694:	cd bf       	out	0x3d, r28	; 61
    3696:	9f 83       	std	Y+7, r25	; 0x07
    3698:	8e 83       	std	Y+6, r24	; 0x06
    369a:	79 87       	std	Y+9, r23	; 0x09
    369c:	68 87       	std	Y+8, r22	; 0x08
    369e:	5b 87       	std	Y+11, r21	; 0x0b
    36a0:	4a 87       	std	Y+10, r20	; 0x0a
    36a2:	3d 87       	std	Y+13, r19	; 0x0d
    36a4:	2c 87       	std	Y+12, r18	; 0x0c
    36a6:	0e 87       	std	Y+14, r16	; 0x0e
    36a8:	f8 8a       	std	Y+16, r15	; 0x10
    36aa:	ef 86       	std	Y+15, r14	; 0x0f
        #else /* portSTACK_GROWTH */
            {
                StackType_t * pxStack;

                /* Allocate space for the stack used by the task being created. */
                pxStack = pvPortMallocStack( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation is the stack. */
    36ac:	8a 85       	ldd	r24, Y+10	; 0x0a
    36ae:	9b 85       	ldd	r25, Y+11	; 0x0b
    36b0:	0e 94 33 07 	call	0xe66	; 0xe66 <pvPortMalloc>
    36b4:	9a 83       	std	Y+2, r25	; 0x02
    36b6:	89 83       	std	Y+1, r24	; 0x01

                if( pxStack != NULL )
    36b8:	89 81       	ldd	r24, Y+1	; 0x01
    36ba:	9a 81       	ldd	r25, Y+2	; 0x02
    36bc:	00 97       	sbiw	r24, 0x00	; 0
    36be:	b1 f0       	breq	.+44     	; 0x36ec <xTaskCreate+0x7e>
                {
                    /* Allocate space for the TCB. */
                    pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of TCB_t is always a pointer to the task's stack. */
    36c0:	86 e2       	ldi	r24, 0x26	; 38
    36c2:	90 e0       	ldi	r25, 0x00	; 0
    36c4:	0e 94 33 07 	call	0xe66	; 0xe66 <pvPortMalloc>
    36c8:	9d 83       	std	Y+5, r25	; 0x05
    36ca:	8c 83       	std	Y+4, r24	; 0x04

                    if( pxNewTCB != NULL )
    36cc:	8c 81       	ldd	r24, Y+4	; 0x04
    36ce:	9d 81       	ldd	r25, Y+5	; 0x05
    36d0:	00 97       	sbiw	r24, 0x00	; 0
    36d2:	39 f0       	breq	.+14     	; 0x36e2 <xTaskCreate+0x74>
                    {
                        /* Store the stack location in the TCB. */
                        pxNewTCB->pxStack = pxStack;
    36d4:	ec 81       	ldd	r30, Y+4	; 0x04
    36d6:	fd 81       	ldd	r31, Y+5	; 0x05
    36d8:	89 81       	ldd	r24, Y+1	; 0x01
    36da:	9a 81       	ldd	r25, Y+2	; 0x02
    36dc:	90 8f       	std	Z+24, r25	; 0x18
    36de:	87 8b       	std	Z+23, r24	; 0x17
    36e0:	07 c0       	rjmp	.+14     	; 0x36f0 <xTaskCreate+0x82>
                    }
                    else
                    {
                        /* The stack cannot be used as the TCB was not created.  Free
                         * it again. */
                        vPortFreeStack( pxStack );
    36e2:	89 81       	ldd	r24, Y+1	; 0x01
    36e4:	9a 81       	ldd	r25, Y+2	; 0x02
    36e6:	0e 94 8d 07 	call	0xf1a	; 0xf1a <vPortFree>
    36ea:	02 c0       	rjmp	.+4      	; 0x36f0 <xTaskCreate+0x82>
                    }
                }
                else
                {
                    pxNewTCB = NULL;
    36ec:	1d 82       	std	Y+5, r1	; 0x05
    36ee:	1c 82       	std	Y+4, r1	; 0x04
                }
            }
        #endif /* portSTACK_GROWTH */

        if( pxNewTCB != NULL )
    36f0:	8c 81       	ldd	r24, Y+4	; 0x04
    36f2:	9d 81       	ldd	r25, Y+5	; 0x05
    36f4:	00 97       	sbiw	r24, 0x00	; 0
    36f6:	e9 f0       	breq	.+58     	; 0x3732 <xTaskCreate+0xc4>
                     * task was created dynamically in case it is later deleted. */
                    pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
                }
            #endif /* tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE */

            prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
    36f8:	8a 85       	ldd	r24, Y+10	; 0x0a
    36fa:	9b 85       	ldd	r25, Y+11	; 0x0b
    36fc:	9c 01       	movw	r18, r24
    36fe:	40 e0       	ldi	r20, 0x00	; 0
    3700:	50 e0       	ldi	r21, 0x00	; 0
    3702:	8e 81       	ldd	r24, Y+6	; 0x06
    3704:	9f 81       	ldd	r25, Y+7	; 0x07
    3706:	68 85       	ldd	r22, Y+8	; 0x08
    3708:	79 85       	ldd	r23, Y+9	; 0x09
    370a:	ec 85       	ldd	r30, Y+12	; 0x0c
    370c:	fd 85       	ldd	r31, Y+13	; 0x0d
    370e:	af 85       	ldd	r26, Y+15	; 0x0f
    3710:	b8 89       	ldd	r27, Y+16	; 0x10
    3712:	ac 80       	ldd	r10, Y+4	; 0x04
    3714:	bd 80       	ldd	r11, Y+5	; 0x05
    3716:	8f 01       	movw	r16, r30
    3718:	ee 84       	ldd	r14, Y+14	; 0x0e
    371a:	6d 01       	movw	r12, r26
    371c:	88 24       	eor	r8, r8
    371e:	99 24       	eor	r9, r9
    3720:	0e 94 af 1b 	call	0x375e	; 0x375e <prvInitialiseNewTask>
            prvAddNewTaskToReadyList( pxNewTCB );
    3724:	8c 81       	ldd	r24, Y+4	; 0x04
    3726:	9d 81       	ldd	r25, Y+5	; 0x05
    3728:	0e 94 74 1c 	call	0x38e8	; 0x38e8 <prvAddNewTaskToReadyList>
            xReturn = pdPASS;
    372c:	81 e0       	ldi	r24, 0x01	; 1
    372e:	8b 83       	std	Y+3, r24	; 0x03
    3730:	02 c0       	rjmp	.+4      	; 0x3736 <xTaskCreate+0xc8>
        }
        else
        {
            xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    3732:	8f ef       	ldi	r24, 0xFF	; 255
    3734:	8b 83       	std	Y+3, r24	; 0x03
        }

        return xReturn;
    3736:	8b 81       	ldd	r24, Y+3	; 0x03
    }
    3738:	60 96       	adiw	r28, 0x10	; 16
    373a:	0f b6       	in	r0, 0x3f	; 63
    373c:	f8 94       	cli
    373e:	de bf       	out	0x3e, r29	; 62
    3740:	0f be       	out	0x3f, r0	; 63
    3742:	cd bf       	out	0x3d, r28	; 61
    3744:	cf 91       	pop	r28
    3746:	df 91       	pop	r29
    3748:	1f 91       	pop	r17
    374a:	0f 91       	pop	r16
    374c:	ff 90       	pop	r15
    374e:	ef 90       	pop	r14
    3750:	df 90       	pop	r13
    3752:	cf 90       	pop	r12
    3754:	bf 90       	pop	r11
    3756:	af 90       	pop	r10
    3758:	9f 90       	pop	r9
    375a:	8f 90       	pop	r8
    375c:	08 95       	ret

0000375e <prvInitialiseNewTask>:
                                  void * const pvParameters,
                                  UBaseType_t uxPriority,
                                  TaskHandle_t * const pxCreatedTask,
                                  TCB_t * pxNewTCB,
                                  const MemoryRegion_t * const xRegions )
{
    375e:	8f 92       	push	r8
    3760:	9f 92       	push	r9
    3762:	af 92       	push	r10
    3764:	bf 92       	push	r11
    3766:	cf 92       	push	r12
    3768:	df 92       	push	r13
    376a:	ef 92       	push	r14
    376c:	0f 93       	push	r16
    376e:	1f 93       	push	r17
    3770:	df 93       	push	r29
    3772:	cf 93       	push	r28
    3774:	cd b7       	in	r28, 0x3d	; 61
    3776:	de b7       	in	r29, 0x3e	; 62
    3778:	64 97       	sbiw	r28, 0x14	; 20
    377a:	0f b6       	in	r0, 0x3f	; 63
    377c:	f8 94       	cli
    377e:	de bf       	out	0x3e, r29	; 62
    3780:	0f be       	out	0x3f, r0	; 63
    3782:	cd bf       	out	0x3d, r28	; 61
    3784:	9d 83       	std	Y+5, r25	; 0x05
    3786:	8c 83       	std	Y+4, r24	; 0x04
    3788:	7f 83       	std	Y+7, r23	; 0x07
    378a:	6e 83       	std	Y+6, r22	; 0x06
    378c:	28 87       	std	Y+8, r18	; 0x08
    378e:	39 87       	std	Y+9, r19	; 0x09
    3790:	4a 87       	std	Y+10, r20	; 0x0a
    3792:	5b 87       	std	Y+11, r21	; 0x0b
    3794:	1d 87       	std	Y+13, r17	; 0x0d
    3796:	0c 87       	std	Y+12, r16	; 0x0c
    3798:	ee 86       	std	Y+14, r14	; 0x0e
    379a:	d8 8a       	std	Y+16, r13	; 0x10
    379c:	cf 86       	std	Y+15, r12	; 0x0f
    379e:	ba 8a       	std	Y+18, r11	; 0x12
    37a0:	a9 8a       	std	Y+17, r10	; 0x11
    37a2:	9c 8a       	std	Y+20, r9	; 0x14
    37a4:	8b 8a       	std	Y+19, r8	; 0x13
     * grows from high memory to low (as per the 80x86) or vice versa.
     * portSTACK_GROWTH is used to make the result positive or negative as required
     * by the port. */
    #if ( portSTACK_GROWTH < 0 )
        {
            pxTopOfStack = &( pxNewTCB->pxStack[ ulStackDepth - ( uint32_t ) 1 ] );
    37a6:	e9 89       	ldd	r30, Y+17	; 0x11
    37a8:	fa 89       	ldd	r31, Y+18	; 0x12
    37aa:	27 89       	ldd	r18, Z+23	; 0x17
    37ac:	30 8d       	ldd	r19, Z+24	; 0x18
    37ae:	88 85       	ldd	r24, Y+8	; 0x08
    37b0:	99 85       	ldd	r25, Y+9	; 0x09
    37b2:	01 97       	sbiw	r24, 0x01	; 1
    37b4:	82 0f       	add	r24, r18
    37b6:	93 1f       	adc	r25, r19
    37b8:	9b 83       	std	Y+3, r25	; 0x03
    37ba:	8a 83       	std	Y+2, r24	; 0x02
            pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
        }
    #endif /* portSTACK_GROWTH */

    /* Store the task name in the TCB. */
    if( pcName != NULL )
    37bc:	8e 81       	ldd	r24, Y+6	; 0x06
    37be:	9f 81       	ldd	r25, Y+7	; 0x07
    37c0:	00 97       	sbiw	r24, 0x00	; 0
    37c2:	51 f1       	breq	.+84     	; 0x3818 <prvInitialiseNewTask+0xba>
    {
        for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    37c4:	19 82       	std	Y+1, r1	; 0x01
    37c6:	21 c0       	rjmp	.+66     	; 0x380a <prvInitialiseNewTask+0xac>
        {
            pxNewTCB->pcTaskName[ x ] = pcName[ x ];
    37c8:	89 81       	ldd	r24, Y+1	; 0x01
    37ca:	48 2f       	mov	r20, r24
    37cc:	50 e0       	ldi	r21, 0x00	; 0
    37ce:	89 81       	ldd	r24, Y+1	; 0x01
    37d0:	28 2f       	mov	r18, r24
    37d2:	30 e0       	ldi	r19, 0x00	; 0
    37d4:	8e 81       	ldd	r24, Y+6	; 0x06
    37d6:	9f 81       	ldd	r25, Y+7	; 0x07
    37d8:	fc 01       	movw	r30, r24
    37da:	e2 0f       	add	r30, r18
    37dc:	f3 1f       	adc	r31, r19
    37de:	20 81       	ld	r18, Z
    37e0:	89 89       	ldd	r24, Y+17	; 0x11
    37e2:	9a 89       	ldd	r25, Y+18	; 0x12
    37e4:	84 0f       	add	r24, r20
    37e6:	95 1f       	adc	r25, r21
    37e8:	fc 01       	movw	r30, r24
    37ea:	79 96       	adiw	r30, 0x19	; 25
    37ec:	20 83       	st	Z, r18

            /* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
             * configMAX_TASK_NAME_LEN characters just in case the memory after the
             * string is not accessible (extremely unlikely). */
            if( pcName[ x ] == ( char ) 0x00 )
    37ee:	89 81       	ldd	r24, Y+1	; 0x01
    37f0:	28 2f       	mov	r18, r24
    37f2:	30 e0       	ldi	r19, 0x00	; 0
    37f4:	8e 81       	ldd	r24, Y+6	; 0x06
    37f6:	9f 81       	ldd	r25, Y+7	; 0x07
    37f8:	fc 01       	movw	r30, r24
    37fa:	e2 0f       	add	r30, r18
    37fc:	f3 1f       	adc	r31, r19
    37fe:	80 81       	ld	r24, Z
    3800:	88 23       	and	r24, r24
    3802:	31 f0       	breq	.+12     	; 0x3810 <prvInitialiseNewTask+0xb2>
    #endif /* portSTACK_GROWTH */

    /* Store the task name in the TCB. */
    if( pcName != NULL )
    {
        for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    3804:	89 81       	ldd	r24, Y+1	; 0x01
    3806:	8f 5f       	subi	r24, 0xFF	; 255
    3808:	89 83       	std	Y+1, r24	; 0x01
    380a:	89 81       	ldd	r24, Y+1	; 0x01
    380c:	88 30       	cpi	r24, 0x08	; 8
    380e:	e0 f2       	brcs	.-72     	; 0x37c8 <prvInitialiseNewTask+0x6a>
            }
        }

        /* Ensure the name string is terminated in the case that the string length
         * was greater or equal to configMAX_TASK_NAME_LEN. */
        pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
    3810:	e9 89       	ldd	r30, Y+17	; 0x11
    3812:	fa 89       	ldd	r31, Y+18	; 0x12
    3814:	10 a2       	std	Z+32, r1	; 0x20
    3816:	03 c0       	rjmp	.+6      	; 0x381e <prvInitialiseNewTask+0xc0>
    }
    else
    {
        /* The task has not been given a name, so just ensure there is a NULL
         * terminator when it is read out. */
        pxNewTCB->pcTaskName[ 0 ] = 0x00;
    3818:	e9 89       	ldd	r30, Y+17	; 0x11
    381a:	fa 89       	ldd	r31, Y+18	; 0x12
    381c:	11 8e       	std	Z+25, r1	; 0x19
    }

    /* This is used as an array index so must ensure it's not too large. */
    configASSERT( uxPriority < configMAX_PRIORITIES );

    if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
    381e:	8e 85       	ldd	r24, Y+14	; 0x0e
    3820:	84 30       	cpi	r24, 0x04	; 4
    3822:	10 f0       	brcs	.+4      	; 0x3828 <prvInitialiseNewTask+0xca>
    {
        uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
    3824:	83 e0       	ldi	r24, 0x03	; 3
    3826:	8e 87       	std	Y+14, r24	; 0x0e
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    pxNewTCB->uxPriority = uxPriority;
    3828:	e9 89       	ldd	r30, Y+17	; 0x11
    382a:	fa 89       	ldd	r31, Y+18	; 0x12
    382c:	8e 85       	ldd	r24, Y+14	; 0x0e
    382e:	86 8b       	std	Z+22, r24	; 0x16
            pxNewTCB->uxBasePriority = uxPriority;
            pxNewTCB->uxMutexesHeld = 0;
        }
    #endif /* configUSE_MUTEXES */

    vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
    3830:	89 89       	ldd	r24, Y+17	; 0x11
    3832:	9a 89       	ldd	r25, Y+18	; 0x12
    3834:	02 96       	adiw	r24, 0x02	; 2
    3836:	0e 94 d5 10 	call	0x21aa	; 0x21aa <vListInitialiseItem>
    vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
    383a:	89 89       	ldd	r24, Y+17	; 0x11
    383c:	9a 89       	ldd	r25, Y+18	; 0x12
    383e:	0c 96       	adiw	r24, 0x0c	; 12
    3840:	0e 94 d5 10 	call	0x21aa	; 0x21aa <vListInitialiseItem>

    /* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
     * back to  the containing TCB from a generic item in a list. */
    listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
    3844:	e9 89       	ldd	r30, Y+17	; 0x11
    3846:	fa 89       	ldd	r31, Y+18	; 0x12
    3848:	89 89       	ldd	r24, Y+17	; 0x11
    384a:	9a 89       	ldd	r25, Y+18	; 0x12
    384c:	91 87       	std	Z+9, r25	; 0x09
    384e:	80 87       	std	Z+8, r24	; 0x08

    /* Event lists are always in priority order. */
    listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    3850:	8e 85       	ldd	r24, Y+14	; 0x0e
    3852:	28 2f       	mov	r18, r24
    3854:	30 e0       	ldi	r19, 0x00	; 0
    3856:	84 e0       	ldi	r24, 0x04	; 4
    3858:	90 e0       	ldi	r25, 0x00	; 0
    385a:	82 1b       	sub	r24, r18
    385c:	93 0b       	sbc	r25, r19
    385e:	e9 89       	ldd	r30, Y+17	; 0x11
    3860:	fa 89       	ldd	r31, Y+18	; 0x12
    3862:	95 87       	std	Z+13, r25	; 0x0d
    3864:	84 87       	std	Z+12, r24	; 0x0c
    listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
    3866:	e9 89       	ldd	r30, Y+17	; 0x11
    3868:	fa 89       	ldd	r31, Y+18	; 0x12
    386a:	89 89       	ldd	r24, Y+17	; 0x11
    386c:	9a 89       	ldd	r25, Y+18	; 0x12
    386e:	93 8b       	std	Z+19, r25	; 0x13
    3870:	82 8b       	std	Z+18, r24	; 0x12
        }
    #endif

    #if ( configUSE_TASK_NOTIFICATIONS == 1 )
        {
            memset( ( void * ) &( pxNewTCB->ulNotifiedValue[ 0 ] ), 0x00, sizeof( pxNewTCB->ulNotifiedValue ) );
    3872:	89 89       	ldd	r24, Y+17	; 0x11
    3874:	9a 89       	ldd	r25, Y+18	; 0x12
    3876:	81 96       	adiw	r24, 0x21	; 33
    3878:	60 e0       	ldi	r22, 0x00	; 0
    387a:	70 e0       	ldi	r23, 0x00	; 0
    387c:	44 e0       	ldi	r20, 0x04	; 4
    387e:	50 e0       	ldi	r21, 0x00	; 0
    3880:	0e 94 8a 49 	call	0x9314	; 0x9314 <memset>
            memset( ( void * ) &( pxNewTCB->ucNotifyState[ 0 ] ), 0x00, sizeof( pxNewTCB->ucNotifyState ) );
    3884:	89 89       	ldd	r24, Y+17	; 0x11
    3886:	9a 89       	ldd	r25, Y+18	; 0x12
    3888:	85 96       	adiw	r24, 0x25	; 37
    388a:	60 e0       	ldi	r22, 0x00	; 0
    388c:	70 e0       	ldi	r23, 0x00	; 0
    388e:	41 e0       	ldi	r20, 0x01	; 1
    3890:	50 e0       	ldi	r21, 0x00	; 0
    3892:	0e 94 8a 49 	call	0x9314	; 0x9314 <memset>
                        }
                    #endif /* portSTACK_GROWTH */
                }
            #else /* portHAS_STACK_OVERFLOW_CHECKING */
                {
                    pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    3896:	8a 81       	ldd	r24, Y+2	; 0x02
    3898:	9b 81       	ldd	r25, Y+3	; 0x03
    389a:	2c 81       	ldd	r18, Y+4	; 0x04
    389c:	3d 81       	ldd	r19, Y+5	; 0x05
    389e:	4c 85       	ldd	r20, Y+12	; 0x0c
    38a0:	5d 85       	ldd	r21, Y+13	; 0x0d
    38a2:	b9 01       	movw	r22, r18
    38a4:	0e 94 b3 07 	call	0xf66	; 0xf66 <pxPortInitialiseStack>
    38a8:	e9 89       	ldd	r30, Y+17	; 0x11
    38aa:	fa 89       	ldd	r31, Y+18	; 0x12
    38ac:	91 83       	std	Z+1, r25	; 0x01
    38ae:	80 83       	st	Z, r24
                }
            #endif /* portHAS_STACK_OVERFLOW_CHECKING */
        }
    #endif /* portUSING_MPU_WRAPPERS */

    if( pxCreatedTask != NULL )
    38b0:	8f 85       	ldd	r24, Y+15	; 0x0f
    38b2:	98 89       	ldd	r25, Y+16	; 0x10
    38b4:	00 97       	sbiw	r24, 0x00	; 0
    38b6:	31 f0       	breq	.+12     	; 0x38c4 <prvInitialiseNewTask+0x166>
    {
        /* Pass the handle out in an anonymous way.  The handle can be used to
         * change the created task's priority, delete the created task, etc.*/
        *pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
    38b8:	ef 85       	ldd	r30, Y+15	; 0x0f
    38ba:	f8 89       	ldd	r31, Y+16	; 0x10
    38bc:	89 89       	ldd	r24, Y+17	; 0x11
    38be:	9a 89       	ldd	r25, Y+18	; 0x12
    38c0:	91 83       	std	Z+1, r25	; 0x01
    38c2:	80 83       	st	Z, r24
    }
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }
}
    38c4:	64 96       	adiw	r28, 0x14	; 20
    38c6:	0f b6       	in	r0, 0x3f	; 63
    38c8:	f8 94       	cli
    38ca:	de bf       	out	0x3e, r29	; 62
    38cc:	0f be       	out	0x3f, r0	; 63
    38ce:	cd bf       	out	0x3d, r28	; 61
    38d0:	cf 91       	pop	r28
    38d2:	df 91       	pop	r29
    38d4:	1f 91       	pop	r17
    38d6:	0f 91       	pop	r16
    38d8:	ef 90       	pop	r14
    38da:	df 90       	pop	r13
    38dc:	cf 90       	pop	r12
    38de:	bf 90       	pop	r11
    38e0:	af 90       	pop	r10
    38e2:	9f 90       	pop	r9
    38e4:	8f 90       	pop	r8
    38e6:	08 95       	ret

000038e8 <prvAddNewTaskToReadyList>:
/*-----------------------------------------------------------*/

static void prvAddNewTaskToReadyList( TCB_t * pxNewTCB )
{
    38e8:	df 93       	push	r29
    38ea:	cf 93       	push	r28
    38ec:	00 d0       	rcall	.+0      	; 0x38ee <prvAddNewTaskToReadyList+0x6>
    38ee:	00 d0       	rcall	.+0      	; 0x38f0 <prvAddNewTaskToReadyList+0x8>
    38f0:	cd b7       	in	r28, 0x3d	; 61
    38f2:	de b7       	in	r29, 0x3e	; 62
    38f4:	9c 83       	std	Y+4, r25	; 0x04
    38f6:	8b 83       	std	Y+3, r24	; 0x03
    /* Ensure interrupts don't access the task lists while the lists are being
     * updated. */
    taskENTER_CRITICAL();
    38f8:	0f b6       	in	r0, 0x3f	; 63
    38fa:	f8 94       	cli
    38fc:	0f 92       	push	r0
    {
        uxCurrentNumberOfTasks++;
    38fe:	80 91 6d 08 	lds	r24, 0x086D
    3902:	8f 5f       	subi	r24, 0xFF	; 255
    3904:	80 93 6d 08 	sts	0x086D, r24

        if( pxCurrentTCB == NULL )
    3908:	80 91 6a 08 	lds	r24, 0x086A
    390c:	90 91 6b 08 	lds	r25, 0x086B
    3910:	00 97       	sbiw	r24, 0x00	; 0
    3912:	69 f4       	brne	.+26     	; 0x392e <prvAddNewTaskToReadyList+0x46>
        {
            /* There are no other tasks, or all the other tasks are in
             * the suspended state - make this the current task. */
            pxCurrentTCB = pxNewTCB;
    3914:	8b 81       	ldd	r24, Y+3	; 0x03
    3916:	9c 81       	ldd	r25, Y+4	; 0x04
    3918:	90 93 6b 08 	sts	0x086B, r25
    391c:	80 93 6a 08 	sts	0x086A, r24

            if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
    3920:	80 91 6d 08 	lds	r24, 0x086D
    3924:	81 30       	cpi	r24, 0x01	; 1
    3926:	b9 f4       	brne	.+46     	; 0x3956 <prvAddNewTaskToReadyList+0x6e>
            {
                /* This is the first task to be created so do the preliminary
                 * initialisation required.  We will not recover if this call
                 * fails, but we will report the failure. */
                prvInitialiseTaskLists();
    3928:	0e 94 58 26 	call	0x4cb0	; 0x4cb0 <prvInitialiseTaskLists>
    392c:	14 c0       	rjmp	.+40     	; 0x3956 <prvAddNewTaskToReadyList+0x6e>
        else
        {
            /* If the scheduler is not already running, make this task the
             * current task if it is the highest priority task to be created
             * so far. */
            if( xSchedulerRunning == pdFALSE )
    392e:	80 91 71 08 	lds	r24, 0x0871
    3932:	88 23       	and	r24, r24
    3934:	81 f4       	brne	.+32     	; 0x3956 <prvAddNewTaskToReadyList+0x6e>
            {
                if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
    3936:	e0 91 6a 08 	lds	r30, 0x086A
    393a:	f0 91 6b 08 	lds	r31, 0x086B
    393e:	96 89       	ldd	r25, Z+22	; 0x16
    3940:	eb 81       	ldd	r30, Y+3	; 0x03
    3942:	fc 81       	ldd	r31, Y+4	; 0x04
    3944:	86 89       	ldd	r24, Z+22	; 0x16
    3946:	89 17       	cp	r24, r25
    3948:	30 f0       	brcs	.+12     	; 0x3956 <prvAddNewTaskToReadyList+0x6e>
                {
                    pxCurrentTCB = pxNewTCB;
    394a:	8b 81       	ldd	r24, Y+3	; 0x03
    394c:	9c 81       	ldd	r25, Y+4	; 0x04
    394e:	90 93 6b 08 	sts	0x086B, r25
    3952:	80 93 6a 08 	sts	0x086A, r24
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }

        uxTaskNumber++;
    3956:	80 91 76 08 	lds	r24, 0x0876
    395a:	8f 5f       	subi	r24, 0xFF	; 255
    395c:	80 93 76 08 	sts	0x0876, r24
                pxNewTCB->uxTCBNumber = uxTaskNumber;
            }
        #endif /* configUSE_TRACE_FACILITY */
        traceTASK_CREATE( pxNewTCB );

        prvAddTaskToReadyList( pxNewTCB );
    3960:	eb 81       	ldd	r30, Y+3	; 0x03
    3962:	fc 81       	ldd	r31, Y+4	; 0x04
    3964:	96 89       	ldd	r25, Z+22	; 0x16
    3966:	80 91 70 08 	lds	r24, 0x0870
    396a:	89 17       	cp	r24, r25
    396c:	28 f4       	brcc	.+10     	; 0x3978 <prvAddNewTaskToReadyList+0x90>
    396e:	eb 81       	ldd	r30, Y+3	; 0x03
    3970:	fc 81       	ldd	r31, Y+4	; 0x04
    3972:	86 89       	ldd	r24, Z+22	; 0x16
    3974:	80 93 70 08 	sts	0x0870, r24
    3978:	eb 81       	ldd	r30, Y+3	; 0x03
    397a:	fc 81       	ldd	r31, Y+4	; 0x04
    397c:	86 89       	ldd	r24, Z+22	; 0x16
    397e:	28 2f       	mov	r18, r24
    3980:	30 e0       	ldi	r19, 0x00	; 0
    3982:	c9 01       	movw	r24, r18
    3984:	88 0f       	add	r24, r24
    3986:	99 1f       	adc	r25, r25
    3988:	88 0f       	add	r24, r24
    398a:	99 1f       	adc	r25, r25
    398c:	88 0f       	add	r24, r24
    398e:	99 1f       	adc	r25, r25
    3990:	82 0f       	add	r24, r18
    3992:	93 1f       	adc	r25, r19
    3994:	fc 01       	movw	r30, r24
    3996:	e4 58       	subi	r30, 0x84	; 132
    3998:	f7 4f       	sbci	r31, 0xF7	; 247
    399a:	81 81       	ldd	r24, Z+1	; 0x01
    399c:	92 81       	ldd	r25, Z+2	; 0x02
    399e:	9a 83       	std	Y+2, r25	; 0x02
    39a0:	89 83       	std	Y+1, r24	; 0x01
    39a2:	eb 81       	ldd	r30, Y+3	; 0x03
    39a4:	fc 81       	ldd	r31, Y+4	; 0x04
    39a6:	89 81       	ldd	r24, Y+1	; 0x01
    39a8:	9a 81       	ldd	r25, Y+2	; 0x02
    39aa:	95 83       	std	Z+5, r25	; 0x05
    39ac:	84 83       	std	Z+4, r24	; 0x04
    39ae:	e9 81       	ldd	r30, Y+1	; 0x01
    39b0:	fa 81       	ldd	r31, Y+2	; 0x02
    39b2:	84 81       	ldd	r24, Z+4	; 0x04
    39b4:	95 81       	ldd	r25, Z+5	; 0x05
    39b6:	eb 81       	ldd	r30, Y+3	; 0x03
    39b8:	fc 81       	ldd	r31, Y+4	; 0x04
    39ba:	97 83       	std	Z+7, r25	; 0x07
    39bc:	86 83       	std	Z+6, r24	; 0x06
    39be:	e9 81       	ldd	r30, Y+1	; 0x01
    39c0:	fa 81       	ldd	r31, Y+2	; 0x02
    39c2:	04 80       	ldd	r0, Z+4	; 0x04
    39c4:	f5 81       	ldd	r31, Z+5	; 0x05
    39c6:	e0 2d       	mov	r30, r0
    39c8:	8b 81       	ldd	r24, Y+3	; 0x03
    39ca:	9c 81       	ldd	r25, Y+4	; 0x04
    39cc:	02 96       	adiw	r24, 0x02	; 2
    39ce:	93 83       	std	Z+3, r25	; 0x03
    39d0:	82 83       	std	Z+2, r24	; 0x02
    39d2:	8b 81       	ldd	r24, Y+3	; 0x03
    39d4:	9c 81       	ldd	r25, Y+4	; 0x04
    39d6:	02 96       	adiw	r24, 0x02	; 2
    39d8:	e9 81       	ldd	r30, Y+1	; 0x01
    39da:	fa 81       	ldd	r31, Y+2	; 0x02
    39dc:	95 83       	std	Z+5, r25	; 0x05
    39de:	84 83       	std	Z+4, r24	; 0x04
    39e0:	eb 81       	ldd	r30, Y+3	; 0x03
    39e2:	fc 81       	ldd	r31, Y+4	; 0x04
    39e4:	86 89       	ldd	r24, Z+22	; 0x16
    39e6:	28 2f       	mov	r18, r24
    39e8:	30 e0       	ldi	r19, 0x00	; 0
    39ea:	c9 01       	movw	r24, r18
    39ec:	88 0f       	add	r24, r24
    39ee:	99 1f       	adc	r25, r25
    39f0:	88 0f       	add	r24, r24
    39f2:	99 1f       	adc	r25, r25
    39f4:	88 0f       	add	r24, r24
    39f6:	99 1f       	adc	r25, r25
    39f8:	82 0f       	add	r24, r18
    39fa:	93 1f       	adc	r25, r19
    39fc:	84 58       	subi	r24, 0x84	; 132
    39fe:	97 4f       	sbci	r25, 0xF7	; 247
    3a00:	eb 81       	ldd	r30, Y+3	; 0x03
    3a02:	fc 81       	ldd	r31, Y+4	; 0x04
    3a04:	93 87       	std	Z+11, r25	; 0x0b
    3a06:	82 87       	std	Z+10, r24	; 0x0a
    3a08:	eb 81       	ldd	r30, Y+3	; 0x03
    3a0a:	fc 81       	ldd	r31, Y+4	; 0x04
    3a0c:	86 89       	ldd	r24, Z+22	; 0x16
    3a0e:	28 2f       	mov	r18, r24
    3a10:	30 e0       	ldi	r19, 0x00	; 0
    3a12:	c9 01       	movw	r24, r18
    3a14:	88 0f       	add	r24, r24
    3a16:	99 1f       	adc	r25, r25
    3a18:	88 0f       	add	r24, r24
    3a1a:	99 1f       	adc	r25, r25
    3a1c:	88 0f       	add	r24, r24
    3a1e:	99 1f       	adc	r25, r25
    3a20:	82 0f       	add	r24, r18
    3a22:	93 1f       	adc	r25, r19
    3a24:	fc 01       	movw	r30, r24
    3a26:	e4 58       	subi	r30, 0x84	; 132
    3a28:	f7 4f       	sbci	r31, 0xF7	; 247
    3a2a:	80 81       	ld	r24, Z
    3a2c:	8f 5f       	subi	r24, 0xFF	; 255
    3a2e:	80 83       	st	Z, r24

        portSETUP_TCB( pxNewTCB );
    }
    taskEXIT_CRITICAL();
    3a30:	0f 90       	pop	r0
    3a32:	0f be       	out	0x3f, r0	; 63

    if( xSchedulerRunning != pdFALSE )
    3a34:	80 91 71 08 	lds	r24, 0x0871
    3a38:	88 23       	and	r24, r24
    3a3a:	61 f0       	breq	.+24     	; 0x3a54 <prvAddNewTaskToReadyList+0x16c>
    {
        /* If the created task is of a higher priority than the current task
         * then it should run now. */
        if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
    3a3c:	e0 91 6a 08 	lds	r30, 0x086A
    3a40:	f0 91 6b 08 	lds	r31, 0x086B
    3a44:	96 89       	ldd	r25, Z+22	; 0x16
    3a46:	eb 81       	ldd	r30, Y+3	; 0x03
    3a48:	fc 81       	ldd	r31, Y+4	; 0x04
    3a4a:	86 89       	ldd	r24, Z+22	; 0x16
    3a4c:	98 17       	cp	r25, r24
    3a4e:	10 f4       	brcc	.+4      	; 0x3a54 <prvAddNewTaskToReadyList+0x16c>
        {
            taskYIELD_IF_USING_PREEMPTION();
    3a50:	0e 94 72 09 	call	0x12e4	; 0x12e4 <vPortYield>
    }
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }
}
    3a54:	0f 90       	pop	r0
    3a56:	0f 90       	pop	r0
    3a58:	0f 90       	pop	r0
    3a5a:	0f 90       	pop	r0
    3a5c:	cf 91       	pop	r28
    3a5e:	df 91       	pop	r29
    3a60:	08 95       	ret

00003a62 <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

    void vTaskDelete( TaskHandle_t xTaskToDelete )
    {
    3a62:	df 93       	push	r29
    3a64:	cf 93       	push	r28
    3a66:	00 d0       	rcall	.+0      	; 0x3a68 <vTaskDelete+0x6>
    3a68:	00 d0       	rcall	.+0      	; 0x3a6a <vTaskDelete+0x8>
    3a6a:	00 d0       	rcall	.+0      	; 0x3a6c <vTaskDelete+0xa>
    3a6c:	cd b7       	in	r28, 0x3d	; 61
    3a6e:	de b7       	in	r29, 0x3e	; 62
    3a70:	9c 83       	std	Y+4, r25	; 0x04
    3a72:	8b 83       	std	Y+3, r24	; 0x03
        TCB_t * pxTCB;

        taskENTER_CRITICAL();
    3a74:	0f b6       	in	r0, 0x3f	; 63
    3a76:	f8 94       	cli
    3a78:	0f 92       	push	r0
        {
            /* If null is passed in here then it is the calling task that is
             * being deleted. */
            pxTCB = prvGetTCBFromHandle( xTaskToDelete );
    3a7a:	8b 81       	ldd	r24, Y+3	; 0x03
    3a7c:	9c 81       	ldd	r25, Y+4	; 0x04
    3a7e:	00 97       	sbiw	r24, 0x00	; 0
    3a80:	39 f4       	brne	.+14     	; 0x3a90 <vTaskDelete+0x2e>
    3a82:	80 91 6a 08 	lds	r24, 0x086A
    3a86:	90 91 6b 08 	lds	r25, 0x086B
    3a8a:	9e 83       	std	Y+6, r25	; 0x06
    3a8c:	8d 83       	std	Y+5, r24	; 0x05
    3a8e:	04 c0       	rjmp	.+8      	; 0x3a98 <vTaskDelete+0x36>
    3a90:	8b 81       	ldd	r24, Y+3	; 0x03
    3a92:	9c 81       	ldd	r25, Y+4	; 0x04
    3a94:	9e 83       	std	Y+6, r25	; 0x06
    3a96:	8d 83       	std	Y+5, r24	; 0x05
    3a98:	8d 81       	ldd	r24, Y+5	; 0x05
    3a9a:	9e 81       	ldd	r25, Y+6	; 0x06
    3a9c:	9a 83       	std	Y+2, r25	; 0x02
    3a9e:	89 83       	std	Y+1, r24	; 0x01

            /* Remove task from the ready/delayed list. */
            if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    3aa0:	89 81       	ldd	r24, Y+1	; 0x01
    3aa2:	9a 81       	ldd	r25, Y+2	; 0x02
    3aa4:	02 96       	adiw	r24, 0x02	; 2
    3aa6:	0e 94 95 11 	call	0x232a	; 0x232a <uxListRemove>
            {
                mtCOVERAGE_TEST_MARKER();
            }

            /* Is the task waiting on an event also? */
            if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    3aaa:	e9 81       	ldd	r30, Y+1	; 0x01
    3aac:	fa 81       	ldd	r31, Y+2	; 0x02
    3aae:	84 89       	ldd	r24, Z+20	; 0x14
    3ab0:	95 89       	ldd	r25, Z+21	; 0x15
    3ab2:	00 97       	sbiw	r24, 0x00	; 0
    3ab4:	29 f0       	breq	.+10     	; 0x3ac0 <vTaskDelete+0x5e>
            {
                ( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    3ab6:	89 81       	ldd	r24, Y+1	; 0x01
    3ab8:	9a 81       	ldd	r25, Y+2	; 0x02
    3aba:	0c 96       	adiw	r24, 0x0c	; 12
    3abc:	0e 94 95 11 	call	0x232a	; 0x232a <uxListRemove>

            /* Increment the uxTaskNumber also so kernel aware debuggers can
             * detect that the task lists need re-generating.  This is done before
             * portPRE_TASK_DELETE_HOOK() as in the Windows port that macro will
             * not return. */
            uxTaskNumber++;
    3ac0:	80 91 76 08 	lds	r24, 0x0876
    3ac4:	8f 5f       	subi	r24, 0xFF	; 255
    3ac6:	80 93 76 08 	sts	0x0876, r24

            if( pxTCB == pxCurrentTCB )
    3aca:	20 91 6a 08 	lds	r18, 0x086A
    3ace:	30 91 6b 08 	lds	r19, 0x086B
    3ad2:	89 81       	ldd	r24, Y+1	; 0x01
    3ad4:	9a 81       	ldd	r25, Y+2	; 0x02
    3ad6:	82 17       	cp	r24, r18
    3ad8:	93 07       	cpc	r25, r19
    3ada:	81 f4       	brne	.+32     	; 0x3afc <vTaskDelete+0x9a>
                /* A task is deleting itself.  This cannot complete within the
                 * task itself, as a context switch to another task is required.
                 * Place the task in the termination list.  The idle task will
                 * check the termination list and free up any memory allocated by
                 * the scheduler for the TCB and stack of the deleted task. */
                vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xStateListItem ) );
    3adc:	89 81       	ldd	r24, Y+1	; 0x01
    3ade:	9a 81       	ldd	r25, Y+2	; 0x02
    3ae0:	9c 01       	movw	r18, r24
    3ae2:	2e 5f       	subi	r18, 0xFE	; 254
    3ae4:	3f 4f       	sbci	r19, 0xFF	; 255
    3ae6:	8f eb       	ldi	r24, 0xBF	; 191
    3ae8:	98 e0       	ldi	r25, 0x08	; 8
    3aea:	b9 01       	movw	r22, r18
    3aec:	0e 94 e5 10 	call	0x21ca	; 0x21ca <vListInsertEnd>

                /* Increment the ucTasksDeleted variable so the idle task knows
                 * there is a task that has been deleted and that it should therefore
                 * check the xTasksWaitingTermination list. */
                ++uxDeletedTasksWaitingCleanUp;
    3af0:	80 91 6c 08 	lds	r24, 0x086C
    3af4:	8f 5f       	subi	r24, 0xFF	; 255
    3af6:	80 93 6c 08 	sts	0x086C, r24
    3afa:	07 c0       	rjmp	.+14     	; 0x3b0a <vTaskDelete+0xa8>
                 * required. */
                portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
            }
            else
            {
                --uxCurrentNumberOfTasks;
    3afc:	80 91 6d 08 	lds	r24, 0x086D
    3b00:	81 50       	subi	r24, 0x01	; 1
    3b02:	80 93 6d 08 	sts	0x086D, r24
                traceTASK_DELETE( pxTCB );

                /* Reset the next expected unblock time in case it referred to
                 * the task that has just been deleted. */
                prvResetNextTaskUnblockTime();
    3b06:	0e 94 da 26 	call	0x4db4	; 0x4db4 <prvResetNextTaskUnblockTime>
            }
        }
        taskEXIT_CRITICAL();
    3b0a:	0f 90       	pop	r0
    3b0c:	0f be       	out	0x3f, r0	; 63

        /* If the task is not deleting itself, call prvDeleteTCB from outside of
         * critical section. If a task deletes itself, prvDeleteTCB is called
         * from prvCheckTasksWaitingTermination which is called from Idle task. */
        if( pxTCB != pxCurrentTCB )
    3b0e:	20 91 6a 08 	lds	r18, 0x086A
    3b12:	30 91 6b 08 	lds	r19, 0x086B
    3b16:	89 81       	ldd	r24, Y+1	; 0x01
    3b18:	9a 81       	ldd	r25, Y+2	; 0x02
    3b1a:	82 17       	cp	r24, r18
    3b1c:	93 07       	cpc	r25, r19
    3b1e:	21 f0       	breq	.+8      	; 0x3b28 <vTaskDelete+0xc6>
        {
            prvDeleteTCB( pxTCB );
    3b20:	89 81       	ldd	r24, Y+1	; 0x01
    3b22:	9a 81       	ldd	r25, Y+2	; 0x02
    3b24:	0e 94 c4 26 	call	0x4d88	; 0x4d88 <prvDeleteTCB>
        }

        /* Force a reschedule if it is the currently running task that has just
         * been deleted. */
        if( xSchedulerRunning != pdFALSE )
    3b28:	80 91 71 08 	lds	r24, 0x0871
    3b2c:	88 23       	and	r24, r24
    3b2e:	59 f0       	breq	.+22     	; 0x3b46 <vTaskDelete+0xe4>
        {
            if( pxTCB == pxCurrentTCB )
    3b30:	20 91 6a 08 	lds	r18, 0x086A
    3b34:	30 91 6b 08 	lds	r19, 0x086B
    3b38:	89 81       	ldd	r24, Y+1	; 0x01
    3b3a:	9a 81       	ldd	r25, Y+2	; 0x02
    3b3c:	82 17       	cp	r24, r18
    3b3e:	93 07       	cpc	r25, r19
    3b40:	11 f4       	brne	.+4      	; 0x3b46 <vTaskDelete+0xe4>
            {
                configASSERT( uxSchedulerSuspended == 0 );
                portYIELD_WITHIN_API();
    3b42:	0e 94 72 09 	call	0x12e4	; 0x12e4 <vPortYield>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
    }
    3b46:	26 96       	adiw	r28, 0x06	; 6
    3b48:	0f b6       	in	r0, 0x3f	; 63
    3b4a:	f8 94       	cli
    3b4c:	de bf       	out	0x3e, r29	; 62
    3b4e:	0f be       	out	0x3f, r0	; 63
    3b50:	cd bf       	out	0x3d, r28	; 61
    3b52:	cf 91       	pop	r28
    3b54:	df 91       	pop	r29
    3b56:	08 95       	ret

00003b58 <xTaskDelayUntil>:

#if ( INCLUDE_xTaskDelayUntil == 1 )

    BaseType_t xTaskDelayUntil( TickType_t * const pxPreviousWakeTime,
                                const TickType_t xTimeIncrement )
    {
    3b58:	df 93       	push	r29
    3b5a:	cf 93       	push	r28
    3b5c:	cd b7       	in	r28, 0x3d	; 61
    3b5e:	de b7       	in	r29, 0x3e	; 62
    3b60:	2a 97       	sbiw	r28, 0x0a	; 10
    3b62:	0f b6       	in	r0, 0x3f	; 63
    3b64:	f8 94       	cli
    3b66:	de bf       	out	0x3e, r29	; 62
    3b68:	0f be       	out	0x3f, r0	; 63
    3b6a:	cd bf       	out	0x3d, r28	; 61
    3b6c:	98 87       	std	Y+8, r25	; 0x08
    3b6e:	8f 83       	std	Y+7, r24	; 0x07
    3b70:	7a 87       	std	Y+10, r23	; 0x0a
    3b72:	69 87       	std	Y+9, r22	; 0x09
        TickType_t xTimeToWake;
        BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
    3b74:	1b 82       	std	Y+3, r1	; 0x03

        configASSERT( pxPreviousWakeTime );
        configASSERT( ( xTimeIncrement > 0U ) );
        configASSERT( uxSchedulerSuspended == 0 );

        vTaskSuspendAll();
    3b76:	0e 94 88 1e 	call	0x3d10	; 0x3d10 <vTaskSuspendAll>
        {
            /* Minor optimisation.  The tick count cannot change in this
             * block. */
            const TickType_t xConstTickCount = xTickCount;
    3b7a:	80 91 6e 08 	lds	r24, 0x086E
    3b7e:	90 91 6f 08 	lds	r25, 0x086F
    3b82:	9a 83       	std	Y+2, r25	; 0x02
    3b84:	89 83       	std	Y+1, r24	; 0x01

            /* Generate the tick time at which the task wants to wake. */
            xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    3b86:	ef 81       	ldd	r30, Y+7	; 0x07
    3b88:	f8 85       	ldd	r31, Y+8	; 0x08
    3b8a:	20 81       	ld	r18, Z
    3b8c:	31 81       	ldd	r19, Z+1	; 0x01
    3b8e:	89 85       	ldd	r24, Y+9	; 0x09
    3b90:	9a 85       	ldd	r25, Y+10	; 0x0a
    3b92:	82 0f       	add	r24, r18
    3b94:	93 1f       	adc	r25, r19
    3b96:	9e 83       	std	Y+6, r25	; 0x06
    3b98:	8d 83       	std	Y+5, r24	; 0x05

            if( xConstTickCount < *pxPreviousWakeTime )
    3b9a:	ef 81       	ldd	r30, Y+7	; 0x07
    3b9c:	f8 85       	ldd	r31, Y+8	; 0x08
    3b9e:	20 81       	ld	r18, Z
    3ba0:	31 81       	ldd	r19, Z+1	; 0x01
    3ba2:	89 81       	ldd	r24, Y+1	; 0x01
    3ba4:	9a 81       	ldd	r25, Y+2	; 0x02
    3ba6:	82 17       	cp	r24, r18
    3ba8:	93 07       	cpc	r25, r19
    3baa:	98 f4       	brcc	.+38     	; 0x3bd2 <xTaskDelayUntil+0x7a>
                /* The tick count has overflowed since this function was
                 * lasted called.  In this case the only time we should ever
                 * actually delay is if the wake time has also  overflowed,
                 * and the wake time is greater than the tick time.  When this
                 * is the case it is as if neither time had overflowed. */
                if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
    3bac:	ef 81       	ldd	r30, Y+7	; 0x07
    3bae:	f8 85       	ldd	r31, Y+8	; 0x08
    3bb0:	20 81       	ld	r18, Z
    3bb2:	31 81       	ldd	r19, Z+1	; 0x01
    3bb4:	8d 81       	ldd	r24, Y+5	; 0x05
    3bb6:	9e 81       	ldd	r25, Y+6	; 0x06
    3bb8:	82 17       	cp	r24, r18
    3bba:	93 07       	cpc	r25, r19
    3bbc:	e0 f4       	brcc	.+56     	; 0x3bf6 <xTaskDelayUntil+0x9e>
    3bbe:	2d 81       	ldd	r18, Y+5	; 0x05
    3bc0:	3e 81       	ldd	r19, Y+6	; 0x06
    3bc2:	89 81       	ldd	r24, Y+1	; 0x01
    3bc4:	9a 81       	ldd	r25, Y+2	; 0x02
    3bc6:	82 17       	cp	r24, r18
    3bc8:	93 07       	cpc	r25, r19
    3bca:	a8 f4       	brcc	.+42     	; 0x3bf6 <xTaskDelayUntil+0x9e>
                {
                    xShouldDelay = pdTRUE;
    3bcc:	81 e0       	ldi	r24, 0x01	; 1
    3bce:	8b 83       	std	Y+3, r24	; 0x03
    3bd0:	12 c0       	rjmp	.+36     	; 0x3bf6 <xTaskDelayUntil+0x9e>
            else
            {
                /* The tick time has not overflowed.  In this case we will
                 * delay if either the wake time has overflowed, and/or the
                 * tick time is less than the wake time. */
                if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
    3bd2:	ef 81       	ldd	r30, Y+7	; 0x07
    3bd4:	f8 85       	ldd	r31, Y+8	; 0x08
    3bd6:	20 81       	ld	r18, Z
    3bd8:	31 81       	ldd	r19, Z+1	; 0x01
    3bda:	8d 81       	ldd	r24, Y+5	; 0x05
    3bdc:	9e 81       	ldd	r25, Y+6	; 0x06
    3bde:	82 17       	cp	r24, r18
    3be0:	93 07       	cpc	r25, r19
    3be2:	38 f0       	brcs	.+14     	; 0x3bf2 <xTaskDelayUntil+0x9a>
    3be4:	2d 81       	ldd	r18, Y+5	; 0x05
    3be6:	3e 81       	ldd	r19, Y+6	; 0x06
    3be8:	89 81       	ldd	r24, Y+1	; 0x01
    3bea:	9a 81       	ldd	r25, Y+2	; 0x02
    3bec:	82 17       	cp	r24, r18
    3bee:	93 07       	cpc	r25, r19
    3bf0:	10 f4       	brcc	.+4      	; 0x3bf6 <xTaskDelayUntil+0x9e>
                {
                    xShouldDelay = pdTRUE;
    3bf2:	81 e0       	ldi	r24, 0x01	; 1
    3bf4:	8b 83       	std	Y+3, r24	; 0x03
                    mtCOVERAGE_TEST_MARKER();
                }
            }

            /* Update the wake time ready for the next call. */
            *pxPreviousWakeTime = xTimeToWake;
    3bf6:	ef 81       	ldd	r30, Y+7	; 0x07
    3bf8:	f8 85       	ldd	r31, Y+8	; 0x08
    3bfa:	8d 81       	ldd	r24, Y+5	; 0x05
    3bfc:	9e 81       	ldd	r25, Y+6	; 0x06
    3bfe:	91 83       	std	Z+1, r25	; 0x01
    3c00:	80 83       	st	Z, r24

            if( xShouldDelay != pdFALSE )
    3c02:	8b 81       	ldd	r24, Y+3	; 0x03
    3c04:	88 23       	and	r24, r24
    3c06:	49 f0       	breq	.+18     	; 0x3c1a <xTaskDelayUntil+0xc2>
            {
                traceTASK_DELAY_UNTIL( xTimeToWake );

                /* prvAddCurrentTaskToDelayedList() needs the block time, not
                 * the time to wake, so subtract the current tick count. */
                prvAddCurrentTaskToDelayedList( xTimeToWake - xConstTickCount, pdFALSE );
    3c08:	8d 81       	ldd	r24, Y+5	; 0x05
    3c0a:	9e 81       	ldd	r25, Y+6	; 0x06
    3c0c:	29 81       	ldd	r18, Y+1	; 0x01
    3c0e:	3a 81       	ldd	r19, Y+2	; 0x02
    3c10:	82 1b       	sub	r24, r18
    3c12:	93 0b       	sbc	r25, r19
    3c14:	60 e0       	ldi	r22, 0x00	; 0
    3c16:	0e 94 c1 2e 	call	0x5d82	; 0x5d82 <prvAddCurrentTaskToDelayedList>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        xAlreadyYielded = xTaskResumeAll();
    3c1a:	0e 94 94 1e 	call	0x3d28	; 0x3d28 <xTaskResumeAll>
    3c1e:	8c 83       	std	Y+4, r24	; 0x04

        /* Force a reschedule if xTaskResumeAll has not already done so, we may
         * have put ourselves to sleep. */
        if( xAlreadyYielded == pdFALSE )
    3c20:	8c 81       	ldd	r24, Y+4	; 0x04
    3c22:	88 23       	and	r24, r24
    3c24:	11 f4       	brne	.+4      	; 0x3c2a <xTaskDelayUntil+0xd2>
        {
            portYIELD_WITHIN_API();
    3c26:	0e 94 72 09 	call	0x12e4	; 0x12e4 <vPortYield>
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        return xShouldDelay;
    3c2a:	8b 81       	ldd	r24, Y+3	; 0x03
    }
    3c2c:	2a 96       	adiw	r28, 0x0a	; 10
    3c2e:	0f b6       	in	r0, 0x3f	; 63
    3c30:	f8 94       	cli
    3c32:	de bf       	out	0x3e, r29	; 62
    3c34:	0f be       	out	0x3f, r0	; 63
    3c36:	cd bf       	out	0x3d, r28	; 61
    3c38:	cf 91       	pop	r28
    3c3a:	df 91       	pop	r29
    3c3c:	08 95       	ret

00003c3e <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

    void vTaskDelay( const TickType_t xTicksToDelay )
    {
    3c3e:	df 93       	push	r29
    3c40:	cf 93       	push	r28
    3c42:	00 d0       	rcall	.+0      	; 0x3c44 <vTaskDelay+0x6>
    3c44:	0f 92       	push	r0
    3c46:	cd b7       	in	r28, 0x3d	; 61
    3c48:	de b7       	in	r29, 0x3e	; 62
    3c4a:	9b 83       	std	Y+3, r25	; 0x03
    3c4c:	8a 83       	std	Y+2, r24	; 0x02
        BaseType_t xAlreadyYielded = pdFALSE;
    3c4e:	19 82       	std	Y+1, r1	; 0x01

        /* A delay time of zero just forces a reschedule. */
        if( xTicksToDelay > ( TickType_t ) 0U )
    3c50:	8a 81       	ldd	r24, Y+2	; 0x02
    3c52:	9b 81       	ldd	r25, Y+3	; 0x03
    3c54:	00 97       	sbiw	r24, 0x00	; 0
    3c56:	51 f0       	breq	.+20     	; 0x3c6c <vTaskDelay+0x2e>
        {
            configASSERT( uxSchedulerSuspended == 0 );
            vTaskSuspendAll();
    3c58:	0e 94 88 1e 	call	0x3d10	; 0x3d10 <vTaskSuspendAll>
                 * list or removed from the blocked list until the scheduler
                 * is resumed.
                 *
                 * This task cannot be in an event list as it is the currently
                 * executing task. */
                prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
    3c5c:	8a 81       	ldd	r24, Y+2	; 0x02
    3c5e:	9b 81       	ldd	r25, Y+3	; 0x03
    3c60:	60 e0       	ldi	r22, 0x00	; 0
    3c62:	0e 94 c1 2e 	call	0x5d82	; 0x5d82 <prvAddCurrentTaskToDelayedList>
            }
            xAlreadyYielded = xTaskResumeAll();
    3c66:	0e 94 94 1e 	call	0x3d28	; 0x3d28 <xTaskResumeAll>
    3c6a:	89 83       	std	Y+1, r24	; 0x01
            mtCOVERAGE_TEST_MARKER();
        }

        /* Force a reschedule if xTaskResumeAll has not already done so, we may
         * have put ourselves to sleep. */
        if( xAlreadyYielded == pdFALSE )
    3c6c:	89 81       	ldd	r24, Y+1	; 0x01
    3c6e:	88 23       	and	r24, r24
    3c70:	11 f4       	brne	.+4      	; 0x3c76 <vTaskDelay+0x38>
        {
            portYIELD_WITHIN_API();
    3c72:	0e 94 72 09 	call	0x12e4	; 0x12e4 <vPortYield>
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }
    3c76:	0f 90       	pop	r0
    3c78:	0f 90       	pop	r0
    3c7a:	0f 90       	pop	r0
    3c7c:	cf 91       	pop	r28
    3c7e:	df 91       	pop	r29
    3c80:	08 95       	ret

00003c82 <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
    3c82:	ef 92       	push	r14
    3c84:	ff 92       	push	r15
    3c86:	0f 93       	push	r16
    3c88:	df 93       	push	r29
    3c8a:	cf 93       	push	r28
    3c8c:	00 d0       	rcall	.+0      	; 0x3c8e <vTaskStartScheduler+0xc>
    3c8e:	cd b7       	in	r28, 0x3d	; 61
    3c90:	de b7       	in	r29, 0x3e	; 62
            }
        }
    #else /* if ( configSUPPORT_STATIC_ALLOCATION == 1 ) */
        {
            /* The Idle task is being created using dynamically allocated RAM. */
            xReturn = xTaskCreate( prvIdleTask,
    3c92:	88 e4       	ldi	r24, 0x48	; 72
    3c94:	96 e2       	ldi	r25, 0x26	; 38
    3c96:	20 e0       	ldi	r18, 0x00	; 0
    3c98:	31 e0       	ldi	r19, 0x01	; 1
    3c9a:	e9 e7       	ldi	r30, 0x79	; 121
    3c9c:	f8 e0       	ldi	r31, 0x08	; 8
    3c9e:	b9 01       	movw	r22, r18
    3ca0:	45 e5       	ldi	r20, 0x55	; 85
    3ca2:	50 e0       	ldi	r21, 0x00	; 0
    3ca4:	20 e0       	ldi	r18, 0x00	; 0
    3ca6:	30 e0       	ldi	r19, 0x00	; 0
    3ca8:	00 e0       	ldi	r16, 0x00	; 0
    3caa:	7f 01       	movw	r14, r30
    3cac:	0e 94 37 1b 	call	0x366e	; 0x366e <xTaskCreate>
    3cb0:	89 83       	std	Y+1, r24	; 0x01
        }
    #endif /* configSUPPORT_STATIC_ALLOCATION */

    #if ( configUSE_TIMERS == 1 )
        {
            if( xReturn == pdPASS )
    3cb2:	89 81       	ldd	r24, Y+1	; 0x01
    3cb4:	81 30       	cpi	r24, 0x01	; 1
    3cb6:	19 f4       	brne	.+6      	; 0x3cbe <vTaskStartScheduler+0x3c>
            {
                xReturn = xTimerCreateTimerTask();
    3cb8:	0e 94 27 2f 	call	0x5e4e	; 0x5e4e <xTimerCreateTimerTask>
    3cbc:	89 83       	std	Y+1, r24	; 0x01
                mtCOVERAGE_TEST_MARKER();
            }
        }
    #endif /* configUSE_TIMERS */

    if( xReturn == pdPASS )
    3cbe:	89 81       	ldd	r24, Y+1	; 0x01
    3cc0:	81 30       	cpi	r24, 0x01	; 1
    3cc2:	81 f4       	brne	.+32     	; 0x3ce4 <vTaskStartScheduler+0x62>
        /* Interrupts are turned off here, to ensure a tick does not occur
         * before or during the call to xPortStartScheduler().  The stacks of
         * the created tasks contain a status word with interrupts switched on
         * so interrupts will automatically get re-enabled when the first task
         * starts to run. */
        portDISABLE_INTERRUPTS();
    3cc4:	f8 94       	cli
                 * for additional information. */
                _impure_ptr = &( pxCurrentTCB->xNewLib_reent );
            }
        #endif /* configUSE_NEWLIB_REENTRANT */

        xNextTaskUnblockTime = portMAX_DELAY;
    3cc6:	8f ef       	ldi	r24, 0xFF	; 255
    3cc8:	9f ef       	ldi	r25, 0xFF	; 255
    3cca:	90 93 78 08 	sts	0x0878, r25
    3cce:	80 93 77 08 	sts	0x0877, r24
        xSchedulerRunning = pdTRUE;
    3cd2:	81 e0       	ldi	r24, 0x01	; 1
    3cd4:	80 93 71 08 	sts	0x0871, r24
        xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
    3cd8:	10 92 6f 08 	sts	0x086F, r1
    3cdc:	10 92 6e 08 	sts	0x086E, r1

        traceTASK_SWITCHED_IN();

        /* Setting up the timer tick is hardware specific and thus in the
         * portable interface. */
        if( xPortStartScheduler() != pdFALSE )
    3ce0:	0e 94 36 09 	call	0x126c	; 0x126c <xPortStartScheduler>
     * meaning xIdleTaskHandle is not used anywhere else. */
    ( void ) xIdleTaskHandle;

    /* OpenOCD makes use of uxTopUsedPriority for thread debugging. Prevent uxTopUsedPriority
     * from getting optimized out as it is no longer used by the kernel. */
    ( void ) uxTopUsedPriority;
    3ce4:	80 91 37 02 	lds	r24, 0x0237
}
    3ce8:	0f 90       	pop	r0
    3cea:	0f 90       	pop	r0
    3cec:	cf 91       	pop	r28
    3cee:	df 91       	pop	r29
    3cf0:	0f 91       	pop	r16
    3cf2:	ff 90       	pop	r15
    3cf4:	ef 90       	pop	r14
    3cf6:	08 95       	ret

00003cf8 <vTaskEndScheduler>:
/*-----------------------------------------------------------*/

void vTaskEndScheduler( void )
{
    3cf8:	df 93       	push	r29
    3cfa:	cf 93       	push	r28
    3cfc:	cd b7       	in	r28, 0x3d	; 61
    3cfe:	de b7       	in	r29, 0x3e	; 62
    /* Stop the scheduler interrupts and call the portable scheduler end
     * routine so the original ISRs can be restored if necessary.  The port
     * layer must ensure interrupts enable  bit is left in the correct state. */
    portDISABLE_INTERRUPTS();
    3d00:	f8 94       	cli
    xSchedulerRunning = pdFALSE;
    3d02:	10 92 71 08 	sts	0x0871, r1
    vPortEndScheduler();
    3d06:	0e 94 6b 09 	call	0x12d6	; 0x12d6 <vPortEndScheduler>
}
    3d0a:	cf 91       	pop	r28
    3d0c:	df 91       	pop	r29
    3d0e:	08 95       	ret

00003d10 <vTaskSuspendAll>:
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
    3d10:	df 93       	push	r29
    3d12:	cf 93       	push	r28
    3d14:	cd b7       	in	r28, 0x3d	; 61
    3d16:	de b7       	in	r29, 0x3e	; 62
     * do not otherwise exhibit real time behaviour. */
    portSOFTWARE_BARRIER();

    /* The scheduler is suspended if uxSchedulerSuspended is non-zero.  An increment
     * is used to allow calls to vTaskSuspendAll() to nest. */
    ++uxSchedulerSuspended;
    3d18:	80 91 7b 08 	lds	r24, 0x087B
    3d1c:	8f 5f       	subi	r24, 0xFF	; 255
    3d1e:	80 93 7b 08 	sts	0x087B, r24

    /* Enforces ordering for ports and optimised compilers that may otherwise place
     * the above increment elsewhere. */
    portMEMORY_BARRIER();
}
    3d22:	cf 91       	pop	r28
    3d24:	df 91       	pop	r29
    3d26:	08 95       	ret

00003d28 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
    3d28:	df 93       	push	r29
    3d2a:	cf 93       	push	r28
    3d2c:	cd b7       	in	r28, 0x3d	; 61
    3d2e:	de b7       	in	r29, 0x3e	; 62
    3d30:	2b 97       	sbiw	r28, 0x0b	; 11
    3d32:	0f b6       	in	r0, 0x3f	; 63
    3d34:	f8 94       	cli
    3d36:	de bf       	out	0x3e, r29	; 62
    3d38:	0f be       	out	0x3f, r0	; 63
    3d3a:	cd bf       	out	0x3d, r28	; 61
    TCB_t * pxTCB = NULL;
    3d3c:	1b 86       	std	Y+11, r1	; 0x0b
    3d3e:	1a 86       	std	Y+10, r1	; 0x0a
    BaseType_t xAlreadyYielded = pdFALSE;
    3d40:	19 86       	std	Y+9, r1	; 0x09
    /* It is possible that an ISR caused a task to be removed from an event
     * list while the scheduler was suspended.  If this was the case then the
     * removed task will have been added to the xPendingReadyList.  Once the
     * scheduler has been resumed it is safe to move all the pending ready
     * tasks from this list into their appropriate ready list. */
    taskENTER_CRITICAL();
    3d42:	0f b6       	in	r0, 0x3f	; 63
    3d44:	f8 94       	cli
    3d46:	0f 92       	push	r0
    {
        --uxSchedulerSuspended;
    3d48:	80 91 7b 08 	lds	r24, 0x087B
    3d4c:	81 50       	subi	r24, 0x01	; 1
    3d4e:	80 93 7b 08 	sts	0x087B, r24

        if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    3d52:	80 91 7b 08 	lds	r24, 0x087B
    3d56:	88 23       	and	r24, r24
    3d58:	09 f0       	breq	.+2      	; 0x3d5c <xTaskResumeAll+0x34>
    3d5a:	2a c1       	rjmp	.+596    	; 0x3fb0 <xTaskResumeAll+0x288>
        {
            if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
    3d5c:	80 91 6d 08 	lds	r24, 0x086D
    3d60:	88 23       	and	r24, r24
    3d62:	09 f4       	brne	.+2      	; 0x3d66 <xTaskResumeAll+0x3e>
    3d64:	25 c1       	rjmp	.+586    	; 0x3fb0 <xTaskResumeAll+0x288>
    3d66:	f3 c0       	rjmp	.+486    	; 0x3f4e <xTaskResumeAll+0x226>
            {
                /* Move any readied tasks from the pending list into the
                 * appropriate ready list. */
                while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
                {
                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    3d68:	e0 91 bb 08 	lds	r30, 0x08BB
    3d6c:	f0 91 bc 08 	lds	r31, 0x08BC
    3d70:	86 81       	ldd	r24, Z+6	; 0x06
    3d72:	97 81       	ldd	r25, Z+7	; 0x07
    3d74:	9b 87       	std	Y+11, r25	; 0x0b
    3d76:	8a 87       	std	Y+10, r24	; 0x0a
                    listREMOVE_ITEM( &( pxTCB->xEventListItem ) );
    3d78:	ea 85       	ldd	r30, Y+10	; 0x0a
    3d7a:	fb 85       	ldd	r31, Y+11	; 0x0b
    3d7c:	84 89       	ldd	r24, Z+20	; 0x14
    3d7e:	95 89       	ldd	r25, Z+21	; 0x15
    3d80:	98 87       	std	Y+8, r25	; 0x08
    3d82:	8f 83       	std	Y+7, r24	; 0x07
    3d84:	ea 85       	ldd	r30, Y+10	; 0x0a
    3d86:	fb 85       	ldd	r31, Y+11	; 0x0b
    3d88:	a6 85       	ldd	r26, Z+14	; 0x0e
    3d8a:	b7 85       	ldd	r27, Z+15	; 0x0f
    3d8c:	ea 85       	ldd	r30, Y+10	; 0x0a
    3d8e:	fb 85       	ldd	r31, Y+11	; 0x0b
    3d90:	80 89       	ldd	r24, Z+16	; 0x10
    3d92:	91 89       	ldd	r25, Z+17	; 0x11
    3d94:	15 96       	adiw	r26, 0x05	; 5
    3d96:	9c 93       	st	X, r25
    3d98:	8e 93       	st	-X, r24
    3d9a:	14 97       	sbiw	r26, 0x04	; 4
    3d9c:	ea 85       	ldd	r30, Y+10	; 0x0a
    3d9e:	fb 85       	ldd	r31, Y+11	; 0x0b
    3da0:	a0 89       	ldd	r26, Z+16	; 0x10
    3da2:	b1 89       	ldd	r27, Z+17	; 0x11
    3da4:	ea 85       	ldd	r30, Y+10	; 0x0a
    3da6:	fb 85       	ldd	r31, Y+11	; 0x0b
    3da8:	86 85       	ldd	r24, Z+14	; 0x0e
    3daa:	97 85       	ldd	r25, Z+15	; 0x0f
    3dac:	13 96       	adiw	r26, 0x03	; 3
    3dae:	9c 93       	st	X, r25
    3db0:	8e 93       	st	-X, r24
    3db2:	12 97       	sbiw	r26, 0x02	; 2
    3db4:	ef 81       	ldd	r30, Y+7	; 0x07
    3db6:	f8 85       	ldd	r31, Y+8	; 0x08
    3db8:	21 81       	ldd	r18, Z+1	; 0x01
    3dba:	32 81       	ldd	r19, Z+2	; 0x02
    3dbc:	8a 85       	ldd	r24, Y+10	; 0x0a
    3dbe:	9b 85       	ldd	r25, Y+11	; 0x0b
    3dc0:	0c 96       	adiw	r24, 0x0c	; 12
    3dc2:	28 17       	cp	r18, r24
    3dc4:	39 07       	cpc	r19, r25
    3dc6:	41 f4       	brne	.+16     	; 0x3dd8 <xTaskResumeAll+0xb0>
    3dc8:	ea 85       	ldd	r30, Y+10	; 0x0a
    3dca:	fb 85       	ldd	r31, Y+11	; 0x0b
    3dcc:	80 89       	ldd	r24, Z+16	; 0x10
    3dce:	91 89       	ldd	r25, Z+17	; 0x11
    3dd0:	ef 81       	ldd	r30, Y+7	; 0x07
    3dd2:	f8 85       	ldd	r31, Y+8	; 0x08
    3dd4:	92 83       	std	Z+2, r25	; 0x02
    3dd6:	81 83       	std	Z+1, r24	; 0x01
    3dd8:	ea 85       	ldd	r30, Y+10	; 0x0a
    3dda:	fb 85       	ldd	r31, Y+11	; 0x0b
    3ddc:	15 8a       	std	Z+21, r1	; 0x15
    3dde:	14 8a       	std	Z+20, r1	; 0x14
    3de0:	ef 81       	ldd	r30, Y+7	; 0x07
    3de2:	f8 85       	ldd	r31, Y+8	; 0x08
    3de4:	80 81       	ld	r24, Z
    3de6:	81 50       	subi	r24, 0x01	; 1
    3de8:	ef 81       	ldd	r30, Y+7	; 0x07
    3dea:	f8 85       	ldd	r31, Y+8	; 0x08
    3dec:	80 83       	st	Z, r24
                    portMEMORY_BARRIER();
                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
    3dee:	ea 85       	ldd	r30, Y+10	; 0x0a
    3df0:	fb 85       	ldd	r31, Y+11	; 0x0b
    3df2:	82 85       	ldd	r24, Z+10	; 0x0a
    3df4:	93 85       	ldd	r25, Z+11	; 0x0b
    3df6:	9e 83       	std	Y+6, r25	; 0x06
    3df8:	8d 83       	std	Y+5, r24	; 0x05
    3dfa:	ea 85       	ldd	r30, Y+10	; 0x0a
    3dfc:	fb 85       	ldd	r31, Y+11	; 0x0b
    3dfe:	a4 81       	ldd	r26, Z+4	; 0x04
    3e00:	b5 81       	ldd	r27, Z+5	; 0x05
    3e02:	ea 85       	ldd	r30, Y+10	; 0x0a
    3e04:	fb 85       	ldd	r31, Y+11	; 0x0b
    3e06:	86 81       	ldd	r24, Z+6	; 0x06
    3e08:	97 81       	ldd	r25, Z+7	; 0x07
    3e0a:	15 96       	adiw	r26, 0x05	; 5
    3e0c:	9c 93       	st	X, r25
    3e0e:	8e 93       	st	-X, r24
    3e10:	14 97       	sbiw	r26, 0x04	; 4
    3e12:	ea 85       	ldd	r30, Y+10	; 0x0a
    3e14:	fb 85       	ldd	r31, Y+11	; 0x0b
    3e16:	a6 81       	ldd	r26, Z+6	; 0x06
    3e18:	b7 81       	ldd	r27, Z+7	; 0x07
    3e1a:	ea 85       	ldd	r30, Y+10	; 0x0a
    3e1c:	fb 85       	ldd	r31, Y+11	; 0x0b
    3e1e:	84 81       	ldd	r24, Z+4	; 0x04
    3e20:	95 81       	ldd	r25, Z+5	; 0x05
    3e22:	13 96       	adiw	r26, 0x03	; 3
    3e24:	9c 93       	st	X, r25
    3e26:	8e 93       	st	-X, r24
    3e28:	12 97       	sbiw	r26, 0x02	; 2
    3e2a:	ed 81       	ldd	r30, Y+5	; 0x05
    3e2c:	fe 81       	ldd	r31, Y+6	; 0x06
    3e2e:	21 81       	ldd	r18, Z+1	; 0x01
    3e30:	32 81       	ldd	r19, Z+2	; 0x02
    3e32:	8a 85       	ldd	r24, Y+10	; 0x0a
    3e34:	9b 85       	ldd	r25, Y+11	; 0x0b
    3e36:	02 96       	adiw	r24, 0x02	; 2
    3e38:	28 17       	cp	r18, r24
    3e3a:	39 07       	cpc	r19, r25
    3e3c:	41 f4       	brne	.+16     	; 0x3e4e <xTaskResumeAll+0x126>
    3e3e:	ea 85       	ldd	r30, Y+10	; 0x0a
    3e40:	fb 85       	ldd	r31, Y+11	; 0x0b
    3e42:	86 81       	ldd	r24, Z+6	; 0x06
    3e44:	97 81       	ldd	r25, Z+7	; 0x07
    3e46:	ed 81       	ldd	r30, Y+5	; 0x05
    3e48:	fe 81       	ldd	r31, Y+6	; 0x06
    3e4a:	92 83       	std	Z+2, r25	; 0x02
    3e4c:	81 83       	std	Z+1, r24	; 0x01
    3e4e:	ea 85       	ldd	r30, Y+10	; 0x0a
    3e50:	fb 85       	ldd	r31, Y+11	; 0x0b
    3e52:	13 86       	std	Z+11, r1	; 0x0b
    3e54:	12 86       	std	Z+10, r1	; 0x0a
    3e56:	ed 81       	ldd	r30, Y+5	; 0x05
    3e58:	fe 81       	ldd	r31, Y+6	; 0x06
    3e5a:	80 81       	ld	r24, Z
    3e5c:	81 50       	subi	r24, 0x01	; 1
    3e5e:	ed 81       	ldd	r30, Y+5	; 0x05
    3e60:	fe 81       	ldd	r31, Y+6	; 0x06
    3e62:	80 83       	st	Z, r24
                    prvAddTaskToReadyList( pxTCB );
    3e64:	ea 85       	ldd	r30, Y+10	; 0x0a
    3e66:	fb 85       	ldd	r31, Y+11	; 0x0b
    3e68:	96 89       	ldd	r25, Z+22	; 0x16
    3e6a:	80 91 70 08 	lds	r24, 0x0870
    3e6e:	89 17       	cp	r24, r25
    3e70:	28 f4       	brcc	.+10     	; 0x3e7c <xTaskResumeAll+0x154>
    3e72:	ea 85       	ldd	r30, Y+10	; 0x0a
    3e74:	fb 85       	ldd	r31, Y+11	; 0x0b
    3e76:	86 89       	ldd	r24, Z+22	; 0x16
    3e78:	80 93 70 08 	sts	0x0870, r24
    3e7c:	ea 85       	ldd	r30, Y+10	; 0x0a
    3e7e:	fb 85       	ldd	r31, Y+11	; 0x0b
    3e80:	86 89       	ldd	r24, Z+22	; 0x16
    3e82:	28 2f       	mov	r18, r24
    3e84:	30 e0       	ldi	r19, 0x00	; 0
    3e86:	c9 01       	movw	r24, r18
    3e88:	88 0f       	add	r24, r24
    3e8a:	99 1f       	adc	r25, r25
    3e8c:	88 0f       	add	r24, r24
    3e8e:	99 1f       	adc	r25, r25
    3e90:	88 0f       	add	r24, r24
    3e92:	99 1f       	adc	r25, r25
    3e94:	82 0f       	add	r24, r18
    3e96:	93 1f       	adc	r25, r19
    3e98:	fc 01       	movw	r30, r24
    3e9a:	e4 58       	subi	r30, 0x84	; 132
    3e9c:	f7 4f       	sbci	r31, 0xF7	; 247
    3e9e:	81 81       	ldd	r24, Z+1	; 0x01
    3ea0:	92 81       	ldd	r25, Z+2	; 0x02
    3ea2:	9c 83       	std	Y+4, r25	; 0x04
    3ea4:	8b 83       	std	Y+3, r24	; 0x03
    3ea6:	ea 85       	ldd	r30, Y+10	; 0x0a
    3ea8:	fb 85       	ldd	r31, Y+11	; 0x0b
    3eaa:	8b 81       	ldd	r24, Y+3	; 0x03
    3eac:	9c 81       	ldd	r25, Y+4	; 0x04
    3eae:	95 83       	std	Z+5, r25	; 0x05
    3eb0:	84 83       	std	Z+4, r24	; 0x04
    3eb2:	eb 81       	ldd	r30, Y+3	; 0x03
    3eb4:	fc 81       	ldd	r31, Y+4	; 0x04
    3eb6:	84 81       	ldd	r24, Z+4	; 0x04
    3eb8:	95 81       	ldd	r25, Z+5	; 0x05
    3eba:	ea 85       	ldd	r30, Y+10	; 0x0a
    3ebc:	fb 85       	ldd	r31, Y+11	; 0x0b
    3ebe:	97 83       	std	Z+7, r25	; 0x07
    3ec0:	86 83       	std	Z+6, r24	; 0x06
    3ec2:	eb 81       	ldd	r30, Y+3	; 0x03
    3ec4:	fc 81       	ldd	r31, Y+4	; 0x04
    3ec6:	04 80       	ldd	r0, Z+4	; 0x04
    3ec8:	f5 81       	ldd	r31, Z+5	; 0x05
    3eca:	e0 2d       	mov	r30, r0
    3ecc:	8a 85       	ldd	r24, Y+10	; 0x0a
    3ece:	9b 85       	ldd	r25, Y+11	; 0x0b
    3ed0:	02 96       	adiw	r24, 0x02	; 2
    3ed2:	93 83       	std	Z+3, r25	; 0x03
    3ed4:	82 83       	std	Z+2, r24	; 0x02
    3ed6:	8a 85       	ldd	r24, Y+10	; 0x0a
    3ed8:	9b 85       	ldd	r25, Y+11	; 0x0b
    3eda:	02 96       	adiw	r24, 0x02	; 2
    3edc:	eb 81       	ldd	r30, Y+3	; 0x03
    3ede:	fc 81       	ldd	r31, Y+4	; 0x04
    3ee0:	95 83       	std	Z+5, r25	; 0x05
    3ee2:	84 83       	std	Z+4, r24	; 0x04
    3ee4:	ea 85       	ldd	r30, Y+10	; 0x0a
    3ee6:	fb 85       	ldd	r31, Y+11	; 0x0b
    3ee8:	86 89       	ldd	r24, Z+22	; 0x16
    3eea:	28 2f       	mov	r18, r24
    3eec:	30 e0       	ldi	r19, 0x00	; 0
    3eee:	c9 01       	movw	r24, r18
    3ef0:	88 0f       	add	r24, r24
    3ef2:	99 1f       	adc	r25, r25
    3ef4:	88 0f       	add	r24, r24
    3ef6:	99 1f       	adc	r25, r25
    3ef8:	88 0f       	add	r24, r24
    3efa:	99 1f       	adc	r25, r25
    3efc:	82 0f       	add	r24, r18
    3efe:	93 1f       	adc	r25, r19
    3f00:	84 58       	subi	r24, 0x84	; 132
    3f02:	97 4f       	sbci	r25, 0xF7	; 247
    3f04:	ea 85       	ldd	r30, Y+10	; 0x0a
    3f06:	fb 85       	ldd	r31, Y+11	; 0x0b
    3f08:	93 87       	std	Z+11, r25	; 0x0b
    3f0a:	82 87       	std	Z+10, r24	; 0x0a
    3f0c:	ea 85       	ldd	r30, Y+10	; 0x0a
    3f0e:	fb 85       	ldd	r31, Y+11	; 0x0b
    3f10:	86 89       	ldd	r24, Z+22	; 0x16
    3f12:	28 2f       	mov	r18, r24
    3f14:	30 e0       	ldi	r19, 0x00	; 0
    3f16:	c9 01       	movw	r24, r18
    3f18:	88 0f       	add	r24, r24
    3f1a:	99 1f       	adc	r25, r25
    3f1c:	88 0f       	add	r24, r24
    3f1e:	99 1f       	adc	r25, r25
    3f20:	88 0f       	add	r24, r24
    3f22:	99 1f       	adc	r25, r25
    3f24:	82 0f       	add	r24, r18
    3f26:	93 1f       	adc	r25, r19
    3f28:	fc 01       	movw	r30, r24
    3f2a:	e4 58       	subi	r30, 0x84	; 132
    3f2c:	f7 4f       	sbci	r31, 0xF7	; 247
    3f2e:	80 81       	ld	r24, Z
    3f30:	8f 5f       	subi	r24, 0xFF	; 255
    3f32:	80 83       	st	Z, r24

                    /* If the moved task has a priority higher than or equal to
                     * the current task then a yield must be performed. */
                    if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    3f34:	ea 85       	ldd	r30, Y+10	; 0x0a
    3f36:	fb 85       	ldd	r31, Y+11	; 0x0b
    3f38:	96 89       	ldd	r25, Z+22	; 0x16
    3f3a:	e0 91 6a 08 	lds	r30, 0x086A
    3f3e:	f0 91 6b 08 	lds	r31, 0x086B
    3f42:	86 89       	ldd	r24, Z+22	; 0x16
    3f44:	98 17       	cp	r25, r24
    3f46:	18 f0       	brcs	.+6      	; 0x3f4e <xTaskResumeAll+0x226>
                    {
                        xYieldPending = pdTRUE;
    3f48:	81 e0       	ldi	r24, 0x01	; 1
    3f4a:	80 93 74 08 	sts	0x0874, r24
        {
            if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
            {
                /* Move any readied tasks from the pending list into the
                 * appropriate ready list. */
                while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
    3f4e:	80 91 b6 08 	lds	r24, 0x08B6
    3f52:	88 23       	and	r24, r24
    3f54:	09 f0       	breq	.+2      	; 0x3f58 <xTaskResumeAll+0x230>
    3f56:	08 cf       	rjmp	.-496    	; 0x3d68 <xTaskResumeAll+0x40>
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }
                }

                if( pxTCB != NULL )
    3f58:	8a 85       	ldd	r24, Y+10	; 0x0a
    3f5a:	9b 85       	ldd	r25, Y+11	; 0x0b
    3f5c:	00 97       	sbiw	r24, 0x00	; 0
    3f5e:	11 f0       	breq	.+4      	; 0x3f64 <xTaskResumeAll+0x23c>
                     * which may have prevented the next unblock time from being
                     * re-calculated, in which case re-calculate it now.  Mainly
                     * important for low power tickless implementations, where
                     * this can prevent an unnecessary exit from low power
                     * state. */
                    prvResetNextTaskUnblockTime();
    3f60:	0e 94 da 26 	call	0x4db4	; 0x4db4 <prvResetNextTaskUnblockTime>
                /* If any ticks occurred while the scheduler was suspended then
                 * they should be processed now.  This ensures the tick count does
                 * not  slip, and that any delayed tasks are resumed at the correct
                 * time. */
                {
                    TickType_t xPendedCounts = xPendedTicks; /* Non-volatile copy. */
    3f64:	80 91 72 08 	lds	r24, 0x0872
    3f68:	90 91 73 08 	lds	r25, 0x0873
    3f6c:	9a 83       	std	Y+2, r25	; 0x02
    3f6e:	89 83       	std	Y+1, r24	; 0x01

                    if( xPendedCounts > ( TickType_t ) 0U )
    3f70:	89 81       	ldd	r24, Y+1	; 0x01
    3f72:	9a 81       	ldd	r25, Y+2	; 0x02
    3f74:	00 97       	sbiw	r24, 0x00	; 0
    3f76:	a1 f0       	breq	.+40     	; 0x3fa0 <xTaskResumeAll+0x278>
                    {
                        do
                        {
                            if( xTaskIncrementTick() != pdFALSE )
    3f78:	0e 94 61 20 	call	0x40c2	; 0x40c2 <xTaskIncrementTick>
    3f7c:	88 23       	and	r24, r24
    3f7e:	19 f0       	breq	.+6      	; 0x3f86 <xTaskResumeAll+0x25e>
                            {
                                xYieldPending = pdTRUE;
    3f80:	81 e0       	ldi	r24, 0x01	; 1
    3f82:	80 93 74 08 	sts	0x0874, r24
                            else
                            {
                                mtCOVERAGE_TEST_MARKER();
                            }

                            --xPendedCounts;
    3f86:	89 81       	ldd	r24, Y+1	; 0x01
    3f88:	9a 81       	ldd	r25, Y+2	; 0x02
    3f8a:	01 97       	sbiw	r24, 0x01	; 1
    3f8c:	9a 83       	std	Y+2, r25	; 0x02
    3f8e:	89 83       	std	Y+1, r24	; 0x01
                        } while( xPendedCounts > ( TickType_t ) 0U );
    3f90:	89 81       	ldd	r24, Y+1	; 0x01
    3f92:	9a 81       	ldd	r25, Y+2	; 0x02
    3f94:	00 97       	sbiw	r24, 0x00	; 0
    3f96:	81 f7       	brne	.-32     	; 0x3f78 <xTaskResumeAll+0x250>

                        xPendedTicks = 0;
    3f98:	10 92 73 08 	sts	0x0873, r1
    3f9c:	10 92 72 08 	sts	0x0872, r1
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }
                }

                if( xYieldPending != pdFALSE )
    3fa0:	80 91 74 08 	lds	r24, 0x0874
    3fa4:	88 23       	and	r24, r24
    3fa6:	21 f0       	breq	.+8      	; 0x3fb0 <xTaskResumeAll+0x288>
                {
                    #if ( configUSE_PREEMPTION != 0 )
                        {
                            xAlreadyYielded = pdTRUE;
    3fa8:	81 e0       	ldi	r24, 0x01	; 1
    3faa:	89 87       	std	Y+9, r24	; 0x09
                        }
                    #endif
                    taskYIELD_IF_USING_PREEMPTION();
    3fac:	0e 94 72 09 	call	0x12e4	; 0x12e4 <vPortYield>
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }
    taskEXIT_CRITICAL();
    3fb0:	0f 90       	pop	r0
    3fb2:	0f be       	out	0x3f, r0	; 63

    return xAlreadyYielded;
    3fb4:	89 85       	ldd	r24, Y+9	; 0x09
}
    3fb6:	2b 96       	adiw	r28, 0x0b	; 11
    3fb8:	0f b6       	in	r0, 0x3f	; 63
    3fba:	f8 94       	cli
    3fbc:	de bf       	out	0x3e, r29	; 62
    3fbe:	0f be       	out	0x3f, r0	; 63
    3fc0:	cd bf       	out	0x3d, r28	; 61
    3fc2:	cf 91       	pop	r28
    3fc4:	df 91       	pop	r29
    3fc6:	08 95       	ret

00003fc8 <xTaskGetTickCount>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCount( void )
{
    3fc8:	df 93       	push	r29
    3fca:	cf 93       	push	r28
    3fcc:	00 d0       	rcall	.+0      	; 0x3fce <xTaskGetTickCount+0x6>
    3fce:	cd b7       	in	r28, 0x3d	; 61
    3fd0:	de b7       	in	r29, 0x3e	; 62
    TickType_t xTicks;

    /* Critical section required if running on a 16 bit processor. */
    portTICK_TYPE_ENTER_CRITICAL();
    3fd2:	0f b6       	in	r0, 0x3f	; 63
    3fd4:	f8 94       	cli
    3fd6:	0f 92       	push	r0
    {
        xTicks = xTickCount;
    3fd8:	80 91 6e 08 	lds	r24, 0x086E
    3fdc:	90 91 6f 08 	lds	r25, 0x086F
    3fe0:	9a 83       	std	Y+2, r25	; 0x02
    3fe2:	89 83       	std	Y+1, r24	; 0x01
    }
    portTICK_TYPE_EXIT_CRITICAL();
    3fe4:	0f 90       	pop	r0
    3fe6:	0f be       	out	0x3f, r0	; 63

    return xTicks;
    3fe8:	89 81       	ldd	r24, Y+1	; 0x01
    3fea:	9a 81       	ldd	r25, Y+2	; 0x02
}
    3fec:	0f 90       	pop	r0
    3fee:	0f 90       	pop	r0
    3ff0:	cf 91       	pop	r28
    3ff2:	df 91       	pop	r29
    3ff4:	08 95       	ret

00003ff6 <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCountFromISR( void )
{
    3ff6:	df 93       	push	r29
    3ff8:	cf 93       	push	r28
    3ffa:	00 d0       	rcall	.+0      	; 0x3ffc <xTaskGetTickCountFromISR+0x6>
    3ffc:	0f 92       	push	r0
    3ffe:	cd b7       	in	r28, 0x3d	; 61
    4000:	de b7       	in	r29, 0x3e	; 62
     * safe API to ensure interrupt entry is as fast and as simple as possible.
     * More information (albeit Cortex-M specific) is provided on the following
     * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

    uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
    4002:	19 82       	std	Y+1, r1	; 0x01
    {
        xReturn = xTickCount;
    4004:	80 91 6e 08 	lds	r24, 0x086E
    4008:	90 91 6f 08 	lds	r25, 0x086F
    400c:	9b 83       	std	Y+3, r25	; 0x03
    400e:	8a 83       	std	Y+2, r24	; 0x02
    }
    portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
    4010:	8a 81       	ldd	r24, Y+2	; 0x02
    4012:	9b 81       	ldd	r25, Y+3	; 0x03
}
    4014:	0f 90       	pop	r0
    4016:	0f 90       	pop	r0
    4018:	0f 90       	pop	r0
    401a:	cf 91       	pop	r28
    401c:	df 91       	pop	r29
    401e:	08 95       	ret

00004020 <uxTaskGetNumberOfTasks>:
/*-----------------------------------------------------------*/

UBaseType_t uxTaskGetNumberOfTasks( void )
{
    4020:	df 93       	push	r29
    4022:	cf 93       	push	r28
    4024:	cd b7       	in	r28, 0x3d	; 61
    4026:	de b7       	in	r29, 0x3e	; 62
    /* A critical section is not required because the variables are of type
     * BaseType_t. */
    return uxCurrentNumberOfTasks;
    4028:	80 91 6d 08 	lds	r24, 0x086D
}
    402c:	cf 91       	pop	r28
    402e:	df 91       	pop	r29
    4030:	08 95       	ret

00004032 <pcTaskGetName>:
/*-----------------------------------------------------------*/

char * pcTaskGetName( TaskHandle_t xTaskToQuery ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
    4032:	df 93       	push	r29
    4034:	cf 93       	push	r28
    4036:	00 d0       	rcall	.+0      	; 0x4038 <pcTaskGetName+0x6>
    4038:	00 d0       	rcall	.+0      	; 0x403a <pcTaskGetName+0x8>
    403a:	00 d0       	rcall	.+0      	; 0x403c <pcTaskGetName+0xa>
    403c:	cd b7       	in	r28, 0x3d	; 61
    403e:	de b7       	in	r29, 0x3e	; 62
    4040:	9c 83       	std	Y+4, r25	; 0x04
    4042:	8b 83       	std	Y+3, r24	; 0x03
    TCB_t * pxTCB;

    /* If null is passed in here then the name of the calling task is being
     * queried. */
    pxTCB = prvGetTCBFromHandle( xTaskToQuery );
    4044:	8b 81       	ldd	r24, Y+3	; 0x03
    4046:	9c 81       	ldd	r25, Y+4	; 0x04
    4048:	00 97       	sbiw	r24, 0x00	; 0
    404a:	39 f4       	brne	.+14     	; 0x405a <pcTaskGetName+0x28>
    404c:	80 91 6a 08 	lds	r24, 0x086A
    4050:	90 91 6b 08 	lds	r25, 0x086B
    4054:	9e 83       	std	Y+6, r25	; 0x06
    4056:	8d 83       	std	Y+5, r24	; 0x05
    4058:	04 c0       	rjmp	.+8      	; 0x4062 <pcTaskGetName+0x30>
    405a:	8b 81       	ldd	r24, Y+3	; 0x03
    405c:	9c 81       	ldd	r25, Y+4	; 0x04
    405e:	9e 83       	std	Y+6, r25	; 0x06
    4060:	8d 83       	std	Y+5, r24	; 0x05
    4062:	8d 81       	ldd	r24, Y+5	; 0x05
    4064:	9e 81       	ldd	r25, Y+6	; 0x06
    4066:	9a 83       	std	Y+2, r25	; 0x02
    4068:	89 83       	std	Y+1, r24	; 0x01
    configASSERT( pxTCB );
    return &( pxTCB->pcTaskName[ 0 ] );
    406a:	89 81       	ldd	r24, Y+1	; 0x01
    406c:	9a 81       	ldd	r25, Y+2	; 0x02
    406e:	49 96       	adiw	r24, 0x19	; 25
}
    4070:	26 96       	adiw	r28, 0x06	; 6
    4072:	0f b6       	in	r0, 0x3f	; 63
    4074:	f8 94       	cli
    4076:	de bf       	out	0x3e, r29	; 62
    4078:	0f be       	out	0x3f, r0	; 63
    407a:	cd bf       	out	0x3d, r28	; 61
    407c:	cf 91       	pop	r28
    407e:	df 91       	pop	r29
    4080:	08 95       	ret

00004082 <xTaskCatchUpTicks>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskCatchUpTicks( TickType_t xTicksToCatchUp )
{
    4082:	df 93       	push	r29
    4084:	cf 93       	push	r28
    4086:	00 d0       	rcall	.+0      	; 0x4088 <xTaskCatchUpTicks+0x6>
    4088:	0f 92       	push	r0
    408a:	cd b7       	in	r28, 0x3d	; 61
    408c:	de b7       	in	r29, 0x3e	; 62
    408e:	9b 83       	std	Y+3, r25	; 0x03
    4090:	8a 83       	std	Y+2, r24	; 0x02
     * relies on xPendedTicks being wound down to 0 in xTaskResumeAll(). */
    configASSERT( uxSchedulerSuspended == 0 );

    /* Use xPendedTicks to mimic xTicksToCatchUp number of ticks occurring when
     * the scheduler is suspended so the ticks are executed in xTaskResumeAll(). */
    vTaskSuspendAll();
    4092:	0e 94 88 1e 	call	0x3d10	; 0x3d10 <vTaskSuspendAll>
    xPendedTicks += xTicksToCatchUp;
    4096:	20 91 72 08 	lds	r18, 0x0872
    409a:	30 91 73 08 	lds	r19, 0x0873
    409e:	8a 81       	ldd	r24, Y+2	; 0x02
    40a0:	9b 81       	ldd	r25, Y+3	; 0x03
    40a2:	82 0f       	add	r24, r18
    40a4:	93 1f       	adc	r25, r19
    40a6:	90 93 73 08 	sts	0x0873, r25
    40aa:	80 93 72 08 	sts	0x0872, r24
    xYieldOccurred = xTaskResumeAll();
    40ae:	0e 94 94 1e 	call	0x3d28	; 0x3d28 <xTaskResumeAll>
    40b2:	89 83       	std	Y+1, r24	; 0x01

    return xYieldOccurred;
    40b4:	89 81       	ldd	r24, Y+1	; 0x01
}
    40b6:	0f 90       	pop	r0
    40b8:	0f 90       	pop	r0
    40ba:	0f 90       	pop	r0
    40bc:	cf 91       	pop	r28
    40be:	df 91       	pop	r29
    40c0:	08 95       	ret

000040c2 <xTaskIncrementTick>:

#endif /* INCLUDE_xTaskAbortDelay */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
    40c2:	df 93       	push	r29
    40c4:	cf 93       	push	r28
    40c6:	cd b7       	in	r28, 0x3d	; 61
    40c8:	de b7       	in	r29, 0x3e	; 62
    40ca:	2f 97       	sbiw	r28, 0x0f	; 15
    40cc:	0f b6       	in	r0, 0x3f	; 63
    40ce:	f8 94       	cli
    40d0:	de bf       	out	0x3e, r29	; 62
    40d2:	0f be       	out	0x3f, r0	; 63
    40d4:	cd bf       	out	0x3d, r28	; 61
    TCB_t * pxTCB;
    TickType_t xItemValue;
    BaseType_t xSwitchRequired = pdFALSE;
    40d6:	1b 86       	std	Y+11, r1	; 0x0b
    /* Called by the portable layer each time a tick interrupt occurs.
     * Increments the tick then checks to see if the new tick value will cause any
     * tasks to be unblocked. */
    traceTASK_INCREMENT_TICK( xTickCount );

    if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    40d8:	80 91 7b 08 	lds	r24, 0x087B
    40dc:	88 23       	and	r24, r24
    40de:	09 f0       	breq	.+2      	; 0x40e2 <xTaskIncrementTick+0x20>
    40e0:	74 c1       	rjmp	.+744    	; 0x43ca <xTaskIncrementTick+0x308>
    {
        /* Minor optimisation.  The tick count cannot change in this
         * block. */
        const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
    40e2:	80 91 6e 08 	lds	r24, 0x086E
    40e6:	90 91 6f 08 	lds	r25, 0x086F
    40ea:	01 96       	adiw	r24, 0x01	; 1
    40ec:	9a 87       	std	Y+10, r25	; 0x0a
    40ee:	89 87       	std	Y+9, r24	; 0x09

        /* Increment the RTOS tick, switching the delayed and overflowed
         * delayed lists if it wraps to 0. */
        xTickCount = xConstTickCount;
    40f0:	89 85       	ldd	r24, Y+9	; 0x09
    40f2:	9a 85       	ldd	r25, Y+10	; 0x0a
    40f4:	90 93 6f 08 	sts	0x086F, r25
    40f8:	80 93 6e 08 	sts	0x086E, r24

        if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
    40fc:	89 85       	ldd	r24, Y+9	; 0x09
    40fe:	9a 85       	ldd	r25, Y+10	; 0x0a
    4100:	00 97       	sbiw	r24, 0x00	; 0
    4102:	d9 f4       	brne	.+54     	; 0x413a <xTaskIncrementTick+0x78>
        {
            taskSWITCH_DELAYED_LISTS();
    4104:	80 91 b2 08 	lds	r24, 0x08B2
    4108:	90 91 b3 08 	lds	r25, 0x08B3
    410c:	98 87       	std	Y+8, r25	; 0x08
    410e:	8f 83       	std	Y+7, r24	; 0x07
    4110:	80 91 b4 08 	lds	r24, 0x08B4
    4114:	90 91 b5 08 	lds	r25, 0x08B5
    4118:	90 93 b3 08 	sts	0x08B3, r25
    411c:	80 93 b2 08 	sts	0x08B2, r24
    4120:	8f 81       	ldd	r24, Y+7	; 0x07
    4122:	98 85       	ldd	r25, Y+8	; 0x08
    4124:	90 93 b5 08 	sts	0x08B5, r25
    4128:	80 93 b4 08 	sts	0x08B4, r24
    412c:	80 91 75 08 	lds	r24, 0x0875
    4130:	8f 5f       	subi	r24, 0xFF	; 255
    4132:	80 93 75 08 	sts	0x0875, r24
    4136:	0e 94 da 26 	call	0x4db4	; 0x4db4 <prvResetNextTaskUnblockTime>

        /* See if this tick has made a timeout expire.  Tasks are stored in
         * the  queue in the order of their wake time - meaning once one task
         * has been found whose block time has not expired there is no need to
         * look any further down the list. */
        if( xConstTickCount >= xNextTaskUnblockTime )
    413a:	20 91 77 08 	lds	r18, 0x0877
    413e:	30 91 78 08 	lds	r19, 0x0878
    4142:	89 85       	ldd	r24, Y+9	; 0x09
    4144:	9a 85       	ldd	r25, Y+10	; 0x0a
    4146:	82 17       	cp	r24, r18
    4148:	93 07       	cpc	r25, r19
    414a:	08 f4       	brcc	.+2      	; 0x414e <xTaskIncrementTick+0x8c>
    414c:	1f c1       	rjmp	.+574    	; 0x438c <xTaskIncrementTick+0x2ca>
        {
            for( ; ; )
            {
                if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    414e:	e0 91 b2 08 	lds	r30, 0x08B2
    4152:	f0 91 b3 08 	lds	r31, 0x08B3
    4156:	80 81       	ld	r24, Z
    4158:	88 23       	and	r24, r24
    415a:	39 f4       	brne	.+14     	; 0x416a <xTaskIncrementTick+0xa8>
                    /* The delayed list is empty.  Set xNextTaskUnblockTime
                     * to the maximum possible value so it is extremely
                     * unlikely that the
                     * if( xTickCount >= xNextTaskUnblockTime ) test will pass
                     * next time through. */
                    xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    415c:	8f ef       	ldi	r24, 0xFF	; 255
    415e:	9f ef       	ldi	r25, 0xFF	; 255
    4160:	90 93 78 08 	sts	0x0878, r25
    4164:	80 93 77 08 	sts	0x0877, r24
    4168:	11 c1       	rjmp	.+546    	; 0x438c <xTaskIncrementTick+0x2ca>
                {
                    /* The delayed list is not empty, get the value of the
                     * item at the head of the delayed list.  This is the time
                     * at which the task at the head of the delayed list must
                     * be removed from the Blocked state. */
                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    416a:	e0 91 b2 08 	lds	r30, 0x08B2
    416e:	f0 91 b3 08 	lds	r31, 0x08B3
    4172:	05 80       	ldd	r0, Z+5	; 0x05
    4174:	f6 81       	ldd	r31, Z+6	; 0x06
    4176:	e0 2d       	mov	r30, r0
    4178:	86 81       	ldd	r24, Z+6	; 0x06
    417a:	97 81       	ldd	r25, Z+7	; 0x07
    417c:	9f 87       	std	Y+15, r25	; 0x0f
    417e:	8e 87       	std	Y+14, r24	; 0x0e
                    xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
    4180:	ee 85       	ldd	r30, Y+14	; 0x0e
    4182:	ff 85       	ldd	r31, Y+15	; 0x0f
    4184:	82 81       	ldd	r24, Z+2	; 0x02
    4186:	93 81       	ldd	r25, Z+3	; 0x03
    4188:	9d 87       	std	Y+13, r25	; 0x0d
    418a:	8c 87       	std	Y+12, r24	; 0x0c

                    if( xConstTickCount < xItemValue )
    418c:	29 85       	ldd	r18, Y+9	; 0x09
    418e:	3a 85       	ldd	r19, Y+10	; 0x0a
    4190:	8c 85       	ldd	r24, Y+12	; 0x0c
    4192:	9d 85       	ldd	r25, Y+13	; 0x0d
    4194:	28 17       	cp	r18, r24
    4196:	39 07       	cpc	r19, r25
    4198:	38 f4       	brcc	.+14     	; 0x41a8 <xTaskIncrementTick+0xe6>
                        /* It is not time to unblock this item yet, but the
                         * item value is the time at which the task at the head
                         * of the blocked list must be removed from the Blocked
                         * state -  so record the item value in
                         * xNextTaskUnblockTime. */
                        xNextTaskUnblockTime = xItemValue;
    419a:	8c 85       	ldd	r24, Y+12	; 0x0c
    419c:	9d 85       	ldd	r25, Y+13	; 0x0d
    419e:	90 93 78 08 	sts	0x0878, r25
    41a2:	80 93 77 08 	sts	0x0877, r24
    41a6:	f2 c0       	rjmp	.+484    	; 0x438c <xTaskIncrementTick+0x2ca>
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }

                    /* It is time to remove the item from the Blocked state. */
                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
    41a8:	ee 85       	ldd	r30, Y+14	; 0x0e
    41aa:	ff 85       	ldd	r31, Y+15	; 0x0f
    41ac:	82 85       	ldd	r24, Z+10	; 0x0a
    41ae:	93 85       	ldd	r25, Z+11	; 0x0b
    41b0:	9e 83       	std	Y+6, r25	; 0x06
    41b2:	8d 83       	std	Y+5, r24	; 0x05
    41b4:	ee 85       	ldd	r30, Y+14	; 0x0e
    41b6:	ff 85       	ldd	r31, Y+15	; 0x0f
    41b8:	a4 81       	ldd	r26, Z+4	; 0x04
    41ba:	b5 81       	ldd	r27, Z+5	; 0x05
    41bc:	ee 85       	ldd	r30, Y+14	; 0x0e
    41be:	ff 85       	ldd	r31, Y+15	; 0x0f
    41c0:	86 81       	ldd	r24, Z+6	; 0x06
    41c2:	97 81       	ldd	r25, Z+7	; 0x07
    41c4:	15 96       	adiw	r26, 0x05	; 5
    41c6:	9c 93       	st	X, r25
    41c8:	8e 93       	st	-X, r24
    41ca:	14 97       	sbiw	r26, 0x04	; 4
    41cc:	ee 85       	ldd	r30, Y+14	; 0x0e
    41ce:	ff 85       	ldd	r31, Y+15	; 0x0f
    41d0:	a6 81       	ldd	r26, Z+6	; 0x06
    41d2:	b7 81       	ldd	r27, Z+7	; 0x07
    41d4:	ee 85       	ldd	r30, Y+14	; 0x0e
    41d6:	ff 85       	ldd	r31, Y+15	; 0x0f
    41d8:	84 81       	ldd	r24, Z+4	; 0x04
    41da:	95 81       	ldd	r25, Z+5	; 0x05
    41dc:	13 96       	adiw	r26, 0x03	; 3
    41de:	9c 93       	st	X, r25
    41e0:	8e 93       	st	-X, r24
    41e2:	12 97       	sbiw	r26, 0x02	; 2
    41e4:	ed 81       	ldd	r30, Y+5	; 0x05
    41e6:	fe 81       	ldd	r31, Y+6	; 0x06
    41e8:	21 81       	ldd	r18, Z+1	; 0x01
    41ea:	32 81       	ldd	r19, Z+2	; 0x02
    41ec:	8e 85       	ldd	r24, Y+14	; 0x0e
    41ee:	9f 85       	ldd	r25, Y+15	; 0x0f
    41f0:	02 96       	adiw	r24, 0x02	; 2
    41f2:	28 17       	cp	r18, r24
    41f4:	39 07       	cpc	r19, r25
    41f6:	41 f4       	brne	.+16     	; 0x4208 <xTaskIncrementTick+0x146>
    41f8:	ee 85       	ldd	r30, Y+14	; 0x0e
    41fa:	ff 85       	ldd	r31, Y+15	; 0x0f
    41fc:	86 81       	ldd	r24, Z+6	; 0x06
    41fe:	97 81       	ldd	r25, Z+7	; 0x07
    4200:	ed 81       	ldd	r30, Y+5	; 0x05
    4202:	fe 81       	ldd	r31, Y+6	; 0x06
    4204:	92 83       	std	Z+2, r25	; 0x02
    4206:	81 83       	std	Z+1, r24	; 0x01
    4208:	ee 85       	ldd	r30, Y+14	; 0x0e
    420a:	ff 85       	ldd	r31, Y+15	; 0x0f
    420c:	13 86       	std	Z+11, r1	; 0x0b
    420e:	12 86       	std	Z+10, r1	; 0x0a
    4210:	ed 81       	ldd	r30, Y+5	; 0x05
    4212:	fe 81       	ldd	r31, Y+6	; 0x06
    4214:	80 81       	ld	r24, Z
    4216:	81 50       	subi	r24, 0x01	; 1
    4218:	ed 81       	ldd	r30, Y+5	; 0x05
    421a:	fe 81       	ldd	r31, Y+6	; 0x06
    421c:	80 83       	st	Z, r24

                    /* Is the task waiting on an event also?  If so remove
                     * it from the event list. */
                    if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    421e:	ee 85       	ldd	r30, Y+14	; 0x0e
    4220:	ff 85       	ldd	r31, Y+15	; 0x0f
    4222:	84 89       	ldd	r24, Z+20	; 0x14
    4224:	95 89       	ldd	r25, Z+21	; 0x15
    4226:	00 97       	sbiw	r24, 0x00	; 0
    4228:	d9 f1       	breq	.+118    	; 0x42a0 <xTaskIncrementTick+0x1de>
                    {
                        listREMOVE_ITEM( &( pxTCB->xEventListItem ) );
    422a:	ee 85       	ldd	r30, Y+14	; 0x0e
    422c:	ff 85       	ldd	r31, Y+15	; 0x0f
    422e:	84 89       	ldd	r24, Z+20	; 0x14
    4230:	95 89       	ldd	r25, Z+21	; 0x15
    4232:	9c 83       	std	Y+4, r25	; 0x04
    4234:	8b 83       	std	Y+3, r24	; 0x03
    4236:	ee 85       	ldd	r30, Y+14	; 0x0e
    4238:	ff 85       	ldd	r31, Y+15	; 0x0f
    423a:	a6 85       	ldd	r26, Z+14	; 0x0e
    423c:	b7 85       	ldd	r27, Z+15	; 0x0f
    423e:	ee 85       	ldd	r30, Y+14	; 0x0e
    4240:	ff 85       	ldd	r31, Y+15	; 0x0f
    4242:	80 89       	ldd	r24, Z+16	; 0x10
    4244:	91 89       	ldd	r25, Z+17	; 0x11
    4246:	15 96       	adiw	r26, 0x05	; 5
    4248:	9c 93       	st	X, r25
    424a:	8e 93       	st	-X, r24
    424c:	14 97       	sbiw	r26, 0x04	; 4
    424e:	ee 85       	ldd	r30, Y+14	; 0x0e
    4250:	ff 85       	ldd	r31, Y+15	; 0x0f
    4252:	a0 89       	ldd	r26, Z+16	; 0x10
    4254:	b1 89       	ldd	r27, Z+17	; 0x11
    4256:	ee 85       	ldd	r30, Y+14	; 0x0e
    4258:	ff 85       	ldd	r31, Y+15	; 0x0f
    425a:	86 85       	ldd	r24, Z+14	; 0x0e
    425c:	97 85       	ldd	r25, Z+15	; 0x0f
    425e:	13 96       	adiw	r26, 0x03	; 3
    4260:	9c 93       	st	X, r25
    4262:	8e 93       	st	-X, r24
    4264:	12 97       	sbiw	r26, 0x02	; 2
    4266:	eb 81       	ldd	r30, Y+3	; 0x03
    4268:	fc 81       	ldd	r31, Y+4	; 0x04
    426a:	21 81       	ldd	r18, Z+1	; 0x01
    426c:	32 81       	ldd	r19, Z+2	; 0x02
    426e:	8e 85       	ldd	r24, Y+14	; 0x0e
    4270:	9f 85       	ldd	r25, Y+15	; 0x0f
    4272:	0c 96       	adiw	r24, 0x0c	; 12
    4274:	28 17       	cp	r18, r24
    4276:	39 07       	cpc	r19, r25
    4278:	41 f4       	brne	.+16     	; 0x428a <xTaskIncrementTick+0x1c8>
    427a:	ee 85       	ldd	r30, Y+14	; 0x0e
    427c:	ff 85       	ldd	r31, Y+15	; 0x0f
    427e:	80 89       	ldd	r24, Z+16	; 0x10
    4280:	91 89       	ldd	r25, Z+17	; 0x11
    4282:	eb 81       	ldd	r30, Y+3	; 0x03
    4284:	fc 81       	ldd	r31, Y+4	; 0x04
    4286:	92 83       	std	Z+2, r25	; 0x02
    4288:	81 83       	std	Z+1, r24	; 0x01
    428a:	ee 85       	ldd	r30, Y+14	; 0x0e
    428c:	ff 85       	ldd	r31, Y+15	; 0x0f
    428e:	15 8a       	std	Z+21, r1	; 0x15
    4290:	14 8a       	std	Z+20, r1	; 0x14
    4292:	eb 81       	ldd	r30, Y+3	; 0x03
    4294:	fc 81       	ldd	r31, Y+4	; 0x04
    4296:	80 81       	ld	r24, Z
    4298:	81 50       	subi	r24, 0x01	; 1
    429a:	eb 81       	ldd	r30, Y+3	; 0x03
    429c:	fc 81       	ldd	r31, Y+4	; 0x04
    429e:	80 83       	st	Z, r24
                        mtCOVERAGE_TEST_MARKER();
                    }

                    /* Place the unblocked task into the appropriate ready
                     * list. */
                    prvAddTaskToReadyList( pxTCB );
    42a0:	ee 85       	ldd	r30, Y+14	; 0x0e
    42a2:	ff 85       	ldd	r31, Y+15	; 0x0f
    42a4:	96 89       	ldd	r25, Z+22	; 0x16
    42a6:	80 91 70 08 	lds	r24, 0x0870
    42aa:	89 17       	cp	r24, r25
    42ac:	28 f4       	brcc	.+10     	; 0x42b8 <xTaskIncrementTick+0x1f6>
    42ae:	ee 85       	ldd	r30, Y+14	; 0x0e
    42b0:	ff 85       	ldd	r31, Y+15	; 0x0f
    42b2:	86 89       	ldd	r24, Z+22	; 0x16
    42b4:	80 93 70 08 	sts	0x0870, r24
    42b8:	ee 85       	ldd	r30, Y+14	; 0x0e
    42ba:	ff 85       	ldd	r31, Y+15	; 0x0f
    42bc:	86 89       	ldd	r24, Z+22	; 0x16
    42be:	28 2f       	mov	r18, r24
    42c0:	30 e0       	ldi	r19, 0x00	; 0
    42c2:	c9 01       	movw	r24, r18
    42c4:	88 0f       	add	r24, r24
    42c6:	99 1f       	adc	r25, r25
    42c8:	88 0f       	add	r24, r24
    42ca:	99 1f       	adc	r25, r25
    42cc:	88 0f       	add	r24, r24
    42ce:	99 1f       	adc	r25, r25
    42d0:	82 0f       	add	r24, r18
    42d2:	93 1f       	adc	r25, r19
    42d4:	fc 01       	movw	r30, r24
    42d6:	e4 58       	subi	r30, 0x84	; 132
    42d8:	f7 4f       	sbci	r31, 0xF7	; 247
    42da:	81 81       	ldd	r24, Z+1	; 0x01
    42dc:	92 81       	ldd	r25, Z+2	; 0x02
    42de:	9a 83       	std	Y+2, r25	; 0x02
    42e0:	89 83       	std	Y+1, r24	; 0x01
    42e2:	ee 85       	ldd	r30, Y+14	; 0x0e
    42e4:	ff 85       	ldd	r31, Y+15	; 0x0f
    42e6:	89 81       	ldd	r24, Y+1	; 0x01
    42e8:	9a 81       	ldd	r25, Y+2	; 0x02
    42ea:	95 83       	std	Z+5, r25	; 0x05
    42ec:	84 83       	std	Z+4, r24	; 0x04
    42ee:	e9 81       	ldd	r30, Y+1	; 0x01
    42f0:	fa 81       	ldd	r31, Y+2	; 0x02
    42f2:	84 81       	ldd	r24, Z+4	; 0x04
    42f4:	95 81       	ldd	r25, Z+5	; 0x05
    42f6:	ee 85       	ldd	r30, Y+14	; 0x0e
    42f8:	ff 85       	ldd	r31, Y+15	; 0x0f
    42fa:	97 83       	std	Z+7, r25	; 0x07
    42fc:	86 83       	std	Z+6, r24	; 0x06
    42fe:	e9 81       	ldd	r30, Y+1	; 0x01
    4300:	fa 81       	ldd	r31, Y+2	; 0x02
    4302:	04 80       	ldd	r0, Z+4	; 0x04
    4304:	f5 81       	ldd	r31, Z+5	; 0x05
    4306:	e0 2d       	mov	r30, r0
    4308:	8e 85       	ldd	r24, Y+14	; 0x0e
    430a:	9f 85       	ldd	r25, Y+15	; 0x0f
    430c:	02 96       	adiw	r24, 0x02	; 2
    430e:	93 83       	std	Z+3, r25	; 0x03
    4310:	82 83       	std	Z+2, r24	; 0x02
    4312:	8e 85       	ldd	r24, Y+14	; 0x0e
    4314:	9f 85       	ldd	r25, Y+15	; 0x0f
    4316:	02 96       	adiw	r24, 0x02	; 2
    4318:	e9 81       	ldd	r30, Y+1	; 0x01
    431a:	fa 81       	ldd	r31, Y+2	; 0x02
    431c:	95 83       	std	Z+5, r25	; 0x05
    431e:	84 83       	std	Z+4, r24	; 0x04
    4320:	ee 85       	ldd	r30, Y+14	; 0x0e
    4322:	ff 85       	ldd	r31, Y+15	; 0x0f
    4324:	86 89       	ldd	r24, Z+22	; 0x16
    4326:	28 2f       	mov	r18, r24
    4328:	30 e0       	ldi	r19, 0x00	; 0
    432a:	c9 01       	movw	r24, r18
    432c:	88 0f       	add	r24, r24
    432e:	99 1f       	adc	r25, r25
    4330:	88 0f       	add	r24, r24
    4332:	99 1f       	adc	r25, r25
    4334:	88 0f       	add	r24, r24
    4336:	99 1f       	adc	r25, r25
    4338:	82 0f       	add	r24, r18
    433a:	93 1f       	adc	r25, r19
    433c:	84 58       	subi	r24, 0x84	; 132
    433e:	97 4f       	sbci	r25, 0xF7	; 247
    4340:	ee 85       	ldd	r30, Y+14	; 0x0e
    4342:	ff 85       	ldd	r31, Y+15	; 0x0f
    4344:	93 87       	std	Z+11, r25	; 0x0b
    4346:	82 87       	std	Z+10, r24	; 0x0a
    4348:	ee 85       	ldd	r30, Y+14	; 0x0e
    434a:	ff 85       	ldd	r31, Y+15	; 0x0f
    434c:	86 89       	ldd	r24, Z+22	; 0x16
    434e:	28 2f       	mov	r18, r24
    4350:	30 e0       	ldi	r19, 0x00	; 0
    4352:	c9 01       	movw	r24, r18
    4354:	88 0f       	add	r24, r24
    4356:	99 1f       	adc	r25, r25
    4358:	88 0f       	add	r24, r24
    435a:	99 1f       	adc	r25, r25
    435c:	88 0f       	add	r24, r24
    435e:	99 1f       	adc	r25, r25
    4360:	82 0f       	add	r24, r18
    4362:	93 1f       	adc	r25, r19
    4364:	fc 01       	movw	r30, r24
    4366:	e4 58       	subi	r30, 0x84	; 132
    4368:	f7 4f       	sbci	r31, 0xF7	; 247
    436a:	80 81       	ld	r24, Z
    436c:	8f 5f       	subi	r24, 0xFF	; 255
    436e:	80 83       	st	Z, r24
                        {
                            /* Preemption is on, but a context switch should
                             * only be performed if the unblocked task has a
                             * priority that is equal to or higher than the
                             * currently executing task. */
                            if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    4370:	ee 85       	ldd	r30, Y+14	; 0x0e
    4372:	ff 85       	ldd	r31, Y+15	; 0x0f
    4374:	96 89       	ldd	r25, Z+22	; 0x16
    4376:	e0 91 6a 08 	lds	r30, 0x086A
    437a:	f0 91 6b 08 	lds	r31, 0x086B
    437e:	86 89       	ldd	r24, Z+22	; 0x16
    4380:	98 17       	cp	r25, r24
    4382:	08 f4       	brcc	.+2      	; 0x4386 <xTaskIncrementTick+0x2c4>
    4384:	e4 ce       	rjmp	.-568    	; 0x414e <xTaskIncrementTick+0x8c>
                            {
                                xSwitchRequired = pdTRUE;
    4386:	81 e0       	ldi	r24, 0x01	; 1
    4388:	8b 87       	std	Y+11, r24	; 0x0b
    438a:	e1 ce       	rjmp	.-574    	; 0x414e <xTaskIncrementTick+0x8c>
        /* Tasks of equal priority to the currently running task will share
         * processing time (time slice) if preemption is on, and the application
         * writer has not explicitly turned time slicing off. */
        #if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
            {
                if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
    438c:	e0 91 6a 08 	lds	r30, 0x086A
    4390:	f0 91 6b 08 	lds	r31, 0x086B
    4394:	86 89       	ldd	r24, Z+22	; 0x16
    4396:	28 2f       	mov	r18, r24
    4398:	30 e0       	ldi	r19, 0x00	; 0
    439a:	c9 01       	movw	r24, r18
    439c:	88 0f       	add	r24, r24
    439e:	99 1f       	adc	r25, r25
    43a0:	88 0f       	add	r24, r24
    43a2:	99 1f       	adc	r25, r25
    43a4:	88 0f       	add	r24, r24
    43a6:	99 1f       	adc	r25, r25
    43a8:	82 0f       	add	r24, r18
    43aa:	93 1f       	adc	r25, r19
    43ac:	fc 01       	movw	r30, r24
    43ae:	e4 58       	subi	r30, 0x84	; 132
    43b0:	f7 4f       	sbci	r31, 0xF7	; 247
    43b2:	80 81       	ld	r24, Z
    43b4:	82 30       	cpi	r24, 0x02	; 2
    43b6:	10 f0       	brcs	.+4      	; 0x43bc <xTaskIncrementTick+0x2fa>
                {
                    xSwitchRequired = pdTRUE;
    43b8:	81 e0       	ldi	r24, 0x01	; 1
    43ba:	8b 87       	std	Y+11, r24	; 0x0b
            }
        #endif /* configUSE_TICK_HOOK */

        #if ( configUSE_PREEMPTION == 1 )
            {
                if( xYieldPending != pdFALSE )
    43bc:	80 91 74 08 	lds	r24, 0x0874
    43c0:	88 23       	and	r24, r24
    43c2:	61 f0       	breq	.+24     	; 0x43dc <xTaskIncrementTick+0x31a>
                {
                    xSwitchRequired = pdTRUE;
    43c4:	81 e0       	ldi	r24, 0x01	; 1
    43c6:	8b 87       	std	Y+11, r24	; 0x0b
    43c8:	09 c0       	rjmp	.+18     	; 0x43dc <xTaskIncrementTick+0x31a>
            }
        #endif /* configUSE_PREEMPTION */
    }
    else
    {
        ++xPendedTicks;
    43ca:	80 91 72 08 	lds	r24, 0x0872
    43ce:	90 91 73 08 	lds	r25, 0x0873
    43d2:	01 96       	adiw	r24, 0x01	; 1
    43d4:	90 93 73 08 	sts	0x0873, r25
    43d8:	80 93 72 08 	sts	0x0872, r24
                vApplicationTickHook();
            }
        #endif
    }

    return xSwitchRequired;
    43dc:	8b 85       	ldd	r24, Y+11	; 0x0b
}
    43de:	2f 96       	adiw	r28, 0x0f	; 15
    43e0:	0f b6       	in	r0, 0x3f	; 63
    43e2:	f8 94       	cli
    43e4:	de bf       	out	0x3e, r29	; 62
    43e6:	0f be       	out	0x3f, r0	; 63
    43e8:	cd bf       	out	0x3d, r28	; 61
    43ea:	cf 91       	pop	r28
    43ec:	df 91       	pop	r29
    43ee:	08 95       	ret

000043f0 <vTaskSwitchContext>:

#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
    43f0:	df 93       	push	r29
    43f2:	cf 93       	push	r28
    43f4:	00 d0       	rcall	.+0      	; 0x43f6 <vTaskSwitchContext+0x6>
    43f6:	0f 92       	push	r0
    43f8:	cd b7       	in	r28, 0x3d	; 61
    43fa:	de b7       	in	r29, 0x3e	; 62
    if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
    43fc:	80 91 7b 08 	lds	r24, 0x087B
    4400:	88 23       	and	r24, r24
    4402:	21 f0       	breq	.+8      	; 0x440c <vTaskSwitchContext+0x1c>
    {
        /* The scheduler is currently suspended - do not allow a context
         * switch. */
        xYieldPending = pdTRUE;
    4404:	81 e0       	ldi	r24, 0x01	; 1
    4406:	80 93 74 08 	sts	0x0874, r24
    440a:	59 c0       	rjmp	.+178    	; 0x44be <vTaskSwitchContext+0xce>
    }
    else
    {
        xYieldPending = pdFALSE;
    440c:	10 92 74 08 	sts	0x0874, r1
            }
        #endif

        /* Select a new task to run using either the generic C or port
         * optimised asm code. */
        taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    4410:	80 91 70 08 	lds	r24, 0x0870
    4414:	8b 83       	std	Y+3, r24	; 0x03
    4416:	03 c0       	rjmp	.+6      	; 0x441e <vTaskSwitchContext+0x2e>
    4418:	8b 81       	ldd	r24, Y+3	; 0x03
    441a:	81 50       	subi	r24, 0x01	; 1
    441c:	8b 83       	std	Y+3, r24	; 0x03
    441e:	8b 81       	ldd	r24, Y+3	; 0x03
    4420:	28 2f       	mov	r18, r24
    4422:	30 e0       	ldi	r19, 0x00	; 0
    4424:	c9 01       	movw	r24, r18
    4426:	88 0f       	add	r24, r24
    4428:	99 1f       	adc	r25, r25
    442a:	88 0f       	add	r24, r24
    442c:	99 1f       	adc	r25, r25
    442e:	88 0f       	add	r24, r24
    4430:	99 1f       	adc	r25, r25
    4432:	82 0f       	add	r24, r18
    4434:	93 1f       	adc	r25, r19
    4436:	fc 01       	movw	r30, r24
    4438:	e4 58       	subi	r30, 0x84	; 132
    443a:	f7 4f       	sbci	r31, 0xF7	; 247
    443c:	80 81       	ld	r24, Z
    443e:	88 23       	and	r24, r24
    4440:	59 f3       	breq	.-42     	; 0x4418 <vTaskSwitchContext+0x28>
    4442:	8b 81       	ldd	r24, Y+3	; 0x03
    4444:	28 2f       	mov	r18, r24
    4446:	30 e0       	ldi	r19, 0x00	; 0
    4448:	c9 01       	movw	r24, r18
    444a:	88 0f       	add	r24, r24
    444c:	99 1f       	adc	r25, r25
    444e:	88 0f       	add	r24, r24
    4450:	99 1f       	adc	r25, r25
    4452:	88 0f       	add	r24, r24
    4454:	99 1f       	adc	r25, r25
    4456:	82 0f       	add	r24, r18
    4458:	93 1f       	adc	r25, r19
    445a:	84 58       	subi	r24, 0x84	; 132
    445c:	97 4f       	sbci	r25, 0xF7	; 247
    445e:	9a 83       	std	Y+2, r25	; 0x02
    4460:	89 83       	std	Y+1, r24	; 0x01
    4462:	e9 81       	ldd	r30, Y+1	; 0x01
    4464:	fa 81       	ldd	r31, Y+2	; 0x02
    4466:	01 80       	ldd	r0, Z+1	; 0x01
    4468:	f2 81       	ldd	r31, Z+2	; 0x02
    446a:	e0 2d       	mov	r30, r0
    446c:	82 81       	ldd	r24, Z+2	; 0x02
    446e:	93 81       	ldd	r25, Z+3	; 0x03
    4470:	e9 81       	ldd	r30, Y+1	; 0x01
    4472:	fa 81       	ldd	r31, Y+2	; 0x02
    4474:	92 83       	std	Z+2, r25	; 0x02
    4476:	81 83       	std	Z+1, r24	; 0x01
    4478:	e9 81       	ldd	r30, Y+1	; 0x01
    447a:	fa 81       	ldd	r31, Y+2	; 0x02
    447c:	21 81       	ldd	r18, Z+1	; 0x01
    447e:	32 81       	ldd	r19, Z+2	; 0x02
    4480:	89 81       	ldd	r24, Y+1	; 0x01
    4482:	9a 81       	ldd	r25, Y+2	; 0x02
    4484:	03 96       	adiw	r24, 0x03	; 3
    4486:	28 17       	cp	r18, r24
    4488:	39 07       	cpc	r19, r25
    448a:	59 f4       	brne	.+22     	; 0x44a2 <vTaskSwitchContext+0xb2>
    448c:	e9 81       	ldd	r30, Y+1	; 0x01
    448e:	fa 81       	ldd	r31, Y+2	; 0x02
    4490:	01 80       	ldd	r0, Z+1	; 0x01
    4492:	f2 81       	ldd	r31, Z+2	; 0x02
    4494:	e0 2d       	mov	r30, r0
    4496:	82 81       	ldd	r24, Z+2	; 0x02
    4498:	93 81       	ldd	r25, Z+3	; 0x03
    449a:	e9 81       	ldd	r30, Y+1	; 0x01
    449c:	fa 81       	ldd	r31, Y+2	; 0x02
    449e:	92 83       	std	Z+2, r25	; 0x02
    44a0:	81 83       	std	Z+1, r24	; 0x01
    44a2:	e9 81       	ldd	r30, Y+1	; 0x01
    44a4:	fa 81       	ldd	r31, Y+2	; 0x02
    44a6:	01 80       	ldd	r0, Z+1	; 0x01
    44a8:	f2 81       	ldd	r31, Z+2	; 0x02
    44aa:	e0 2d       	mov	r30, r0
    44ac:	86 81       	ldd	r24, Z+6	; 0x06
    44ae:	97 81       	ldd	r25, Z+7	; 0x07
    44b0:	90 93 6b 08 	sts	0x086B, r25
    44b4:	80 93 6a 08 	sts	0x086A, r24
    44b8:	8b 81       	ldd	r24, Y+3	; 0x03
    44ba:	80 93 70 08 	sts	0x0870, r24
                 * for additional information. */
                _impure_ptr = &( pxCurrentTCB->xNewLib_reent );
            }
        #endif /* configUSE_NEWLIB_REENTRANT */
    }
}
    44be:	0f 90       	pop	r0
    44c0:	0f 90       	pop	r0
    44c2:	0f 90       	pop	r0
    44c4:	cf 91       	pop	r28
    44c6:	df 91       	pop	r29
    44c8:	08 95       	ret

000044ca <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList,
                            const TickType_t xTicksToWait )
{
    44ca:	df 93       	push	r29
    44cc:	cf 93       	push	r28
    44ce:	00 d0       	rcall	.+0      	; 0x44d0 <vTaskPlaceOnEventList+0x6>
    44d0:	00 d0       	rcall	.+0      	; 0x44d2 <vTaskPlaceOnEventList+0x8>
    44d2:	cd b7       	in	r28, 0x3d	; 61
    44d4:	de b7       	in	r29, 0x3e	; 62
    44d6:	9a 83       	std	Y+2, r25	; 0x02
    44d8:	89 83       	std	Y+1, r24	; 0x01
    44da:	7c 83       	std	Y+4, r23	; 0x04
    44dc:	6b 83       	std	Y+3, r22	; 0x03
     *      xItemValue = ( configMAX_PRIORITIES - uxPriority )
     * Therefore, the event list is sorted in descending priority order.
     *
     * The queue that contains the event list is locked, preventing
     * simultaneous access from interrupts. */
    vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    44de:	80 91 6a 08 	lds	r24, 0x086A
    44e2:	90 91 6b 08 	lds	r25, 0x086B
    44e6:	9c 01       	movw	r18, r24
    44e8:	24 5f       	subi	r18, 0xF4	; 244
    44ea:	3f 4f       	sbci	r19, 0xFF	; 255
    44ec:	89 81       	ldd	r24, Y+1	; 0x01
    44ee:	9a 81       	ldd	r25, Y+2	; 0x02
    44f0:	b9 01       	movw	r22, r18
    44f2:	0e 94 29 11 	call	0x2252	; 0x2252 <vListInsert>

    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    44f6:	8b 81       	ldd	r24, Y+3	; 0x03
    44f8:	9c 81       	ldd	r25, Y+4	; 0x04
    44fa:	61 e0       	ldi	r22, 0x01	; 1
    44fc:	0e 94 c1 2e 	call	0x5d82	; 0x5d82 <prvAddCurrentTaskToDelayedList>
}
    4500:	0f 90       	pop	r0
    4502:	0f 90       	pop	r0
    4504:	0f 90       	pop	r0
    4506:	0f 90       	pop	r0
    4508:	cf 91       	pop	r28
    450a:	df 91       	pop	r29
    450c:	08 95       	ret

0000450e <vTaskPlaceOnUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnUnorderedEventList( List_t * pxEventList,
                                     const TickType_t xItemValue,
                                     const TickType_t xTicksToWait )
{
    450e:	df 93       	push	r29
    4510:	cf 93       	push	r28
    4512:	cd b7       	in	r28, 0x3d	; 61
    4514:	de b7       	in	r29, 0x3e	; 62
    4516:	28 97       	sbiw	r28, 0x08	; 8
    4518:	0f b6       	in	r0, 0x3f	; 63
    451a:	f8 94       	cli
    451c:	de bf       	out	0x3e, r29	; 62
    451e:	0f be       	out	0x3f, r0	; 63
    4520:	cd bf       	out	0x3d, r28	; 61
    4522:	9c 83       	std	Y+4, r25	; 0x04
    4524:	8b 83       	std	Y+3, r24	; 0x03
    4526:	7e 83       	std	Y+6, r23	; 0x06
    4528:	6d 83       	std	Y+5, r22	; 0x05
    452a:	58 87       	std	Y+8, r21	; 0x08
    452c:	4f 83       	std	Y+7, r20	; 0x07
    configASSERT( uxSchedulerSuspended != 0 );

    /* Store the item value in the event list item.  It is safe to access the
     * event list item here as interrupts won't access the event list item of a
     * task that is not in the Blocked state. */
    listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    452e:	e0 91 6a 08 	lds	r30, 0x086A
    4532:	f0 91 6b 08 	lds	r31, 0x086B
    4536:	8d 81       	ldd	r24, Y+5	; 0x05
    4538:	9e 81       	ldd	r25, Y+6	; 0x06
    453a:	90 68       	ori	r25, 0x80	; 128
    453c:	95 87       	std	Z+13, r25	; 0x0d
    453e:	84 87       	std	Z+12, r24	; 0x0c
    /* Place the event list item of the TCB at the end of the appropriate event
     * list.  It is safe to access the event list here because it is part of an
     * event group implementation - and interrupts don't access event groups
     * directly (instead they access them indirectly by pending function calls to
     * the task level). */
    listINSERT_END( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    4540:	eb 81       	ldd	r30, Y+3	; 0x03
    4542:	fc 81       	ldd	r31, Y+4	; 0x04
    4544:	81 81       	ldd	r24, Z+1	; 0x01
    4546:	92 81       	ldd	r25, Z+2	; 0x02
    4548:	9a 83       	std	Y+2, r25	; 0x02
    454a:	89 83       	std	Y+1, r24	; 0x01
    454c:	e0 91 6a 08 	lds	r30, 0x086A
    4550:	f0 91 6b 08 	lds	r31, 0x086B
    4554:	89 81       	ldd	r24, Y+1	; 0x01
    4556:	9a 81       	ldd	r25, Y+2	; 0x02
    4558:	97 87       	std	Z+15, r25	; 0x0f
    455a:	86 87       	std	Z+14, r24	; 0x0e
    455c:	a0 91 6a 08 	lds	r26, 0x086A
    4560:	b0 91 6b 08 	lds	r27, 0x086B
    4564:	e9 81       	ldd	r30, Y+1	; 0x01
    4566:	fa 81       	ldd	r31, Y+2	; 0x02
    4568:	84 81       	ldd	r24, Z+4	; 0x04
    456a:	95 81       	ldd	r25, Z+5	; 0x05
    456c:	51 96       	adiw	r26, 0x11	; 17
    456e:	9c 93       	st	X, r25
    4570:	8e 93       	st	-X, r24
    4572:	50 97       	sbiw	r26, 0x10	; 16
    4574:	e9 81       	ldd	r30, Y+1	; 0x01
    4576:	fa 81       	ldd	r31, Y+2	; 0x02
    4578:	04 80       	ldd	r0, Z+4	; 0x04
    457a:	f5 81       	ldd	r31, Z+5	; 0x05
    457c:	e0 2d       	mov	r30, r0
    457e:	80 91 6a 08 	lds	r24, 0x086A
    4582:	90 91 6b 08 	lds	r25, 0x086B
    4586:	0c 96       	adiw	r24, 0x0c	; 12
    4588:	93 83       	std	Z+3, r25	; 0x03
    458a:	82 83       	std	Z+2, r24	; 0x02
    458c:	80 91 6a 08 	lds	r24, 0x086A
    4590:	90 91 6b 08 	lds	r25, 0x086B
    4594:	0c 96       	adiw	r24, 0x0c	; 12
    4596:	e9 81       	ldd	r30, Y+1	; 0x01
    4598:	fa 81       	ldd	r31, Y+2	; 0x02
    459a:	95 83       	std	Z+5, r25	; 0x05
    459c:	84 83       	std	Z+4, r24	; 0x04
    459e:	e0 91 6a 08 	lds	r30, 0x086A
    45a2:	f0 91 6b 08 	lds	r31, 0x086B
    45a6:	8b 81       	ldd	r24, Y+3	; 0x03
    45a8:	9c 81       	ldd	r25, Y+4	; 0x04
    45aa:	95 8b       	std	Z+21, r25	; 0x15
    45ac:	84 8b       	std	Z+20, r24	; 0x14
    45ae:	eb 81       	ldd	r30, Y+3	; 0x03
    45b0:	fc 81       	ldd	r31, Y+4	; 0x04
    45b2:	80 81       	ld	r24, Z
    45b4:	8f 5f       	subi	r24, 0xFF	; 255
    45b6:	eb 81       	ldd	r30, Y+3	; 0x03
    45b8:	fc 81       	ldd	r31, Y+4	; 0x04
    45ba:	80 83       	st	Z, r24

    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    45bc:	8f 81       	ldd	r24, Y+7	; 0x07
    45be:	98 85       	ldd	r25, Y+8	; 0x08
    45c0:	61 e0       	ldi	r22, 0x01	; 1
    45c2:	0e 94 c1 2e 	call	0x5d82	; 0x5d82 <prvAddCurrentTaskToDelayedList>
}
    45c6:	28 96       	adiw	r28, 0x08	; 8
    45c8:	0f b6       	in	r0, 0x3f	; 63
    45ca:	f8 94       	cli
    45cc:	de bf       	out	0x3e, r29	; 62
    45ce:	0f be       	out	0x3f, r0	; 63
    45d0:	cd bf       	out	0x3d, r28	; 61
    45d2:	cf 91       	pop	r28
    45d4:	df 91       	pop	r29
    45d6:	08 95       	ret

000045d8 <vTaskPlaceOnEventListRestricted>:
#if ( configUSE_TIMERS == 1 )

    void vTaskPlaceOnEventListRestricted( List_t * const pxEventList,
                                          TickType_t xTicksToWait,
                                          const BaseType_t xWaitIndefinitely )
    {
    45d8:	df 93       	push	r29
    45da:	cf 93       	push	r28
    45dc:	cd b7       	in	r28, 0x3d	; 61
    45de:	de b7       	in	r29, 0x3e	; 62
    45e0:	27 97       	sbiw	r28, 0x07	; 7
    45e2:	0f b6       	in	r0, 0x3f	; 63
    45e4:	f8 94       	cli
    45e6:	de bf       	out	0x3e, r29	; 62
    45e8:	0f be       	out	0x3f, r0	; 63
    45ea:	cd bf       	out	0x3d, r28	; 61
    45ec:	9c 83       	std	Y+4, r25	; 0x04
    45ee:	8b 83       	std	Y+3, r24	; 0x03
    45f0:	7e 83       	std	Y+6, r23	; 0x06
    45f2:	6d 83       	std	Y+5, r22	; 0x05
    45f4:	4f 83       	std	Y+7, r20	; 0x07

        /* Place the event list item of the TCB in the appropriate event list.
         * In this case it is assume that this is the only task that is going to
         * be waiting on this event list, so the faster vListInsertEnd() function
         * can be used in place of vListInsert. */
        listINSERT_END( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    45f6:	eb 81       	ldd	r30, Y+3	; 0x03
    45f8:	fc 81       	ldd	r31, Y+4	; 0x04
    45fa:	81 81       	ldd	r24, Z+1	; 0x01
    45fc:	92 81       	ldd	r25, Z+2	; 0x02
    45fe:	9a 83       	std	Y+2, r25	; 0x02
    4600:	89 83       	std	Y+1, r24	; 0x01
    4602:	e0 91 6a 08 	lds	r30, 0x086A
    4606:	f0 91 6b 08 	lds	r31, 0x086B
    460a:	89 81       	ldd	r24, Y+1	; 0x01
    460c:	9a 81       	ldd	r25, Y+2	; 0x02
    460e:	97 87       	std	Z+15, r25	; 0x0f
    4610:	86 87       	std	Z+14, r24	; 0x0e
    4612:	a0 91 6a 08 	lds	r26, 0x086A
    4616:	b0 91 6b 08 	lds	r27, 0x086B
    461a:	e9 81       	ldd	r30, Y+1	; 0x01
    461c:	fa 81       	ldd	r31, Y+2	; 0x02
    461e:	84 81       	ldd	r24, Z+4	; 0x04
    4620:	95 81       	ldd	r25, Z+5	; 0x05
    4622:	51 96       	adiw	r26, 0x11	; 17
    4624:	9c 93       	st	X, r25
    4626:	8e 93       	st	-X, r24
    4628:	50 97       	sbiw	r26, 0x10	; 16
    462a:	e9 81       	ldd	r30, Y+1	; 0x01
    462c:	fa 81       	ldd	r31, Y+2	; 0x02
    462e:	04 80       	ldd	r0, Z+4	; 0x04
    4630:	f5 81       	ldd	r31, Z+5	; 0x05
    4632:	e0 2d       	mov	r30, r0
    4634:	80 91 6a 08 	lds	r24, 0x086A
    4638:	90 91 6b 08 	lds	r25, 0x086B
    463c:	0c 96       	adiw	r24, 0x0c	; 12
    463e:	93 83       	std	Z+3, r25	; 0x03
    4640:	82 83       	std	Z+2, r24	; 0x02
    4642:	80 91 6a 08 	lds	r24, 0x086A
    4646:	90 91 6b 08 	lds	r25, 0x086B
    464a:	0c 96       	adiw	r24, 0x0c	; 12
    464c:	e9 81       	ldd	r30, Y+1	; 0x01
    464e:	fa 81       	ldd	r31, Y+2	; 0x02
    4650:	95 83       	std	Z+5, r25	; 0x05
    4652:	84 83       	std	Z+4, r24	; 0x04
    4654:	e0 91 6a 08 	lds	r30, 0x086A
    4658:	f0 91 6b 08 	lds	r31, 0x086B
    465c:	8b 81       	ldd	r24, Y+3	; 0x03
    465e:	9c 81       	ldd	r25, Y+4	; 0x04
    4660:	95 8b       	std	Z+21, r25	; 0x15
    4662:	84 8b       	std	Z+20, r24	; 0x14
    4664:	eb 81       	ldd	r30, Y+3	; 0x03
    4666:	fc 81       	ldd	r31, Y+4	; 0x04
    4668:	80 81       	ld	r24, Z
    466a:	8f 5f       	subi	r24, 0xFF	; 255
    466c:	eb 81       	ldd	r30, Y+3	; 0x03
    466e:	fc 81       	ldd	r31, Y+4	; 0x04
    4670:	80 83       	st	Z, r24

        /* If the task should block indefinitely then set the block time to a
         * value that will be recognised as an indefinite delay inside the
         * prvAddCurrentTaskToDelayedList() function. */
        if( xWaitIndefinitely != pdFALSE )
    4672:	8f 81       	ldd	r24, Y+7	; 0x07
    4674:	88 23       	and	r24, r24
    4676:	21 f0       	breq	.+8      	; 0x4680 <vTaskPlaceOnEventListRestricted+0xa8>
        {
            xTicksToWait = portMAX_DELAY;
    4678:	8f ef       	ldi	r24, 0xFF	; 255
    467a:	9f ef       	ldi	r25, 0xFF	; 255
    467c:	9e 83       	std	Y+6, r25	; 0x06
    467e:	8d 83       	std	Y+5, r24	; 0x05
        }

        traceTASK_DELAY_UNTIL( ( xTickCount + xTicksToWait ) );
        prvAddCurrentTaskToDelayedList( xTicksToWait, xWaitIndefinitely );
    4680:	8d 81       	ldd	r24, Y+5	; 0x05
    4682:	9e 81       	ldd	r25, Y+6	; 0x06
    4684:	6f 81       	ldd	r22, Y+7	; 0x07
    4686:	0e 94 c1 2e 	call	0x5d82	; 0x5d82 <prvAddCurrentTaskToDelayedList>
    }
    468a:	27 96       	adiw	r28, 0x07	; 7
    468c:	0f b6       	in	r0, 0x3f	; 63
    468e:	f8 94       	cli
    4690:	de bf       	out	0x3e, r29	; 62
    4692:	0f be       	out	0x3f, r0	; 63
    4694:	cd bf       	out	0x3d, r28	; 61
    4696:	cf 91       	pop	r28
    4698:	df 91       	pop	r29
    469a:	08 95       	ret

0000469c <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
    469c:	df 93       	push	r29
    469e:	cf 93       	push	r28
    46a0:	cd b7       	in	r28, 0x3d	; 61
    46a2:	de b7       	in	r29, 0x3e	; 62
    46a4:	2d 97       	sbiw	r28, 0x0d	; 13
    46a6:	0f b6       	in	r0, 0x3f	; 63
    46a8:	f8 94       	cli
    46aa:	de bf       	out	0x3e, r29	; 62
    46ac:	0f be       	out	0x3f, r0	; 63
    46ae:	cd bf       	out	0x3d, r28	; 61
    46b0:	9d 87       	std	Y+13, r25	; 0x0d
    46b2:	8c 87       	std	Y+12, r24	; 0x0c
     * get called - the lock count on the queue will get modified instead.  This
     * means exclusive access to the event list is guaranteed here.
     *
     * This function assumes that a check has already been made to ensure that
     * pxEventList is not empty. */
    pxUnblockedTCB = listGET_OWNER_OF_HEAD_ENTRY( pxEventList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    46b4:	ec 85       	ldd	r30, Y+12	; 0x0c
    46b6:	fd 85       	ldd	r31, Y+13	; 0x0d
    46b8:	05 80       	ldd	r0, Z+5	; 0x05
    46ba:	f6 81       	ldd	r31, Z+6	; 0x06
    46bc:	e0 2d       	mov	r30, r0
    46be:	86 81       	ldd	r24, Z+6	; 0x06
    46c0:	97 81       	ldd	r25, Z+7	; 0x07
    46c2:	9b 87       	std	Y+11, r25	; 0x0b
    46c4:	8a 87       	std	Y+10, r24	; 0x0a
    configASSERT( pxUnblockedTCB );
    listREMOVE_ITEM( &( pxUnblockedTCB->xEventListItem ) );
    46c6:	ea 85       	ldd	r30, Y+10	; 0x0a
    46c8:	fb 85       	ldd	r31, Y+11	; 0x0b
    46ca:	84 89       	ldd	r24, Z+20	; 0x14
    46cc:	95 89       	ldd	r25, Z+21	; 0x15
    46ce:	98 87       	std	Y+8, r25	; 0x08
    46d0:	8f 83       	std	Y+7, r24	; 0x07
    46d2:	ea 85       	ldd	r30, Y+10	; 0x0a
    46d4:	fb 85       	ldd	r31, Y+11	; 0x0b
    46d6:	a6 85       	ldd	r26, Z+14	; 0x0e
    46d8:	b7 85       	ldd	r27, Z+15	; 0x0f
    46da:	ea 85       	ldd	r30, Y+10	; 0x0a
    46dc:	fb 85       	ldd	r31, Y+11	; 0x0b
    46de:	80 89       	ldd	r24, Z+16	; 0x10
    46e0:	91 89       	ldd	r25, Z+17	; 0x11
    46e2:	15 96       	adiw	r26, 0x05	; 5
    46e4:	9c 93       	st	X, r25
    46e6:	8e 93       	st	-X, r24
    46e8:	14 97       	sbiw	r26, 0x04	; 4
    46ea:	ea 85       	ldd	r30, Y+10	; 0x0a
    46ec:	fb 85       	ldd	r31, Y+11	; 0x0b
    46ee:	a0 89       	ldd	r26, Z+16	; 0x10
    46f0:	b1 89       	ldd	r27, Z+17	; 0x11
    46f2:	ea 85       	ldd	r30, Y+10	; 0x0a
    46f4:	fb 85       	ldd	r31, Y+11	; 0x0b
    46f6:	86 85       	ldd	r24, Z+14	; 0x0e
    46f8:	97 85       	ldd	r25, Z+15	; 0x0f
    46fa:	13 96       	adiw	r26, 0x03	; 3
    46fc:	9c 93       	st	X, r25
    46fe:	8e 93       	st	-X, r24
    4700:	12 97       	sbiw	r26, 0x02	; 2
    4702:	ef 81       	ldd	r30, Y+7	; 0x07
    4704:	f8 85       	ldd	r31, Y+8	; 0x08
    4706:	21 81       	ldd	r18, Z+1	; 0x01
    4708:	32 81       	ldd	r19, Z+2	; 0x02
    470a:	8a 85       	ldd	r24, Y+10	; 0x0a
    470c:	9b 85       	ldd	r25, Y+11	; 0x0b
    470e:	0c 96       	adiw	r24, 0x0c	; 12
    4710:	28 17       	cp	r18, r24
    4712:	39 07       	cpc	r19, r25
    4714:	41 f4       	brne	.+16     	; 0x4726 <xTaskRemoveFromEventList+0x8a>
    4716:	ea 85       	ldd	r30, Y+10	; 0x0a
    4718:	fb 85       	ldd	r31, Y+11	; 0x0b
    471a:	80 89       	ldd	r24, Z+16	; 0x10
    471c:	91 89       	ldd	r25, Z+17	; 0x11
    471e:	ef 81       	ldd	r30, Y+7	; 0x07
    4720:	f8 85       	ldd	r31, Y+8	; 0x08
    4722:	92 83       	std	Z+2, r25	; 0x02
    4724:	81 83       	std	Z+1, r24	; 0x01
    4726:	ea 85       	ldd	r30, Y+10	; 0x0a
    4728:	fb 85       	ldd	r31, Y+11	; 0x0b
    472a:	15 8a       	std	Z+21, r1	; 0x15
    472c:	14 8a       	std	Z+20, r1	; 0x14
    472e:	ef 81       	ldd	r30, Y+7	; 0x07
    4730:	f8 85       	ldd	r31, Y+8	; 0x08
    4732:	80 81       	ld	r24, Z
    4734:	81 50       	subi	r24, 0x01	; 1
    4736:	ef 81       	ldd	r30, Y+7	; 0x07
    4738:	f8 85       	ldd	r31, Y+8	; 0x08
    473a:	80 83       	st	Z, r24

    if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    473c:	80 91 7b 08 	lds	r24, 0x087B
    4740:	88 23       	and	r24, r24
    4742:	09 f0       	breq	.+2      	; 0x4746 <xTaskRemoveFromEventList+0xaa>
    4744:	a4 c0       	rjmp	.+328    	; 0x488e <xTaskRemoveFromEventList+0x1f2>
    {
        listREMOVE_ITEM( &( pxUnblockedTCB->xStateListItem ) );
    4746:	ea 85       	ldd	r30, Y+10	; 0x0a
    4748:	fb 85       	ldd	r31, Y+11	; 0x0b
    474a:	82 85       	ldd	r24, Z+10	; 0x0a
    474c:	93 85       	ldd	r25, Z+11	; 0x0b
    474e:	9e 83       	std	Y+6, r25	; 0x06
    4750:	8d 83       	std	Y+5, r24	; 0x05
    4752:	ea 85       	ldd	r30, Y+10	; 0x0a
    4754:	fb 85       	ldd	r31, Y+11	; 0x0b
    4756:	a4 81       	ldd	r26, Z+4	; 0x04
    4758:	b5 81       	ldd	r27, Z+5	; 0x05
    475a:	ea 85       	ldd	r30, Y+10	; 0x0a
    475c:	fb 85       	ldd	r31, Y+11	; 0x0b
    475e:	86 81       	ldd	r24, Z+6	; 0x06
    4760:	97 81       	ldd	r25, Z+7	; 0x07
    4762:	15 96       	adiw	r26, 0x05	; 5
    4764:	9c 93       	st	X, r25
    4766:	8e 93       	st	-X, r24
    4768:	14 97       	sbiw	r26, 0x04	; 4
    476a:	ea 85       	ldd	r30, Y+10	; 0x0a
    476c:	fb 85       	ldd	r31, Y+11	; 0x0b
    476e:	a6 81       	ldd	r26, Z+6	; 0x06
    4770:	b7 81       	ldd	r27, Z+7	; 0x07
    4772:	ea 85       	ldd	r30, Y+10	; 0x0a
    4774:	fb 85       	ldd	r31, Y+11	; 0x0b
    4776:	84 81       	ldd	r24, Z+4	; 0x04
    4778:	95 81       	ldd	r25, Z+5	; 0x05
    477a:	13 96       	adiw	r26, 0x03	; 3
    477c:	9c 93       	st	X, r25
    477e:	8e 93       	st	-X, r24
    4780:	12 97       	sbiw	r26, 0x02	; 2
    4782:	ed 81       	ldd	r30, Y+5	; 0x05
    4784:	fe 81       	ldd	r31, Y+6	; 0x06
    4786:	21 81       	ldd	r18, Z+1	; 0x01
    4788:	32 81       	ldd	r19, Z+2	; 0x02
    478a:	8a 85       	ldd	r24, Y+10	; 0x0a
    478c:	9b 85       	ldd	r25, Y+11	; 0x0b
    478e:	02 96       	adiw	r24, 0x02	; 2
    4790:	28 17       	cp	r18, r24
    4792:	39 07       	cpc	r19, r25
    4794:	41 f4       	brne	.+16     	; 0x47a6 <xTaskRemoveFromEventList+0x10a>
    4796:	ea 85       	ldd	r30, Y+10	; 0x0a
    4798:	fb 85       	ldd	r31, Y+11	; 0x0b
    479a:	86 81       	ldd	r24, Z+6	; 0x06
    479c:	97 81       	ldd	r25, Z+7	; 0x07
    479e:	ed 81       	ldd	r30, Y+5	; 0x05
    47a0:	fe 81       	ldd	r31, Y+6	; 0x06
    47a2:	92 83       	std	Z+2, r25	; 0x02
    47a4:	81 83       	std	Z+1, r24	; 0x01
    47a6:	ea 85       	ldd	r30, Y+10	; 0x0a
    47a8:	fb 85       	ldd	r31, Y+11	; 0x0b
    47aa:	13 86       	std	Z+11, r1	; 0x0b
    47ac:	12 86       	std	Z+10, r1	; 0x0a
    47ae:	ed 81       	ldd	r30, Y+5	; 0x05
    47b0:	fe 81       	ldd	r31, Y+6	; 0x06
    47b2:	80 81       	ld	r24, Z
    47b4:	81 50       	subi	r24, 0x01	; 1
    47b6:	ed 81       	ldd	r30, Y+5	; 0x05
    47b8:	fe 81       	ldd	r31, Y+6	; 0x06
    47ba:	80 83       	st	Z, r24
        prvAddTaskToReadyList( pxUnblockedTCB );
    47bc:	ea 85       	ldd	r30, Y+10	; 0x0a
    47be:	fb 85       	ldd	r31, Y+11	; 0x0b
    47c0:	96 89       	ldd	r25, Z+22	; 0x16
    47c2:	80 91 70 08 	lds	r24, 0x0870
    47c6:	89 17       	cp	r24, r25
    47c8:	28 f4       	brcc	.+10     	; 0x47d4 <xTaskRemoveFromEventList+0x138>
    47ca:	ea 85       	ldd	r30, Y+10	; 0x0a
    47cc:	fb 85       	ldd	r31, Y+11	; 0x0b
    47ce:	86 89       	ldd	r24, Z+22	; 0x16
    47d0:	80 93 70 08 	sts	0x0870, r24
    47d4:	ea 85       	ldd	r30, Y+10	; 0x0a
    47d6:	fb 85       	ldd	r31, Y+11	; 0x0b
    47d8:	86 89       	ldd	r24, Z+22	; 0x16
    47da:	28 2f       	mov	r18, r24
    47dc:	30 e0       	ldi	r19, 0x00	; 0
    47de:	c9 01       	movw	r24, r18
    47e0:	88 0f       	add	r24, r24
    47e2:	99 1f       	adc	r25, r25
    47e4:	88 0f       	add	r24, r24
    47e6:	99 1f       	adc	r25, r25
    47e8:	88 0f       	add	r24, r24
    47ea:	99 1f       	adc	r25, r25
    47ec:	82 0f       	add	r24, r18
    47ee:	93 1f       	adc	r25, r19
    47f0:	fc 01       	movw	r30, r24
    47f2:	e4 58       	subi	r30, 0x84	; 132
    47f4:	f7 4f       	sbci	r31, 0xF7	; 247
    47f6:	81 81       	ldd	r24, Z+1	; 0x01
    47f8:	92 81       	ldd	r25, Z+2	; 0x02
    47fa:	9c 83       	std	Y+4, r25	; 0x04
    47fc:	8b 83       	std	Y+3, r24	; 0x03
    47fe:	ea 85       	ldd	r30, Y+10	; 0x0a
    4800:	fb 85       	ldd	r31, Y+11	; 0x0b
    4802:	8b 81       	ldd	r24, Y+3	; 0x03
    4804:	9c 81       	ldd	r25, Y+4	; 0x04
    4806:	95 83       	std	Z+5, r25	; 0x05
    4808:	84 83       	std	Z+4, r24	; 0x04
    480a:	eb 81       	ldd	r30, Y+3	; 0x03
    480c:	fc 81       	ldd	r31, Y+4	; 0x04
    480e:	84 81       	ldd	r24, Z+4	; 0x04
    4810:	95 81       	ldd	r25, Z+5	; 0x05
    4812:	ea 85       	ldd	r30, Y+10	; 0x0a
    4814:	fb 85       	ldd	r31, Y+11	; 0x0b
    4816:	97 83       	std	Z+7, r25	; 0x07
    4818:	86 83       	std	Z+6, r24	; 0x06
    481a:	eb 81       	ldd	r30, Y+3	; 0x03
    481c:	fc 81       	ldd	r31, Y+4	; 0x04
    481e:	04 80       	ldd	r0, Z+4	; 0x04
    4820:	f5 81       	ldd	r31, Z+5	; 0x05
    4822:	e0 2d       	mov	r30, r0
    4824:	8a 85       	ldd	r24, Y+10	; 0x0a
    4826:	9b 85       	ldd	r25, Y+11	; 0x0b
    4828:	02 96       	adiw	r24, 0x02	; 2
    482a:	93 83       	std	Z+3, r25	; 0x03
    482c:	82 83       	std	Z+2, r24	; 0x02
    482e:	8a 85       	ldd	r24, Y+10	; 0x0a
    4830:	9b 85       	ldd	r25, Y+11	; 0x0b
    4832:	02 96       	adiw	r24, 0x02	; 2
    4834:	eb 81       	ldd	r30, Y+3	; 0x03
    4836:	fc 81       	ldd	r31, Y+4	; 0x04
    4838:	95 83       	std	Z+5, r25	; 0x05
    483a:	84 83       	std	Z+4, r24	; 0x04
    483c:	ea 85       	ldd	r30, Y+10	; 0x0a
    483e:	fb 85       	ldd	r31, Y+11	; 0x0b
    4840:	86 89       	ldd	r24, Z+22	; 0x16
    4842:	28 2f       	mov	r18, r24
    4844:	30 e0       	ldi	r19, 0x00	; 0
    4846:	c9 01       	movw	r24, r18
    4848:	88 0f       	add	r24, r24
    484a:	99 1f       	adc	r25, r25
    484c:	88 0f       	add	r24, r24
    484e:	99 1f       	adc	r25, r25
    4850:	88 0f       	add	r24, r24
    4852:	99 1f       	adc	r25, r25
    4854:	82 0f       	add	r24, r18
    4856:	93 1f       	adc	r25, r19
    4858:	84 58       	subi	r24, 0x84	; 132
    485a:	97 4f       	sbci	r25, 0xF7	; 247
    485c:	ea 85       	ldd	r30, Y+10	; 0x0a
    485e:	fb 85       	ldd	r31, Y+11	; 0x0b
    4860:	93 87       	std	Z+11, r25	; 0x0b
    4862:	82 87       	std	Z+10, r24	; 0x0a
    4864:	ea 85       	ldd	r30, Y+10	; 0x0a
    4866:	fb 85       	ldd	r31, Y+11	; 0x0b
    4868:	86 89       	ldd	r24, Z+22	; 0x16
    486a:	28 2f       	mov	r18, r24
    486c:	30 e0       	ldi	r19, 0x00	; 0
    486e:	c9 01       	movw	r24, r18
    4870:	88 0f       	add	r24, r24
    4872:	99 1f       	adc	r25, r25
    4874:	88 0f       	add	r24, r24
    4876:	99 1f       	adc	r25, r25
    4878:	88 0f       	add	r24, r24
    487a:	99 1f       	adc	r25, r25
    487c:	82 0f       	add	r24, r18
    487e:	93 1f       	adc	r25, r19
    4880:	fc 01       	movw	r30, r24
    4882:	e4 58       	subi	r30, 0x84	; 132
    4884:	f7 4f       	sbci	r31, 0xF7	; 247
    4886:	80 81       	ld	r24, Z
    4888:	8f 5f       	subi	r24, 0xFF	; 255
    488a:	80 83       	st	Z, r24
    488c:	30 c0       	rjmp	.+96     	; 0x48ee <xTaskRemoveFromEventList+0x252>
    }
    else
    {
        /* The delayed and ready lists cannot be accessed, so hold this task
         * pending until the scheduler is resumed. */
        listINSERT_END( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    488e:	80 91 b7 08 	lds	r24, 0x08B7
    4892:	90 91 b8 08 	lds	r25, 0x08B8
    4896:	9a 83       	std	Y+2, r25	; 0x02
    4898:	89 83       	std	Y+1, r24	; 0x01
    489a:	ea 85       	ldd	r30, Y+10	; 0x0a
    489c:	fb 85       	ldd	r31, Y+11	; 0x0b
    489e:	89 81       	ldd	r24, Y+1	; 0x01
    48a0:	9a 81       	ldd	r25, Y+2	; 0x02
    48a2:	97 87       	std	Z+15, r25	; 0x0f
    48a4:	86 87       	std	Z+14, r24	; 0x0e
    48a6:	e9 81       	ldd	r30, Y+1	; 0x01
    48a8:	fa 81       	ldd	r31, Y+2	; 0x02
    48aa:	84 81       	ldd	r24, Z+4	; 0x04
    48ac:	95 81       	ldd	r25, Z+5	; 0x05
    48ae:	ea 85       	ldd	r30, Y+10	; 0x0a
    48b0:	fb 85       	ldd	r31, Y+11	; 0x0b
    48b2:	91 8b       	std	Z+17, r25	; 0x11
    48b4:	80 8b       	std	Z+16, r24	; 0x10
    48b6:	e9 81       	ldd	r30, Y+1	; 0x01
    48b8:	fa 81       	ldd	r31, Y+2	; 0x02
    48ba:	04 80       	ldd	r0, Z+4	; 0x04
    48bc:	f5 81       	ldd	r31, Z+5	; 0x05
    48be:	e0 2d       	mov	r30, r0
    48c0:	8a 85       	ldd	r24, Y+10	; 0x0a
    48c2:	9b 85       	ldd	r25, Y+11	; 0x0b
    48c4:	0c 96       	adiw	r24, 0x0c	; 12
    48c6:	93 83       	std	Z+3, r25	; 0x03
    48c8:	82 83       	std	Z+2, r24	; 0x02
    48ca:	8a 85       	ldd	r24, Y+10	; 0x0a
    48cc:	9b 85       	ldd	r25, Y+11	; 0x0b
    48ce:	0c 96       	adiw	r24, 0x0c	; 12
    48d0:	e9 81       	ldd	r30, Y+1	; 0x01
    48d2:	fa 81       	ldd	r31, Y+2	; 0x02
    48d4:	95 83       	std	Z+5, r25	; 0x05
    48d6:	84 83       	std	Z+4, r24	; 0x04
    48d8:	ea 85       	ldd	r30, Y+10	; 0x0a
    48da:	fb 85       	ldd	r31, Y+11	; 0x0b
    48dc:	86 eb       	ldi	r24, 0xB6	; 182
    48de:	98 e0       	ldi	r25, 0x08	; 8
    48e0:	95 8b       	std	Z+21, r25	; 0x15
    48e2:	84 8b       	std	Z+20, r24	; 0x14
    48e4:	80 91 b6 08 	lds	r24, 0x08B6
    48e8:	8f 5f       	subi	r24, 0xFF	; 255
    48ea:	80 93 b6 08 	sts	0x08B6, r24
    }

    if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    48ee:	ea 85       	ldd	r30, Y+10	; 0x0a
    48f0:	fb 85       	ldd	r31, Y+11	; 0x0b
    48f2:	96 89       	ldd	r25, Z+22	; 0x16
    48f4:	e0 91 6a 08 	lds	r30, 0x086A
    48f8:	f0 91 6b 08 	lds	r31, 0x086B
    48fc:	86 89       	ldd	r24, Z+22	; 0x16
    48fe:	89 17       	cp	r24, r25
    4900:	30 f4       	brcc	.+12     	; 0x490e <xTaskRemoveFromEventList+0x272>
    {
        /* Return true if the task removed from the event list has a higher
         * priority than the calling task.  This allows the calling task to know if
         * it should force a context switch now. */
        xReturn = pdTRUE;
    4902:	81 e0       	ldi	r24, 0x01	; 1
    4904:	89 87       	std	Y+9, r24	; 0x09

        /* Mark that a yield is pending in case the user is not using the
         * "xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
        xYieldPending = pdTRUE;
    4906:	81 e0       	ldi	r24, 0x01	; 1
    4908:	80 93 74 08 	sts	0x0874, r24
    490c:	01 c0       	rjmp	.+2      	; 0x4910 <xTaskRemoveFromEventList+0x274>
    }
    else
    {
        xReturn = pdFALSE;
    490e:	19 86       	std	Y+9, r1	; 0x09
    }

    return xReturn;
    4910:	89 85       	ldd	r24, Y+9	; 0x09
}
    4912:	2d 96       	adiw	r28, 0x0d	; 13
    4914:	0f b6       	in	r0, 0x3f	; 63
    4916:	f8 94       	cli
    4918:	de bf       	out	0x3e, r29	; 62
    491a:	0f be       	out	0x3f, r0	; 63
    491c:	cd bf       	out	0x3d, r28	; 61
    491e:	cf 91       	pop	r28
    4920:	df 91       	pop	r29
    4922:	08 95       	ret

00004924 <vTaskRemoveFromUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem,
                                        const TickType_t xItemValue )
{
    4924:	df 93       	push	r29
    4926:	cf 93       	push	r28
    4928:	cd b7       	in	r28, 0x3d	; 61
    492a:	de b7       	in	r29, 0x3e	; 62
    492c:	2c 97       	sbiw	r28, 0x0c	; 12
    492e:	0f b6       	in	r0, 0x3f	; 63
    4930:	f8 94       	cli
    4932:	de bf       	out	0x3e, r29	; 62
    4934:	0f be       	out	0x3f, r0	; 63
    4936:	cd bf       	out	0x3d, r28	; 61
    4938:	9a 87       	std	Y+10, r25	; 0x0a
    493a:	89 87       	std	Y+9, r24	; 0x09
    493c:	7c 87       	std	Y+12, r23	; 0x0c
    493e:	6b 87       	std	Y+11, r22	; 0x0b
    /* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
     * the event flags implementation. */
    configASSERT( uxSchedulerSuspended != pdFALSE );

    /* Store the new item value in the event list. */
    listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    4940:	8b 85       	ldd	r24, Y+11	; 0x0b
    4942:	9c 85       	ldd	r25, Y+12	; 0x0c
    4944:	90 68       	ori	r25, 0x80	; 128
    4946:	e9 85       	ldd	r30, Y+9	; 0x09
    4948:	fa 85       	ldd	r31, Y+10	; 0x0a
    494a:	91 83       	std	Z+1, r25	; 0x01
    494c:	80 83       	st	Z, r24

    /* Remove the event list form the event flag.  Interrupts do not access
     * event flags. */
    pxUnblockedTCB = listGET_LIST_ITEM_OWNER( pxEventListItem ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    494e:	e9 85       	ldd	r30, Y+9	; 0x09
    4950:	fa 85       	ldd	r31, Y+10	; 0x0a
    4952:	86 81       	ldd	r24, Z+6	; 0x06
    4954:	97 81       	ldd	r25, Z+7	; 0x07
    4956:	98 87       	std	Y+8, r25	; 0x08
    4958:	8f 83       	std	Y+7, r24	; 0x07
    configASSERT( pxUnblockedTCB );
    listREMOVE_ITEM( pxEventListItem );
    495a:	e9 85       	ldd	r30, Y+9	; 0x09
    495c:	fa 85       	ldd	r31, Y+10	; 0x0a
    495e:	80 85       	ldd	r24, Z+8	; 0x08
    4960:	91 85       	ldd	r25, Z+9	; 0x09
    4962:	9e 83       	std	Y+6, r25	; 0x06
    4964:	8d 83       	std	Y+5, r24	; 0x05
    4966:	e9 85       	ldd	r30, Y+9	; 0x09
    4968:	fa 85       	ldd	r31, Y+10	; 0x0a
    496a:	a2 81       	ldd	r26, Z+2	; 0x02
    496c:	b3 81       	ldd	r27, Z+3	; 0x03
    496e:	e9 85       	ldd	r30, Y+9	; 0x09
    4970:	fa 85       	ldd	r31, Y+10	; 0x0a
    4972:	84 81       	ldd	r24, Z+4	; 0x04
    4974:	95 81       	ldd	r25, Z+5	; 0x05
    4976:	15 96       	adiw	r26, 0x05	; 5
    4978:	9c 93       	st	X, r25
    497a:	8e 93       	st	-X, r24
    497c:	14 97       	sbiw	r26, 0x04	; 4
    497e:	e9 85       	ldd	r30, Y+9	; 0x09
    4980:	fa 85       	ldd	r31, Y+10	; 0x0a
    4982:	a4 81       	ldd	r26, Z+4	; 0x04
    4984:	b5 81       	ldd	r27, Z+5	; 0x05
    4986:	e9 85       	ldd	r30, Y+9	; 0x09
    4988:	fa 85       	ldd	r31, Y+10	; 0x0a
    498a:	82 81       	ldd	r24, Z+2	; 0x02
    498c:	93 81       	ldd	r25, Z+3	; 0x03
    498e:	13 96       	adiw	r26, 0x03	; 3
    4990:	9c 93       	st	X, r25
    4992:	8e 93       	st	-X, r24
    4994:	12 97       	sbiw	r26, 0x02	; 2
    4996:	ed 81       	ldd	r30, Y+5	; 0x05
    4998:	fe 81       	ldd	r31, Y+6	; 0x06
    499a:	21 81       	ldd	r18, Z+1	; 0x01
    499c:	32 81       	ldd	r19, Z+2	; 0x02
    499e:	89 85       	ldd	r24, Y+9	; 0x09
    49a0:	9a 85       	ldd	r25, Y+10	; 0x0a
    49a2:	28 17       	cp	r18, r24
    49a4:	39 07       	cpc	r19, r25
    49a6:	41 f4       	brne	.+16     	; 0x49b8 <vTaskRemoveFromUnorderedEventList+0x94>
    49a8:	e9 85       	ldd	r30, Y+9	; 0x09
    49aa:	fa 85       	ldd	r31, Y+10	; 0x0a
    49ac:	84 81       	ldd	r24, Z+4	; 0x04
    49ae:	95 81       	ldd	r25, Z+5	; 0x05
    49b0:	ed 81       	ldd	r30, Y+5	; 0x05
    49b2:	fe 81       	ldd	r31, Y+6	; 0x06
    49b4:	92 83       	std	Z+2, r25	; 0x02
    49b6:	81 83       	std	Z+1, r24	; 0x01
    49b8:	e9 85       	ldd	r30, Y+9	; 0x09
    49ba:	fa 85       	ldd	r31, Y+10	; 0x0a
    49bc:	11 86       	std	Z+9, r1	; 0x09
    49be:	10 86       	std	Z+8, r1	; 0x08
    49c0:	ed 81       	ldd	r30, Y+5	; 0x05
    49c2:	fe 81       	ldd	r31, Y+6	; 0x06
    49c4:	80 81       	ld	r24, Z
    49c6:	81 50       	subi	r24, 0x01	; 1
    49c8:	ed 81       	ldd	r30, Y+5	; 0x05
    49ca:	fe 81       	ldd	r31, Y+6	; 0x06
    49cc:	80 83       	st	Z, r24
    #endif

    /* Remove the task from the delayed list and add it to the ready list.  The
     * scheduler is suspended so interrupts will not be accessing the ready
     * lists. */
    listREMOVE_ITEM( &( pxUnblockedTCB->xStateListItem ) );
    49ce:	ef 81       	ldd	r30, Y+7	; 0x07
    49d0:	f8 85       	ldd	r31, Y+8	; 0x08
    49d2:	82 85       	ldd	r24, Z+10	; 0x0a
    49d4:	93 85       	ldd	r25, Z+11	; 0x0b
    49d6:	9c 83       	std	Y+4, r25	; 0x04
    49d8:	8b 83       	std	Y+3, r24	; 0x03
    49da:	ef 81       	ldd	r30, Y+7	; 0x07
    49dc:	f8 85       	ldd	r31, Y+8	; 0x08
    49de:	a4 81       	ldd	r26, Z+4	; 0x04
    49e0:	b5 81       	ldd	r27, Z+5	; 0x05
    49e2:	ef 81       	ldd	r30, Y+7	; 0x07
    49e4:	f8 85       	ldd	r31, Y+8	; 0x08
    49e6:	86 81       	ldd	r24, Z+6	; 0x06
    49e8:	97 81       	ldd	r25, Z+7	; 0x07
    49ea:	15 96       	adiw	r26, 0x05	; 5
    49ec:	9c 93       	st	X, r25
    49ee:	8e 93       	st	-X, r24
    49f0:	14 97       	sbiw	r26, 0x04	; 4
    49f2:	ef 81       	ldd	r30, Y+7	; 0x07
    49f4:	f8 85       	ldd	r31, Y+8	; 0x08
    49f6:	a6 81       	ldd	r26, Z+6	; 0x06
    49f8:	b7 81       	ldd	r27, Z+7	; 0x07
    49fa:	ef 81       	ldd	r30, Y+7	; 0x07
    49fc:	f8 85       	ldd	r31, Y+8	; 0x08
    49fe:	84 81       	ldd	r24, Z+4	; 0x04
    4a00:	95 81       	ldd	r25, Z+5	; 0x05
    4a02:	13 96       	adiw	r26, 0x03	; 3
    4a04:	9c 93       	st	X, r25
    4a06:	8e 93       	st	-X, r24
    4a08:	12 97       	sbiw	r26, 0x02	; 2
    4a0a:	eb 81       	ldd	r30, Y+3	; 0x03
    4a0c:	fc 81       	ldd	r31, Y+4	; 0x04
    4a0e:	21 81       	ldd	r18, Z+1	; 0x01
    4a10:	32 81       	ldd	r19, Z+2	; 0x02
    4a12:	8f 81       	ldd	r24, Y+7	; 0x07
    4a14:	98 85       	ldd	r25, Y+8	; 0x08
    4a16:	02 96       	adiw	r24, 0x02	; 2
    4a18:	28 17       	cp	r18, r24
    4a1a:	39 07       	cpc	r19, r25
    4a1c:	41 f4       	brne	.+16     	; 0x4a2e <vTaskRemoveFromUnorderedEventList+0x10a>
    4a1e:	ef 81       	ldd	r30, Y+7	; 0x07
    4a20:	f8 85       	ldd	r31, Y+8	; 0x08
    4a22:	86 81       	ldd	r24, Z+6	; 0x06
    4a24:	97 81       	ldd	r25, Z+7	; 0x07
    4a26:	eb 81       	ldd	r30, Y+3	; 0x03
    4a28:	fc 81       	ldd	r31, Y+4	; 0x04
    4a2a:	92 83       	std	Z+2, r25	; 0x02
    4a2c:	81 83       	std	Z+1, r24	; 0x01
    4a2e:	ef 81       	ldd	r30, Y+7	; 0x07
    4a30:	f8 85       	ldd	r31, Y+8	; 0x08
    4a32:	13 86       	std	Z+11, r1	; 0x0b
    4a34:	12 86       	std	Z+10, r1	; 0x0a
    4a36:	eb 81       	ldd	r30, Y+3	; 0x03
    4a38:	fc 81       	ldd	r31, Y+4	; 0x04
    4a3a:	80 81       	ld	r24, Z
    4a3c:	81 50       	subi	r24, 0x01	; 1
    4a3e:	eb 81       	ldd	r30, Y+3	; 0x03
    4a40:	fc 81       	ldd	r31, Y+4	; 0x04
    4a42:	80 83       	st	Z, r24
    prvAddTaskToReadyList( pxUnblockedTCB );
    4a44:	ef 81       	ldd	r30, Y+7	; 0x07
    4a46:	f8 85       	ldd	r31, Y+8	; 0x08
    4a48:	96 89       	ldd	r25, Z+22	; 0x16
    4a4a:	80 91 70 08 	lds	r24, 0x0870
    4a4e:	89 17       	cp	r24, r25
    4a50:	28 f4       	brcc	.+10     	; 0x4a5c <vTaskRemoveFromUnorderedEventList+0x138>
    4a52:	ef 81       	ldd	r30, Y+7	; 0x07
    4a54:	f8 85       	ldd	r31, Y+8	; 0x08
    4a56:	86 89       	ldd	r24, Z+22	; 0x16
    4a58:	80 93 70 08 	sts	0x0870, r24
    4a5c:	ef 81       	ldd	r30, Y+7	; 0x07
    4a5e:	f8 85       	ldd	r31, Y+8	; 0x08
    4a60:	86 89       	ldd	r24, Z+22	; 0x16
    4a62:	28 2f       	mov	r18, r24
    4a64:	30 e0       	ldi	r19, 0x00	; 0
    4a66:	c9 01       	movw	r24, r18
    4a68:	88 0f       	add	r24, r24
    4a6a:	99 1f       	adc	r25, r25
    4a6c:	88 0f       	add	r24, r24
    4a6e:	99 1f       	adc	r25, r25
    4a70:	88 0f       	add	r24, r24
    4a72:	99 1f       	adc	r25, r25
    4a74:	82 0f       	add	r24, r18
    4a76:	93 1f       	adc	r25, r19
    4a78:	fc 01       	movw	r30, r24
    4a7a:	e4 58       	subi	r30, 0x84	; 132
    4a7c:	f7 4f       	sbci	r31, 0xF7	; 247
    4a7e:	81 81       	ldd	r24, Z+1	; 0x01
    4a80:	92 81       	ldd	r25, Z+2	; 0x02
    4a82:	9a 83       	std	Y+2, r25	; 0x02
    4a84:	89 83       	std	Y+1, r24	; 0x01
    4a86:	ef 81       	ldd	r30, Y+7	; 0x07
    4a88:	f8 85       	ldd	r31, Y+8	; 0x08
    4a8a:	89 81       	ldd	r24, Y+1	; 0x01
    4a8c:	9a 81       	ldd	r25, Y+2	; 0x02
    4a8e:	95 83       	std	Z+5, r25	; 0x05
    4a90:	84 83       	std	Z+4, r24	; 0x04
    4a92:	e9 81       	ldd	r30, Y+1	; 0x01
    4a94:	fa 81       	ldd	r31, Y+2	; 0x02
    4a96:	84 81       	ldd	r24, Z+4	; 0x04
    4a98:	95 81       	ldd	r25, Z+5	; 0x05
    4a9a:	ef 81       	ldd	r30, Y+7	; 0x07
    4a9c:	f8 85       	ldd	r31, Y+8	; 0x08
    4a9e:	97 83       	std	Z+7, r25	; 0x07
    4aa0:	86 83       	std	Z+6, r24	; 0x06
    4aa2:	e9 81       	ldd	r30, Y+1	; 0x01
    4aa4:	fa 81       	ldd	r31, Y+2	; 0x02
    4aa6:	04 80       	ldd	r0, Z+4	; 0x04
    4aa8:	f5 81       	ldd	r31, Z+5	; 0x05
    4aaa:	e0 2d       	mov	r30, r0
    4aac:	8f 81       	ldd	r24, Y+7	; 0x07
    4aae:	98 85       	ldd	r25, Y+8	; 0x08
    4ab0:	02 96       	adiw	r24, 0x02	; 2
    4ab2:	93 83       	std	Z+3, r25	; 0x03
    4ab4:	82 83       	std	Z+2, r24	; 0x02
    4ab6:	8f 81       	ldd	r24, Y+7	; 0x07
    4ab8:	98 85       	ldd	r25, Y+8	; 0x08
    4aba:	02 96       	adiw	r24, 0x02	; 2
    4abc:	e9 81       	ldd	r30, Y+1	; 0x01
    4abe:	fa 81       	ldd	r31, Y+2	; 0x02
    4ac0:	95 83       	std	Z+5, r25	; 0x05
    4ac2:	84 83       	std	Z+4, r24	; 0x04
    4ac4:	ef 81       	ldd	r30, Y+7	; 0x07
    4ac6:	f8 85       	ldd	r31, Y+8	; 0x08
    4ac8:	86 89       	ldd	r24, Z+22	; 0x16
    4aca:	28 2f       	mov	r18, r24
    4acc:	30 e0       	ldi	r19, 0x00	; 0
    4ace:	c9 01       	movw	r24, r18
    4ad0:	88 0f       	add	r24, r24
    4ad2:	99 1f       	adc	r25, r25
    4ad4:	88 0f       	add	r24, r24
    4ad6:	99 1f       	adc	r25, r25
    4ad8:	88 0f       	add	r24, r24
    4ada:	99 1f       	adc	r25, r25
    4adc:	82 0f       	add	r24, r18
    4ade:	93 1f       	adc	r25, r19
    4ae0:	84 58       	subi	r24, 0x84	; 132
    4ae2:	97 4f       	sbci	r25, 0xF7	; 247
    4ae4:	ef 81       	ldd	r30, Y+7	; 0x07
    4ae6:	f8 85       	ldd	r31, Y+8	; 0x08
    4ae8:	93 87       	std	Z+11, r25	; 0x0b
    4aea:	82 87       	std	Z+10, r24	; 0x0a
    4aec:	ef 81       	ldd	r30, Y+7	; 0x07
    4aee:	f8 85       	ldd	r31, Y+8	; 0x08
    4af0:	86 89       	ldd	r24, Z+22	; 0x16
    4af2:	28 2f       	mov	r18, r24
    4af4:	30 e0       	ldi	r19, 0x00	; 0
    4af6:	c9 01       	movw	r24, r18
    4af8:	88 0f       	add	r24, r24
    4afa:	99 1f       	adc	r25, r25
    4afc:	88 0f       	add	r24, r24
    4afe:	99 1f       	adc	r25, r25
    4b00:	88 0f       	add	r24, r24
    4b02:	99 1f       	adc	r25, r25
    4b04:	82 0f       	add	r24, r18
    4b06:	93 1f       	adc	r25, r19
    4b08:	fc 01       	movw	r30, r24
    4b0a:	e4 58       	subi	r30, 0x84	; 132
    4b0c:	f7 4f       	sbci	r31, 0xF7	; 247
    4b0e:	80 81       	ld	r24, Z
    4b10:	8f 5f       	subi	r24, 0xFF	; 255
    4b12:	80 83       	st	Z, r24

    if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    4b14:	ef 81       	ldd	r30, Y+7	; 0x07
    4b16:	f8 85       	ldd	r31, Y+8	; 0x08
    4b18:	96 89       	ldd	r25, Z+22	; 0x16
    4b1a:	e0 91 6a 08 	lds	r30, 0x086A
    4b1e:	f0 91 6b 08 	lds	r31, 0x086B
    4b22:	86 89       	ldd	r24, Z+22	; 0x16
    4b24:	89 17       	cp	r24, r25
    4b26:	18 f4       	brcc	.+6      	; 0x4b2e <vTaskRemoveFromUnorderedEventList+0x20a>
    {
        /* The unblocked task has a priority above that of the calling task, so
         * a context switch is required.  This function is called with the
         * scheduler suspended so xYieldPending is set so the context switch
         * occurs immediately that the scheduler is resumed (unsuspended). */
        xYieldPending = pdTRUE;
    4b28:	81 e0       	ldi	r24, 0x01	; 1
    4b2a:	80 93 74 08 	sts	0x0874, r24
    }
}
    4b2e:	2c 96       	adiw	r28, 0x0c	; 12
    4b30:	0f b6       	in	r0, 0x3f	; 63
    4b32:	f8 94       	cli
    4b34:	de bf       	out	0x3e, r29	; 62
    4b36:	0f be       	out	0x3f, r0	; 63
    4b38:	cd bf       	out	0x3d, r28	; 61
    4b3a:	cf 91       	pop	r28
    4b3c:	df 91       	pop	r29
    4b3e:	08 95       	ret

00004b40 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    4b40:	df 93       	push	r29
    4b42:	cf 93       	push	r28
    4b44:	00 d0       	rcall	.+0      	; 0x4b46 <vTaskSetTimeOutState+0x6>
    4b46:	cd b7       	in	r28, 0x3d	; 61
    4b48:	de b7       	in	r29, 0x3e	; 62
    4b4a:	9a 83       	std	Y+2, r25	; 0x02
    4b4c:	89 83       	std	Y+1, r24	; 0x01
    configASSERT( pxTimeOut );
    taskENTER_CRITICAL();
    4b4e:	0f b6       	in	r0, 0x3f	; 63
    4b50:	f8 94       	cli
    4b52:	0f 92       	push	r0
    {
        pxTimeOut->xOverflowCount = xNumOfOverflows;
    4b54:	80 91 75 08 	lds	r24, 0x0875
    4b58:	e9 81       	ldd	r30, Y+1	; 0x01
    4b5a:	fa 81       	ldd	r31, Y+2	; 0x02
    4b5c:	80 83       	st	Z, r24
        pxTimeOut->xTimeOnEntering = xTickCount;
    4b5e:	80 91 6e 08 	lds	r24, 0x086E
    4b62:	90 91 6f 08 	lds	r25, 0x086F
    4b66:	e9 81       	ldd	r30, Y+1	; 0x01
    4b68:	fa 81       	ldd	r31, Y+2	; 0x02
    4b6a:	92 83       	std	Z+2, r25	; 0x02
    4b6c:	81 83       	std	Z+1, r24	; 0x01
    }
    taskEXIT_CRITICAL();
    4b6e:	0f 90       	pop	r0
    4b70:	0f be       	out	0x3f, r0	; 63
}
    4b72:	0f 90       	pop	r0
    4b74:	0f 90       	pop	r0
    4b76:	cf 91       	pop	r28
    4b78:	df 91       	pop	r29
    4b7a:	08 95       	ret

00004b7c <vTaskInternalSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    4b7c:	df 93       	push	r29
    4b7e:	cf 93       	push	r28
    4b80:	00 d0       	rcall	.+0      	; 0x4b82 <vTaskInternalSetTimeOutState+0x6>
    4b82:	cd b7       	in	r28, 0x3d	; 61
    4b84:	de b7       	in	r29, 0x3e	; 62
    4b86:	9a 83       	std	Y+2, r25	; 0x02
    4b88:	89 83       	std	Y+1, r24	; 0x01
    /* For internal use only as it does not use a critical section. */
    pxTimeOut->xOverflowCount = xNumOfOverflows;
    4b8a:	80 91 75 08 	lds	r24, 0x0875
    4b8e:	e9 81       	ldd	r30, Y+1	; 0x01
    4b90:	fa 81       	ldd	r31, Y+2	; 0x02
    4b92:	80 83       	st	Z, r24
    pxTimeOut->xTimeOnEntering = xTickCount;
    4b94:	80 91 6e 08 	lds	r24, 0x086E
    4b98:	90 91 6f 08 	lds	r25, 0x086F
    4b9c:	e9 81       	ldd	r30, Y+1	; 0x01
    4b9e:	fa 81       	ldd	r31, Y+2	; 0x02
    4ba0:	92 83       	std	Z+2, r25	; 0x02
    4ba2:	81 83       	std	Z+1, r24	; 0x01
}
    4ba4:	0f 90       	pop	r0
    4ba6:	0f 90       	pop	r0
    4ba8:	cf 91       	pop	r28
    4baa:	df 91       	pop	r29
    4bac:	08 95       	ret

00004bae <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut,
                                 TickType_t * const pxTicksToWait )
{
    4bae:	df 93       	push	r29
    4bb0:	cf 93       	push	r28
    4bb2:	cd b7       	in	r28, 0x3d	; 61
    4bb4:	de b7       	in	r29, 0x3e	; 62
    4bb6:	29 97       	sbiw	r28, 0x09	; 9
    4bb8:	0f b6       	in	r0, 0x3f	; 63
    4bba:	f8 94       	cli
    4bbc:	de bf       	out	0x3e, r29	; 62
    4bbe:	0f be       	out	0x3f, r0	; 63
    4bc0:	cd bf       	out	0x3d, r28	; 61
    4bc2:	9f 83       	std	Y+7, r25	; 0x07
    4bc4:	8e 83       	std	Y+6, r24	; 0x06
    4bc6:	79 87       	std	Y+9, r23	; 0x09
    4bc8:	68 87       	std	Y+8, r22	; 0x08
    BaseType_t xReturn;

    configASSERT( pxTimeOut );
    configASSERT( pxTicksToWait );

    taskENTER_CRITICAL();
    4bca:	0f b6       	in	r0, 0x3f	; 63
    4bcc:	f8 94       	cli
    4bce:	0f 92       	push	r0
    {
        /* Minor optimisation.  The tick count cannot change in this block. */
        const TickType_t xConstTickCount = xTickCount;
    4bd0:	80 91 6e 08 	lds	r24, 0x086E
    4bd4:	90 91 6f 08 	lds	r25, 0x086F
    4bd8:	9c 83       	std	Y+4, r25	; 0x04
    4bda:	8b 83       	std	Y+3, r24	; 0x03
        const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
    4bdc:	ee 81       	ldd	r30, Y+6	; 0x06
    4bde:	ff 81       	ldd	r31, Y+7	; 0x07
    4be0:	21 81       	ldd	r18, Z+1	; 0x01
    4be2:	32 81       	ldd	r19, Z+2	; 0x02
    4be4:	8b 81       	ldd	r24, Y+3	; 0x03
    4be6:	9c 81       	ldd	r25, Y+4	; 0x04
    4be8:	82 1b       	sub	r24, r18
    4bea:	93 0b       	sbc	r25, r19
    4bec:	9a 83       	std	Y+2, r25	; 0x02
    4bee:	89 83       	std	Y+1, r24	; 0x01
                xReturn = pdFALSE;
            }
            else
        #endif

        if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
    4bf0:	ee 81       	ldd	r30, Y+6	; 0x06
    4bf2:	ff 81       	ldd	r31, Y+7	; 0x07
    4bf4:	90 81       	ld	r25, Z
    4bf6:	80 91 75 08 	lds	r24, 0x0875
    4bfa:	98 17       	cp	r25, r24
    4bfc:	81 f0       	breq	.+32     	; 0x4c1e <xTaskCheckForTimeOut+0x70>
    4bfe:	ee 81       	ldd	r30, Y+6	; 0x06
    4c00:	ff 81       	ldd	r31, Y+7	; 0x07
    4c02:	21 81       	ldd	r18, Z+1	; 0x01
    4c04:	32 81       	ldd	r19, Z+2	; 0x02
    4c06:	8b 81       	ldd	r24, Y+3	; 0x03
    4c08:	9c 81       	ldd	r25, Y+4	; 0x04
    4c0a:	82 17       	cp	r24, r18
    4c0c:	93 07       	cpc	r25, r19
    4c0e:	38 f0       	brcs	.+14     	; 0x4c1e <xTaskCheckForTimeOut+0x70>
            /* The tick count is greater than the time at which
             * vTaskSetTimeout() was called, but has also overflowed since
             * vTaskSetTimeOut() was called.  It must have wrapped all the way
             * around and gone past again. This passed since vTaskSetTimeout()
             * was called. */
            xReturn = pdTRUE;
    4c10:	81 e0       	ldi	r24, 0x01	; 1
    4c12:	8d 83       	std	Y+5, r24	; 0x05
            *pxTicksToWait = ( TickType_t ) 0;
    4c14:	e8 85       	ldd	r30, Y+8	; 0x08
    4c16:	f9 85       	ldd	r31, Y+9	; 0x09
    4c18:	11 82       	std	Z+1, r1	; 0x01
    4c1a:	10 82       	st	Z, r1
    4c1c:	23 c0       	rjmp	.+70     	; 0x4c64 <xTaskCheckForTimeOut+0xb6>
        }
        else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
    4c1e:	e8 85       	ldd	r30, Y+8	; 0x08
    4c20:	f9 85       	ldd	r31, Y+9	; 0x09
    4c22:	20 81       	ld	r18, Z
    4c24:	31 81       	ldd	r19, Z+1	; 0x01
    4c26:	89 81       	ldd	r24, Y+1	; 0x01
    4c28:	9a 81       	ldd	r25, Y+2	; 0x02
    4c2a:	82 17       	cp	r24, r18
    4c2c:	93 07       	cpc	r25, r19
    4c2e:	a0 f4       	brcc	.+40     	; 0x4c58 <xTaskCheckForTimeOut+0xaa>
        {
            /* Not a genuine timeout. Adjust parameters for time remaining. */
            *pxTicksToWait -= xElapsedTime;
    4c30:	e8 85       	ldd	r30, Y+8	; 0x08
    4c32:	f9 85       	ldd	r31, Y+9	; 0x09
    4c34:	20 81       	ld	r18, Z
    4c36:	31 81       	ldd	r19, Z+1	; 0x01
    4c38:	89 81       	ldd	r24, Y+1	; 0x01
    4c3a:	9a 81       	ldd	r25, Y+2	; 0x02
    4c3c:	a9 01       	movw	r20, r18
    4c3e:	48 1b       	sub	r20, r24
    4c40:	59 0b       	sbc	r21, r25
    4c42:	ca 01       	movw	r24, r20
    4c44:	e8 85       	ldd	r30, Y+8	; 0x08
    4c46:	f9 85       	ldd	r31, Y+9	; 0x09
    4c48:	91 83       	std	Z+1, r25	; 0x01
    4c4a:	80 83       	st	Z, r24
            vTaskInternalSetTimeOutState( pxTimeOut );
    4c4c:	8e 81       	ldd	r24, Y+6	; 0x06
    4c4e:	9f 81       	ldd	r25, Y+7	; 0x07
    4c50:	0e 94 be 25 	call	0x4b7c	; 0x4b7c <vTaskInternalSetTimeOutState>
            xReturn = pdFALSE;
    4c54:	1d 82       	std	Y+5, r1	; 0x05
    4c56:	06 c0       	rjmp	.+12     	; 0x4c64 <xTaskCheckForTimeOut+0xb6>
        }
        else
        {
            *pxTicksToWait = ( TickType_t ) 0;
    4c58:	e8 85       	ldd	r30, Y+8	; 0x08
    4c5a:	f9 85       	ldd	r31, Y+9	; 0x09
    4c5c:	11 82       	std	Z+1, r1	; 0x01
    4c5e:	10 82       	st	Z, r1
            xReturn = pdTRUE;
    4c60:	81 e0       	ldi	r24, 0x01	; 1
    4c62:	8d 83       	std	Y+5, r24	; 0x05
        }
    }
    taskEXIT_CRITICAL();
    4c64:	0f 90       	pop	r0
    4c66:	0f be       	out	0x3f, r0	; 63

    return xReturn;
    4c68:	8d 81       	ldd	r24, Y+5	; 0x05
}
    4c6a:	29 96       	adiw	r28, 0x09	; 9
    4c6c:	0f b6       	in	r0, 0x3f	; 63
    4c6e:	f8 94       	cli
    4c70:	de bf       	out	0x3e, r29	; 62
    4c72:	0f be       	out	0x3f, r0	; 63
    4c74:	cd bf       	out	0x3d, r28	; 61
    4c76:	cf 91       	pop	r28
    4c78:	df 91       	pop	r29
    4c7a:	08 95       	ret

00004c7c <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
    4c7c:	df 93       	push	r29
    4c7e:	cf 93       	push	r28
    4c80:	cd b7       	in	r28, 0x3d	; 61
    4c82:	de b7       	in	r29, 0x3e	; 62
    xYieldPending = pdTRUE;
    4c84:	81 e0       	ldi	r24, 0x01	; 1
    4c86:	80 93 74 08 	sts	0x0874, r24
}
    4c8a:	cf 91       	pop	r28
    4c8c:	df 91       	pop	r29
    4c8e:	08 95       	ret

00004c90 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
    4c90:	df 93       	push	r29
    4c92:	cf 93       	push	r28
    4c94:	00 d0       	rcall	.+0      	; 0x4c96 <prvIdleTask+0x6>
    4c96:	cd b7       	in	r28, 0x3d	; 61
    4c98:	de b7       	in	r29, 0x3e	; 62
    4c9a:	9a 83       	std	Y+2, r25	; 0x02
    4c9c:	89 83       	std	Y+1, r24	; 0x01

    for( ; ; )
    {
        /* See if any tasks have deleted themselves - if so then the idle task
         * is responsible for freeing the deleted task's TCB and stack. */
        prvCheckTasksWaitingTermination();
    4c9e:	0e 94 95 26 	call	0x4d2a	; 0x4d2a <prvCheckTasksWaitingTermination>
                 *
                 * A critical region is not required here as we are just reading from
                 * the list, and an occasional incorrect value will not matter.  If
                 * the ready list at the idle priority contains more than one task
                 * then a task other than the idle task is ready to execute. */
                if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
    4ca2:	80 91 7c 08 	lds	r24, 0x087C
    4ca6:	82 30       	cpi	r24, 0x02	; 2
    4ca8:	d0 f3       	brcs	.-12     	; 0x4c9e <prvIdleTask+0xe>
                {
                    taskYIELD();
    4caa:	0e 94 72 09 	call	0x12e4	; 0x12e4 <vPortYield>
    4cae:	f7 cf       	rjmp	.-18     	; 0x4c9e <prvIdleTask+0xe>

00004cb0 <prvInitialiseTaskLists>:

#endif /* portUSING_MPU_WRAPPERS */
/*-----------------------------------------------------------*/

static void prvInitialiseTaskLists( void )
{
    4cb0:	df 93       	push	r29
    4cb2:	cf 93       	push	r28
    4cb4:	0f 92       	push	r0
    4cb6:	cd b7       	in	r28, 0x3d	; 61
    4cb8:	de b7       	in	r29, 0x3e	; 62
    UBaseType_t uxPriority;

    for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    4cba:	19 82       	std	Y+1, r1	; 0x01
    4cbc:	13 c0       	rjmp	.+38     	; 0x4ce4 <prvInitialiseTaskLists+0x34>
    {
        vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
    4cbe:	89 81       	ldd	r24, Y+1	; 0x01
    4cc0:	28 2f       	mov	r18, r24
    4cc2:	30 e0       	ldi	r19, 0x00	; 0
    4cc4:	c9 01       	movw	r24, r18
    4cc6:	88 0f       	add	r24, r24
    4cc8:	99 1f       	adc	r25, r25
    4cca:	88 0f       	add	r24, r24
    4ccc:	99 1f       	adc	r25, r25
    4cce:	88 0f       	add	r24, r24
    4cd0:	99 1f       	adc	r25, r25
    4cd2:	82 0f       	add	r24, r18
    4cd4:	93 1f       	adc	r25, r19
    4cd6:	84 58       	subi	r24, 0x84	; 132
    4cd8:	97 4f       	sbci	r25, 0xF7	; 247
    4cda:	0e 94 ab 10 	call	0x2156	; 0x2156 <vListInitialise>

static void prvInitialiseTaskLists( void )
{
    UBaseType_t uxPriority;

    for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    4cde:	89 81       	ldd	r24, Y+1	; 0x01
    4ce0:	8f 5f       	subi	r24, 0xFF	; 255
    4ce2:	89 83       	std	Y+1, r24	; 0x01
    4ce4:	89 81       	ldd	r24, Y+1	; 0x01
    4ce6:	84 30       	cpi	r24, 0x04	; 4
    4ce8:	50 f3       	brcs	.-44     	; 0x4cbe <prvInitialiseTaskLists+0xe>
    {
        vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
    }

    vListInitialise( &xDelayedTaskList1 );
    4cea:	80 ea       	ldi	r24, 0xA0	; 160
    4cec:	98 e0       	ldi	r25, 0x08	; 8
    4cee:	0e 94 ab 10 	call	0x2156	; 0x2156 <vListInitialise>
    vListInitialise( &xDelayedTaskList2 );
    4cf2:	89 ea       	ldi	r24, 0xA9	; 169
    4cf4:	98 e0       	ldi	r25, 0x08	; 8
    4cf6:	0e 94 ab 10 	call	0x2156	; 0x2156 <vListInitialise>
    vListInitialise( &xPendingReadyList );
    4cfa:	86 eb       	ldi	r24, 0xB6	; 182
    4cfc:	98 e0       	ldi	r25, 0x08	; 8
    4cfe:	0e 94 ab 10 	call	0x2156	; 0x2156 <vListInitialise>

    #if ( INCLUDE_vTaskDelete == 1 )
        {
            vListInitialise( &xTasksWaitingTermination );
    4d02:	8f eb       	ldi	r24, 0xBF	; 191
    4d04:	98 e0       	ldi	r25, 0x08	; 8
    4d06:	0e 94 ab 10 	call	0x2156	; 0x2156 <vListInitialise>
        }
    #endif /* INCLUDE_vTaskSuspend */

    /* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
     * using list2. */
    pxDelayedTaskList = &xDelayedTaskList1;
    4d0a:	80 ea       	ldi	r24, 0xA0	; 160
    4d0c:	98 e0       	ldi	r25, 0x08	; 8
    4d0e:	90 93 b3 08 	sts	0x08B3, r25
    4d12:	80 93 b2 08 	sts	0x08B2, r24
    pxOverflowDelayedTaskList = &xDelayedTaskList2;
    4d16:	89 ea       	ldi	r24, 0xA9	; 169
    4d18:	98 e0       	ldi	r25, 0x08	; 8
    4d1a:	90 93 b5 08 	sts	0x08B5, r25
    4d1e:	80 93 b4 08 	sts	0x08B4, r24
}
    4d22:	0f 90       	pop	r0
    4d24:	cf 91       	pop	r28
    4d26:	df 91       	pop	r29
    4d28:	08 95       	ret

00004d2a <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
    4d2a:	df 93       	push	r29
    4d2c:	cf 93       	push	r28
    4d2e:	00 d0       	rcall	.+0      	; 0x4d30 <prvCheckTasksWaitingTermination+0x6>
    4d30:	cd b7       	in	r28, 0x3d	; 61
    4d32:	de b7       	in	r29, 0x3e	; 62
    4d34:	20 c0       	rjmp	.+64     	; 0x4d76 <prvCheckTasksWaitingTermination+0x4c>

            /* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
             * being called too often in the idle task. */
            while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
            {
                taskENTER_CRITICAL();
    4d36:	0f b6       	in	r0, 0x3f	; 63
    4d38:	f8 94       	cli
    4d3a:	0f 92       	push	r0
                {
                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    4d3c:	e0 91 c4 08 	lds	r30, 0x08C4
    4d40:	f0 91 c5 08 	lds	r31, 0x08C5
    4d44:	86 81       	ldd	r24, Z+6	; 0x06
    4d46:	97 81       	ldd	r25, Z+7	; 0x07
    4d48:	9a 83       	std	Y+2, r25	; 0x02
    4d4a:	89 83       	std	Y+1, r24	; 0x01
                    ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    4d4c:	89 81       	ldd	r24, Y+1	; 0x01
    4d4e:	9a 81       	ldd	r25, Y+2	; 0x02
    4d50:	02 96       	adiw	r24, 0x02	; 2
    4d52:	0e 94 95 11 	call	0x232a	; 0x232a <uxListRemove>
                    --uxCurrentNumberOfTasks;
    4d56:	80 91 6d 08 	lds	r24, 0x086D
    4d5a:	81 50       	subi	r24, 0x01	; 1
    4d5c:	80 93 6d 08 	sts	0x086D, r24
                    --uxDeletedTasksWaitingCleanUp;
    4d60:	80 91 6c 08 	lds	r24, 0x086C
    4d64:	81 50       	subi	r24, 0x01	; 1
    4d66:	80 93 6c 08 	sts	0x086C, r24
                }
                taskEXIT_CRITICAL();
    4d6a:	0f 90       	pop	r0
    4d6c:	0f be       	out	0x3f, r0	; 63

                prvDeleteTCB( pxTCB );
    4d6e:	89 81       	ldd	r24, Y+1	; 0x01
    4d70:	9a 81       	ldd	r25, Y+2	; 0x02
    4d72:	0e 94 c4 26 	call	0x4d88	; 0x4d88 <prvDeleteTCB>
        {
            TCB_t * pxTCB;

            /* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
             * being called too often in the idle task. */
            while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
    4d76:	80 91 6c 08 	lds	r24, 0x086C
    4d7a:	88 23       	and	r24, r24
    4d7c:	e1 f6       	brne	.-72     	; 0x4d36 <prvCheckTasksWaitingTermination+0xc>

                prvDeleteTCB( pxTCB );
            }
        }
    #endif /* INCLUDE_vTaskDelete */
}
    4d7e:	0f 90       	pop	r0
    4d80:	0f 90       	pop	r0
    4d82:	cf 91       	pop	r28
    4d84:	df 91       	pop	r29
    4d86:	08 95       	ret

00004d88 <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

    static void prvDeleteTCB( TCB_t * pxTCB )
    {
    4d88:	df 93       	push	r29
    4d8a:	cf 93       	push	r28
    4d8c:	00 d0       	rcall	.+0      	; 0x4d8e <prvDeleteTCB+0x6>
    4d8e:	cd b7       	in	r28, 0x3d	; 61
    4d90:	de b7       	in	r29, 0x3e	; 62
    4d92:	9a 83       	std	Y+2, r25	; 0x02
    4d94:	89 83       	std	Y+1, r24	; 0x01

        #if ( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
            {
                /* The task can only have been allocated dynamically - free both
                 * the stack and TCB. */
                vPortFreeStack( pxTCB->pxStack );
    4d96:	e9 81       	ldd	r30, Y+1	; 0x01
    4d98:	fa 81       	ldd	r31, Y+2	; 0x02
    4d9a:	87 89       	ldd	r24, Z+23	; 0x17
    4d9c:	90 8d       	ldd	r25, Z+24	; 0x18
    4d9e:	0e 94 8d 07 	call	0xf1a	; 0xf1a <vPortFree>
                vPortFree( pxTCB );
    4da2:	89 81       	ldd	r24, Y+1	; 0x01
    4da4:	9a 81       	ldd	r25, Y+2	; 0x02
    4da6:	0e 94 8d 07 	call	0xf1a	; 0xf1a <vPortFree>
                    configASSERT( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB );
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        #endif /* configSUPPORT_DYNAMIC_ALLOCATION */
    }
    4daa:	0f 90       	pop	r0
    4dac:	0f 90       	pop	r0
    4dae:	cf 91       	pop	r28
    4db0:	df 91       	pop	r29
    4db2:	08 95       	ret

00004db4 <prvResetNextTaskUnblockTime>:

#endif /* INCLUDE_vTaskDelete */
/*-----------------------------------------------------------*/

static void prvResetNextTaskUnblockTime( void )
{
    4db4:	df 93       	push	r29
    4db6:	cf 93       	push	r28
    4db8:	cd b7       	in	r28, 0x3d	; 61
    4dba:	de b7       	in	r29, 0x3e	; 62
    if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    4dbc:	e0 91 b2 08 	lds	r30, 0x08B2
    4dc0:	f0 91 b3 08 	lds	r31, 0x08B3
    4dc4:	80 81       	ld	r24, Z
    4dc6:	88 23       	and	r24, r24
    4dc8:	39 f4       	brne	.+14     	; 0x4dd8 <prvResetNextTaskUnblockTime+0x24>
    {
        /* The new current delayed list is empty.  Set xNextTaskUnblockTime to
         * the maximum possible value so it is  extremely unlikely that the
         * if( xTickCount >= xNextTaskUnblockTime ) test will pass until
         * there is an item in the delayed list. */
        xNextTaskUnblockTime = portMAX_DELAY;
    4dca:	8f ef       	ldi	r24, 0xFF	; 255
    4dcc:	9f ef       	ldi	r25, 0xFF	; 255
    4dce:	90 93 78 08 	sts	0x0878, r25
    4dd2:	80 93 77 08 	sts	0x0877, r24
    4dd6:	0d c0       	rjmp	.+26     	; 0x4df2 <prvResetNextTaskUnblockTime+0x3e>
    {
        /* The new current delayed list is not empty, get the value of
         * the item at the head of the delayed list.  This is the time at
         * which the task at the head of the delayed list should be removed
         * from the Blocked state. */
        xNextTaskUnblockTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxDelayedTaskList );
    4dd8:	e0 91 b2 08 	lds	r30, 0x08B2
    4ddc:	f0 91 b3 08 	lds	r31, 0x08B3
    4de0:	05 80       	ldd	r0, Z+5	; 0x05
    4de2:	f6 81       	ldd	r31, Z+6	; 0x06
    4de4:	e0 2d       	mov	r30, r0
    4de6:	80 81       	ld	r24, Z
    4de8:	91 81       	ldd	r25, Z+1	; 0x01
    4dea:	90 93 78 08 	sts	0x0878, r25
    4dee:	80 93 77 08 	sts	0x0877, r24
    }
}
    4df2:	cf 91       	pop	r28
    4df4:	df 91       	pop	r29
    4df6:	08 95       	ret

00004df8 <xTaskGetSchedulerState>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )

    BaseType_t xTaskGetSchedulerState( void )
    {
    4df8:	df 93       	push	r29
    4dfa:	cf 93       	push	r28
    4dfc:	0f 92       	push	r0
    4dfe:	cd b7       	in	r28, 0x3d	; 61
    4e00:	de b7       	in	r29, 0x3e	; 62
        BaseType_t xReturn;

        if( xSchedulerRunning == pdFALSE )
    4e02:	80 91 71 08 	lds	r24, 0x0871
    4e06:	88 23       	and	r24, r24
    4e08:	19 f4       	brne	.+6      	; 0x4e10 <xTaskGetSchedulerState+0x18>
        {
            xReturn = taskSCHEDULER_NOT_STARTED;
    4e0a:	81 e0       	ldi	r24, 0x01	; 1
    4e0c:	89 83       	std	Y+1, r24	; 0x01
    4e0e:	08 c0       	rjmp	.+16     	; 0x4e20 <xTaskGetSchedulerState+0x28>
        }
        else
        {
            if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    4e10:	80 91 7b 08 	lds	r24, 0x087B
    4e14:	88 23       	and	r24, r24
    4e16:	19 f4       	brne	.+6      	; 0x4e1e <xTaskGetSchedulerState+0x26>
            {
                xReturn = taskSCHEDULER_RUNNING;
    4e18:	82 e0       	ldi	r24, 0x02	; 2
    4e1a:	89 83       	std	Y+1, r24	; 0x01
    4e1c:	01 c0       	rjmp	.+2      	; 0x4e20 <xTaskGetSchedulerState+0x28>
            }
            else
            {
                xReturn = taskSCHEDULER_SUSPENDED;
    4e1e:	19 82       	std	Y+1, r1	; 0x01
            }
        }

        return xReturn;
    4e20:	89 81       	ldd	r24, Y+1	; 0x01
    }
    4e22:	0f 90       	pop	r0
    4e24:	cf 91       	pop	r28
    4e26:	df 91       	pop	r29
    4e28:	08 95       	ret

00004e2a <uxTaskResetEventItemValue>:

#endif /* ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

TickType_t uxTaskResetEventItemValue( void )
{
    4e2a:	df 93       	push	r29
    4e2c:	cf 93       	push	r28
    4e2e:	00 d0       	rcall	.+0      	; 0x4e30 <uxTaskResetEventItemValue+0x6>
    4e30:	cd b7       	in	r28, 0x3d	; 61
    4e32:	de b7       	in	r29, 0x3e	; 62
    TickType_t uxReturn;

    uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
    4e34:	e0 91 6a 08 	lds	r30, 0x086A
    4e38:	f0 91 6b 08 	lds	r31, 0x086B
    4e3c:	84 85       	ldd	r24, Z+12	; 0x0c
    4e3e:	95 85       	ldd	r25, Z+13	; 0x0d
    4e40:	9a 83       	std	Y+2, r25	; 0x02
    4e42:	89 83       	std	Y+1, r24	; 0x01

    /* Reset the event list item to its normal value - so it can be used with
     * queues and semaphores. */
    listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    4e44:	a0 91 6a 08 	lds	r26, 0x086A
    4e48:	b0 91 6b 08 	lds	r27, 0x086B
    4e4c:	e0 91 6a 08 	lds	r30, 0x086A
    4e50:	f0 91 6b 08 	lds	r31, 0x086B
    4e54:	86 89       	ldd	r24, Z+22	; 0x16
    4e56:	28 2f       	mov	r18, r24
    4e58:	30 e0       	ldi	r19, 0x00	; 0
    4e5a:	84 e0       	ldi	r24, 0x04	; 4
    4e5c:	90 e0       	ldi	r25, 0x00	; 0
    4e5e:	82 1b       	sub	r24, r18
    4e60:	93 0b       	sbc	r25, r19
    4e62:	1d 96       	adiw	r26, 0x0d	; 13
    4e64:	9c 93       	st	X, r25
    4e66:	8e 93       	st	-X, r24
    4e68:	1c 97       	sbiw	r26, 0x0c	; 12

    return uxReturn;
    4e6a:	89 81       	ldd	r24, Y+1	; 0x01
    4e6c:	9a 81       	ldd	r25, Y+2	; 0x02
}
    4e6e:	0f 90       	pop	r0
    4e70:	0f 90       	pop	r0
    4e72:	cf 91       	pop	r28
    4e74:	df 91       	pop	r29
    4e76:	08 95       	ret

00004e78 <ulTaskGenericNotifyTake>:
#if ( configUSE_TASK_NOTIFICATIONS == 1 )

    uint32_t ulTaskGenericNotifyTake( UBaseType_t uxIndexToWait,
                                      BaseType_t xClearCountOnExit,
                                      TickType_t xTicksToWait )
    {
    4e78:	df 93       	push	r29
    4e7a:	cf 93       	push	r28
    4e7c:	cd b7       	in	r28, 0x3d	; 61
    4e7e:	de b7       	in	r29, 0x3e	; 62
    4e80:	28 97       	sbiw	r28, 0x08	; 8
    4e82:	0f b6       	in	r0, 0x3f	; 63
    4e84:	f8 94       	cli
    4e86:	de bf       	out	0x3e, r29	; 62
    4e88:	0f be       	out	0x3f, r0	; 63
    4e8a:	cd bf       	out	0x3d, r28	; 61
    4e8c:	8d 83       	std	Y+5, r24	; 0x05
    4e8e:	6e 83       	std	Y+6, r22	; 0x06
    4e90:	58 87       	std	Y+8, r21	; 0x08
    4e92:	4f 83       	std	Y+7, r20	; 0x07
        uint32_t ulReturn;

        configASSERT( uxIndexToWait < configTASK_NOTIFICATION_ARRAY_ENTRIES );

        taskENTER_CRITICAL();
    4e94:	0f b6       	in	r0, 0x3f	; 63
    4e96:	f8 94       	cli
    4e98:	0f 92       	push	r0
        {
            /* Only block if the notification count is not already non-zero. */
            if( pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] == 0UL )
    4e9a:	20 91 6a 08 	lds	r18, 0x086A
    4e9e:	30 91 6b 08 	lds	r19, 0x086B
    4ea2:	8d 81       	ldd	r24, Y+5	; 0x05
    4ea4:	88 2f       	mov	r24, r24
    4ea6:	90 e0       	ldi	r25, 0x00	; 0
    4ea8:	88 0f       	add	r24, r24
    4eaa:	99 1f       	adc	r25, r25
    4eac:	88 0f       	add	r24, r24
    4eae:	99 1f       	adc	r25, r25
    4eb0:	82 0f       	add	r24, r18
    4eb2:	93 1f       	adc	r25, r19
    4eb4:	fc 01       	movw	r30, r24
    4eb6:	b1 96       	adiw	r30, 0x21	; 33
    4eb8:	80 81       	ld	r24, Z
    4eba:	91 81       	ldd	r25, Z+1	; 0x01
    4ebc:	a2 81       	ldd	r26, Z+2	; 0x02
    4ebe:	b3 81       	ldd	r27, Z+3	; 0x03
    4ec0:	00 97       	sbiw	r24, 0x00	; 0
    4ec2:	a1 05       	cpc	r26, r1
    4ec4:	b1 05       	cpc	r27, r1
    4ec6:	c1 f4       	brne	.+48     	; 0x4ef8 <ulTaskGenericNotifyTake+0x80>
            {
                /* Mark this task as waiting for a notification. */
                pxCurrentTCB->ucNotifyState[ uxIndexToWait ] = taskWAITING_NOTIFICATION;
    4ec8:	20 91 6a 08 	lds	r18, 0x086A
    4ecc:	30 91 6b 08 	lds	r19, 0x086B
    4ed0:	8d 81       	ldd	r24, Y+5	; 0x05
    4ed2:	88 2f       	mov	r24, r24
    4ed4:	90 e0       	ldi	r25, 0x00	; 0
    4ed6:	82 0f       	add	r24, r18
    4ed8:	93 1f       	adc	r25, r19
    4eda:	fc 01       	movw	r30, r24
    4edc:	b5 96       	adiw	r30, 0x25	; 37
    4ede:	81 e0       	ldi	r24, 0x01	; 1
    4ee0:	80 83       	st	Z, r24

                if( xTicksToWait > ( TickType_t ) 0 )
    4ee2:	8f 81       	ldd	r24, Y+7	; 0x07
    4ee4:	98 85       	ldd	r25, Y+8	; 0x08
    4ee6:	00 97       	sbiw	r24, 0x00	; 0
    4ee8:	39 f0       	breq	.+14     	; 0x4ef8 <ulTaskGenericNotifyTake+0x80>
                {
                    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    4eea:	8f 81       	ldd	r24, Y+7	; 0x07
    4eec:	98 85       	ldd	r25, Y+8	; 0x08
    4eee:	61 e0       	ldi	r22, 0x01	; 1
    4ef0:	0e 94 c1 2e 	call	0x5d82	; 0x5d82 <prvAddCurrentTaskToDelayedList>

                    /* All ports are written to allow a yield in a critical
                     * section (some will yield immediately, others wait until the
                     * critical section exits) - but it is not something that
                     * application code should ever do. */
                    portYIELD_WITHIN_API();
    4ef4:	0e 94 72 09 	call	0x12e4	; 0x12e4 <vPortYield>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        taskEXIT_CRITICAL();
    4ef8:	0f 90       	pop	r0
    4efa:	0f be       	out	0x3f, r0	; 63

        taskENTER_CRITICAL();
    4efc:	0f b6       	in	r0, 0x3f	; 63
    4efe:	f8 94       	cli
    4f00:	0f 92       	push	r0
        {
            traceTASK_NOTIFY_TAKE( uxIndexToWait );
            ulReturn = pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ];
    4f02:	20 91 6a 08 	lds	r18, 0x086A
    4f06:	30 91 6b 08 	lds	r19, 0x086B
    4f0a:	8d 81       	ldd	r24, Y+5	; 0x05
    4f0c:	88 2f       	mov	r24, r24
    4f0e:	90 e0       	ldi	r25, 0x00	; 0
    4f10:	88 0f       	add	r24, r24
    4f12:	99 1f       	adc	r25, r25
    4f14:	88 0f       	add	r24, r24
    4f16:	99 1f       	adc	r25, r25
    4f18:	82 0f       	add	r24, r18
    4f1a:	93 1f       	adc	r25, r19
    4f1c:	fc 01       	movw	r30, r24
    4f1e:	b1 96       	adiw	r30, 0x21	; 33
    4f20:	80 81       	ld	r24, Z
    4f22:	91 81       	ldd	r25, Z+1	; 0x01
    4f24:	a2 81       	ldd	r26, Z+2	; 0x02
    4f26:	b3 81       	ldd	r27, Z+3	; 0x03
    4f28:	89 83       	std	Y+1, r24	; 0x01
    4f2a:	9a 83       	std	Y+2, r25	; 0x02
    4f2c:	ab 83       	std	Y+3, r26	; 0x03
    4f2e:	bc 83       	std	Y+4, r27	; 0x04

            if( ulReturn != 0UL )
    4f30:	89 81       	ldd	r24, Y+1	; 0x01
    4f32:	9a 81       	ldd	r25, Y+2	; 0x02
    4f34:	ab 81       	ldd	r26, Y+3	; 0x03
    4f36:	bc 81       	ldd	r27, Y+4	; 0x04
    4f38:	00 97       	sbiw	r24, 0x00	; 0
    4f3a:	a1 05       	cpc	r26, r1
    4f3c:	b1 05       	cpc	r27, r1
    4f3e:	a9 f1       	breq	.+106    	; 0x4faa <ulTaskGenericNotifyTake+0x132>
            {
                if( xClearCountOnExit != pdFALSE )
    4f40:	8e 81       	ldd	r24, Y+6	; 0x06
    4f42:	88 23       	and	r24, r24
    4f44:	a1 f0       	breq	.+40     	; 0x4f6e <ulTaskGenericNotifyTake+0xf6>
                {
                    pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] = 0UL;
    4f46:	20 91 6a 08 	lds	r18, 0x086A
    4f4a:	30 91 6b 08 	lds	r19, 0x086B
    4f4e:	8d 81       	ldd	r24, Y+5	; 0x05
    4f50:	88 2f       	mov	r24, r24
    4f52:	90 e0       	ldi	r25, 0x00	; 0
    4f54:	88 0f       	add	r24, r24
    4f56:	99 1f       	adc	r25, r25
    4f58:	88 0f       	add	r24, r24
    4f5a:	99 1f       	adc	r25, r25
    4f5c:	82 0f       	add	r24, r18
    4f5e:	93 1f       	adc	r25, r19
    4f60:	fc 01       	movw	r30, r24
    4f62:	b1 96       	adiw	r30, 0x21	; 33
    4f64:	10 82       	st	Z, r1
    4f66:	11 82       	std	Z+1, r1	; 0x01
    4f68:	12 82       	std	Z+2, r1	; 0x02
    4f6a:	13 82       	std	Z+3, r1	; 0x03
    4f6c:	1e c0       	rjmp	.+60     	; 0x4faa <ulTaskGenericNotifyTake+0x132>
                }
                else
                {
                    pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] = ulReturn - ( uint32_t ) 1;
    4f6e:	e0 91 6a 08 	lds	r30, 0x086A
    4f72:	f0 91 6b 08 	lds	r31, 0x086B
    4f76:	8d 81       	ldd	r24, Y+5	; 0x05
    4f78:	68 2f       	mov	r22, r24
    4f7a:	70 e0       	ldi	r23, 0x00	; 0
    4f7c:	89 81       	ldd	r24, Y+1	; 0x01
    4f7e:	9a 81       	ldd	r25, Y+2	; 0x02
    4f80:	ab 81       	ldd	r26, Y+3	; 0x03
    4f82:	bc 81       	ldd	r27, Y+4	; 0x04
    4f84:	9c 01       	movw	r18, r24
    4f86:	ad 01       	movw	r20, r26
    4f88:	21 50       	subi	r18, 0x01	; 1
    4f8a:	30 40       	sbci	r19, 0x00	; 0
    4f8c:	40 40       	sbci	r20, 0x00	; 0
    4f8e:	50 40       	sbci	r21, 0x00	; 0
    4f90:	cb 01       	movw	r24, r22
    4f92:	88 0f       	add	r24, r24
    4f94:	99 1f       	adc	r25, r25
    4f96:	88 0f       	add	r24, r24
    4f98:	99 1f       	adc	r25, r25
    4f9a:	8e 0f       	add	r24, r30
    4f9c:	9f 1f       	adc	r25, r31
    4f9e:	fc 01       	movw	r30, r24
    4fa0:	b1 96       	adiw	r30, 0x21	; 33
    4fa2:	20 83       	st	Z, r18
    4fa4:	31 83       	std	Z+1, r19	; 0x01
    4fa6:	42 83       	std	Z+2, r20	; 0x02
    4fa8:	53 83       	std	Z+3, r21	; 0x03
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }

            pxCurrentTCB->ucNotifyState[ uxIndexToWait ] = taskNOT_WAITING_NOTIFICATION;
    4faa:	20 91 6a 08 	lds	r18, 0x086A
    4fae:	30 91 6b 08 	lds	r19, 0x086B
    4fb2:	8d 81       	ldd	r24, Y+5	; 0x05
    4fb4:	88 2f       	mov	r24, r24
    4fb6:	90 e0       	ldi	r25, 0x00	; 0
    4fb8:	82 0f       	add	r24, r18
    4fba:	93 1f       	adc	r25, r19
    4fbc:	fc 01       	movw	r30, r24
    4fbe:	b5 96       	adiw	r30, 0x25	; 37
    4fc0:	10 82       	st	Z, r1
        }
        taskEXIT_CRITICAL();
    4fc2:	0f 90       	pop	r0
    4fc4:	0f be       	out	0x3f, r0	; 63

        return ulReturn;
    4fc6:	89 81       	ldd	r24, Y+1	; 0x01
    4fc8:	9a 81       	ldd	r25, Y+2	; 0x02
    4fca:	ab 81       	ldd	r26, Y+3	; 0x03
    4fcc:	bc 81       	ldd	r27, Y+4	; 0x04
    }
    4fce:	bc 01       	movw	r22, r24
    4fd0:	cd 01       	movw	r24, r26
    4fd2:	28 96       	adiw	r28, 0x08	; 8
    4fd4:	0f b6       	in	r0, 0x3f	; 63
    4fd6:	f8 94       	cli
    4fd8:	de bf       	out	0x3e, r29	; 62
    4fda:	0f be       	out	0x3f, r0	; 63
    4fdc:	cd bf       	out	0x3d, r28	; 61
    4fde:	cf 91       	pop	r28
    4fe0:	df 91       	pop	r29
    4fe2:	08 95       	ret

00004fe4 <xTaskGenericNotifyWait>:
    BaseType_t xTaskGenericNotifyWait( UBaseType_t uxIndexToWait,
                                       uint32_t ulBitsToClearOnEntry,
                                       uint32_t ulBitsToClearOnExit,
                                       uint32_t * pulNotificationValue,
                                       TickType_t xTicksToWait )
    {
    4fe4:	cf 92       	push	r12
    4fe6:	df 92       	push	r13
    4fe8:	ef 92       	push	r14
    4fea:	ff 92       	push	r15
    4fec:	0f 93       	push	r16
    4fee:	1f 93       	push	r17
    4ff0:	df 93       	push	r29
    4ff2:	cf 93       	push	r28
    4ff4:	cd b7       	in	r28, 0x3d	; 61
    4ff6:	de b7       	in	r29, 0x3e	; 62
    4ff8:	2e 97       	sbiw	r28, 0x0e	; 14
    4ffa:	0f b6       	in	r0, 0x3f	; 63
    4ffc:	f8 94       	cli
    4ffe:	de bf       	out	0x3e, r29	; 62
    5000:	0f be       	out	0x3f, r0	; 63
    5002:	cd bf       	out	0x3d, r28	; 61
    5004:	8a 83       	std	Y+2, r24	; 0x02
    5006:	4b 83       	std	Y+3, r20	; 0x03
    5008:	5c 83       	std	Y+4, r21	; 0x04
    500a:	6d 83       	std	Y+5, r22	; 0x05
    500c:	7e 83       	std	Y+6, r23	; 0x06
    500e:	0f 83       	std	Y+7, r16	; 0x07
    5010:	18 87       	std	Y+8, r17	; 0x08
    5012:	29 87       	std	Y+9, r18	; 0x09
    5014:	3a 87       	std	Y+10, r19	; 0x0a
    5016:	fc 86       	std	Y+12, r15	; 0x0c
    5018:	eb 86       	std	Y+11, r14	; 0x0b
    501a:	de 86       	std	Y+14, r13	; 0x0e
    501c:	cd 86       	std	Y+13, r12	; 0x0d
        BaseType_t xReturn;

        configASSERT( uxIndexToWait < configTASK_NOTIFICATION_ARRAY_ENTRIES );

        taskENTER_CRITICAL();
    501e:	0f b6       	in	r0, 0x3f	; 63
    5020:	f8 94       	cli
    5022:	0f 92       	push	r0
        {
            /* Only block if a notification is not already pending. */
            if( pxCurrentTCB->ucNotifyState[ uxIndexToWait ] != taskNOTIFICATION_RECEIVED )
    5024:	20 91 6a 08 	lds	r18, 0x086A
    5028:	30 91 6b 08 	lds	r19, 0x086B
    502c:	8a 81       	ldd	r24, Y+2	; 0x02
    502e:	88 2f       	mov	r24, r24
    5030:	90 e0       	ldi	r25, 0x00	; 0
    5032:	82 0f       	add	r24, r18
    5034:	93 1f       	adc	r25, r19
    5036:	fc 01       	movw	r30, r24
    5038:	b5 96       	adiw	r30, 0x25	; 37
    503a:	80 81       	ld	r24, Z
    503c:	82 30       	cpi	r24, 0x02	; 2
    503e:	09 f4       	brne	.+2      	; 0x5042 <xTaskGenericNotifyWait+0x5e>
    5040:	47 c0       	rjmp	.+142    	; 0x50d0 <xTaskGenericNotifyWait+0xec>
            {
                /* Clear bits in the task's notification value as bits may get
                 * set  by the notifying task or interrupt.  This can be used to
                 * clear the value to zero. */
                pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] &= ~ulBitsToClearOnEntry;
    5042:	60 91 6a 08 	lds	r22, 0x086A
    5046:	70 91 6b 08 	lds	r23, 0x086B
    504a:	8a 81       	ldd	r24, Y+2	; 0x02
    504c:	08 2f       	mov	r16, r24
    504e:	10 e0       	ldi	r17, 0x00	; 0
    5050:	8a 81       	ldd	r24, Y+2	; 0x02
    5052:	88 2f       	mov	r24, r24
    5054:	90 e0       	ldi	r25, 0x00	; 0
    5056:	88 0f       	add	r24, r24
    5058:	99 1f       	adc	r25, r25
    505a:	88 0f       	add	r24, r24
    505c:	99 1f       	adc	r25, r25
    505e:	86 0f       	add	r24, r22
    5060:	97 1f       	adc	r25, r23
    5062:	fc 01       	movw	r30, r24
    5064:	b1 96       	adiw	r30, 0x21	; 33
    5066:	20 81       	ld	r18, Z
    5068:	31 81       	ldd	r19, Z+1	; 0x01
    506a:	42 81       	ldd	r20, Z+2	; 0x02
    506c:	53 81       	ldd	r21, Z+3	; 0x03
    506e:	8b 81       	ldd	r24, Y+3	; 0x03
    5070:	9c 81       	ldd	r25, Y+4	; 0x04
    5072:	ad 81       	ldd	r26, Y+5	; 0x05
    5074:	be 81       	ldd	r27, Y+6	; 0x06
    5076:	80 95       	com	r24
    5078:	90 95       	com	r25
    507a:	a0 95       	com	r26
    507c:	b0 95       	com	r27
    507e:	28 23       	and	r18, r24
    5080:	39 23       	and	r19, r25
    5082:	4a 23       	and	r20, r26
    5084:	5b 23       	and	r21, r27
    5086:	c8 01       	movw	r24, r16
    5088:	88 0f       	add	r24, r24
    508a:	99 1f       	adc	r25, r25
    508c:	88 0f       	add	r24, r24
    508e:	99 1f       	adc	r25, r25
    5090:	86 0f       	add	r24, r22
    5092:	97 1f       	adc	r25, r23
    5094:	fc 01       	movw	r30, r24
    5096:	b1 96       	adiw	r30, 0x21	; 33
    5098:	20 83       	st	Z, r18
    509a:	31 83       	std	Z+1, r19	; 0x01
    509c:	42 83       	std	Z+2, r20	; 0x02
    509e:	53 83       	std	Z+3, r21	; 0x03

                /* Mark this task as waiting for a notification. */
                pxCurrentTCB->ucNotifyState[ uxIndexToWait ] = taskWAITING_NOTIFICATION;
    50a0:	20 91 6a 08 	lds	r18, 0x086A
    50a4:	30 91 6b 08 	lds	r19, 0x086B
    50a8:	8a 81       	ldd	r24, Y+2	; 0x02
    50aa:	88 2f       	mov	r24, r24
    50ac:	90 e0       	ldi	r25, 0x00	; 0
    50ae:	82 0f       	add	r24, r18
    50b0:	93 1f       	adc	r25, r19
    50b2:	fc 01       	movw	r30, r24
    50b4:	b5 96       	adiw	r30, 0x25	; 37
    50b6:	81 e0       	ldi	r24, 0x01	; 1
    50b8:	80 83       	st	Z, r24

                if( xTicksToWait > ( TickType_t ) 0 )
    50ba:	8d 85       	ldd	r24, Y+13	; 0x0d
    50bc:	9e 85       	ldd	r25, Y+14	; 0x0e
    50be:	00 97       	sbiw	r24, 0x00	; 0
    50c0:	39 f0       	breq	.+14     	; 0x50d0 <xTaskGenericNotifyWait+0xec>
                {
                    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    50c2:	8d 85       	ldd	r24, Y+13	; 0x0d
    50c4:	9e 85       	ldd	r25, Y+14	; 0x0e
    50c6:	61 e0       	ldi	r22, 0x01	; 1
    50c8:	0e 94 c1 2e 	call	0x5d82	; 0x5d82 <prvAddCurrentTaskToDelayedList>

                    /* All ports are written to allow a yield in a critical
                     * section (some will yield immediately, others wait until the
                     * critical section exits) - but it is not something that
                     * application code should ever do. */
                    portYIELD_WITHIN_API();
    50cc:	0e 94 72 09 	call	0x12e4	; 0x12e4 <vPortYield>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        taskEXIT_CRITICAL();
    50d0:	0f 90       	pop	r0
    50d2:	0f be       	out	0x3f, r0	; 63

        taskENTER_CRITICAL();
    50d4:	0f b6       	in	r0, 0x3f	; 63
    50d6:	f8 94       	cli
    50d8:	0f 92       	push	r0
        {
            traceTASK_NOTIFY_WAIT( uxIndexToWait );

            if( pulNotificationValue != NULL )
    50da:	8b 85       	ldd	r24, Y+11	; 0x0b
    50dc:	9c 85       	ldd	r25, Y+12	; 0x0c
    50de:	00 97       	sbiw	r24, 0x00	; 0
    50e0:	c9 f0       	breq	.+50     	; 0x5114 <xTaskGenericNotifyWait+0x130>
            {
                /* Output the current notification value, which may or may not
                 * have changed. */
                *pulNotificationValue = pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ];
    50e2:	20 91 6a 08 	lds	r18, 0x086A
    50e6:	30 91 6b 08 	lds	r19, 0x086B
    50ea:	8a 81       	ldd	r24, Y+2	; 0x02
    50ec:	88 2f       	mov	r24, r24
    50ee:	90 e0       	ldi	r25, 0x00	; 0
    50f0:	88 0f       	add	r24, r24
    50f2:	99 1f       	adc	r25, r25
    50f4:	88 0f       	add	r24, r24
    50f6:	99 1f       	adc	r25, r25
    50f8:	82 0f       	add	r24, r18
    50fa:	93 1f       	adc	r25, r19
    50fc:	fc 01       	movw	r30, r24
    50fe:	b1 96       	adiw	r30, 0x21	; 33
    5100:	80 81       	ld	r24, Z
    5102:	91 81       	ldd	r25, Z+1	; 0x01
    5104:	a2 81       	ldd	r26, Z+2	; 0x02
    5106:	b3 81       	ldd	r27, Z+3	; 0x03
    5108:	eb 85       	ldd	r30, Y+11	; 0x0b
    510a:	fc 85       	ldd	r31, Y+12	; 0x0c
    510c:	80 83       	st	Z, r24
    510e:	91 83       	std	Z+1, r25	; 0x01
    5110:	a2 83       	std	Z+2, r26	; 0x02
    5112:	b3 83       	std	Z+3, r27	; 0x03

            /* If ucNotifyValue is set then either the task never entered the
             * blocked state (because a notification was already pending) or the
             * task unblocked because of a notification.  Otherwise the task
             * unblocked because of a timeout. */
            if( pxCurrentTCB->ucNotifyState[ uxIndexToWait ] != taskNOTIFICATION_RECEIVED )
    5114:	20 91 6a 08 	lds	r18, 0x086A
    5118:	30 91 6b 08 	lds	r19, 0x086B
    511c:	8a 81       	ldd	r24, Y+2	; 0x02
    511e:	88 2f       	mov	r24, r24
    5120:	90 e0       	ldi	r25, 0x00	; 0
    5122:	82 0f       	add	r24, r18
    5124:	93 1f       	adc	r25, r19
    5126:	fc 01       	movw	r30, r24
    5128:	b5 96       	adiw	r30, 0x25	; 37
    512a:	80 81       	ld	r24, Z
    512c:	82 30       	cpi	r24, 0x02	; 2
    512e:	11 f0       	breq	.+4      	; 0x5134 <xTaskGenericNotifyWait+0x150>
            {
                /* A notification was not received. */
                xReturn = pdFALSE;
    5130:	19 82       	std	Y+1, r1	; 0x01
    5132:	31 c0       	rjmp	.+98     	; 0x5196 <xTaskGenericNotifyWait+0x1b2>
            }
            else
            {
                /* A notification was already pending or a notification was
                 * received while the task was waiting. */
                pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] &= ~ulBitsToClearOnExit;
    5134:	60 91 6a 08 	lds	r22, 0x086A
    5138:	70 91 6b 08 	lds	r23, 0x086B
    513c:	8a 81       	ldd	r24, Y+2	; 0x02
    513e:	08 2f       	mov	r16, r24
    5140:	10 e0       	ldi	r17, 0x00	; 0
    5142:	8a 81       	ldd	r24, Y+2	; 0x02
    5144:	88 2f       	mov	r24, r24
    5146:	90 e0       	ldi	r25, 0x00	; 0
    5148:	88 0f       	add	r24, r24
    514a:	99 1f       	adc	r25, r25
    514c:	88 0f       	add	r24, r24
    514e:	99 1f       	adc	r25, r25
    5150:	86 0f       	add	r24, r22
    5152:	97 1f       	adc	r25, r23
    5154:	fc 01       	movw	r30, r24
    5156:	b1 96       	adiw	r30, 0x21	; 33
    5158:	20 81       	ld	r18, Z
    515a:	31 81       	ldd	r19, Z+1	; 0x01
    515c:	42 81       	ldd	r20, Z+2	; 0x02
    515e:	53 81       	ldd	r21, Z+3	; 0x03
    5160:	8f 81       	ldd	r24, Y+7	; 0x07
    5162:	98 85       	ldd	r25, Y+8	; 0x08
    5164:	a9 85       	ldd	r26, Y+9	; 0x09
    5166:	ba 85       	ldd	r27, Y+10	; 0x0a
    5168:	80 95       	com	r24
    516a:	90 95       	com	r25
    516c:	a0 95       	com	r26
    516e:	b0 95       	com	r27
    5170:	28 23       	and	r18, r24
    5172:	39 23       	and	r19, r25
    5174:	4a 23       	and	r20, r26
    5176:	5b 23       	and	r21, r27
    5178:	c8 01       	movw	r24, r16
    517a:	88 0f       	add	r24, r24
    517c:	99 1f       	adc	r25, r25
    517e:	88 0f       	add	r24, r24
    5180:	99 1f       	adc	r25, r25
    5182:	86 0f       	add	r24, r22
    5184:	97 1f       	adc	r25, r23
    5186:	fc 01       	movw	r30, r24
    5188:	b1 96       	adiw	r30, 0x21	; 33
    518a:	20 83       	st	Z, r18
    518c:	31 83       	std	Z+1, r19	; 0x01
    518e:	42 83       	std	Z+2, r20	; 0x02
    5190:	53 83       	std	Z+3, r21	; 0x03
                xReturn = pdTRUE;
    5192:	81 e0       	ldi	r24, 0x01	; 1
    5194:	89 83       	std	Y+1, r24	; 0x01
            }

            pxCurrentTCB->ucNotifyState[ uxIndexToWait ] = taskNOT_WAITING_NOTIFICATION;
    5196:	20 91 6a 08 	lds	r18, 0x086A
    519a:	30 91 6b 08 	lds	r19, 0x086B
    519e:	8a 81       	ldd	r24, Y+2	; 0x02
    51a0:	88 2f       	mov	r24, r24
    51a2:	90 e0       	ldi	r25, 0x00	; 0
    51a4:	82 0f       	add	r24, r18
    51a6:	93 1f       	adc	r25, r19
    51a8:	fc 01       	movw	r30, r24
    51aa:	b5 96       	adiw	r30, 0x25	; 37
    51ac:	10 82       	st	Z, r1
        }
        taskEXIT_CRITICAL();
    51ae:	0f 90       	pop	r0
    51b0:	0f be       	out	0x3f, r0	; 63

        return xReturn;
    51b2:	89 81       	ldd	r24, Y+1	; 0x01
    }
    51b4:	2e 96       	adiw	r28, 0x0e	; 14
    51b6:	0f b6       	in	r0, 0x3f	; 63
    51b8:	f8 94       	cli
    51ba:	de bf       	out	0x3e, r29	; 62
    51bc:	0f be       	out	0x3f, r0	; 63
    51be:	cd bf       	out	0x3d, r28	; 61
    51c0:	cf 91       	pop	r28
    51c2:	df 91       	pop	r29
    51c4:	1f 91       	pop	r17
    51c6:	0f 91       	pop	r16
    51c8:	ff 90       	pop	r15
    51ca:	ef 90       	pop	r14
    51cc:	df 90       	pop	r13
    51ce:	cf 90       	pop	r12
    51d0:	08 95       	ret

000051d2 <xTaskGenericNotify>:
    BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify,
                                   UBaseType_t uxIndexToNotify,
                                   uint32_t ulValue,
                                   eNotifyAction eAction,
                                   uint32_t * pulPreviousNotificationValue )
    {
    51d2:	ef 92       	push	r14
    51d4:	ff 92       	push	r15
    51d6:	0f 93       	push	r16
    51d8:	1f 93       	push	r17
    51da:	df 93       	push	r29
    51dc:	cf 93       	push	r28
    51de:	cd b7       	in	r28, 0x3d	; 61
    51e0:	de b7       	in	r29, 0x3e	; 62
    51e2:	64 97       	sbiw	r28, 0x14	; 20
    51e4:	0f b6       	in	r0, 0x3f	; 63
    51e6:	f8 94       	cli
    51e8:	de bf       	out	0x3e, r29	; 62
    51ea:	0f be       	out	0x3f, r0	; 63
    51ec:	cd bf       	out	0x3d, r28	; 61
    51ee:	9a 87       	std	Y+10, r25	; 0x0a
    51f0:	89 87       	std	Y+9, r24	; 0x09
    51f2:	6b 87       	std	Y+11, r22	; 0x0b
    51f4:	2c 87       	std	Y+12, r18	; 0x0c
    51f6:	3d 87       	std	Y+13, r19	; 0x0d
    51f8:	4e 87       	std	Y+14, r20	; 0x0e
    51fa:	5f 87       	std	Y+15, r21	; 0x0f
    51fc:	08 8b       	std	Y+16, r16	; 0x10
    51fe:	fa 8a       	std	Y+18, r15	; 0x12
    5200:	e9 8a       	std	Y+17, r14	; 0x11
        TCB_t * pxTCB;
        BaseType_t xReturn = pdPASS;
    5202:	81 e0       	ldi	r24, 0x01	; 1
    5204:	8e 83       	std	Y+6, r24	; 0x06
        uint8_t ucOriginalNotifyState;

        configASSERT( uxIndexToNotify < configTASK_NOTIFICATION_ARRAY_ENTRIES );
        configASSERT( xTaskToNotify );
        pxTCB = xTaskToNotify;
    5206:	89 85       	ldd	r24, Y+9	; 0x09
    5208:	9a 85       	ldd	r25, Y+10	; 0x0a
    520a:	98 87       	std	Y+8, r25	; 0x08
    520c:	8f 83       	std	Y+7, r24	; 0x07

        taskENTER_CRITICAL();
    520e:	0f b6       	in	r0, 0x3f	; 63
    5210:	f8 94       	cli
    5212:	0f 92       	push	r0
        {
            if( pulPreviousNotificationValue != NULL )
    5214:	89 89       	ldd	r24, Y+17	; 0x11
    5216:	9a 89       	ldd	r25, Y+18	; 0x12
    5218:	00 97       	sbiw	r24, 0x00	; 0
    521a:	b9 f0       	breq	.+46     	; 0x524a <xTaskGenericNotify+0x78>
            {
                *pulPreviousNotificationValue = pxTCB->ulNotifiedValue[ uxIndexToNotify ];
    521c:	8b 85       	ldd	r24, Y+11	; 0x0b
    521e:	88 2f       	mov	r24, r24
    5220:	90 e0       	ldi	r25, 0x00	; 0
    5222:	2f 81       	ldd	r18, Y+7	; 0x07
    5224:	38 85       	ldd	r19, Y+8	; 0x08
    5226:	88 0f       	add	r24, r24
    5228:	99 1f       	adc	r25, r25
    522a:	88 0f       	add	r24, r24
    522c:	99 1f       	adc	r25, r25
    522e:	82 0f       	add	r24, r18
    5230:	93 1f       	adc	r25, r19
    5232:	fc 01       	movw	r30, r24
    5234:	b1 96       	adiw	r30, 0x21	; 33
    5236:	80 81       	ld	r24, Z
    5238:	91 81       	ldd	r25, Z+1	; 0x01
    523a:	a2 81       	ldd	r26, Z+2	; 0x02
    523c:	b3 81       	ldd	r27, Z+3	; 0x03
    523e:	e9 89       	ldd	r30, Y+17	; 0x11
    5240:	fa 89       	ldd	r31, Y+18	; 0x12
    5242:	80 83       	st	Z, r24
    5244:	91 83       	std	Z+1, r25	; 0x01
    5246:	a2 83       	std	Z+2, r26	; 0x02
    5248:	b3 83       	std	Z+3, r27	; 0x03
            }

            ucOriginalNotifyState = pxTCB->ucNotifyState[ uxIndexToNotify ];
    524a:	8b 85       	ldd	r24, Y+11	; 0x0b
    524c:	28 2f       	mov	r18, r24
    524e:	30 e0       	ldi	r19, 0x00	; 0
    5250:	8f 81       	ldd	r24, Y+7	; 0x07
    5252:	98 85       	ldd	r25, Y+8	; 0x08
    5254:	82 0f       	add	r24, r18
    5256:	93 1f       	adc	r25, r19
    5258:	fc 01       	movw	r30, r24
    525a:	b5 96       	adiw	r30, 0x25	; 37
    525c:	80 81       	ld	r24, Z
    525e:	8d 83       	std	Y+5, r24	; 0x05

            pxTCB->ucNotifyState[ uxIndexToNotify ] = taskNOTIFICATION_RECEIVED;
    5260:	8b 85       	ldd	r24, Y+11	; 0x0b
    5262:	28 2f       	mov	r18, r24
    5264:	30 e0       	ldi	r19, 0x00	; 0
    5266:	8f 81       	ldd	r24, Y+7	; 0x07
    5268:	98 85       	ldd	r25, Y+8	; 0x08
    526a:	82 0f       	add	r24, r18
    526c:	93 1f       	adc	r25, r19
    526e:	fc 01       	movw	r30, r24
    5270:	b5 96       	adiw	r30, 0x25	; 37
    5272:	82 e0       	ldi	r24, 0x02	; 2
    5274:	80 83       	st	Z, r24

            switch( eAction )
    5276:	88 89       	ldd	r24, Y+16	; 0x10
    5278:	28 2f       	mov	r18, r24
    527a:	30 e0       	ldi	r19, 0x00	; 0
    527c:	3c 8b       	std	Y+20, r19	; 0x14
    527e:	2b 8b       	std	Y+19, r18	; 0x13
    5280:	8b 89       	ldd	r24, Y+19	; 0x13
    5282:	9c 89       	ldd	r25, Y+20	; 0x14
    5284:	82 30       	cpi	r24, 0x02	; 2
    5286:	91 05       	cpc	r25, r1
    5288:	09 f4       	brne	.+2      	; 0x528c <xTaskGenericNotify+0xba>
    528a:	46 c0       	rjmp	.+140    	; 0x5318 <xTaskGenericNotify+0x146>
    528c:	2b 89       	ldd	r18, Y+19	; 0x13
    528e:	3c 89       	ldd	r19, Y+20	; 0x14
    5290:	23 30       	cpi	r18, 0x03	; 3
    5292:	31 05       	cpc	r19, r1
    5294:	34 f4       	brge	.+12     	; 0x52a2 <xTaskGenericNotify+0xd0>
    5296:	8b 89       	ldd	r24, Y+19	; 0x13
    5298:	9c 89       	ldd	r25, Y+20	; 0x14
    529a:	81 30       	cpi	r24, 0x01	; 1
    529c:	91 05       	cpc	r25, r1
    529e:	71 f0       	breq	.+28     	; 0x52bc <xTaskGenericNotify+0xea>
    52a0:	93 c0       	rjmp	.+294    	; 0x53c8 <xTaskGenericNotify+0x1f6>
    52a2:	2b 89       	ldd	r18, Y+19	; 0x13
    52a4:	3c 89       	ldd	r19, Y+20	; 0x14
    52a6:	23 30       	cpi	r18, 0x03	; 3
    52a8:	31 05       	cpc	r19, r1
    52aa:	09 f4       	brne	.+2      	; 0x52ae <xTaskGenericNotify+0xdc>
    52ac:	5d c0       	rjmp	.+186    	; 0x5368 <xTaskGenericNotify+0x196>
    52ae:	8b 89       	ldd	r24, Y+19	; 0x13
    52b0:	9c 89       	ldd	r25, Y+20	; 0x14
    52b2:	84 30       	cpi	r24, 0x04	; 4
    52b4:	91 05       	cpc	r25, r1
    52b6:	09 f4       	brne	.+2      	; 0x52ba <xTaskGenericNotify+0xe8>
    52b8:	6d c0       	rjmp	.+218    	; 0x5394 <xTaskGenericNotify+0x1c2>
    52ba:	86 c0       	rjmp	.+268    	; 0x53c8 <xTaskGenericNotify+0x1f6>
            {
                case eSetBits:
                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] |= ulValue;
    52bc:	8b 85       	ldd	r24, Y+11	; 0x0b
    52be:	08 2f       	mov	r16, r24
    52c0:	10 e0       	ldi	r17, 0x00	; 0
    52c2:	8b 85       	ldd	r24, Y+11	; 0x0b
    52c4:	88 2f       	mov	r24, r24
    52c6:	90 e0       	ldi	r25, 0x00	; 0
    52c8:	2f 81       	ldd	r18, Y+7	; 0x07
    52ca:	38 85       	ldd	r19, Y+8	; 0x08
    52cc:	88 0f       	add	r24, r24
    52ce:	99 1f       	adc	r25, r25
    52d0:	88 0f       	add	r24, r24
    52d2:	99 1f       	adc	r25, r25
    52d4:	82 0f       	add	r24, r18
    52d6:	93 1f       	adc	r25, r19
    52d8:	fc 01       	movw	r30, r24
    52da:	b1 96       	adiw	r30, 0x21	; 33
    52dc:	20 81       	ld	r18, Z
    52de:	31 81       	ldd	r19, Z+1	; 0x01
    52e0:	42 81       	ldd	r20, Z+2	; 0x02
    52e2:	53 81       	ldd	r21, Z+3	; 0x03
    52e4:	8c 85       	ldd	r24, Y+12	; 0x0c
    52e6:	9d 85       	ldd	r25, Y+13	; 0x0d
    52e8:	ae 85       	ldd	r26, Y+14	; 0x0e
    52ea:	bf 85       	ldd	r27, Y+15	; 0x0f
    52ec:	ba 01       	movw	r22, r20
    52ee:	a9 01       	movw	r20, r18
    52f0:	48 2b       	or	r20, r24
    52f2:	59 2b       	or	r21, r25
    52f4:	6a 2b       	or	r22, r26
    52f6:	7b 2b       	or	r23, r27
    52f8:	2f 81       	ldd	r18, Y+7	; 0x07
    52fa:	38 85       	ldd	r19, Y+8	; 0x08
    52fc:	c8 01       	movw	r24, r16
    52fe:	88 0f       	add	r24, r24
    5300:	99 1f       	adc	r25, r25
    5302:	88 0f       	add	r24, r24
    5304:	99 1f       	adc	r25, r25
    5306:	82 0f       	add	r24, r18
    5308:	93 1f       	adc	r25, r19
    530a:	fc 01       	movw	r30, r24
    530c:	b1 96       	adiw	r30, 0x21	; 33
    530e:	40 83       	st	Z, r20
    5310:	51 83       	std	Z+1, r21	; 0x01
    5312:	62 83       	std	Z+2, r22	; 0x02
    5314:	73 83       	std	Z+3, r23	; 0x03
    5316:	58 c0       	rjmp	.+176    	; 0x53c8 <xTaskGenericNotify+0x1f6>
                    break;

                case eIncrement:
                    ( pxTCB->ulNotifiedValue[ uxIndexToNotify ] )++;
    5318:	8b 85       	ldd	r24, Y+11	; 0x0b
    531a:	08 2f       	mov	r16, r24
    531c:	10 e0       	ldi	r17, 0x00	; 0
    531e:	2f 81       	ldd	r18, Y+7	; 0x07
    5320:	38 85       	ldd	r19, Y+8	; 0x08
    5322:	c8 01       	movw	r24, r16
    5324:	88 0f       	add	r24, r24
    5326:	99 1f       	adc	r25, r25
    5328:	88 0f       	add	r24, r24
    532a:	99 1f       	adc	r25, r25
    532c:	82 0f       	add	r24, r18
    532e:	93 1f       	adc	r25, r19
    5330:	fc 01       	movw	r30, r24
    5332:	b1 96       	adiw	r30, 0x21	; 33
    5334:	80 81       	ld	r24, Z
    5336:	91 81       	ldd	r25, Z+1	; 0x01
    5338:	a2 81       	ldd	r26, Z+2	; 0x02
    533a:	b3 81       	ldd	r27, Z+3	; 0x03
    533c:	ac 01       	movw	r20, r24
    533e:	bd 01       	movw	r22, r26
    5340:	4f 5f       	subi	r20, 0xFF	; 255
    5342:	5f 4f       	sbci	r21, 0xFF	; 255
    5344:	6f 4f       	sbci	r22, 0xFF	; 255
    5346:	7f 4f       	sbci	r23, 0xFF	; 255
    5348:	2f 81       	ldd	r18, Y+7	; 0x07
    534a:	38 85       	ldd	r19, Y+8	; 0x08
    534c:	c8 01       	movw	r24, r16
    534e:	88 0f       	add	r24, r24
    5350:	99 1f       	adc	r25, r25
    5352:	88 0f       	add	r24, r24
    5354:	99 1f       	adc	r25, r25
    5356:	82 0f       	add	r24, r18
    5358:	93 1f       	adc	r25, r19
    535a:	fc 01       	movw	r30, r24
    535c:	b1 96       	adiw	r30, 0x21	; 33
    535e:	40 83       	st	Z, r20
    5360:	51 83       	std	Z+1, r21	; 0x01
    5362:	62 83       	std	Z+2, r22	; 0x02
    5364:	73 83       	std	Z+3, r23	; 0x03
    5366:	30 c0       	rjmp	.+96     	; 0x53c8 <xTaskGenericNotify+0x1f6>
                    break;

                case eSetValueWithOverwrite:
                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
    5368:	8b 85       	ldd	r24, Y+11	; 0x0b
    536a:	88 2f       	mov	r24, r24
    536c:	90 e0       	ldi	r25, 0x00	; 0
    536e:	2f 81       	ldd	r18, Y+7	; 0x07
    5370:	38 85       	ldd	r19, Y+8	; 0x08
    5372:	88 0f       	add	r24, r24
    5374:	99 1f       	adc	r25, r25
    5376:	88 0f       	add	r24, r24
    5378:	99 1f       	adc	r25, r25
    537a:	82 0f       	add	r24, r18
    537c:	93 1f       	adc	r25, r19
    537e:	fc 01       	movw	r30, r24
    5380:	b1 96       	adiw	r30, 0x21	; 33
    5382:	8c 85       	ldd	r24, Y+12	; 0x0c
    5384:	9d 85       	ldd	r25, Y+13	; 0x0d
    5386:	ae 85       	ldd	r26, Y+14	; 0x0e
    5388:	bf 85       	ldd	r27, Y+15	; 0x0f
    538a:	80 83       	st	Z, r24
    538c:	91 83       	std	Z+1, r25	; 0x01
    538e:	a2 83       	std	Z+2, r26	; 0x02
    5390:	b3 83       	std	Z+3, r27	; 0x03
    5392:	1a c0       	rjmp	.+52     	; 0x53c8 <xTaskGenericNotify+0x1f6>
                    break;

                case eSetValueWithoutOverwrite:

                    if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    5394:	8d 81       	ldd	r24, Y+5	; 0x05
    5396:	82 30       	cpi	r24, 0x02	; 2
    5398:	b1 f0       	breq	.+44     	; 0x53c6 <xTaskGenericNotify+0x1f4>
                    {
                        pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
    539a:	8b 85       	ldd	r24, Y+11	; 0x0b
    539c:	88 2f       	mov	r24, r24
    539e:	90 e0       	ldi	r25, 0x00	; 0
    53a0:	2f 81       	ldd	r18, Y+7	; 0x07
    53a2:	38 85       	ldd	r19, Y+8	; 0x08
    53a4:	88 0f       	add	r24, r24
    53a6:	99 1f       	adc	r25, r25
    53a8:	88 0f       	add	r24, r24
    53aa:	99 1f       	adc	r25, r25
    53ac:	82 0f       	add	r24, r18
    53ae:	93 1f       	adc	r25, r19
    53b0:	fc 01       	movw	r30, r24
    53b2:	b1 96       	adiw	r30, 0x21	; 33
    53b4:	8c 85       	ldd	r24, Y+12	; 0x0c
    53b6:	9d 85       	ldd	r25, Y+13	; 0x0d
    53b8:	ae 85       	ldd	r26, Y+14	; 0x0e
    53ba:	bf 85       	ldd	r27, Y+15	; 0x0f
    53bc:	80 83       	st	Z, r24
    53be:	91 83       	std	Z+1, r25	; 0x01
    53c0:	a2 83       	std	Z+2, r26	; 0x02
    53c2:	b3 83       	std	Z+3, r27	; 0x03
    53c4:	01 c0       	rjmp	.+2      	; 0x53c8 <xTaskGenericNotify+0x1f6>
                    }
                    else
                    {
                        /* The value could not be written to the task. */
                        xReturn = pdFAIL;
    53c6:	1e 82       	std	Y+6, r1	; 0x06

            traceTASK_NOTIFY( uxIndexToNotify );

            /* If the task is in the blocked state specifically to wait for a
             * notification then unblock it now. */
            if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    53c8:	8d 81       	ldd	r24, Y+5	; 0x05
    53ca:	81 30       	cpi	r24, 0x01	; 1
    53cc:	09 f0       	breq	.+2      	; 0x53d0 <xTaskGenericNotify+0x1fe>
    53ce:	af c0       	rjmp	.+350    	; 0x552e <xTaskGenericNotify+0x35c>
            {
                listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
    53d0:	ef 81       	ldd	r30, Y+7	; 0x07
    53d2:	f8 85       	ldd	r31, Y+8	; 0x08
    53d4:	82 85       	ldd	r24, Z+10	; 0x0a
    53d6:	93 85       	ldd	r25, Z+11	; 0x0b
    53d8:	9c 83       	std	Y+4, r25	; 0x04
    53da:	8b 83       	std	Y+3, r24	; 0x03
    53dc:	ef 81       	ldd	r30, Y+7	; 0x07
    53de:	f8 85       	ldd	r31, Y+8	; 0x08
    53e0:	a4 81       	ldd	r26, Z+4	; 0x04
    53e2:	b5 81       	ldd	r27, Z+5	; 0x05
    53e4:	ef 81       	ldd	r30, Y+7	; 0x07
    53e6:	f8 85       	ldd	r31, Y+8	; 0x08
    53e8:	86 81       	ldd	r24, Z+6	; 0x06
    53ea:	97 81       	ldd	r25, Z+7	; 0x07
    53ec:	15 96       	adiw	r26, 0x05	; 5
    53ee:	9c 93       	st	X, r25
    53f0:	8e 93       	st	-X, r24
    53f2:	14 97       	sbiw	r26, 0x04	; 4
    53f4:	ef 81       	ldd	r30, Y+7	; 0x07
    53f6:	f8 85       	ldd	r31, Y+8	; 0x08
    53f8:	a6 81       	ldd	r26, Z+6	; 0x06
    53fa:	b7 81       	ldd	r27, Z+7	; 0x07
    53fc:	ef 81       	ldd	r30, Y+7	; 0x07
    53fe:	f8 85       	ldd	r31, Y+8	; 0x08
    5400:	84 81       	ldd	r24, Z+4	; 0x04
    5402:	95 81       	ldd	r25, Z+5	; 0x05
    5404:	13 96       	adiw	r26, 0x03	; 3
    5406:	9c 93       	st	X, r25
    5408:	8e 93       	st	-X, r24
    540a:	12 97       	sbiw	r26, 0x02	; 2
    540c:	eb 81       	ldd	r30, Y+3	; 0x03
    540e:	fc 81       	ldd	r31, Y+4	; 0x04
    5410:	21 81       	ldd	r18, Z+1	; 0x01
    5412:	32 81       	ldd	r19, Z+2	; 0x02
    5414:	8f 81       	ldd	r24, Y+7	; 0x07
    5416:	98 85       	ldd	r25, Y+8	; 0x08
    5418:	02 96       	adiw	r24, 0x02	; 2
    541a:	28 17       	cp	r18, r24
    541c:	39 07       	cpc	r19, r25
    541e:	41 f4       	brne	.+16     	; 0x5430 <xTaskGenericNotify+0x25e>
    5420:	ef 81       	ldd	r30, Y+7	; 0x07
    5422:	f8 85       	ldd	r31, Y+8	; 0x08
    5424:	86 81       	ldd	r24, Z+6	; 0x06
    5426:	97 81       	ldd	r25, Z+7	; 0x07
    5428:	eb 81       	ldd	r30, Y+3	; 0x03
    542a:	fc 81       	ldd	r31, Y+4	; 0x04
    542c:	92 83       	std	Z+2, r25	; 0x02
    542e:	81 83       	std	Z+1, r24	; 0x01
    5430:	ef 81       	ldd	r30, Y+7	; 0x07
    5432:	f8 85       	ldd	r31, Y+8	; 0x08
    5434:	13 86       	std	Z+11, r1	; 0x0b
    5436:	12 86       	std	Z+10, r1	; 0x0a
    5438:	eb 81       	ldd	r30, Y+3	; 0x03
    543a:	fc 81       	ldd	r31, Y+4	; 0x04
    543c:	80 81       	ld	r24, Z
    543e:	81 50       	subi	r24, 0x01	; 1
    5440:	eb 81       	ldd	r30, Y+3	; 0x03
    5442:	fc 81       	ldd	r31, Y+4	; 0x04
    5444:	80 83       	st	Z, r24
                prvAddTaskToReadyList( pxTCB );
    5446:	ef 81       	ldd	r30, Y+7	; 0x07
    5448:	f8 85       	ldd	r31, Y+8	; 0x08
    544a:	96 89       	ldd	r25, Z+22	; 0x16
    544c:	80 91 70 08 	lds	r24, 0x0870
    5450:	89 17       	cp	r24, r25
    5452:	28 f4       	brcc	.+10     	; 0x545e <xTaskGenericNotify+0x28c>
    5454:	ef 81       	ldd	r30, Y+7	; 0x07
    5456:	f8 85       	ldd	r31, Y+8	; 0x08
    5458:	86 89       	ldd	r24, Z+22	; 0x16
    545a:	80 93 70 08 	sts	0x0870, r24
    545e:	ef 81       	ldd	r30, Y+7	; 0x07
    5460:	f8 85       	ldd	r31, Y+8	; 0x08
    5462:	86 89       	ldd	r24, Z+22	; 0x16
    5464:	28 2f       	mov	r18, r24
    5466:	30 e0       	ldi	r19, 0x00	; 0
    5468:	c9 01       	movw	r24, r18
    546a:	88 0f       	add	r24, r24
    546c:	99 1f       	adc	r25, r25
    546e:	88 0f       	add	r24, r24
    5470:	99 1f       	adc	r25, r25
    5472:	88 0f       	add	r24, r24
    5474:	99 1f       	adc	r25, r25
    5476:	82 0f       	add	r24, r18
    5478:	93 1f       	adc	r25, r19
    547a:	fc 01       	movw	r30, r24
    547c:	e4 58       	subi	r30, 0x84	; 132
    547e:	f7 4f       	sbci	r31, 0xF7	; 247
    5480:	81 81       	ldd	r24, Z+1	; 0x01
    5482:	92 81       	ldd	r25, Z+2	; 0x02
    5484:	9a 83       	std	Y+2, r25	; 0x02
    5486:	89 83       	std	Y+1, r24	; 0x01
    5488:	ef 81       	ldd	r30, Y+7	; 0x07
    548a:	f8 85       	ldd	r31, Y+8	; 0x08
    548c:	89 81       	ldd	r24, Y+1	; 0x01
    548e:	9a 81       	ldd	r25, Y+2	; 0x02
    5490:	95 83       	std	Z+5, r25	; 0x05
    5492:	84 83       	std	Z+4, r24	; 0x04
    5494:	e9 81       	ldd	r30, Y+1	; 0x01
    5496:	fa 81       	ldd	r31, Y+2	; 0x02
    5498:	84 81       	ldd	r24, Z+4	; 0x04
    549a:	95 81       	ldd	r25, Z+5	; 0x05
    549c:	ef 81       	ldd	r30, Y+7	; 0x07
    549e:	f8 85       	ldd	r31, Y+8	; 0x08
    54a0:	97 83       	std	Z+7, r25	; 0x07
    54a2:	86 83       	std	Z+6, r24	; 0x06
    54a4:	e9 81       	ldd	r30, Y+1	; 0x01
    54a6:	fa 81       	ldd	r31, Y+2	; 0x02
    54a8:	04 80       	ldd	r0, Z+4	; 0x04
    54aa:	f5 81       	ldd	r31, Z+5	; 0x05
    54ac:	e0 2d       	mov	r30, r0
    54ae:	8f 81       	ldd	r24, Y+7	; 0x07
    54b0:	98 85       	ldd	r25, Y+8	; 0x08
    54b2:	02 96       	adiw	r24, 0x02	; 2
    54b4:	93 83       	std	Z+3, r25	; 0x03
    54b6:	82 83       	std	Z+2, r24	; 0x02
    54b8:	8f 81       	ldd	r24, Y+7	; 0x07
    54ba:	98 85       	ldd	r25, Y+8	; 0x08
    54bc:	02 96       	adiw	r24, 0x02	; 2
    54be:	e9 81       	ldd	r30, Y+1	; 0x01
    54c0:	fa 81       	ldd	r31, Y+2	; 0x02
    54c2:	95 83       	std	Z+5, r25	; 0x05
    54c4:	84 83       	std	Z+4, r24	; 0x04
    54c6:	ef 81       	ldd	r30, Y+7	; 0x07
    54c8:	f8 85       	ldd	r31, Y+8	; 0x08
    54ca:	86 89       	ldd	r24, Z+22	; 0x16
    54cc:	28 2f       	mov	r18, r24
    54ce:	30 e0       	ldi	r19, 0x00	; 0
    54d0:	c9 01       	movw	r24, r18
    54d2:	88 0f       	add	r24, r24
    54d4:	99 1f       	adc	r25, r25
    54d6:	88 0f       	add	r24, r24
    54d8:	99 1f       	adc	r25, r25
    54da:	88 0f       	add	r24, r24
    54dc:	99 1f       	adc	r25, r25
    54de:	82 0f       	add	r24, r18
    54e0:	93 1f       	adc	r25, r19
    54e2:	84 58       	subi	r24, 0x84	; 132
    54e4:	97 4f       	sbci	r25, 0xF7	; 247
    54e6:	ef 81       	ldd	r30, Y+7	; 0x07
    54e8:	f8 85       	ldd	r31, Y+8	; 0x08
    54ea:	93 87       	std	Z+11, r25	; 0x0b
    54ec:	82 87       	std	Z+10, r24	; 0x0a
    54ee:	ef 81       	ldd	r30, Y+7	; 0x07
    54f0:	f8 85       	ldd	r31, Y+8	; 0x08
    54f2:	86 89       	ldd	r24, Z+22	; 0x16
    54f4:	28 2f       	mov	r18, r24
    54f6:	30 e0       	ldi	r19, 0x00	; 0
    54f8:	c9 01       	movw	r24, r18
    54fa:	88 0f       	add	r24, r24
    54fc:	99 1f       	adc	r25, r25
    54fe:	88 0f       	add	r24, r24
    5500:	99 1f       	adc	r25, r25
    5502:	88 0f       	add	r24, r24
    5504:	99 1f       	adc	r25, r25
    5506:	82 0f       	add	r24, r18
    5508:	93 1f       	adc	r25, r19
    550a:	fc 01       	movw	r30, r24
    550c:	e4 58       	subi	r30, 0x84	; 132
    550e:	f7 4f       	sbci	r31, 0xF7	; 247
    5510:	80 81       	ld	r24, Z
    5512:	8f 5f       	subi	r24, 0xFF	; 255
    5514:	80 83       	st	Z, r24
                         * earliest possible time. */
                        prvResetNextTaskUnblockTime();
                    }
                #endif

                if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    5516:	ef 81       	ldd	r30, Y+7	; 0x07
    5518:	f8 85       	ldd	r31, Y+8	; 0x08
    551a:	96 89       	ldd	r25, Z+22	; 0x16
    551c:	e0 91 6a 08 	lds	r30, 0x086A
    5520:	f0 91 6b 08 	lds	r31, 0x086B
    5524:	86 89       	ldd	r24, Z+22	; 0x16
    5526:	89 17       	cp	r24, r25
    5528:	10 f4       	brcc	.+4      	; 0x552e <xTaskGenericNotify+0x35c>
                {
                    /* The notified task has a priority above the currently
                     * executing task so a yield is required. */
                    taskYIELD_IF_USING_PREEMPTION();
    552a:	0e 94 72 09 	call	0x12e4	; 0x12e4 <vPortYield>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        taskEXIT_CRITICAL();
    552e:	0f 90       	pop	r0
    5530:	0f be       	out	0x3f, r0	; 63

        return xReturn;
    5532:	8e 81       	ldd	r24, Y+6	; 0x06
    }
    5534:	64 96       	adiw	r28, 0x14	; 20
    5536:	0f b6       	in	r0, 0x3f	; 63
    5538:	f8 94       	cli
    553a:	de bf       	out	0x3e, r29	; 62
    553c:	0f be       	out	0x3f, r0	; 63
    553e:	cd bf       	out	0x3d, r28	; 61
    5540:	cf 91       	pop	r28
    5542:	df 91       	pop	r29
    5544:	1f 91       	pop	r17
    5546:	0f 91       	pop	r16
    5548:	ff 90       	pop	r15
    554a:	ef 90       	pop	r14
    554c:	08 95       	ret

0000554e <xTaskGenericNotifyFromISR>:
                                          UBaseType_t uxIndexToNotify,
                                          uint32_t ulValue,
                                          eNotifyAction eAction,
                                          uint32_t * pulPreviousNotificationValue,
                                          BaseType_t * pxHigherPriorityTaskWoken )
    {
    554e:	cf 92       	push	r12
    5550:	df 92       	push	r13
    5552:	ef 92       	push	r14
    5554:	ff 92       	push	r15
    5556:	0f 93       	push	r16
    5558:	1f 93       	push	r17
    555a:	df 93       	push	r29
    555c:	cf 93       	push	r28
    555e:	cd b7       	in	r28, 0x3d	; 61
    5560:	de b7       	in	r29, 0x3e	; 62
    5562:	69 97       	sbiw	r28, 0x19	; 25
    5564:	0f b6       	in	r0, 0x3f	; 63
    5566:	f8 94       	cli
    5568:	de bf       	out	0x3e, r29	; 62
    556a:	0f be       	out	0x3f, r0	; 63
    556c:	cd bf       	out	0x3d, r28	; 61
    556e:	9d 87       	std	Y+13, r25	; 0x0d
    5570:	8c 87       	std	Y+12, r24	; 0x0c
    5572:	6e 87       	std	Y+14, r22	; 0x0e
    5574:	2f 87       	std	Y+15, r18	; 0x0f
    5576:	38 8b       	std	Y+16, r19	; 0x10
    5578:	49 8b       	std	Y+17, r20	; 0x11
    557a:	5a 8b       	std	Y+18, r21	; 0x12
    557c:	0b 8b       	std	Y+19, r16	; 0x13
    557e:	fd 8a       	std	Y+21, r15	; 0x15
    5580:	ec 8a       	std	Y+20, r14	; 0x14
    5582:	df 8a       	std	Y+23, r13	; 0x17
    5584:	ce 8a       	std	Y+22, r12	; 0x16
        TCB_t * pxTCB;
        uint8_t ucOriginalNotifyState;
        BaseType_t xReturn = pdPASS;
    5586:	81 e0       	ldi	r24, 0x01	; 1
    5588:	88 87       	std	Y+8, r24	; 0x08
         * simple as possible.  More information (albeit Cortex-M specific) is
         * provided on the following link:
         * https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
        portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

        pxTCB = xTaskToNotify;
    558a:	8c 85       	ldd	r24, Y+12	; 0x0c
    558c:	9d 85       	ldd	r25, Y+13	; 0x0d
    558e:	9b 87       	std	Y+11, r25	; 0x0b
    5590:	8a 87       	std	Y+10, r24	; 0x0a

        uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    5592:	1f 82       	std	Y+7, r1	; 0x07
        {
            if( pulPreviousNotificationValue != NULL )
    5594:	8c 89       	ldd	r24, Y+20	; 0x14
    5596:	9d 89       	ldd	r25, Y+21	; 0x15
    5598:	00 97       	sbiw	r24, 0x00	; 0
    559a:	b9 f0       	breq	.+46     	; 0x55ca <xTaskGenericNotifyFromISR+0x7c>
            {
                *pulPreviousNotificationValue = pxTCB->ulNotifiedValue[ uxIndexToNotify ];
    559c:	8e 85       	ldd	r24, Y+14	; 0x0e
    559e:	88 2f       	mov	r24, r24
    55a0:	90 e0       	ldi	r25, 0x00	; 0
    55a2:	2a 85       	ldd	r18, Y+10	; 0x0a
    55a4:	3b 85       	ldd	r19, Y+11	; 0x0b
    55a6:	88 0f       	add	r24, r24
    55a8:	99 1f       	adc	r25, r25
    55aa:	88 0f       	add	r24, r24
    55ac:	99 1f       	adc	r25, r25
    55ae:	82 0f       	add	r24, r18
    55b0:	93 1f       	adc	r25, r19
    55b2:	fc 01       	movw	r30, r24
    55b4:	b1 96       	adiw	r30, 0x21	; 33
    55b6:	80 81       	ld	r24, Z
    55b8:	91 81       	ldd	r25, Z+1	; 0x01
    55ba:	a2 81       	ldd	r26, Z+2	; 0x02
    55bc:	b3 81       	ldd	r27, Z+3	; 0x03
    55be:	ec 89       	ldd	r30, Y+20	; 0x14
    55c0:	fd 89       	ldd	r31, Y+21	; 0x15
    55c2:	80 83       	st	Z, r24
    55c4:	91 83       	std	Z+1, r25	; 0x01
    55c6:	a2 83       	std	Z+2, r26	; 0x02
    55c8:	b3 83       	std	Z+3, r27	; 0x03
            }

            ucOriginalNotifyState = pxTCB->ucNotifyState[ uxIndexToNotify ];
    55ca:	8e 85       	ldd	r24, Y+14	; 0x0e
    55cc:	28 2f       	mov	r18, r24
    55ce:	30 e0       	ldi	r19, 0x00	; 0
    55d0:	8a 85       	ldd	r24, Y+10	; 0x0a
    55d2:	9b 85       	ldd	r25, Y+11	; 0x0b
    55d4:	82 0f       	add	r24, r18
    55d6:	93 1f       	adc	r25, r19
    55d8:	fc 01       	movw	r30, r24
    55da:	b5 96       	adiw	r30, 0x25	; 37
    55dc:	80 81       	ld	r24, Z
    55de:	89 87       	std	Y+9, r24	; 0x09
            pxTCB->ucNotifyState[ uxIndexToNotify ] = taskNOTIFICATION_RECEIVED;
    55e0:	8e 85       	ldd	r24, Y+14	; 0x0e
    55e2:	28 2f       	mov	r18, r24
    55e4:	30 e0       	ldi	r19, 0x00	; 0
    55e6:	8a 85       	ldd	r24, Y+10	; 0x0a
    55e8:	9b 85       	ldd	r25, Y+11	; 0x0b
    55ea:	82 0f       	add	r24, r18
    55ec:	93 1f       	adc	r25, r19
    55ee:	fc 01       	movw	r30, r24
    55f0:	b5 96       	adiw	r30, 0x25	; 37
    55f2:	82 e0       	ldi	r24, 0x02	; 2
    55f4:	80 83       	st	Z, r24

            switch( eAction )
    55f6:	8b 89       	ldd	r24, Y+19	; 0x13
    55f8:	28 2f       	mov	r18, r24
    55fa:	30 e0       	ldi	r19, 0x00	; 0
    55fc:	39 8f       	std	Y+25, r19	; 0x19
    55fe:	28 8f       	std	Y+24, r18	; 0x18
    5600:	88 8d       	ldd	r24, Y+24	; 0x18
    5602:	99 8d       	ldd	r25, Y+25	; 0x19
    5604:	82 30       	cpi	r24, 0x02	; 2
    5606:	91 05       	cpc	r25, r1
    5608:	09 f4       	brne	.+2      	; 0x560c <xTaskGenericNotifyFromISR+0xbe>
    560a:	46 c0       	rjmp	.+140    	; 0x5698 <xTaskGenericNotifyFromISR+0x14a>
    560c:	28 8d       	ldd	r18, Y+24	; 0x18
    560e:	39 8d       	ldd	r19, Y+25	; 0x19
    5610:	23 30       	cpi	r18, 0x03	; 3
    5612:	31 05       	cpc	r19, r1
    5614:	34 f4       	brge	.+12     	; 0x5622 <xTaskGenericNotifyFromISR+0xd4>
    5616:	88 8d       	ldd	r24, Y+24	; 0x18
    5618:	99 8d       	ldd	r25, Y+25	; 0x19
    561a:	81 30       	cpi	r24, 0x01	; 1
    561c:	91 05       	cpc	r25, r1
    561e:	71 f0       	breq	.+28     	; 0x563c <xTaskGenericNotifyFromISR+0xee>
    5620:	93 c0       	rjmp	.+294    	; 0x5748 <xTaskGenericNotifyFromISR+0x1fa>
    5622:	28 8d       	ldd	r18, Y+24	; 0x18
    5624:	39 8d       	ldd	r19, Y+25	; 0x19
    5626:	23 30       	cpi	r18, 0x03	; 3
    5628:	31 05       	cpc	r19, r1
    562a:	09 f4       	brne	.+2      	; 0x562e <xTaskGenericNotifyFromISR+0xe0>
    562c:	5d c0       	rjmp	.+186    	; 0x56e8 <xTaskGenericNotifyFromISR+0x19a>
    562e:	88 8d       	ldd	r24, Y+24	; 0x18
    5630:	99 8d       	ldd	r25, Y+25	; 0x19
    5632:	84 30       	cpi	r24, 0x04	; 4
    5634:	91 05       	cpc	r25, r1
    5636:	09 f4       	brne	.+2      	; 0x563a <xTaskGenericNotifyFromISR+0xec>
    5638:	6d c0       	rjmp	.+218    	; 0x5714 <xTaskGenericNotifyFromISR+0x1c6>
    563a:	86 c0       	rjmp	.+268    	; 0x5748 <xTaskGenericNotifyFromISR+0x1fa>
            {
                case eSetBits:
                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] |= ulValue;
    563c:	8e 85       	ldd	r24, Y+14	; 0x0e
    563e:	08 2f       	mov	r16, r24
    5640:	10 e0       	ldi	r17, 0x00	; 0
    5642:	8e 85       	ldd	r24, Y+14	; 0x0e
    5644:	88 2f       	mov	r24, r24
    5646:	90 e0       	ldi	r25, 0x00	; 0
    5648:	2a 85       	ldd	r18, Y+10	; 0x0a
    564a:	3b 85       	ldd	r19, Y+11	; 0x0b
    564c:	88 0f       	add	r24, r24
    564e:	99 1f       	adc	r25, r25
    5650:	88 0f       	add	r24, r24
    5652:	99 1f       	adc	r25, r25
    5654:	82 0f       	add	r24, r18
    5656:	93 1f       	adc	r25, r19
    5658:	fc 01       	movw	r30, r24
    565a:	b1 96       	adiw	r30, 0x21	; 33
    565c:	20 81       	ld	r18, Z
    565e:	31 81       	ldd	r19, Z+1	; 0x01
    5660:	42 81       	ldd	r20, Z+2	; 0x02
    5662:	53 81       	ldd	r21, Z+3	; 0x03
    5664:	8f 85       	ldd	r24, Y+15	; 0x0f
    5666:	98 89       	ldd	r25, Y+16	; 0x10
    5668:	a9 89       	ldd	r26, Y+17	; 0x11
    566a:	ba 89       	ldd	r27, Y+18	; 0x12
    566c:	ba 01       	movw	r22, r20
    566e:	a9 01       	movw	r20, r18
    5670:	48 2b       	or	r20, r24
    5672:	59 2b       	or	r21, r25
    5674:	6a 2b       	or	r22, r26
    5676:	7b 2b       	or	r23, r27
    5678:	2a 85       	ldd	r18, Y+10	; 0x0a
    567a:	3b 85       	ldd	r19, Y+11	; 0x0b
    567c:	c8 01       	movw	r24, r16
    567e:	88 0f       	add	r24, r24
    5680:	99 1f       	adc	r25, r25
    5682:	88 0f       	add	r24, r24
    5684:	99 1f       	adc	r25, r25
    5686:	82 0f       	add	r24, r18
    5688:	93 1f       	adc	r25, r19
    568a:	fc 01       	movw	r30, r24
    568c:	b1 96       	adiw	r30, 0x21	; 33
    568e:	40 83       	st	Z, r20
    5690:	51 83       	std	Z+1, r21	; 0x01
    5692:	62 83       	std	Z+2, r22	; 0x02
    5694:	73 83       	std	Z+3, r23	; 0x03
    5696:	58 c0       	rjmp	.+176    	; 0x5748 <xTaskGenericNotifyFromISR+0x1fa>
                    break;

                case eIncrement:
                    ( pxTCB->ulNotifiedValue[ uxIndexToNotify ] )++;
    5698:	8e 85       	ldd	r24, Y+14	; 0x0e
    569a:	08 2f       	mov	r16, r24
    569c:	10 e0       	ldi	r17, 0x00	; 0
    569e:	2a 85       	ldd	r18, Y+10	; 0x0a
    56a0:	3b 85       	ldd	r19, Y+11	; 0x0b
    56a2:	c8 01       	movw	r24, r16
    56a4:	88 0f       	add	r24, r24
    56a6:	99 1f       	adc	r25, r25
    56a8:	88 0f       	add	r24, r24
    56aa:	99 1f       	adc	r25, r25
    56ac:	82 0f       	add	r24, r18
    56ae:	93 1f       	adc	r25, r19
    56b0:	fc 01       	movw	r30, r24
    56b2:	b1 96       	adiw	r30, 0x21	; 33
    56b4:	80 81       	ld	r24, Z
    56b6:	91 81       	ldd	r25, Z+1	; 0x01
    56b8:	a2 81       	ldd	r26, Z+2	; 0x02
    56ba:	b3 81       	ldd	r27, Z+3	; 0x03
    56bc:	ac 01       	movw	r20, r24
    56be:	bd 01       	movw	r22, r26
    56c0:	4f 5f       	subi	r20, 0xFF	; 255
    56c2:	5f 4f       	sbci	r21, 0xFF	; 255
    56c4:	6f 4f       	sbci	r22, 0xFF	; 255
    56c6:	7f 4f       	sbci	r23, 0xFF	; 255
    56c8:	2a 85       	ldd	r18, Y+10	; 0x0a
    56ca:	3b 85       	ldd	r19, Y+11	; 0x0b
    56cc:	c8 01       	movw	r24, r16
    56ce:	88 0f       	add	r24, r24
    56d0:	99 1f       	adc	r25, r25
    56d2:	88 0f       	add	r24, r24
    56d4:	99 1f       	adc	r25, r25
    56d6:	82 0f       	add	r24, r18
    56d8:	93 1f       	adc	r25, r19
    56da:	fc 01       	movw	r30, r24
    56dc:	b1 96       	adiw	r30, 0x21	; 33
    56de:	40 83       	st	Z, r20
    56e0:	51 83       	std	Z+1, r21	; 0x01
    56e2:	62 83       	std	Z+2, r22	; 0x02
    56e4:	73 83       	std	Z+3, r23	; 0x03
    56e6:	30 c0       	rjmp	.+96     	; 0x5748 <xTaskGenericNotifyFromISR+0x1fa>
                    break;

                case eSetValueWithOverwrite:
                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
    56e8:	8e 85       	ldd	r24, Y+14	; 0x0e
    56ea:	88 2f       	mov	r24, r24
    56ec:	90 e0       	ldi	r25, 0x00	; 0
    56ee:	2a 85       	ldd	r18, Y+10	; 0x0a
    56f0:	3b 85       	ldd	r19, Y+11	; 0x0b
    56f2:	88 0f       	add	r24, r24
    56f4:	99 1f       	adc	r25, r25
    56f6:	88 0f       	add	r24, r24
    56f8:	99 1f       	adc	r25, r25
    56fa:	82 0f       	add	r24, r18
    56fc:	93 1f       	adc	r25, r19
    56fe:	fc 01       	movw	r30, r24
    5700:	b1 96       	adiw	r30, 0x21	; 33
    5702:	8f 85       	ldd	r24, Y+15	; 0x0f
    5704:	98 89       	ldd	r25, Y+16	; 0x10
    5706:	a9 89       	ldd	r26, Y+17	; 0x11
    5708:	ba 89       	ldd	r27, Y+18	; 0x12
    570a:	80 83       	st	Z, r24
    570c:	91 83       	std	Z+1, r25	; 0x01
    570e:	a2 83       	std	Z+2, r26	; 0x02
    5710:	b3 83       	std	Z+3, r27	; 0x03
    5712:	1a c0       	rjmp	.+52     	; 0x5748 <xTaskGenericNotifyFromISR+0x1fa>
                    break;

                case eSetValueWithoutOverwrite:

                    if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    5714:	89 85       	ldd	r24, Y+9	; 0x09
    5716:	82 30       	cpi	r24, 0x02	; 2
    5718:	b1 f0       	breq	.+44     	; 0x5746 <xTaskGenericNotifyFromISR+0x1f8>
                    {
                        pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
    571a:	8e 85       	ldd	r24, Y+14	; 0x0e
    571c:	88 2f       	mov	r24, r24
    571e:	90 e0       	ldi	r25, 0x00	; 0
    5720:	2a 85       	ldd	r18, Y+10	; 0x0a
    5722:	3b 85       	ldd	r19, Y+11	; 0x0b
    5724:	88 0f       	add	r24, r24
    5726:	99 1f       	adc	r25, r25
    5728:	88 0f       	add	r24, r24
    572a:	99 1f       	adc	r25, r25
    572c:	82 0f       	add	r24, r18
    572e:	93 1f       	adc	r25, r19
    5730:	fc 01       	movw	r30, r24
    5732:	b1 96       	adiw	r30, 0x21	; 33
    5734:	8f 85       	ldd	r24, Y+15	; 0x0f
    5736:	98 89       	ldd	r25, Y+16	; 0x10
    5738:	a9 89       	ldd	r26, Y+17	; 0x11
    573a:	ba 89       	ldd	r27, Y+18	; 0x12
    573c:	80 83       	st	Z, r24
    573e:	91 83       	std	Z+1, r25	; 0x01
    5740:	a2 83       	std	Z+2, r26	; 0x02
    5742:	b3 83       	std	Z+3, r27	; 0x03
    5744:	01 c0       	rjmp	.+2      	; 0x5748 <xTaskGenericNotifyFromISR+0x1fa>
                    }
                    else
                    {
                        /* The value could not be written to the task. */
                        xReturn = pdFAIL;
    5746:	18 86       	std	Y+8, r1	; 0x08

            traceTASK_NOTIFY_FROM_ISR( uxIndexToNotify );

            /* If the task is in the blocked state specifically to wait for a
             * notification then unblock it now. */
            if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    5748:	89 85       	ldd	r24, Y+9	; 0x09
    574a:	81 30       	cpi	r24, 0x01	; 1
    574c:	09 f0       	breq	.+2      	; 0x5750 <xTaskGenericNotifyFromISR+0x202>
    574e:	ee c0       	rjmp	.+476    	; 0x592c <xTaskGenericNotifyFromISR+0x3de>
            {
                /* The task should not have been on an event list. */
                configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

                if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    5750:	80 91 7b 08 	lds	r24, 0x087B
    5754:	88 23       	and	r24, r24
    5756:	09 f0       	breq	.+2      	; 0x575a <xTaskGenericNotifyFromISR+0x20c>
    5758:	a4 c0       	rjmp	.+328    	; 0x58a2 <xTaskGenericNotifyFromISR+0x354>
                {
                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
    575a:	ea 85       	ldd	r30, Y+10	; 0x0a
    575c:	fb 85       	ldd	r31, Y+11	; 0x0b
    575e:	82 85       	ldd	r24, Z+10	; 0x0a
    5760:	93 85       	ldd	r25, Z+11	; 0x0b
    5762:	9e 83       	std	Y+6, r25	; 0x06
    5764:	8d 83       	std	Y+5, r24	; 0x05
    5766:	ea 85       	ldd	r30, Y+10	; 0x0a
    5768:	fb 85       	ldd	r31, Y+11	; 0x0b
    576a:	a4 81       	ldd	r26, Z+4	; 0x04
    576c:	b5 81       	ldd	r27, Z+5	; 0x05
    576e:	ea 85       	ldd	r30, Y+10	; 0x0a
    5770:	fb 85       	ldd	r31, Y+11	; 0x0b
    5772:	86 81       	ldd	r24, Z+6	; 0x06
    5774:	97 81       	ldd	r25, Z+7	; 0x07
    5776:	15 96       	adiw	r26, 0x05	; 5
    5778:	9c 93       	st	X, r25
    577a:	8e 93       	st	-X, r24
    577c:	14 97       	sbiw	r26, 0x04	; 4
    577e:	ea 85       	ldd	r30, Y+10	; 0x0a
    5780:	fb 85       	ldd	r31, Y+11	; 0x0b
    5782:	a6 81       	ldd	r26, Z+6	; 0x06
    5784:	b7 81       	ldd	r27, Z+7	; 0x07
    5786:	ea 85       	ldd	r30, Y+10	; 0x0a
    5788:	fb 85       	ldd	r31, Y+11	; 0x0b
    578a:	84 81       	ldd	r24, Z+4	; 0x04
    578c:	95 81       	ldd	r25, Z+5	; 0x05
    578e:	13 96       	adiw	r26, 0x03	; 3
    5790:	9c 93       	st	X, r25
    5792:	8e 93       	st	-X, r24
    5794:	12 97       	sbiw	r26, 0x02	; 2
    5796:	ed 81       	ldd	r30, Y+5	; 0x05
    5798:	fe 81       	ldd	r31, Y+6	; 0x06
    579a:	21 81       	ldd	r18, Z+1	; 0x01
    579c:	32 81       	ldd	r19, Z+2	; 0x02
    579e:	8a 85       	ldd	r24, Y+10	; 0x0a
    57a0:	9b 85       	ldd	r25, Y+11	; 0x0b
    57a2:	02 96       	adiw	r24, 0x02	; 2
    57a4:	28 17       	cp	r18, r24
    57a6:	39 07       	cpc	r19, r25
    57a8:	41 f4       	brne	.+16     	; 0x57ba <xTaskGenericNotifyFromISR+0x26c>
    57aa:	ea 85       	ldd	r30, Y+10	; 0x0a
    57ac:	fb 85       	ldd	r31, Y+11	; 0x0b
    57ae:	86 81       	ldd	r24, Z+6	; 0x06
    57b0:	97 81       	ldd	r25, Z+7	; 0x07
    57b2:	ed 81       	ldd	r30, Y+5	; 0x05
    57b4:	fe 81       	ldd	r31, Y+6	; 0x06
    57b6:	92 83       	std	Z+2, r25	; 0x02
    57b8:	81 83       	std	Z+1, r24	; 0x01
    57ba:	ea 85       	ldd	r30, Y+10	; 0x0a
    57bc:	fb 85       	ldd	r31, Y+11	; 0x0b
    57be:	13 86       	std	Z+11, r1	; 0x0b
    57c0:	12 86       	std	Z+10, r1	; 0x0a
    57c2:	ed 81       	ldd	r30, Y+5	; 0x05
    57c4:	fe 81       	ldd	r31, Y+6	; 0x06
    57c6:	80 81       	ld	r24, Z
    57c8:	81 50       	subi	r24, 0x01	; 1
    57ca:	ed 81       	ldd	r30, Y+5	; 0x05
    57cc:	fe 81       	ldd	r31, Y+6	; 0x06
    57ce:	80 83       	st	Z, r24
                    prvAddTaskToReadyList( pxTCB );
    57d0:	ea 85       	ldd	r30, Y+10	; 0x0a
    57d2:	fb 85       	ldd	r31, Y+11	; 0x0b
    57d4:	96 89       	ldd	r25, Z+22	; 0x16
    57d6:	80 91 70 08 	lds	r24, 0x0870
    57da:	89 17       	cp	r24, r25
    57dc:	28 f4       	brcc	.+10     	; 0x57e8 <xTaskGenericNotifyFromISR+0x29a>
    57de:	ea 85       	ldd	r30, Y+10	; 0x0a
    57e0:	fb 85       	ldd	r31, Y+11	; 0x0b
    57e2:	86 89       	ldd	r24, Z+22	; 0x16
    57e4:	80 93 70 08 	sts	0x0870, r24
    57e8:	ea 85       	ldd	r30, Y+10	; 0x0a
    57ea:	fb 85       	ldd	r31, Y+11	; 0x0b
    57ec:	86 89       	ldd	r24, Z+22	; 0x16
    57ee:	28 2f       	mov	r18, r24
    57f0:	30 e0       	ldi	r19, 0x00	; 0
    57f2:	c9 01       	movw	r24, r18
    57f4:	88 0f       	add	r24, r24
    57f6:	99 1f       	adc	r25, r25
    57f8:	88 0f       	add	r24, r24
    57fa:	99 1f       	adc	r25, r25
    57fc:	88 0f       	add	r24, r24
    57fe:	99 1f       	adc	r25, r25
    5800:	82 0f       	add	r24, r18
    5802:	93 1f       	adc	r25, r19
    5804:	fc 01       	movw	r30, r24
    5806:	e4 58       	subi	r30, 0x84	; 132
    5808:	f7 4f       	sbci	r31, 0xF7	; 247
    580a:	81 81       	ldd	r24, Z+1	; 0x01
    580c:	92 81       	ldd	r25, Z+2	; 0x02
    580e:	9c 83       	std	Y+4, r25	; 0x04
    5810:	8b 83       	std	Y+3, r24	; 0x03
    5812:	ea 85       	ldd	r30, Y+10	; 0x0a
    5814:	fb 85       	ldd	r31, Y+11	; 0x0b
    5816:	8b 81       	ldd	r24, Y+3	; 0x03
    5818:	9c 81       	ldd	r25, Y+4	; 0x04
    581a:	95 83       	std	Z+5, r25	; 0x05
    581c:	84 83       	std	Z+4, r24	; 0x04
    581e:	eb 81       	ldd	r30, Y+3	; 0x03
    5820:	fc 81       	ldd	r31, Y+4	; 0x04
    5822:	84 81       	ldd	r24, Z+4	; 0x04
    5824:	95 81       	ldd	r25, Z+5	; 0x05
    5826:	ea 85       	ldd	r30, Y+10	; 0x0a
    5828:	fb 85       	ldd	r31, Y+11	; 0x0b
    582a:	97 83       	std	Z+7, r25	; 0x07
    582c:	86 83       	std	Z+6, r24	; 0x06
    582e:	eb 81       	ldd	r30, Y+3	; 0x03
    5830:	fc 81       	ldd	r31, Y+4	; 0x04
    5832:	04 80       	ldd	r0, Z+4	; 0x04
    5834:	f5 81       	ldd	r31, Z+5	; 0x05
    5836:	e0 2d       	mov	r30, r0
    5838:	8a 85       	ldd	r24, Y+10	; 0x0a
    583a:	9b 85       	ldd	r25, Y+11	; 0x0b
    583c:	02 96       	adiw	r24, 0x02	; 2
    583e:	93 83       	std	Z+3, r25	; 0x03
    5840:	82 83       	std	Z+2, r24	; 0x02
    5842:	8a 85       	ldd	r24, Y+10	; 0x0a
    5844:	9b 85       	ldd	r25, Y+11	; 0x0b
    5846:	02 96       	adiw	r24, 0x02	; 2
    5848:	eb 81       	ldd	r30, Y+3	; 0x03
    584a:	fc 81       	ldd	r31, Y+4	; 0x04
    584c:	95 83       	std	Z+5, r25	; 0x05
    584e:	84 83       	std	Z+4, r24	; 0x04
    5850:	ea 85       	ldd	r30, Y+10	; 0x0a
    5852:	fb 85       	ldd	r31, Y+11	; 0x0b
    5854:	86 89       	ldd	r24, Z+22	; 0x16
    5856:	28 2f       	mov	r18, r24
    5858:	30 e0       	ldi	r19, 0x00	; 0
    585a:	c9 01       	movw	r24, r18
    585c:	88 0f       	add	r24, r24
    585e:	99 1f       	adc	r25, r25
    5860:	88 0f       	add	r24, r24
    5862:	99 1f       	adc	r25, r25
    5864:	88 0f       	add	r24, r24
    5866:	99 1f       	adc	r25, r25
    5868:	82 0f       	add	r24, r18
    586a:	93 1f       	adc	r25, r19
    586c:	84 58       	subi	r24, 0x84	; 132
    586e:	97 4f       	sbci	r25, 0xF7	; 247
    5870:	ea 85       	ldd	r30, Y+10	; 0x0a
    5872:	fb 85       	ldd	r31, Y+11	; 0x0b
    5874:	93 87       	std	Z+11, r25	; 0x0b
    5876:	82 87       	std	Z+10, r24	; 0x0a
    5878:	ea 85       	ldd	r30, Y+10	; 0x0a
    587a:	fb 85       	ldd	r31, Y+11	; 0x0b
    587c:	86 89       	ldd	r24, Z+22	; 0x16
    587e:	28 2f       	mov	r18, r24
    5880:	30 e0       	ldi	r19, 0x00	; 0
    5882:	c9 01       	movw	r24, r18
    5884:	88 0f       	add	r24, r24
    5886:	99 1f       	adc	r25, r25
    5888:	88 0f       	add	r24, r24
    588a:	99 1f       	adc	r25, r25
    588c:	88 0f       	add	r24, r24
    588e:	99 1f       	adc	r25, r25
    5890:	82 0f       	add	r24, r18
    5892:	93 1f       	adc	r25, r19
    5894:	fc 01       	movw	r30, r24
    5896:	e4 58       	subi	r30, 0x84	; 132
    5898:	f7 4f       	sbci	r31, 0xF7	; 247
    589a:	80 81       	ld	r24, Z
    589c:	8f 5f       	subi	r24, 0xFF	; 255
    589e:	80 83       	st	Z, r24
    58a0:	30 c0       	rjmp	.+96     	; 0x5902 <xTaskGenericNotifyFromISR+0x3b4>
                }
                else
                {
                    /* The delayed and ready lists cannot be accessed, so hold
                     * this task pending until the scheduler is resumed. */
                    listINSERT_END( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    58a2:	80 91 b7 08 	lds	r24, 0x08B7
    58a6:	90 91 b8 08 	lds	r25, 0x08B8
    58aa:	9a 83       	std	Y+2, r25	; 0x02
    58ac:	89 83       	std	Y+1, r24	; 0x01
    58ae:	ea 85       	ldd	r30, Y+10	; 0x0a
    58b0:	fb 85       	ldd	r31, Y+11	; 0x0b
    58b2:	89 81       	ldd	r24, Y+1	; 0x01
    58b4:	9a 81       	ldd	r25, Y+2	; 0x02
    58b6:	97 87       	std	Z+15, r25	; 0x0f
    58b8:	86 87       	std	Z+14, r24	; 0x0e
    58ba:	e9 81       	ldd	r30, Y+1	; 0x01
    58bc:	fa 81       	ldd	r31, Y+2	; 0x02
    58be:	84 81       	ldd	r24, Z+4	; 0x04
    58c0:	95 81       	ldd	r25, Z+5	; 0x05
    58c2:	ea 85       	ldd	r30, Y+10	; 0x0a
    58c4:	fb 85       	ldd	r31, Y+11	; 0x0b
    58c6:	91 8b       	std	Z+17, r25	; 0x11
    58c8:	80 8b       	std	Z+16, r24	; 0x10
    58ca:	e9 81       	ldd	r30, Y+1	; 0x01
    58cc:	fa 81       	ldd	r31, Y+2	; 0x02
    58ce:	04 80       	ldd	r0, Z+4	; 0x04
    58d0:	f5 81       	ldd	r31, Z+5	; 0x05
    58d2:	e0 2d       	mov	r30, r0
    58d4:	8a 85       	ldd	r24, Y+10	; 0x0a
    58d6:	9b 85       	ldd	r25, Y+11	; 0x0b
    58d8:	0c 96       	adiw	r24, 0x0c	; 12
    58da:	93 83       	std	Z+3, r25	; 0x03
    58dc:	82 83       	std	Z+2, r24	; 0x02
    58de:	8a 85       	ldd	r24, Y+10	; 0x0a
    58e0:	9b 85       	ldd	r25, Y+11	; 0x0b
    58e2:	0c 96       	adiw	r24, 0x0c	; 12
    58e4:	e9 81       	ldd	r30, Y+1	; 0x01
    58e6:	fa 81       	ldd	r31, Y+2	; 0x02
    58e8:	95 83       	std	Z+5, r25	; 0x05
    58ea:	84 83       	std	Z+4, r24	; 0x04
    58ec:	ea 85       	ldd	r30, Y+10	; 0x0a
    58ee:	fb 85       	ldd	r31, Y+11	; 0x0b
    58f0:	86 eb       	ldi	r24, 0xB6	; 182
    58f2:	98 e0       	ldi	r25, 0x08	; 8
    58f4:	95 8b       	std	Z+21, r25	; 0x15
    58f6:	84 8b       	std	Z+20, r24	; 0x14
    58f8:	80 91 b6 08 	lds	r24, 0x08B6
    58fc:	8f 5f       	subi	r24, 0xFF	; 255
    58fe:	80 93 b6 08 	sts	0x08B6, r24
                }

                if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    5902:	ea 85       	ldd	r30, Y+10	; 0x0a
    5904:	fb 85       	ldd	r31, Y+11	; 0x0b
    5906:	96 89       	ldd	r25, Z+22	; 0x16
    5908:	e0 91 6a 08 	lds	r30, 0x086A
    590c:	f0 91 6b 08 	lds	r31, 0x086B
    5910:	86 89       	ldd	r24, Z+22	; 0x16
    5912:	89 17       	cp	r24, r25
    5914:	58 f4       	brcc	.+22     	; 0x592c <xTaskGenericNotifyFromISR+0x3de>
                {
                    /* The notified task has a priority above the currently
                     * executing task so a yield is required. */
                    if( pxHigherPriorityTaskWoken != NULL )
    5916:	8e 89       	ldd	r24, Y+22	; 0x16
    5918:	9f 89       	ldd	r25, Y+23	; 0x17
    591a:	00 97       	sbiw	r24, 0x00	; 0
    591c:	21 f0       	breq	.+8      	; 0x5926 <xTaskGenericNotifyFromISR+0x3d8>
                    {
                        *pxHigherPriorityTaskWoken = pdTRUE;
    591e:	ee 89       	ldd	r30, Y+22	; 0x16
    5920:	ff 89       	ldd	r31, Y+23	; 0x17
    5922:	81 e0       	ldi	r24, 0x01	; 1
    5924:	80 83       	st	Z, r24
                    }

                    /* Mark that a yield is pending in case the user is not
                     * using the "xHigherPriorityTaskWoken" parameter to an ISR
                     * safe FreeRTOS function. */
                    xYieldPending = pdTRUE;
    5926:	81 e0       	ldi	r24, 0x01	; 1
    5928:	80 93 74 08 	sts	0x0874, r24
                }
            }
        }
        portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

        return xReturn;
    592c:	88 85       	ldd	r24, Y+8	; 0x08
    }
    592e:	69 96       	adiw	r28, 0x19	; 25
    5930:	0f b6       	in	r0, 0x3f	; 63
    5932:	f8 94       	cli
    5934:	de bf       	out	0x3e, r29	; 62
    5936:	0f be       	out	0x3f, r0	; 63
    5938:	cd bf       	out	0x3d, r28	; 61
    593a:	cf 91       	pop	r28
    593c:	df 91       	pop	r29
    593e:	1f 91       	pop	r17
    5940:	0f 91       	pop	r16
    5942:	ff 90       	pop	r15
    5944:	ef 90       	pop	r14
    5946:	df 90       	pop	r13
    5948:	cf 90       	pop	r12
    594a:	08 95       	ret

0000594c <vTaskGenericNotifyGiveFromISR>:
#if ( configUSE_TASK_NOTIFICATIONS == 1 )

    void vTaskGenericNotifyGiveFromISR( TaskHandle_t xTaskToNotify,
                                        UBaseType_t uxIndexToNotify,
                                        BaseType_t * pxHigherPriorityTaskWoken )
    {
    594c:	0f 93       	push	r16
    594e:	1f 93       	push	r17
    5950:	df 93       	push	r29
    5952:	cf 93       	push	r28
    5954:	cd b7       	in	r28, 0x3d	; 61
    5956:	de b7       	in	r29, 0x3e	; 62
    5958:	2f 97       	sbiw	r28, 0x0f	; 15
    595a:	0f b6       	in	r0, 0x3f	; 63
    595c:	f8 94       	cli
    595e:	de bf       	out	0x3e, r29	; 62
    5960:	0f be       	out	0x3f, r0	; 63
    5962:	cd bf       	out	0x3d, r28	; 61
    5964:	9c 87       	std	Y+12, r25	; 0x0c
    5966:	8b 87       	std	Y+11, r24	; 0x0b
    5968:	6d 87       	std	Y+13, r22	; 0x0d
    596a:	5f 87       	std	Y+15, r21	; 0x0f
    596c:	4e 87       	std	Y+14, r20	; 0x0e
         * simple as possible.  More information (albeit Cortex-M specific) is
         * provided on the following link:
         * https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
        portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

        pxTCB = xTaskToNotify;
    596e:	8b 85       	ldd	r24, Y+11	; 0x0b
    5970:	9c 85       	ldd	r25, Y+12	; 0x0c
    5972:	9a 87       	std	Y+10, r25	; 0x0a
    5974:	89 87       	std	Y+9, r24	; 0x09

        uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    5976:	1f 82       	std	Y+7, r1	; 0x07
        {
            ucOriginalNotifyState = pxTCB->ucNotifyState[ uxIndexToNotify ];
    5978:	8d 85       	ldd	r24, Y+13	; 0x0d
    597a:	28 2f       	mov	r18, r24
    597c:	30 e0       	ldi	r19, 0x00	; 0
    597e:	89 85       	ldd	r24, Y+9	; 0x09
    5980:	9a 85       	ldd	r25, Y+10	; 0x0a
    5982:	82 0f       	add	r24, r18
    5984:	93 1f       	adc	r25, r19
    5986:	fc 01       	movw	r30, r24
    5988:	b5 96       	adiw	r30, 0x25	; 37
    598a:	80 81       	ld	r24, Z
    598c:	88 87       	std	Y+8, r24	; 0x08
            pxTCB->ucNotifyState[ uxIndexToNotify ] = taskNOTIFICATION_RECEIVED;
    598e:	8d 85       	ldd	r24, Y+13	; 0x0d
    5990:	28 2f       	mov	r18, r24
    5992:	30 e0       	ldi	r19, 0x00	; 0
    5994:	89 85       	ldd	r24, Y+9	; 0x09
    5996:	9a 85       	ldd	r25, Y+10	; 0x0a
    5998:	82 0f       	add	r24, r18
    599a:	93 1f       	adc	r25, r19
    599c:	fc 01       	movw	r30, r24
    599e:	b5 96       	adiw	r30, 0x25	; 37
    59a0:	82 e0       	ldi	r24, 0x02	; 2
    59a2:	80 83       	st	Z, r24

            /* 'Giving' is equivalent to incrementing a count in a counting
             * semaphore. */
            ( pxTCB->ulNotifiedValue[ uxIndexToNotify ] )++;
    59a4:	8d 85       	ldd	r24, Y+13	; 0x0d
    59a6:	08 2f       	mov	r16, r24
    59a8:	10 e0       	ldi	r17, 0x00	; 0
    59aa:	29 85       	ldd	r18, Y+9	; 0x09
    59ac:	3a 85       	ldd	r19, Y+10	; 0x0a
    59ae:	c8 01       	movw	r24, r16
    59b0:	88 0f       	add	r24, r24
    59b2:	99 1f       	adc	r25, r25
    59b4:	88 0f       	add	r24, r24
    59b6:	99 1f       	adc	r25, r25
    59b8:	82 0f       	add	r24, r18
    59ba:	93 1f       	adc	r25, r19
    59bc:	fc 01       	movw	r30, r24
    59be:	b1 96       	adiw	r30, 0x21	; 33
    59c0:	80 81       	ld	r24, Z
    59c2:	91 81       	ldd	r25, Z+1	; 0x01
    59c4:	a2 81       	ldd	r26, Z+2	; 0x02
    59c6:	b3 81       	ldd	r27, Z+3	; 0x03
    59c8:	ac 01       	movw	r20, r24
    59ca:	bd 01       	movw	r22, r26
    59cc:	4f 5f       	subi	r20, 0xFF	; 255
    59ce:	5f 4f       	sbci	r21, 0xFF	; 255
    59d0:	6f 4f       	sbci	r22, 0xFF	; 255
    59d2:	7f 4f       	sbci	r23, 0xFF	; 255
    59d4:	29 85       	ldd	r18, Y+9	; 0x09
    59d6:	3a 85       	ldd	r19, Y+10	; 0x0a
    59d8:	c8 01       	movw	r24, r16
    59da:	88 0f       	add	r24, r24
    59dc:	99 1f       	adc	r25, r25
    59de:	88 0f       	add	r24, r24
    59e0:	99 1f       	adc	r25, r25
    59e2:	82 0f       	add	r24, r18
    59e4:	93 1f       	adc	r25, r19
    59e6:	fc 01       	movw	r30, r24
    59e8:	b1 96       	adiw	r30, 0x21	; 33
    59ea:	40 83       	st	Z, r20
    59ec:	51 83       	std	Z+1, r21	; 0x01
    59ee:	62 83       	std	Z+2, r22	; 0x02
    59f0:	73 83       	std	Z+3, r23	; 0x03

            traceTASK_NOTIFY_GIVE_FROM_ISR( uxIndexToNotify );

            /* If the task is in the blocked state specifically to wait for a
             * notification then unblock it now. */
            if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    59f2:	88 85       	ldd	r24, Y+8	; 0x08
    59f4:	81 30       	cpi	r24, 0x01	; 1
    59f6:	09 f0       	breq	.+2      	; 0x59fa <vTaskGenericNotifyGiveFromISR+0xae>
    59f8:	ee c0       	rjmp	.+476    	; 0x5bd6 <vTaskGenericNotifyGiveFromISR+0x28a>
            {
                /* The task should not have been on an event list. */
                configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

                if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    59fa:	80 91 7b 08 	lds	r24, 0x087B
    59fe:	88 23       	and	r24, r24
    5a00:	09 f0       	breq	.+2      	; 0x5a04 <vTaskGenericNotifyGiveFromISR+0xb8>
    5a02:	a4 c0       	rjmp	.+328    	; 0x5b4c <vTaskGenericNotifyGiveFromISR+0x200>
                {
                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
    5a04:	e9 85       	ldd	r30, Y+9	; 0x09
    5a06:	fa 85       	ldd	r31, Y+10	; 0x0a
    5a08:	82 85       	ldd	r24, Z+10	; 0x0a
    5a0a:	93 85       	ldd	r25, Z+11	; 0x0b
    5a0c:	9e 83       	std	Y+6, r25	; 0x06
    5a0e:	8d 83       	std	Y+5, r24	; 0x05
    5a10:	e9 85       	ldd	r30, Y+9	; 0x09
    5a12:	fa 85       	ldd	r31, Y+10	; 0x0a
    5a14:	a4 81       	ldd	r26, Z+4	; 0x04
    5a16:	b5 81       	ldd	r27, Z+5	; 0x05
    5a18:	e9 85       	ldd	r30, Y+9	; 0x09
    5a1a:	fa 85       	ldd	r31, Y+10	; 0x0a
    5a1c:	86 81       	ldd	r24, Z+6	; 0x06
    5a1e:	97 81       	ldd	r25, Z+7	; 0x07
    5a20:	15 96       	adiw	r26, 0x05	; 5
    5a22:	9c 93       	st	X, r25
    5a24:	8e 93       	st	-X, r24
    5a26:	14 97       	sbiw	r26, 0x04	; 4
    5a28:	e9 85       	ldd	r30, Y+9	; 0x09
    5a2a:	fa 85       	ldd	r31, Y+10	; 0x0a
    5a2c:	a6 81       	ldd	r26, Z+6	; 0x06
    5a2e:	b7 81       	ldd	r27, Z+7	; 0x07
    5a30:	e9 85       	ldd	r30, Y+9	; 0x09
    5a32:	fa 85       	ldd	r31, Y+10	; 0x0a
    5a34:	84 81       	ldd	r24, Z+4	; 0x04
    5a36:	95 81       	ldd	r25, Z+5	; 0x05
    5a38:	13 96       	adiw	r26, 0x03	; 3
    5a3a:	9c 93       	st	X, r25
    5a3c:	8e 93       	st	-X, r24
    5a3e:	12 97       	sbiw	r26, 0x02	; 2
    5a40:	ed 81       	ldd	r30, Y+5	; 0x05
    5a42:	fe 81       	ldd	r31, Y+6	; 0x06
    5a44:	21 81       	ldd	r18, Z+1	; 0x01
    5a46:	32 81       	ldd	r19, Z+2	; 0x02
    5a48:	89 85       	ldd	r24, Y+9	; 0x09
    5a4a:	9a 85       	ldd	r25, Y+10	; 0x0a
    5a4c:	02 96       	adiw	r24, 0x02	; 2
    5a4e:	28 17       	cp	r18, r24
    5a50:	39 07       	cpc	r19, r25
    5a52:	41 f4       	brne	.+16     	; 0x5a64 <vTaskGenericNotifyGiveFromISR+0x118>
    5a54:	e9 85       	ldd	r30, Y+9	; 0x09
    5a56:	fa 85       	ldd	r31, Y+10	; 0x0a
    5a58:	86 81       	ldd	r24, Z+6	; 0x06
    5a5a:	97 81       	ldd	r25, Z+7	; 0x07
    5a5c:	ed 81       	ldd	r30, Y+5	; 0x05
    5a5e:	fe 81       	ldd	r31, Y+6	; 0x06
    5a60:	92 83       	std	Z+2, r25	; 0x02
    5a62:	81 83       	std	Z+1, r24	; 0x01
    5a64:	e9 85       	ldd	r30, Y+9	; 0x09
    5a66:	fa 85       	ldd	r31, Y+10	; 0x0a
    5a68:	13 86       	std	Z+11, r1	; 0x0b
    5a6a:	12 86       	std	Z+10, r1	; 0x0a
    5a6c:	ed 81       	ldd	r30, Y+5	; 0x05
    5a6e:	fe 81       	ldd	r31, Y+6	; 0x06
    5a70:	80 81       	ld	r24, Z
    5a72:	81 50       	subi	r24, 0x01	; 1
    5a74:	ed 81       	ldd	r30, Y+5	; 0x05
    5a76:	fe 81       	ldd	r31, Y+6	; 0x06
    5a78:	80 83       	st	Z, r24
                    prvAddTaskToReadyList( pxTCB );
    5a7a:	e9 85       	ldd	r30, Y+9	; 0x09
    5a7c:	fa 85       	ldd	r31, Y+10	; 0x0a
    5a7e:	96 89       	ldd	r25, Z+22	; 0x16
    5a80:	80 91 70 08 	lds	r24, 0x0870
    5a84:	89 17       	cp	r24, r25
    5a86:	28 f4       	brcc	.+10     	; 0x5a92 <vTaskGenericNotifyGiveFromISR+0x146>
    5a88:	e9 85       	ldd	r30, Y+9	; 0x09
    5a8a:	fa 85       	ldd	r31, Y+10	; 0x0a
    5a8c:	86 89       	ldd	r24, Z+22	; 0x16
    5a8e:	80 93 70 08 	sts	0x0870, r24
    5a92:	e9 85       	ldd	r30, Y+9	; 0x09
    5a94:	fa 85       	ldd	r31, Y+10	; 0x0a
    5a96:	86 89       	ldd	r24, Z+22	; 0x16
    5a98:	28 2f       	mov	r18, r24
    5a9a:	30 e0       	ldi	r19, 0x00	; 0
    5a9c:	c9 01       	movw	r24, r18
    5a9e:	88 0f       	add	r24, r24
    5aa0:	99 1f       	adc	r25, r25
    5aa2:	88 0f       	add	r24, r24
    5aa4:	99 1f       	adc	r25, r25
    5aa6:	88 0f       	add	r24, r24
    5aa8:	99 1f       	adc	r25, r25
    5aaa:	82 0f       	add	r24, r18
    5aac:	93 1f       	adc	r25, r19
    5aae:	fc 01       	movw	r30, r24
    5ab0:	e4 58       	subi	r30, 0x84	; 132
    5ab2:	f7 4f       	sbci	r31, 0xF7	; 247
    5ab4:	81 81       	ldd	r24, Z+1	; 0x01
    5ab6:	92 81       	ldd	r25, Z+2	; 0x02
    5ab8:	9c 83       	std	Y+4, r25	; 0x04
    5aba:	8b 83       	std	Y+3, r24	; 0x03
    5abc:	e9 85       	ldd	r30, Y+9	; 0x09
    5abe:	fa 85       	ldd	r31, Y+10	; 0x0a
    5ac0:	8b 81       	ldd	r24, Y+3	; 0x03
    5ac2:	9c 81       	ldd	r25, Y+4	; 0x04
    5ac4:	95 83       	std	Z+5, r25	; 0x05
    5ac6:	84 83       	std	Z+4, r24	; 0x04
    5ac8:	eb 81       	ldd	r30, Y+3	; 0x03
    5aca:	fc 81       	ldd	r31, Y+4	; 0x04
    5acc:	84 81       	ldd	r24, Z+4	; 0x04
    5ace:	95 81       	ldd	r25, Z+5	; 0x05
    5ad0:	e9 85       	ldd	r30, Y+9	; 0x09
    5ad2:	fa 85       	ldd	r31, Y+10	; 0x0a
    5ad4:	97 83       	std	Z+7, r25	; 0x07
    5ad6:	86 83       	std	Z+6, r24	; 0x06
    5ad8:	eb 81       	ldd	r30, Y+3	; 0x03
    5ada:	fc 81       	ldd	r31, Y+4	; 0x04
    5adc:	04 80       	ldd	r0, Z+4	; 0x04
    5ade:	f5 81       	ldd	r31, Z+5	; 0x05
    5ae0:	e0 2d       	mov	r30, r0
    5ae2:	89 85       	ldd	r24, Y+9	; 0x09
    5ae4:	9a 85       	ldd	r25, Y+10	; 0x0a
    5ae6:	02 96       	adiw	r24, 0x02	; 2
    5ae8:	93 83       	std	Z+3, r25	; 0x03
    5aea:	82 83       	std	Z+2, r24	; 0x02
    5aec:	89 85       	ldd	r24, Y+9	; 0x09
    5aee:	9a 85       	ldd	r25, Y+10	; 0x0a
    5af0:	02 96       	adiw	r24, 0x02	; 2
    5af2:	eb 81       	ldd	r30, Y+3	; 0x03
    5af4:	fc 81       	ldd	r31, Y+4	; 0x04
    5af6:	95 83       	std	Z+5, r25	; 0x05
    5af8:	84 83       	std	Z+4, r24	; 0x04
    5afa:	e9 85       	ldd	r30, Y+9	; 0x09
    5afc:	fa 85       	ldd	r31, Y+10	; 0x0a
    5afe:	86 89       	ldd	r24, Z+22	; 0x16
    5b00:	28 2f       	mov	r18, r24
    5b02:	30 e0       	ldi	r19, 0x00	; 0
    5b04:	c9 01       	movw	r24, r18
    5b06:	88 0f       	add	r24, r24
    5b08:	99 1f       	adc	r25, r25
    5b0a:	88 0f       	add	r24, r24
    5b0c:	99 1f       	adc	r25, r25
    5b0e:	88 0f       	add	r24, r24
    5b10:	99 1f       	adc	r25, r25
    5b12:	82 0f       	add	r24, r18
    5b14:	93 1f       	adc	r25, r19
    5b16:	84 58       	subi	r24, 0x84	; 132
    5b18:	97 4f       	sbci	r25, 0xF7	; 247
    5b1a:	e9 85       	ldd	r30, Y+9	; 0x09
    5b1c:	fa 85       	ldd	r31, Y+10	; 0x0a
    5b1e:	93 87       	std	Z+11, r25	; 0x0b
    5b20:	82 87       	std	Z+10, r24	; 0x0a
    5b22:	e9 85       	ldd	r30, Y+9	; 0x09
    5b24:	fa 85       	ldd	r31, Y+10	; 0x0a
    5b26:	86 89       	ldd	r24, Z+22	; 0x16
    5b28:	28 2f       	mov	r18, r24
    5b2a:	30 e0       	ldi	r19, 0x00	; 0
    5b2c:	c9 01       	movw	r24, r18
    5b2e:	88 0f       	add	r24, r24
    5b30:	99 1f       	adc	r25, r25
    5b32:	88 0f       	add	r24, r24
    5b34:	99 1f       	adc	r25, r25
    5b36:	88 0f       	add	r24, r24
    5b38:	99 1f       	adc	r25, r25
    5b3a:	82 0f       	add	r24, r18
    5b3c:	93 1f       	adc	r25, r19
    5b3e:	fc 01       	movw	r30, r24
    5b40:	e4 58       	subi	r30, 0x84	; 132
    5b42:	f7 4f       	sbci	r31, 0xF7	; 247
    5b44:	80 81       	ld	r24, Z
    5b46:	8f 5f       	subi	r24, 0xFF	; 255
    5b48:	80 83       	st	Z, r24
    5b4a:	30 c0       	rjmp	.+96     	; 0x5bac <vTaskGenericNotifyGiveFromISR+0x260>
                }
                else
                {
                    /* The delayed and ready lists cannot be accessed, so hold
                     * this task pending until the scheduler is resumed. */
                    listINSERT_END( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    5b4c:	80 91 b7 08 	lds	r24, 0x08B7
    5b50:	90 91 b8 08 	lds	r25, 0x08B8
    5b54:	9a 83       	std	Y+2, r25	; 0x02
    5b56:	89 83       	std	Y+1, r24	; 0x01
    5b58:	e9 85       	ldd	r30, Y+9	; 0x09
    5b5a:	fa 85       	ldd	r31, Y+10	; 0x0a
    5b5c:	89 81       	ldd	r24, Y+1	; 0x01
    5b5e:	9a 81       	ldd	r25, Y+2	; 0x02
    5b60:	97 87       	std	Z+15, r25	; 0x0f
    5b62:	86 87       	std	Z+14, r24	; 0x0e
    5b64:	e9 81       	ldd	r30, Y+1	; 0x01
    5b66:	fa 81       	ldd	r31, Y+2	; 0x02
    5b68:	84 81       	ldd	r24, Z+4	; 0x04
    5b6a:	95 81       	ldd	r25, Z+5	; 0x05
    5b6c:	e9 85       	ldd	r30, Y+9	; 0x09
    5b6e:	fa 85       	ldd	r31, Y+10	; 0x0a
    5b70:	91 8b       	std	Z+17, r25	; 0x11
    5b72:	80 8b       	std	Z+16, r24	; 0x10
    5b74:	e9 81       	ldd	r30, Y+1	; 0x01
    5b76:	fa 81       	ldd	r31, Y+2	; 0x02
    5b78:	04 80       	ldd	r0, Z+4	; 0x04
    5b7a:	f5 81       	ldd	r31, Z+5	; 0x05
    5b7c:	e0 2d       	mov	r30, r0
    5b7e:	89 85       	ldd	r24, Y+9	; 0x09
    5b80:	9a 85       	ldd	r25, Y+10	; 0x0a
    5b82:	0c 96       	adiw	r24, 0x0c	; 12
    5b84:	93 83       	std	Z+3, r25	; 0x03
    5b86:	82 83       	std	Z+2, r24	; 0x02
    5b88:	89 85       	ldd	r24, Y+9	; 0x09
    5b8a:	9a 85       	ldd	r25, Y+10	; 0x0a
    5b8c:	0c 96       	adiw	r24, 0x0c	; 12
    5b8e:	e9 81       	ldd	r30, Y+1	; 0x01
    5b90:	fa 81       	ldd	r31, Y+2	; 0x02
    5b92:	95 83       	std	Z+5, r25	; 0x05
    5b94:	84 83       	std	Z+4, r24	; 0x04
    5b96:	e9 85       	ldd	r30, Y+9	; 0x09
    5b98:	fa 85       	ldd	r31, Y+10	; 0x0a
    5b9a:	86 eb       	ldi	r24, 0xB6	; 182
    5b9c:	98 e0       	ldi	r25, 0x08	; 8
    5b9e:	95 8b       	std	Z+21, r25	; 0x15
    5ba0:	84 8b       	std	Z+20, r24	; 0x14
    5ba2:	80 91 b6 08 	lds	r24, 0x08B6
    5ba6:	8f 5f       	subi	r24, 0xFF	; 255
    5ba8:	80 93 b6 08 	sts	0x08B6, r24
                }

                if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    5bac:	e9 85       	ldd	r30, Y+9	; 0x09
    5bae:	fa 85       	ldd	r31, Y+10	; 0x0a
    5bb0:	96 89       	ldd	r25, Z+22	; 0x16
    5bb2:	e0 91 6a 08 	lds	r30, 0x086A
    5bb6:	f0 91 6b 08 	lds	r31, 0x086B
    5bba:	86 89       	ldd	r24, Z+22	; 0x16
    5bbc:	89 17       	cp	r24, r25
    5bbe:	58 f4       	brcc	.+22     	; 0x5bd6 <vTaskGenericNotifyGiveFromISR+0x28a>
                {
                    /* The notified task has a priority above the currently
                     * executing task so a yield is required. */
                    if( pxHigherPriorityTaskWoken != NULL )
    5bc0:	8e 85       	ldd	r24, Y+14	; 0x0e
    5bc2:	9f 85       	ldd	r25, Y+15	; 0x0f
    5bc4:	00 97       	sbiw	r24, 0x00	; 0
    5bc6:	21 f0       	breq	.+8      	; 0x5bd0 <vTaskGenericNotifyGiveFromISR+0x284>
                    {
                        *pxHigherPriorityTaskWoken = pdTRUE;
    5bc8:	ee 85       	ldd	r30, Y+14	; 0x0e
    5bca:	ff 85       	ldd	r31, Y+15	; 0x0f
    5bcc:	81 e0       	ldi	r24, 0x01	; 1
    5bce:	80 83       	st	Z, r24
                    }

                    /* Mark that a yield is pending in case the user is not
                     * using the "xHigherPriorityTaskWoken" parameter in an ISR
                     * safe FreeRTOS function. */
                    xYieldPending = pdTRUE;
    5bd0:	81 e0       	ldi	r24, 0x01	; 1
    5bd2:	80 93 74 08 	sts	0x0874, r24
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
    }
    5bd6:	2f 96       	adiw	r28, 0x0f	; 15
    5bd8:	0f b6       	in	r0, 0x3f	; 63
    5bda:	f8 94       	cli
    5bdc:	de bf       	out	0x3e, r29	; 62
    5bde:	0f be       	out	0x3f, r0	; 63
    5be0:	cd bf       	out	0x3d, r28	; 61
    5be2:	cf 91       	pop	r28
    5be4:	df 91       	pop	r29
    5be6:	1f 91       	pop	r17
    5be8:	0f 91       	pop	r16
    5bea:	08 95       	ret

00005bec <xTaskGenericNotifyStateClear>:

#if ( configUSE_TASK_NOTIFICATIONS == 1 )

    BaseType_t xTaskGenericNotifyStateClear( TaskHandle_t xTask,
                                             UBaseType_t uxIndexToClear )
    {
    5bec:	df 93       	push	r29
    5bee:	cf 93       	push	r28
    5bf0:	cd b7       	in	r28, 0x3d	; 61
    5bf2:	de b7       	in	r29, 0x3e	; 62
    5bf4:	28 97       	sbiw	r28, 0x08	; 8
    5bf6:	0f b6       	in	r0, 0x3f	; 63
    5bf8:	f8 94       	cli
    5bfa:	de bf       	out	0x3e, r29	; 62
    5bfc:	0f be       	out	0x3f, r0	; 63
    5bfe:	cd bf       	out	0x3d, r28	; 61
    5c00:	9d 83       	std	Y+5, r25	; 0x05
    5c02:	8c 83       	std	Y+4, r24	; 0x04
    5c04:	6e 83       	std	Y+6, r22	; 0x06

        configASSERT( uxIndexToClear < configTASK_NOTIFICATION_ARRAY_ENTRIES );

        /* If null is passed in here then it is the calling task that is having
         * its notification state cleared. */
        pxTCB = prvGetTCBFromHandle( xTask );
    5c06:	8c 81       	ldd	r24, Y+4	; 0x04
    5c08:	9d 81       	ldd	r25, Y+5	; 0x05
    5c0a:	00 97       	sbiw	r24, 0x00	; 0
    5c0c:	39 f4       	brne	.+14     	; 0x5c1c <xTaskGenericNotifyStateClear+0x30>
    5c0e:	80 91 6a 08 	lds	r24, 0x086A
    5c12:	90 91 6b 08 	lds	r25, 0x086B
    5c16:	98 87       	std	Y+8, r25	; 0x08
    5c18:	8f 83       	std	Y+7, r24	; 0x07
    5c1a:	04 c0       	rjmp	.+8      	; 0x5c24 <xTaskGenericNotifyStateClear+0x38>
    5c1c:	8c 81       	ldd	r24, Y+4	; 0x04
    5c1e:	9d 81       	ldd	r25, Y+5	; 0x05
    5c20:	98 87       	std	Y+8, r25	; 0x08
    5c22:	8f 83       	std	Y+7, r24	; 0x07
    5c24:	8f 81       	ldd	r24, Y+7	; 0x07
    5c26:	98 85       	ldd	r25, Y+8	; 0x08
    5c28:	9b 83       	std	Y+3, r25	; 0x03
    5c2a:	8a 83       	std	Y+2, r24	; 0x02

        taskENTER_CRITICAL();
    5c2c:	0f b6       	in	r0, 0x3f	; 63
    5c2e:	f8 94       	cli
    5c30:	0f 92       	push	r0
        {
            if( pxTCB->ucNotifyState[ uxIndexToClear ] == taskNOTIFICATION_RECEIVED )
    5c32:	8e 81       	ldd	r24, Y+6	; 0x06
    5c34:	28 2f       	mov	r18, r24
    5c36:	30 e0       	ldi	r19, 0x00	; 0
    5c38:	8a 81       	ldd	r24, Y+2	; 0x02
    5c3a:	9b 81       	ldd	r25, Y+3	; 0x03
    5c3c:	82 0f       	add	r24, r18
    5c3e:	93 1f       	adc	r25, r19
    5c40:	fc 01       	movw	r30, r24
    5c42:	b5 96       	adiw	r30, 0x25	; 37
    5c44:	80 81       	ld	r24, Z
    5c46:	82 30       	cpi	r24, 0x02	; 2
    5c48:	69 f4       	brne	.+26     	; 0x5c64 <xTaskGenericNotifyStateClear+0x78>
            {
                pxTCB->ucNotifyState[ uxIndexToClear ] = taskNOT_WAITING_NOTIFICATION;
    5c4a:	8e 81       	ldd	r24, Y+6	; 0x06
    5c4c:	28 2f       	mov	r18, r24
    5c4e:	30 e0       	ldi	r19, 0x00	; 0
    5c50:	8a 81       	ldd	r24, Y+2	; 0x02
    5c52:	9b 81       	ldd	r25, Y+3	; 0x03
    5c54:	82 0f       	add	r24, r18
    5c56:	93 1f       	adc	r25, r19
    5c58:	fc 01       	movw	r30, r24
    5c5a:	b5 96       	adiw	r30, 0x25	; 37
    5c5c:	10 82       	st	Z, r1
                xReturn = pdPASS;
    5c5e:	81 e0       	ldi	r24, 0x01	; 1
    5c60:	89 83       	std	Y+1, r24	; 0x01
    5c62:	01 c0       	rjmp	.+2      	; 0x5c66 <xTaskGenericNotifyStateClear+0x7a>
            }
            else
            {
                xReturn = pdFAIL;
    5c64:	19 82       	std	Y+1, r1	; 0x01
            }
        }
        taskEXIT_CRITICAL();
    5c66:	0f 90       	pop	r0
    5c68:	0f be       	out	0x3f, r0	; 63

        return xReturn;
    5c6a:	89 81       	ldd	r24, Y+1	; 0x01
    }
    5c6c:	28 96       	adiw	r28, 0x08	; 8
    5c6e:	0f b6       	in	r0, 0x3f	; 63
    5c70:	f8 94       	cli
    5c72:	de bf       	out	0x3e, r29	; 62
    5c74:	0f be       	out	0x3f, r0	; 63
    5c76:	cd bf       	out	0x3d, r28	; 61
    5c78:	cf 91       	pop	r28
    5c7a:	df 91       	pop	r29
    5c7c:	08 95       	ret

00005c7e <ulTaskGenericNotifyValueClear>:
#if ( configUSE_TASK_NOTIFICATIONS == 1 )

    uint32_t ulTaskGenericNotifyValueClear( TaskHandle_t xTask,
                                            UBaseType_t uxIndexToClear,
                                            uint32_t ulBitsToClear )
    {
    5c7e:	0f 93       	push	r16
    5c80:	1f 93       	push	r17
    5c82:	df 93       	push	r29
    5c84:	cf 93       	push	r28
    5c86:	cd b7       	in	r28, 0x3d	; 61
    5c88:	de b7       	in	r29, 0x3e	; 62
    5c8a:	2f 97       	sbiw	r28, 0x0f	; 15
    5c8c:	0f b6       	in	r0, 0x3f	; 63
    5c8e:	f8 94       	cli
    5c90:	de bf       	out	0x3e, r29	; 62
    5c92:	0f be       	out	0x3f, r0	; 63
    5c94:	cd bf       	out	0x3d, r28	; 61
    5c96:	98 87       	std	Y+8, r25	; 0x08
    5c98:	8f 83       	std	Y+7, r24	; 0x07
    5c9a:	69 87       	std	Y+9, r22	; 0x09
    5c9c:	2a 87       	std	Y+10, r18	; 0x0a
    5c9e:	3b 87       	std	Y+11, r19	; 0x0b
    5ca0:	4c 87       	std	Y+12, r20	; 0x0c
    5ca2:	5d 87       	std	Y+13, r21	; 0x0d
        TCB_t * pxTCB;
        uint32_t ulReturn;

        /* If null is passed in here then it is the calling task that is having
         * its notification state cleared. */
        pxTCB = prvGetTCBFromHandle( xTask );
    5ca4:	8f 81       	ldd	r24, Y+7	; 0x07
    5ca6:	98 85       	ldd	r25, Y+8	; 0x08
    5ca8:	00 97       	sbiw	r24, 0x00	; 0
    5caa:	39 f4       	brne	.+14     	; 0x5cba <ulTaskGenericNotifyValueClear+0x3c>
    5cac:	80 91 6a 08 	lds	r24, 0x086A
    5cb0:	90 91 6b 08 	lds	r25, 0x086B
    5cb4:	9f 87       	std	Y+15, r25	; 0x0f
    5cb6:	8e 87       	std	Y+14, r24	; 0x0e
    5cb8:	04 c0       	rjmp	.+8      	; 0x5cc2 <ulTaskGenericNotifyValueClear+0x44>
    5cba:	8f 81       	ldd	r24, Y+7	; 0x07
    5cbc:	98 85       	ldd	r25, Y+8	; 0x08
    5cbe:	9f 87       	std	Y+15, r25	; 0x0f
    5cc0:	8e 87       	std	Y+14, r24	; 0x0e
    5cc2:	8e 85       	ldd	r24, Y+14	; 0x0e
    5cc4:	9f 85       	ldd	r25, Y+15	; 0x0f
    5cc6:	9e 83       	std	Y+6, r25	; 0x06
    5cc8:	8d 83       	std	Y+5, r24	; 0x05

        taskENTER_CRITICAL();
    5cca:	0f b6       	in	r0, 0x3f	; 63
    5ccc:	f8 94       	cli
    5cce:	0f 92       	push	r0
        {
            /* Return the notification as it was before the bits were cleared,
             * then clear the bit mask. */
            ulReturn = pxTCB->ulNotifiedValue[ uxIndexToClear ];
    5cd0:	89 85       	ldd	r24, Y+9	; 0x09
    5cd2:	88 2f       	mov	r24, r24
    5cd4:	90 e0       	ldi	r25, 0x00	; 0
    5cd6:	2d 81       	ldd	r18, Y+5	; 0x05
    5cd8:	3e 81       	ldd	r19, Y+6	; 0x06
    5cda:	88 0f       	add	r24, r24
    5cdc:	99 1f       	adc	r25, r25
    5cde:	88 0f       	add	r24, r24
    5ce0:	99 1f       	adc	r25, r25
    5ce2:	82 0f       	add	r24, r18
    5ce4:	93 1f       	adc	r25, r19
    5ce6:	fc 01       	movw	r30, r24
    5ce8:	b1 96       	adiw	r30, 0x21	; 33
    5cea:	80 81       	ld	r24, Z
    5cec:	91 81       	ldd	r25, Z+1	; 0x01
    5cee:	a2 81       	ldd	r26, Z+2	; 0x02
    5cf0:	b3 81       	ldd	r27, Z+3	; 0x03
    5cf2:	89 83       	std	Y+1, r24	; 0x01
    5cf4:	9a 83       	std	Y+2, r25	; 0x02
    5cf6:	ab 83       	std	Y+3, r26	; 0x03
    5cf8:	bc 83       	std	Y+4, r27	; 0x04
            pxTCB->ulNotifiedValue[ uxIndexToClear ] &= ~ulBitsToClear;
    5cfa:	89 85       	ldd	r24, Y+9	; 0x09
    5cfc:	08 2f       	mov	r16, r24
    5cfe:	10 e0       	ldi	r17, 0x00	; 0
    5d00:	89 85       	ldd	r24, Y+9	; 0x09
    5d02:	88 2f       	mov	r24, r24
    5d04:	90 e0       	ldi	r25, 0x00	; 0
    5d06:	2d 81       	ldd	r18, Y+5	; 0x05
    5d08:	3e 81       	ldd	r19, Y+6	; 0x06
    5d0a:	88 0f       	add	r24, r24
    5d0c:	99 1f       	adc	r25, r25
    5d0e:	88 0f       	add	r24, r24
    5d10:	99 1f       	adc	r25, r25
    5d12:	82 0f       	add	r24, r18
    5d14:	93 1f       	adc	r25, r19
    5d16:	fc 01       	movw	r30, r24
    5d18:	b1 96       	adiw	r30, 0x21	; 33
    5d1a:	20 81       	ld	r18, Z
    5d1c:	31 81       	ldd	r19, Z+1	; 0x01
    5d1e:	42 81       	ldd	r20, Z+2	; 0x02
    5d20:	53 81       	ldd	r21, Z+3	; 0x03
    5d22:	8a 85       	ldd	r24, Y+10	; 0x0a
    5d24:	9b 85       	ldd	r25, Y+11	; 0x0b
    5d26:	ac 85       	ldd	r26, Y+12	; 0x0c
    5d28:	bd 85       	ldd	r27, Y+13	; 0x0d
    5d2a:	80 95       	com	r24
    5d2c:	90 95       	com	r25
    5d2e:	a0 95       	com	r26
    5d30:	b0 95       	com	r27
    5d32:	ba 01       	movw	r22, r20
    5d34:	a9 01       	movw	r20, r18
    5d36:	48 23       	and	r20, r24
    5d38:	59 23       	and	r21, r25
    5d3a:	6a 23       	and	r22, r26
    5d3c:	7b 23       	and	r23, r27
    5d3e:	2d 81       	ldd	r18, Y+5	; 0x05
    5d40:	3e 81       	ldd	r19, Y+6	; 0x06
    5d42:	c8 01       	movw	r24, r16
    5d44:	88 0f       	add	r24, r24
    5d46:	99 1f       	adc	r25, r25
    5d48:	88 0f       	add	r24, r24
    5d4a:	99 1f       	adc	r25, r25
    5d4c:	82 0f       	add	r24, r18
    5d4e:	93 1f       	adc	r25, r19
    5d50:	fc 01       	movw	r30, r24
    5d52:	b1 96       	adiw	r30, 0x21	; 33
    5d54:	40 83       	st	Z, r20
    5d56:	51 83       	std	Z+1, r21	; 0x01
    5d58:	62 83       	std	Z+2, r22	; 0x02
    5d5a:	73 83       	std	Z+3, r23	; 0x03
        }
        taskEXIT_CRITICAL();
    5d5c:	0f 90       	pop	r0
    5d5e:	0f be       	out	0x3f, r0	; 63

        return ulReturn;
    5d60:	89 81       	ldd	r24, Y+1	; 0x01
    5d62:	9a 81       	ldd	r25, Y+2	; 0x02
    5d64:	ab 81       	ldd	r26, Y+3	; 0x03
    5d66:	bc 81       	ldd	r27, Y+4	; 0x04
    }
    5d68:	bc 01       	movw	r22, r24
    5d6a:	cd 01       	movw	r24, r26
    5d6c:	2f 96       	adiw	r28, 0x0f	; 15
    5d6e:	0f b6       	in	r0, 0x3f	; 63
    5d70:	f8 94       	cli
    5d72:	de bf       	out	0x3e, r29	; 62
    5d74:	0f be       	out	0x3f, r0	; 63
    5d76:	cd bf       	out	0x3d, r28	; 61
    5d78:	cf 91       	pop	r28
    5d7a:	df 91       	pop	r29
    5d7c:	1f 91       	pop	r17
    5d7e:	0f 91       	pop	r16
    5d80:	08 95       	ret

00005d82 <prvAddCurrentTaskToDelayedList>:
#endif /* if ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( INCLUDE_xTaskGetIdleTaskHandle == 1 ) ) */
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait,
                                            const BaseType_t xCanBlockIndefinitely )
{
    5d82:	df 93       	push	r29
    5d84:	cf 93       	push	r28
    5d86:	cd b7       	in	r28, 0x3d	; 61
    5d88:	de b7       	in	r29, 0x3e	; 62
    5d8a:	27 97       	sbiw	r28, 0x07	; 7
    5d8c:	0f b6       	in	r0, 0x3f	; 63
    5d8e:	f8 94       	cli
    5d90:	de bf       	out	0x3e, r29	; 62
    5d92:	0f be       	out	0x3f, r0	; 63
    5d94:	cd bf       	out	0x3d, r28	; 61
    5d96:	9e 83       	std	Y+6, r25	; 0x06
    5d98:	8d 83       	std	Y+5, r24	; 0x05
    5d9a:	6f 83       	std	Y+7, r22	; 0x07
    TickType_t xTimeToWake;
    const TickType_t xConstTickCount = xTickCount;
    5d9c:	80 91 6e 08 	lds	r24, 0x086E
    5da0:	90 91 6f 08 	lds	r25, 0x086F
    5da4:	9a 83       	std	Y+2, r25	; 0x02
    5da6:	89 83       	std	Y+1, r24	; 0x01
        }
    #endif

    /* Remove the task from the ready list before adding it to the blocked list
     * as the same list item is used for both lists. */
    if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    5da8:	80 91 6a 08 	lds	r24, 0x086A
    5dac:	90 91 6b 08 	lds	r25, 0x086B
    5db0:	02 96       	adiw	r24, 0x02	; 2
    5db2:	0e 94 95 11 	call	0x232a	; 0x232a <uxListRemove>
    #else /* INCLUDE_vTaskSuspend */
        {
            /* Calculate the time at which the task should be woken if the event
             * does not occur.  This may overflow but this doesn't matter, the kernel
             * will manage it correctly. */
            xTimeToWake = xConstTickCount + xTicksToWait;
    5db6:	29 81       	ldd	r18, Y+1	; 0x01
    5db8:	3a 81       	ldd	r19, Y+2	; 0x02
    5dba:	8d 81       	ldd	r24, Y+5	; 0x05
    5dbc:	9e 81       	ldd	r25, Y+6	; 0x06
    5dbe:	82 0f       	add	r24, r18
    5dc0:	93 1f       	adc	r25, r19
    5dc2:	9c 83       	std	Y+4, r25	; 0x04
    5dc4:	8b 83       	std	Y+3, r24	; 0x03

            /* The list item will be inserted in wake time order. */
            listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
    5dc6:	e0 91 6a 08 	lds	r30, 0x086A
    5dca:	f0 91 6b 08 	lds	r31, 0x086B
    5dce:	8b 81       	ldd	r24, Y+3	; 0x03
    5dd0:	9c 81       	ldd	r25, Y+4	; 0x04
    5dd2:	93 83       	std	Z+3, r25	; 0x03
    5dd4:	82 83       	std	Z+2, r24	; 0x02

            if( xTimeToWake < xConstTickCount )
    5dd6:	2b 81       	ldd	r18, Y+3	; 0x03
    5dd8:	3c 81       	ldd	r19, Y+4	; 0x04
    5dda:	89 81       	ldd	r24, Y+1	; 0x01
    5ddc:	9a 81       	ldd	r25, Y+2	; 0x02
    5dde:	28 17       	cp	r18, r24
    5de0:	39 07       	cpc	r19, r25
    5de2:	70 f4       	brcc	.+28     	; 0x5e00 <prvAddCurrentTaskToDelayedList+0x7e>
            {
                /* Wake time has overflowed.  Place this item in the overflow list. */
                vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    5de4:	80 91 b4 08 	lds	r24, 0x08B4
    5de8:	90 91 b5 08 	lds	r25, 0x08B5
    5dec:	20 91 6a 08 	lds	r18, 0x086A
    5df0:	30 91 6b 08 	lds	r19, 0x086B
    5df4:	2e 5f       	subi	r18, 0xFE	; 254
    5df6:	3f 4f       	sbci	r19, 0xFF	; 255
    5df8:	b9 01       	movw	r22, r18
    5dfa:	0e 94 29 11 	call	0x2252	; 0x2252 <vListInsert>
    5dfe:	1e c0       	rjmp	.+60     	; 0x5e3c <prvAddCurrentTaskToDelayedList+0xba>
            }
            else
            {
                /* The wake time has not overflowed, so the current block list is used. */
                vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    5e00:	40 91 b2 08 	lds	r20, 0x08B2
    5e04:	50 91 b3 08 	lds	r21, 0x08B3
    5e08:	80 91 6a 08 	lds	r24, 0x086A
    5e0c:	90 91 6b 08 	lds	r25, 0x086B
    5e10:	9c 01       	movw	r18, r24
    5e12:	2e 5f       	subi	r18, 0xFE	; 254
    5e14:	3f 4f       	sbci	r19, 0xFF	; 255
    5e16:	ca 01       	movw	r24, r20
    5e18:	b9 01       	movw	r22, r18
    5e1a:	0e 94 29 11 	call	0x2252	; 0x2252 <vListInsert>

                /* If the task entering the blocked state was placed at the head of the
                 * list of blocked tasks then xNextTaskUnblockTime needs to be updated
                 * too. */
                if( xTimeToWake < xNextTaskUnblockTime )
    5e1e:	20 91 77 08 	lds	r18, 0x0877
    5e22:	30 91 78 08 	lds	r19, 0x0878
    5e26:	8b 81       	ldd	r24, Y+3	; 0x03
    5e28:	9c 81       	ldd	r25, Y+4	; 0x04
    5e2a:	82 17       	cp	r24, r18
    5e2c:	93 07       	cpc	r25, r19
    5e2e:	30 f4       	brcc	.+12     	; 0x5e3c <prvAddCurrentTaskToDelayedList+0xba>
                {
                    xNextTaskUnblockTime = xTimeToWake;
    5e30:	8b 81       	ldd	r24, Y+3	; 0x03
    5e32:	9c 81       	ldd	r25, Y+4	; 0x04
    5e34:	90 93 78 08 	sts	0x0878, r25
    5e38:	80 93 77 08 	sts	0x0877, r24

            /* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
            ( void ) xCanBlockIndefinitely;
        }
    #endif /* INCLUDE_vTaskSuspend */
}
    5e3c:	27 96       	adiw	r28, 0x07	; 7
    5e3e:	0f b6       	in	r0, 0x3f	; 63
    5e40:	f8 94       	cli
    5e42:	de bf       	out	0x3e, r29	; 62
    5e44:	0f be       	out	0x3f, r0	; 63
    5e46:	cd bf       	out	0x3d, r28	; 61
    5e48:	cf 91       	pop	r28
    5e4a:	df 91       	pop	r29
    5e4c:	08 95       	ret

00005e4e <xTimerCreateTimerTask>:
                                       TimerCallbackFunction_t pxCallbackFunction,
                                       Timer_t * pxNewTimer ) PRIVILEGED_FUNCTION;
/*-----------------------------------------------------------*/

    BaseType_t xTimerCreateTimerTask( void )
    {
    5e4e:	ef 92       	push	r14
    5e50:	ff 92       	push	r15
    5e52:	0f 93       	push	r16
    5e54:	df 93       	push	r29
    5e56:	cf 93       	push	r28
    5e58:	0f 92       	push	r0
    5e5a:	cd b7       	in	r28, 0x3d	; 61
    5e5c:	de b7       	in	r29, 0x3e	; 62
        BaseType_t xReturn = pdFAIL;
    5e5e:	19 82       	std	Y+1, r1	; 0x01

        /* This function is called when the scheduler is started if
         * configUSE_TIMERS is set to 1.  Check that the infrastructure used by the
         * timer service task has been created/initialised.  If timers have already
         * been created then the initialisation will already have been performed. */
        prvCheckForValidListAndQueue();
    5e60:	0e 94 e6 33 	call	0x67cc	; 0x67cc <prvCheckForValidListAndQueue>

        if( xTimerQueue != NULL )
    5e64:	80 91 c8 08 	lds	r24, 0x08C8
    5e68:	90 91 c9 08 	lds	r25, 0x08C9
    5e6c:	00 97       	sbiw	r24, 0x00	; 0
    5e6e:	81 f0       	breq	.+32     	; 0x5e90 <xTimerCreateTimerTask+0x42>
                        xReturn = pdPASS;
                    }
                }
            #else /* if ( configSUPPORT_STATIC_ALLOCATION == 1 ) */
                {
                    xReturn = xTaskCreate( prvTimerTask,
    5e70:	88 e7       	ldi	r24, 0x78	; 120
    5e72:	91 e3       	ldi	r25, 0x31	; 49
    5e74:	25 e0       	ldi	r18, 0x05	; 5
    5e76:	31 e0       	ldi	r19, 0x01	; 1
    5e78:	ea ec       	ldi	r30, 0xCA	; 202
    5e7a:	f8 e0       	ldi	r31, 0x08	; 8
    5e7c:	b9 01       	movw	r22, r18
    5e7e:	45 e5       	ldi	r20, 0x55	; 85
    5e80:	50 e0       	ldi	r21, 0x00	; 0
    5e82:	20 e0       	ldi	r18, 0x00	; 0
    5e84:	30 e0       	ldi	r19, 0x00	; 0
    5e86:	03 e0       	ldi	r16, 0x03	; 3
    5e88:	7f 01       	movw	r14, r30
    5e8a:	0e 94 37 1b 	call	0x366e	; 0x366e <xTaskCreate>
    5e8e:	89 83       	std	Y+1, r24	; 0x01
        {
            mtCOVERAGE_TEST_MARKER();
        }

        configASSERT( xReturn );
        return xReturn;
    5e90:	89 81       	ldd	r24, Y+1	; 0x01
    }
    5e92:	0f 90       	pop	r0
    5e94:	cf 91       	pop	r28
    5e96:	df 91       	pop	r29
    5e98:	0f 91       	pop	r16
    5e9a:	ff 90       	pop	r15
    5e9c:	ef 90       	pop	r14
    5e9e:	08 95       	ret

00005ea0 <xTimerCreate>:
        TimerHandle_t xTimerCreate( const char * const pcTimerName, /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
                                    const TickType_t xTimerPeriodInTicks,
                                    const UBaseType_t uxAutoReload,
                                    void * const pvTimerID,
                                    TimerCallbackFunction_t pxCallbackFunction )
        {
    5ea0:	ef 92       	push	r14
    5ea2:	ff 92       	push	r15
    5ea4:	0f 93       	push	r16
    5ea6:	1f 93       	push	r17
    5ea8:	df 93       	push	r29
    5eaa:	cf 93       	push	r28
    5eac:	cd b7       	in	r28, 0x3d	; 61
    5eae:	de b7       	in	r29, 0x3e	; 62
    5eb0:	2b 97       	sbiw	r28, 0x0b	; 11
    5eb2:	0f b6       	in	r0, 0x3f	; 63
    5eb4:	f8 94       	cli
    5eb6:	de bf       	out	0x3e, r29	; 62
    5eb8:	0f be       	out	0x3f, r0	; 63
    5eba:	cd bf       	out	0x3d, r28	; 61
    5ebc:	9c 83       	std	Y+4, r25	; 0x04
    5ebe:	8b 83       	std	Y+3, r24	; 0x03
    5ec0:	7e 83       	std	Y+6, r23	; 0x06
    5ec2:	6d 83       	std	Y+5, r22	; 0x05
    5ec4:	4f 83       	std	Y+7, r20	; 0x07
    5ec6:	39 87       	std	Y+9, r19	; 0x09
    5ec8:	28 87       	std	Y+8, r18	; 0x08
    5eca:	1b 87       	std	Y+11, r17	; 0x0b
    5ecc:	0a 87       	std	Y+10, r16	; 0x0a
            Timer_t * pxNewTimer;

            pxNewTimer = ( Timer_t * ) pvPortMalloc( sizeof( Timer_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of Timer_t is always a pointer to the timer's mame. */
    5ece:	83 e1       	ldi	r24, 0x13	; 19
    5ed0:	90 e0       	ldi	r25, 0x00	; 0
    5ed2:	0e 94 33 07 	call	0xe66	; 0xe66 <pvPortMalloc>
    5ed6:	9a 83       	std	Y+2, r25	; 0x02
    5ed8:	89 83       	std	Y+1, r24	; 0x01

            if( pxNewTimer != NULL )
    5eda:	89 81       	ldd	r24, Y+1	; 0x01
    5edc:	9a 81       	ldd	r25, Y+2	; 0x02
    5ede:	00 97       	sbiw	r24, 0x00	; 0
    5ee0:	99 f0       	breq	.+38     	; 0x5f08 <xTimerCreate+0x68>
            {
                /* Status is thus far zero as the timer is not created statically
                 * and has not been started.  The auto-reload bit may get set in
                 * prvInitialiseNewTimer. */
                pxNewTimer->ucStatus = 0x00;
    5ee2:	e9 81       	ldd	r30, Y+1	; 0x01
    5ee4:	fa 81       	ldd	r31, Y+2	; 0x02
    5ee6:	12 8a       	std	Z+18, r1	; 0x12
                prvInitialiseNewTimer( pcTimerName, xTimerPeriodInTicks, uxAutoReload, pvTimerID, pxCallbackFunction, pxNewTimer );
    5ee8:	8b 81       	ldd	r24, Y+3	; 0x03
    5eea:	9c 81       	ldd	r25, Y+4	; 0x04
    5eec:	2d 81       	ldd	r18, Y+5	; 0x05
    5eee:	3e 81       	ldd	r19, Y+6	; 0x06
    5ef0:	e8 85       	ldd	r30, Y+8	; 0x08
    5ef2:	f9 85       	ldd	r31, Y+9	; 0x09
    5ef4:	aa 85       	ldd	r26, Y+10	; 0x0a
    5ef6:	bb 85       	ldd	r27, Y+11	; 0x0b
    5ef8:	e9 80       	ldd	r14, Y+1	; 0x01
    5efa:	fa 80       	ldd	r15, Y+2	; 0x02
    5efc:	b9 01       	movw	r22, r18
    5efe:	4f 81       	ldd	r20, Y+7	; 0x07
    5f00:	9f 01       	movw	r18, r30
    5f02:	8d 01       	movw	r16, r26
    5f04:	0e 94 93 2f 	call	0x5f26	; 0x5f26 <prvInitialiseNewTimer>
            }

            return pxNewTimer;
    5f08:	89 81       	ldd	r24, Y+1	; 0x01
    5f0a:	9a 81       	ldd	r25, Y+2	; 0x02
        }
    5f0c:	2b 96       	adiw	r28, 0x0b	; 11
    5f0e:	0f b6       	in	r0, 0x3f	; 63
    5f10:	f8 94       	cli
    5f12:	de bf       	out	0x3e, r29	; 62
    5f14:	0f be       	out	0x3f, r0	; 63
    5f16:	cd bf       	out	0x3d, r28	; 61
    5f18:	cf 91       	pop	r28
    5f1a:	df 91       	pop	r29
    5f1c:	1f 91       	pop	r17
    5f1e:	0f 91       	pop	r16
    5f20:	ff 90       	pop	r15
    5f22:	ef 90       	pop	r14
    5f24:	08 95       	ret

00005f26 <prvInitialiseNewTimer>:
                                       const TickType_t xTimerPeriodInTicks,
                                       const UBaseType_t uxAutoReload,
                                       void * const pvTimerID,
                                       TimerCallbackFunction_t pxCallbackFunction,
                                       Timer_t * pxNewTimer )
    {
    5f26:	ef 92       	push	r14
    5f28:	ff 92       	push	r15
    5f2a:	0f 93       	push	r16
    5f2c:	1f 93       	push	r17
    5f2e:	df 93       	push	r29
    5f30:	cf 93       	push	r28
    5f32:	cd b7       	in	r28, 0x3d	; 61
    5f34:	de b7       	in	r29, 0x3e	; 62
    5f36:	2b 97       	sbiw	r28, 0x0b	; 11
    5f38:	0f b6       	in	r0, 0x3f	; 63
    5f3a:	f8 94       	cli
    5f3c:	de bf       	out	0x3e, r29	; 62
    5f3e:	0f be       	out	0x3f, r0	; 63
    5f40:	cd bf       	out	0x3d, r28	; 61
    5f42:	9a 83       	std	Y+2, r25	; 0x02
    5f44:	89 83       	std	Y+1, r24	; 0x01
    5f46:	7c 83       	std	Y+4, r23	; 0x04
    5f48:	6b 83       	std	Y+3, r22	; 0x03
    5f4a:	4d 83       	std	Y+5, r20	; 0x05
    5f4c:	3f 83       	std	Y+7, r19	; 0x07
    5f4e:	2e 83       	std	Y+6, r18	; 0x06
    5f50:	19 87       	std	Y+9, r17	; 0x09
    5f52:	08 87       	std	Y+8, r16	; 0x08
    5f54:	fb 86       	std	Y+11, r15	; 0x0b
    5f56:	ea 86       	std	Y+10, r14	; 0x0a
        /* 0 is not a valid value for xTimerPeriodInTicks. */
        configASSERT( ( xTimerPeriodInTicks > 0 ) );

        /* Ensure the infrastructure used by the timer service task has been
         * created/initialised. */
        prvCheckForValidListAndQueue();
    5f58:	0e 94 e6 33 	call	0x67cc	; 0x67cc <prvCheckForValidListAndQueue>

        /* Initialise the timer structure members using the function
         * parameters. */
        pxNewTimer->pcTimerName = pcTimerName;
    5f5c:	ea 85       	ldd	r30, Y+10	; 0x0a
    5f5e:	fb 85       	ldd	r31, Y+11	; 0x0b
    5f60:	89 81       	ldd	r24, Y+1	; 0x01
    5f62:	9a 81       	ldd	r25, Y+2	; 0x02
    5f64:	91 83       	std	Z+1, r25	; 0x01
    5f66:	80 83       	st	Z, r24
        pxNewTimer->xTimerPeriodInTicks = xTimerPeriodInTicks;
    5f68:	ea 85       	ldd	r30, Y+10	; 0x0a
    5f6a:	fb 85       	ldd	r31, Y+11	; 0x0b
    5f6c:	8b 81       	ldd	r24, Y+3	; 0x03
    5f6e:	9c 81       	ldd	r25, Y+4	; 0x04
    5f70:	95 87       	std	Z+13, r25	; 0x0d
    5f72:	84 87       	std	Z+12, r24	; 0x0c
        pxNewTimer->pvTimerID = pvTimerID;
    5f74:	ea 85       	ldd	r30, Y+10	; 0x0a
    5f76:	fb 85       	ldd	r31, Y+11	; 0x0b
    5f78:	8e 81       	ldd	r24, Y+6	; 0x06
    5f7a:	9f 81       	ldd	r25, Y+7	; 0x07
    5f7c:	97 87       	std	Z+15, r25	; 0x0f
    5f7e:	86 87       	std	Z+14, r24	; 0x0e
        pxNewTimer->pxCallbackFunction = pxCallbackFunction;
    5f80:	ea 85       	ldd	r30, Y+10	; 0x0a
    5f82:	fb 85       	ldd	r31, Y+11	; 0x0b
    5f84:	88 85       	ldd	r24, Y+8	; 0x08
    5f86:	99 85       	ldd	r25, Y+9	; 0x09
    5f88:	91 8b       	std	Z+17, r25	; 0x11
    5f8a:	80 8b       	std	Z+16, r24	; 0x10
        vListInitialiseItem( &( pxNewTimer->xTimerListItem ) );
    5f8c:	8a 85       	ldd	r24, Y+10	; 0x0a
    5f8e:	9b 85       	ldd	r25, Y+11	; 0x0b
    5f90:	02 96       	adiw	r24, 0x02	; 2
    5f92:	0e 94 d5 10 	call	0x21aa	; 0x21aa <vListInitialiseItem>

        if( uxAutoReload != pdFALSE )
    5f96:	8d 81       	ldd	r24, Y+5	; 0x05
    5f98:	88 23       	and	r24, r24
    5f9a:	39 f0       	breq	.+14     	; 0x5faa <prvInitialiseNewTimer+0x84>
        {
            pxNewTimer->ucStatus |= tmrSTATUS_IS_AUTORELOAD;
    5f9c:	ea 85       	ldd	r30, Y+10	; 0x0a
    5f9e:	fb 85       	ldd	r31, Y+11	; 0x0b
    5fa0:	82 89       	ldd	r24, Z+18	; 0x12
    5fa2:	84 60       	ori	r24, 0x04	; 4
    5fa4:	ea 85       	ldd	r30, Y+10	; 0x0a
    5fa6:	fb 85       	ldd	r31, Y+11	; 0x0b
    5fa8:	82 8b       	std	Z+18, r24	; 0x12
        }

        traceTIMER_CREATE( pxNewTimer );
    }
    5faa:	2b 96       	adiw	r28, 0x0b	; 11
    5fac:	0f b6       	in	r0, 0x3f	; 63
    5fae:	f8 94       	cli
    5fb0:	de bf       	out	0x3e, r29	; 62
    5fb2:	0f be       	out	0x3f, r0	; 63
    5fb4:	cd bf       	out	0x3d, r28	; 61
    5fb6:	cf 91       	pop	r28
    5fb8:	df 91       	pop	r29
    5fba:	1f 91       	pop	r17
    5fbc:	0f 91       	pop	r16
    5fbe:	ff 90       	pop	r15
    5fc0:	ef 90       	pop	r14
    5fc2:	08 95       	ret

00005fc4 <xTimerGenericCommand>:
    BaseType_t xTimerGenericCommand( TimerHandle_t xTimer,
                                     const BaseType_t xCommandID,
                                     const TickType_t xOptionalValue,
                                     BaseType_t * const pxHigherPriorityTaskWoken,
                                     const TickType_t xTicksToWait )
    {
    5fc4:	0f 93       	push	r16
    5fc6:	1f 93       	push	r17
    5fc8:	df 93       	push	r29
    5fca:	cf 93       	push	r28
    5fcc:	cd b7       	in	r28, 0x3d	; 61
    5fce:	de b7       	in	r29, 0x3e	; 62
    5fd0:	2f 97       	sbiw	r28, 0x0f	; 15
    5fd2:	0f b6       	in	r0, 0x3f	; 63
    5fd4:	f8 94       	cli
    5fd6:	de bf       	out	0x3e, r29	; 62
    5fd8:	0f be       	out	0x3f, r0	; 63
    5fda:	cd bf       	out	0x3d, r28	; 61
    5fdc:	98 87       	std	Y+8, r25	; 0x08
    5fde:	8f 83       	std	Y+7, r24	; 0x07
    5fe0:	69 87       	std	Y+9, r22	; 0x09
    5fe2:	5b 87       	std	Y+11, r21	; 0x0b
    5fe4:	4a 87       	std	Y+10, r20	; 0x0a
    5fe6:	3d 87       	std	Y+13, r19	; 0x0d
    5fe8:	2c 87       	std	Y+12, r18	; 0x0c
    5fea:	1f 87       	std	Y+15, r17	; 0x0f
    5fec:	0e 87       	std	Y+14, r16	; 0x0e
        BaseType_t xReturn = pdFAIL;
    5fee:	19 82       	std	Y+1, r1	; 0x01

        configASSERT( xTimer );

        /* Send a message to the timer service task to perform a particular action
         * on a particular timer definition. */
        if( xTimerQueue != NULL )
    5ff0:	80 91 c8 08 	lds	r24, 0x08C8
    5ff4:	90 91 c9 08 	lds	r25, 0x08C9
    5ff8:	00 97       	sbiw	r24, 0x00	; 0
    5ffa:	e9 f1       	breq	.+122    	; 0x6076 <xTimerGenericCommand+0xb2>
        {
            /* Send a command to the timer service task to start the xTimer timer. */
            xMessage.xMessageID = xCommandID;
    5ffc:	89 85       	ldd	r24, Y+9	; 0x09
    5ffe:	8a 83       	std	Y+2, r24	; 0x02
            xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
    6000:	8a 85       	ldd	r24, Y+10	; 0x0a
    6002:	9b 85       	ldd	r25, Y+11	; 0x0b
    6004:	9c 83       	std	Y+4, r25	; 0x04
    6006:	8b 83       	std	Y+3, r24	; 0x03
            xMessage.u.xTimerParameters.pxTimer = xTimer;
    6008:	8f 81       	ldd	r24, Y+7	; 0x07
    600a:	98 85       	ldd	r25, Y+8	; 0x08
    600c:	9e 83       	std	Y+6, r25	; 0x06
    600e:	8d 83       	std	Y+5, r24	; 0x05

            if( xCommandID < tmrFIRST_FROM_ISR_COMMAND )
    6010:	89 85       	ldd	r24, Y+9	; 0x09
    6012:	86 30       	cpi	r24, 0x06	; 6
    6014:	14 f5       	brge	.+68     	; 0x605a <xTimerGenericCommand+0x96>
            {
                if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
    6016:	0e 94 fc 26 	call	0x4df8	; 0x4df8 <xTaskGetSchedulerState>
    601a:	82 30       	cpi	r24, 0x02	; 2
    601c:	79 f4       	brne	.+30     	; 0x603c <xTimerGenericCommand+0x78>
                {
                    xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
    601e:	80 91 c8 08 	lds	r24, 0x08C8
    6022:	90 91 c9 08 	lds	r25, 0x08C9
    6026:	9e 01       	movw	r18, r28
    6028:	2e 5f       	subi	r18, 0xFE	; 254
    602a:	3f 4f       	sbci	r19, 0xFF	; 255
    602c:	4e 85       	ldd	r20, Y+14	; 0x0e
    602e:	5f 85       	ldd	r21, Y+15	; 0x0f
    6030:	b9 01       	movw	r22, r18
    6032:	20 e0       	ldi	r18, 0x00	; 0
    6034:	0e 94 3b 13 	call	0x2676	; 0x2676 <xQueueGenericSend>
    6038:	89 83       	std	Y+1, r24	; 0x01
    603a:	1d c0       	rjmp	.+58     	; 0x6076 <xTimerGenericCommand+0xb2>
                }
                else
                {
                    xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
    603c:	80 91 c8 08 	lds	r24, 0x08C8
    6040:	90 91 c9 08 	lds	r25, 0x08C9
    6044:	9e 01       	movw	r18, r28
    6046:	2e 5f       	subi	r18, 0xFE	; 254
    6048:	3f 4f       	sbci	r19, 0xFF	; 255
    604a:	b9 01       	movw	r22, r18
    604c:	40 e0       	ldi	r20, 0x00	; 0
    604e:	50 e0       	ldi	r21, 0x00	; 0
    6050:	20 e0       	ldi	r18, 0x00	; 0
    6052:	0e 94 3b 13 	call	0x2676	; 0x2676 <xQueueGenericSend>
    6056:	89 83       	std	Y+1, r24	; 0x01
    6058:	0e c0       	rjmp	.+28     	; 0x6076 <xTimerGenericCommand+0xb2>
                }
            }
            else
            {
                xReturn = xQueueSendToBackFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
    605a:	80 91 c8 08 	lds	r24, 0x08C8
    605e:	90 91 c9 08 	lds	r25, 0x08C9
    6062:	9e 01       	movw	r18, r28
    6064:	2e 5f       	subi	r18, 0xFE	; 254
    6066:	3f 4f       	sbci	r19, 0xFF	; 255
    6068:	4c 85       	ldd	r20, Y+12	; 0x0c
    606a:	5d 85       	ldd	r21, Y+13	; 0x0d
    606c:	b9 01       	movw	r22, r18
    606e:	20 e0       	ldi	r18, 0x00	; 0
    6070:	0e 94 e7 13 	call	0x27ce	; 0x27ce <xQueueGenericSendFromISR>
    6074:	89 83       	std	Y+1, r24	; 0x01
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        return xReturn;
    6076:	89 81       	ldd	r24, Y+1	; 0x01
    }
    6078:	2f 96       	adiw	r28, 0x0f	; 15
    607a:	0f b6       	in	r0, 0x3f	; 63
    607c:	f8 94       	cli
    607e:	de bf       	out	0x3e, r29	; 62
    6080:	0f be       	out	0x3f, r0	; 63
    6082:	cd bf       	out	0x3d, r28	; 61
    6084:	cf 91       	pop	r28
    6086:	df 91       	pop	r29
    6088:	1f 91       	pop	r17
    608a:	0f 91       	pop	r16
    608c:	08 95       	ret

0000608e <xTimerGetTimerDaemonTaskHandle>:
/*-----------------------------------------------------------*/

    TaskHandle_t xTimerGetTimerDaemonTaskHandle( void )
    {
    608e:	df 93       	push	r29
    6090:	cf 93       	push	r28
    6092:	cd b7       	in	r28, 0x3d	; 61
    6094:	de b7       	in	r29, 0x3e	; 62
        /* If xTimerGetTimerDaemonTaskHandle() is called before the scheduler has been
         * started, then xTimerTaskHandle will be NULL. */
        configASSERT( ( xTimerTaskHandle != NULL ) );
        return xTimerTaskHandle;
    6096:	80 91 ca 08 	lds	r24, 0x08CA
    609a:	90 91 cb 08 	lds	r25, 0x08CB
    }
    609e:	cf 91       	pop	r28
    60a0:	df 91       	pop	r29
    60a2:	08 95       	ret

000060a4 <xTimerGetPeriod>:
/*-----------------------------------------------------------*/

    TickType_t xTimerGetPeriod( TimerHandle_t xTimer )
    {
    60a4:	df 93       	push	r29
    60a6:	cf 93       	push	r28
    60a8:	00 d0       	rcall	.+0      	; 0x60aa <xTimerGetPeriod+0x6>
    60aa:	00 d0       	rcall	.+0      	; 0x60ac <xTimerGetPeriod+0x8>
    60ac:	cd b7       	in	r28, 0x3d	; 61
    60ae:	de b7       	in	r29, 0x3e	; 62
    60b0:	9c 83       	std	Y+4, r25	; 0x04
    60b2:	8b 83       	std	Y+3, r24	; 0x03
        Timer_t * pxTimer = xTimer;
    60b4:	8b 81       	ldd	r24, Y+3	; 0x03
    60b6:	9c 81       	ldd	r25, Y+4	; 0x04
    60b8:	9a 83       	std	Y+2, r25	; 0x02
    60ba:	89 83       	std	Y+1, r24	; 0x01

        configASSERT( xTimer );
        return pxTimer->xTimerPeriodInTicks;
    60bc:	e9 81       	ldd	r30, Y+1	; 0x01
    60be:	fa 81       	ldd	r31, Y+2	; 0x02
    60c0:	84 85       	ldd	r24, Z+12	; 0x0c
    60c2:	95 85       	ldd	r25, Z+13	; 0x0d
    }
    60c4:	0f 90       	pop	r0
    60c6:	0f 90       	pop	r0
    60c8:	0f 90       	pop	r0
    60ca:	0f 90       	pop	r0
    60cc:	cf 91       	pop	r28
    60ce:	df 91       	pop	r29
    60d0:	08 95       	ret

000060d2 <vTimerSetReloadMode>:
/*-----------------------------------------------------------*/

    void vTimerSetReloadMode( TimerHandle_t xTimer,
                              const UBaseType_t uxAutoReload )
    {
    60d2:	df 93       	push	r29
    60d4:	cf 93       	push	r28
    60d6:	00 d0       	rcall	.+0      	; 0x60d8 <vTimerSetReloadMode+0x6>
    60d8:	00 d0       	rcall	.+0      	; 0x60da <vTimerSetReloadMode+0x8>
    60da:	0f 92       	push	r0
    60dc:	cd b7       	in	r28, 0x3d	; 61
    60de:	de b7       	in	r29, 0x3e	; 62
    60e0:	9c 83       	std	Y+4, r25	; 0x04
    60e2:	8b 83       	std	Y+3, r24	; 0x03
    60e4:	6d 83       	std	Y+5, r22	; 0x05
        Timer_t * pxTimer = xTimer;
    60e6:	8b 81       	ldd	r24, Y+3	; 0x03
    60e8:	9c 81       	ldd	r25, Y+4	; 0x04
    60ea:	9a 83       	std	Y+2, r25	; 0x02
    60ec:	89 83       	std	Y+1, r24	; 0x01

        configASSERT( xTimer );
        taskENTER_CRITICAL();
    60ee:	0f b6       	in	r0, 0x3f	; 63
    60f0:	f8 94       	cli
    60f2:	0f 92       	push	r0
        {
            if( uxAutoReload != pdFALSE )
    60f4:	8d 81       	ldd	r24, Y+5	; 0x05
    60f6:	88 23       	and	r24, r24
    60f8:	41 f0       	breq	.+16     	; 0x610a <vTimerSetReloadMode+0x38>
            {
                pxTimer->ucStatus |= tmrSTATUS_IS_AUTORELOAD;
    60fa:	e9 81       	ldd	r30, Y+1	; 0x01
    60fc:	fa 81       	ldd	r31, Y+2	; 0x02
    60fe:	82 89       	ldd	r24, Z+18	; 0x12
    6100:	84 60       	ori	r24, 0x04	; 4
    6102:	e9 81       	ldd	r30, Y+1	; 0x01
    6104:	fa 81       	ldd	r31, Y+2	; 0x02
    6106:	82 8b       	std	Z+18, r24	; 0x12
    6108:	07 c0       	rjmp	.+14     	; 0x6118 <vTimerSetReloadMode+0x46>
            }
            else
            {
                pxTimer->ucStatus &= ( ( uint8_t ) ~tmrSTATUS_IS_AUTORELOAD );
    610a:	e9 81       	ldd	r30, Y+1	; 0x01
    610c:	fa 81       	ldd	r31, Y+2	; 0x02
    610e:	82 89       	ldd	r24, Z+18	; 0x12
    6110:	8b 7f       	andi	r24, 0xFB	; 251
    6112:	e9 81       	ldd	r30, Y+1	; 0x01
    6114:	fa 81       	ldd	r31, Y+2	; 0x02
    6116:	82 8b       	std	Z+18, r24	; 0x12
            }
        }
        taskEXIT_CRITICAL();
    6118:	0f 90       	pop	r0
    611a:	0f be       	out	0x3f, r0	; 63
    }
    611c:	0f 90       	pop	r0
    611e:	0f 90       	pop	r0
    6120:	0f 90       	pop	r0
    6122:	0f 90       	pop	r0
    6124:	0f 90       	pop	r0
    6126:	cf 91       	pop	r28
    6128:	df 91       	pop	r29
    612a:	08 95       	ret

0000612c <uxTimerGetReloadMode>:
/*-----------------------------------------------------------*/

    UBaseType_t uxTimerGetReloadMode( TimerHandle_t xTimer )
    {
    612c:	df 93       	push	r29
    612e:	cf 93       	push	r28
    6130:	00 d0       	rcall	.+0      	; 0x6132 <uxTimerGetReloadMode+0x6>
    6132:	00 d0       	rcall	.+0      	; 0x6134 <uxTimerGetReloadMode+0x8>
    6134:	0f 92       	push	r0
    6136:	cd b7       	in	r28, 0x3d	; 61
    6138:	de b7       	in	r29, 0x3e	; 62
    613a:	9d 83       	std	Y+5, r25	; 0x05
    613c:	8c 83       	std	Y+4, r24	; 0x04
        Timer_t * pxTimer = xTimer;
    613e:	8c 81       	ldd	r24, Y+4	; 0x04
    6140:	9d 81       	ldd	r25, Y+5	; 0x05
    6142:	9b 83       	std	Y+3, r25	; 0x03
    6144:	8a 83       	std	Y+2, r24	; 0x02
        UBaseType_t uxReturn;

        configASSERT( xTimer );
        taskENTER_CRITICAL();
    6146:	0f b6       	in	r0, 0x3f	; 63
    6148:	f8 94       	cli
    614a:	0f 92       	push	r0
        {
            if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) == 0 )
    614c:	ea 81       	ldd	r30, Y+2	; 0x02
    614e:	fb 81       	ldd	r31, Y+3	; 0x03
    6150:	82 89       	ldd	r24, Z+18	; 0x12
    6152:	88 2f       	mov	r24, r24
    6154:	90 e0       	ldi	r25, 0x00	; 0
    6156:	84 70       	andi	r24, 0x04	; 4
    6158:	90 70       	andi	r25, 0x00	; 0
    615a:	00 97       	sbiw	r24, 0x00	; 0
    615c:	11 f4       	brne	.+4      	; 0x6162 <uxTimerGetReloadMode+0x36>
            {
                /* Not an auto-reload timer. */
                uxReturn = ( UBaseType_t ) pdFALSE;
    615e:	19 82       	std	Y+1, r1	; 0x01
    6160:	02 c0       	rjmp	.+4      	; 0x6166 <uxTimerGetReloadMode+0x3a>
            }
            else
            {
                /* Is an auto-reload timer. */
                uxReturn = ( UBaseType_t ) pdTRUE;
    6162:	81 e0       	ldi	r24, 0x01	; 1
    6164:	89 83       	std	Y+1, r24	; 0x01
            }
        }
        taskEXIT_CRITICAL();
    6166:	0f 90       	pop	r0
    6168:	0f be       	out	0x3f, r0	; 63

        return uxReturn;
    616a:	89 81       	ldd	r24, Y+1	; 0x01
    }
    616c:	0f 90       	pop	r0
    616e:	0f 90       	pop	r0
    6170:	0f 90       	pop	r0
    6172:	0f 90       	pop	r0
    6174:	0f 90       	pop	r0
    6176:	cf 91       	pop	r28
    6178:	df 91       	pop	r29
    617a:	08 95       	ret

0000617c <xTimerGetExpiryTime>:
/*-----------------------------------------------------------*/

    TickType_t xTimerGetExpiryTime( TimerHandle_t xTimer )
    {
    617c:	df 93       	push	r29
    617e:	cf 93       	push	r28
    6180:	00 d0       	rcall	.+0      	; 0x6182 <xTimerGetExpiryTime+0x6>
    6182:	00 d0       	rcall	.+0      	; 0x6184 <xTimerGetExpiryTime+0x8>
    6184:	00 d0       	rcall	.+0      	; 0x6186 <xTimerGetExpiryTime+0xa>
    6186:	cd b7       	in	r28, 0x3d	; 61
    6188:	de b7       	in	r29, 0x3e	; 62
    618a:	9e 83       	std	Y+6, r25	; 0x06
    618c:	8d 83       	std	Y+5, r24	; 0x05
        Timer_t * pxTimer = xTimer;
    618e:	8d 81       	ldd	r24, Y+5	; 0x05
    6190:	9e 81       	ldd	r25, Y+6	; 0x06
    6192:	9c 83       	std	Y+4, r25	; 0x04
    6194:	8b 83       	std	Y+3, r24	; 0x03
        TickType_t xReturn;

        configASSERT( xTimer );
        xReturn = listGET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ) );
    6196:	eb 81       	ldd	r30, Y+3	; 0x03
    6198:	fc 81       	ldd	r31, Y+4	; 0x04
    619a:	82 81       	ldd	r24, Z+2	; 0x02
    619c:	93 81       	ldd	r25, Z+3	; 0x03
    619e:	9a 83       	std	Y+2, r25	; 0x02
    61a0:	89 83       	std	Y+1, r24	; 0x01
        return xReturn;
    61a2:	89 81       	ldd	r24, Y+1	; 0x01
    61a4:	9a 81       	ldd	r25, Y+2	; 0x02
    }
    61a6:	26 96       	adiw	r28, 0x06	; 6
    61a8:	0f b6       	in	r0, 0x3f	; 63
    61aa:	f8 94       	cli
    61ac:	de bf       	out	0x3e, r29	; 62
    61ae:	0f be       	out	0x3f, r0	; 63
    61b0:	cd bf       	out	0x3d, r28	; 61
    61b2:	cf 91       	pop	r28
    61b4:	df 91       	pop	r29
    61b6:	08 95       	ret

000061b8 <pcTimerGetName>:
/*-----------------------------------------------------------*/

    const char * pcTimerGetName( TimerHandle_t xTimer ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
    {
    61b8:	df 93       	push	r29
    61ba:	cf 93       	push	r28
    61bc:	00 d0       	rcall	.+0      	; 0x61be <pcTimerGetName+0x6>
    61be:	00 d0       	rcall	.+0      	; 0x61c0 <pcTimerGetName+0x8>
    61c0:	cd b7       	in	r28, 0x3d	; 61
    61c2:	de b7       	in	r29, 0x3e	; 62
    61c4:	9c 83       	std	Y+4, r25	; 0x04
    61c6:	8b 83       	std	Y+3, r24	; 0x03
        Timer_t * pxTimer = xTimer;
    61c8:	8b 81       	ldd	r24, Y+3	; 0x03
    61ca:	9c 81       	ldd	r25, Y+4	; 0x04
    61cc:	9a 83       	std	Y+2, r25	; 0x02
    61ce:	89 83       	std	Y+1, r24	; 0x01

        configASSERT( xTimer );
        return pxTimer->pcTimerName;
    61d0:	e9 81       	ldd	r30, Y+1	; 0x01
    61d2:	fa 81       	ldd	r31, Y+2	; 0x02
    61d4:	80 81       	ld	r24, Z
    61d6:	91 81       	ldd	r25, Z+1	; 0x01
    }
    61d8:	0f 90       	pop	r0
    61da:	0f 90       	pop	r0
    61dc:	0f 90       	pop	r0
    61de:	0f 90       	pop	r0
    61e0:	cf 91       	pop	r28
    61e2:	df 91       	pop	r29
    61e4:	08 95       	ret

000061e6 <prvReloadTimer>:
/*-----------------------------------------------------------*/

    static void prvReloadTimer( Timer_t * const pxTimer,
                                TickType_t xExpiredTime,
                                const TickType_t xTimeNow )
    {
    61e6:	df 93       	push	r29
    61e8:	cf 93       	push	r28
    61ea:	00 d0       	rcall	.+0      	; 0x61ec <prvReloadTimer+0x6>
    61ec:	00 d0       	rcall	.+0      	; 0x61ee <prvReloadTimer+0x8>
    61ee:	00 d0       	rcall	.+0      	; 0x61f0 <prvReloadTimer+0xa>
    61f0:	cd b7       	in	r28, 0x3d	; 61
    61f2:	de b7       	in	r29, 0x3e	; 62
    61f4:	9a 83       	std	Y+2, r25	; 0x02
    61f6:	89 83       	std	Y+1, r24	; 0x01
    61f8:	7c 83       	std	Y+4, r23	; 0x04
    61fa:	6b 83       	std	Y+3, r22	; 0x03
    61fc:	5e 83       	std	Y+6, r21	; 0x06
    61fe:	4d 83       	std	Y+5, r20	; 0x05
    6200:	12 c0       	rjmp	.+36     	; 0x6226 <prvReloadTimer+0x40>
         * If the next expiry time has already passed, advance the expiry time,
         * call the callback function, and try again. */
        while( prvInsertTimerInActiveList( pxTimer, ( xExpiredTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xExpiredTime ) != pdFALSE )
        {
            /* Advance the expiry time. */
            xExpiredTime += pxTimer->xTimerPeriodInTicks;
    6202:	e9 81       	ldd	r30, Y+1	; 0x01
    6204:	fa 81       	ldd	r31, Y+2	; 0x02
    6206:	24 85       	ldd	r18, Z+12	; 0x0c
    6208:	35 85       	ldd	r19, Z+13	; 0x0d
    620a:	8b 81       	ldd	r24, Y+3	; 0x03
    620c:	9c 81       	ldd	r25, Y+4	; 0x04
    620e:	82 0f       	add	r24, r18
    6210:	93 1f       	adc	r25, r19
    6212:	9c 83       	std	Y+4, r25	; 0x04
    6214:	8b 83       	std	Y+3, r24	; 0x03

            /* Call the timer callback. */
            traceTIMER_EXPIRED( pxTimer );
            pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    6216:	e9 81       	ldd	r30, Y+1	; 0x01
    6218:	fa 81       	ldd	r31, Y+2	; 0x02
    621a:	00 88       	ldd	r0, Z+16	; 0x10
    621c:	f1 89       	ldd	r31, Z+17	; 0x11
    621e:	e0 2d       	mov	r30, r0
    6220:	89 81       	ldd	r24, Y+1	; 0x01
    6222:	9a 81       	ldd	r25, Y+2	; 0x02
    6224:	09 95       	icall
                                const TickType_t xTimeNow )
    {
        /* Insert the timer into the appropriate list for the next expiry time.
         * If the next expiry time has already passed, advance the expiry time,
         * call the callback function, and try again. */
        while( prvInsertTimerInActiveList( pxTimer, ( xExpiredTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xExpiredTime ) != pdFALSE )
    6226:	e9 81       	ldd	r30, Y+1	; 0x01
    6228:	fa 81       	ldd	r31, Y+2	; 0x02
    622a:	24 85       	ldd	r18, Z+12	; 0x0c
    622c:	35 85       	ldd	r19, Z+13	; 0x0d
    622e:	8b 81       	ldd	r24, Y+3	; 0x03
    6230:	9c 81       	ldd	r25, Y+4	; 0x04
    6232:	a9 01       	movw	r20, r18
    6234:	48 0f       	add	r20, r24
    6236:	59 1f       	adc	r21, r25
    6238:	89 81       	ldd	r24, Y+1	; 0x01
    623a:	9a 81       	ldd	r25, Y+2	; 0x02
    623c:	2d 81       	ldd	r18, Y+5	; 0x05
    623e:	3e 81       	ldd	r19, Y+6	; 0x06
    6240:	eb 81       	ldd	r30, Y+3	; 0x03
    6242:	fc 81       	ldd	r31, Y+4	; 0x04
    6244:	ba 01       	movw	r22, r20
    6246:	a9 01       	movw	r20, r18
    6248:	9f 01       	movw	r18, r30
    624a:	0e 94 49 32 	call	0x6492	; 0x6492 <prvInsertTimerInActiveList>
    624e:	88 23       	and	r24, r24
    6250:	c1 f6       	brne	.-80     	; 0x6202 <prvReloadTimer+0x1c>

            /* Call the timer callback. */
            traceTIMER_EXPIRED( pxTimer );
            pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
        }
    }
    6252:	26 96       	adiw	r28, 0x06	; 6
    6254:	0f b6       	in	r0, 0x3f	; 63
    6256:	f8 94       	cli
    6258:	de bf       	out	0x3e, r29	; 62
    625a:	0f be       	out	0x3f, r0	; 63
    625c:	cd bf       	out	0x3d, r28	; 61
    625e:	cf 91       	pop	r28
    6260:	df 91       	pop	r29
    6262:	08 95       	ret

00006264 <prvProcessExpiredTimer>:
/*-----------------------------------------------------------*/

    static void prvProcessExpiredTimer( const TickType_t xNextExpireTime,
                                        const TickType_t xTimeNow )
    {
    6264:	df 93       	push	r29
    6266:	cf 93       	push	r28
    6268:	00 d0       	rcall	.+0      	; 0x626a <prvProcessExpiredTimer+0x6>
    626a:	00 d0       	rcall	.+0      	; 0x626c <prvProcessExpiredTimer+0x8>
    626c:	00 d0       	rcall	.+0      	; 0x626e <prvProcessExpiredTimer+0xa>
    626e:	cd b7       	in	r28, 0x3d	; 61
    6270:	de b7       	in	r29, 0x3e	; 62
    6272:	9c 83       	std	Y+4, r25	; 0x04
    6274:	8b 83       	std	Y+3, r24	; 0x03
    6276:	7e 83       	std	Y+6, r23	; 0x06
    6278:	6d 83       	std	Y+5, r22	; 0x05
        Timer_t * const pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); /*lint !e9087 !e9079 void * is used as this macro is used with tasks and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    627a:	e0 91 e0 08 	lds	r30, 0x08E0
    627e:	f0 91 e1 08 	lds	r31, 0x08E1
    6282:	05 80       	ldd	r0, Z+5	; 0x05
    6284:	f6 81       	ldd	r31, Z+6	; 0x06
    6286:	e0 2d       	mov	r30, r0
    6288:	86 81       	ldd	r24, Z+6	; 0x06
    628a:	97 81       	ldd	r25, Z+7	; 0x07
    628c:	9a 83       	std	Y+2, r25	; 0x02
    628e:	89 83       	std	Y+1, r24	; 0x01

        /* Remove the timer from the list of active timers.  A check has already
         * been performed to ensure the list is not empty. */

        ( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    6290:	89 81       	ldd	r24, Y+1	; 0x01
    6292:	9a 81       	ldd	r25, Y+2	; 0x02
    6294:	02 96       	adiw	r24, 0x02	; 2
    6296:	0e 94 95 11 	call	0x232a	; 0x232a <uxListRemove>

        /* If the timer is an auto-reload timer then calculate the next
         * expiry time and re-insert the timer in the list of active timers. */
        if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
    629a:	e9 81       	ldd	r30, Y+1	; 0x01
    629c:	fa 81       	ldd	r31, Y+2	; 0x02
    629e:	82 89       	ldd	r24, Z+18	; 0x12
    62a0:	88 2f       	mov	r24, r24
    62a2:	90 e0       	ldi	r25, 0x00	; 0
    62a4:	84 70       	andi	r24, 0x04	; 4
    62a6:	90 70       	andi	r25, 0x00	; 0
    62a8:	00 97       	sbiw	r24, 0x00	; 0
    62aa:	51 f0       	breq	.+20     	; 0x62c0 <prvProcessExpiredTimer+0x5c>
        {
            prvReloadTimer( pxTimer, xNextExpireTime, xTimeNow );
    62ac:	89 81       	ldd	r24, Y+1	; 0x01
    62ae:	9a 81       	ldd	r25, Y+2	; 0x02
    62b0:	2b 81       	ldd	r18, Y+3	; 0x03
    62b2:	3c 81       	ldd	r19, Y+4	; 0x04
    62b4:	4d 81       	ldd	r20, Y+5	; 0x05
    62b6:	5e 81       	ldd	r21, Y+6	; 0x06
    62b8:	b9 01       	movw	r22, r18
    62ba:	0e 94 f3 30 	call	0x61e6	; 0x61e6 <prvReloadTimer>
    62be:	07 c0       	rjmp	.+14     	; 0x62ce <prvProcessExpiredTimer+0x6a>
        }
        else
        {
            pxTimer->ucStatus &= ( ( uint8_t ) ~tmrSTATUS_IS_ACTIVE );
    62c0:	e9 81       	ldd	r30, Y+1	; 0x01
    62c2:	fa 81       	ldd	r31, Y+2	; 0x02
    62c4:	82 89       	ldd	r24, Z+18	; 0x12
    62c6:	8e 7f       	andi	r24, 0xFE	; 254
    62c8:	e9 81       	ldd	r30, Y+1	; 0x01
    62ca:	fa 81       	ldd	r31, Y+2	; 0x02
    62cc:	82 8b       	std	Z+18, r24	; 0x12
        }

        /* Call the timer callback. */
        traceTIMER_EXPIRED( pxTimer );
        pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    62ce:	e9 81       	ldd	r30, Y+1	; 0x01
    62d0:	fa 81       	ldd	r31, Y+2	; 0x02
    62d2:	00 88       	ldd	r0, Z+16	; 0x10
    62d4:	f1 89       	ldd	r31, Z+17	; 0x11
    62d6:	e0 2d       	mov	r30, r0
    62d8:	89 81       	ldd	r24, Y+1	; 0x01
    62da:	9a 81       	ldd	r25, Y+2	; 0x02
    62dc:	09 95       	icall
    }
    62de:	26 96       	adiw	r28, 0x06	; 6
    62e0:	0f b6       	in	r0, 0x3f	; 63
    62e2:	f8 94       	cli
    62e4:	de bf       	out	0x3e, r29	; 62
    62e6:	0f be       	out	0x3f, r0	; 63
    62e8:	cd bf       	out	0x3d, r28	; 61
    62ea:	cf 91       	pop	r28
    62ec:	df 91       	pop	r29
    62ee:	08 95       	ret

000062f0 <prvTimerTask>:
/*-----------------------------------------------------------*/

    static portTASK_FUNCTION( prvTimerTask, pvParameters )
    {
    62f0:	df 93       	push	r29
    62f2:	cf 93       	push	r28
    62f4:	00 d0       	rcall	.+0      	; 0x62f6 <prvTimerTask+0x6>
    62f6:	00 d0       	rcall	.+0      	; 0x62f8 <prvTimerTask+0x8>
    62f8:	0f 92       	push	r0
    62fa:	cd b7       	in	r28, 0x3d	; 61
    62fc:	de b7       	in	r29, 0x3e	; 62
    62fe:	9d 83       	std	Y+5, r25	; 0x05
    6300:	8c 83       	std	Y+4, r24	; 0x04

        for( ; ; )
        {
            /* Query the timers list to see if it contains any timers, and if so,
             * obtain the time at which the next timer will expire. */
            xNextExpireTime = prvGetNextExpireTime( &xListWasEmpty );
    6302:	ce 01       	movw	r24, r28
    6304:	03 96       	adiw	r24, 0x03	; 3
    6306:	0e 94 e7 31 	call	0x63ce	; 0x63ce <prvGetNextExpireTime>
    630a:	9a 83       	std	Y+2, r25	; 0x02
    630c:	89 83       	std	Y+1, r24	; 0x01

            /* If a timer has expired, process it.  Otherwise, block this task
             * until either a timer does expire, or a command is received. */
            prvProcessTimerOrBlockTask( xNextExpireTime, xListWasEmpty );
    630e:	2b 81       	ldd	r18, Y+3	; 0x03
    6310:	89 81       	ldd	r24, Y+1	; 0x01
    6312:	9a 81       	ldd	r25, Y+2	; 0x02
    6314:	62 2f       	mov	r22, r18
    6316:	0e 94 90 31 	call	0x6320	; 0x6320 <prvProcessTimerOrBlockTask>

            /* Empty the command queue. */
            prvProcessReceivedCommands();
    631a:	0e 94 b1 32 	call	0x6562	; 0x6562 <prvProcessReceivedCommands>
    631e:	f1 cf       	rjmp	.-30     	; 0x6302 <prvTimerTask+0x12>

00006320 <prvProcessTimerOrBlockTask>:
    }
/*-----------------------------------------------------------*/

    static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime,
                                            BaseType_t xListWasEmpty )
    {
    6320:	df 93       	push	r29
    6322:	cf 93       	push	r28
    6324:	00 d0       	rcall	.+0      	; 0x6326 <prvProcessTimerOrBlockTask+0x6>
    6326:	00 d0       	rcall	.+0      	; 0x6328 <prvProcessTimerOrBlockTask+0x8>
    6328:	00 d0       	rcall	.+0      	; 0x632a <prvProcessTimerOrBlockTask+0xa>
    632a:	cd b7       	in	r28, 0x3d	; 61
    632c:	de b7       	in	r29, 0x3e	; 62
    632e:	9d 83       	std	Y+5, r25	; 0x05
    6330:	8c 83       	std	Y+4, r24	; 0x04
    6332:	6e 83       	std	Y+6, r22	; 0x06
        TickType_t xTimeNow;
        BaseType_t xTimerListsWereSwitched;

        vTaskSuspendAll();
    6334:	0e 94 88 1e 	call	0x3d10	; 0x3d10 <vTaskSuspendAll>
            /* Obtain the time now to make an assessment as to whether the timer
             * has expired or not.  If obtaining the time causes the lists to switch
             * then don't process this timer as any timers that remained in the list
             * when the lists were switched will have been processed within the
             * prvSampleTimeNow() function. */
            xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    6338:	ce 01       	movw	r24, r28
    633a:	03 96       	adiw	r24, 0x03	; 3
    633c:	0e 94 1b 32 	call	0x6436	; 0x6436 <prvSampleTimeNow>
    6340:	9a 83       	std	Y+2, r25	; 0x02
    6342:	89 83       	std	Y+1, r24	; 0x01

            if( xTimerListsWereSwitched == pdFALSE )
    6344:	8b 81       	ldd	r24, Y+3	; 0x03
    6346:	88 23       	and	r24, r24
    6348:	b9 f5       	brne	.+110    	; 0x63b8 <prvProcessTimerOrBlockTask+0x98>
            {
                /* The tick count has not overflowed, has the timer expired? */
                if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
    634a:	8e 81       	ldd	r24, Y+6	; 0x06
    634c:	88 23       	and	r24, r24
    634e:	89 f4       	brne	.+34     	; 0x6372 <prvProcessTimerOrBlockTask+0x52>
    6350:	2c 81       	ldd	r18, Y+4	; 0x04
    6352:	3d 81       	ldd	r19, Y+5	; 0x05
    6354:	89 81       	ldd	r24, Y+1	; 0x01
    6356:	9a 81       	ldd	r25, Y+2	; 0x02
    6358:	82 17       	cp	r24, r18
    635a:	93 07       	cpc	r25, r19
    635c:	50 f0       	brcs	.+20     	; 0x6372 <prvProcessTimerOrBlockTask+0x52>
                {
                    ( void ) xTaskResumeAll();
    635e:	0e 94 94 1e 	call	0x3d28	; 0x3d28 <xTaskResumeAll>
                    prvProcessExpiredTimer( xNextExpireTime, xTimeNow );
    6362:	8c 81       	ldd	r24, Y+4	; 0x04
    6364:	9d 81       	ldd	r25, Y+5	; 0x05
    6366:	29 81       	ldd	r18, Y+1	; 0x01
    6368:	3a 81       	ldd	r19, Y+2	; 0x02
    636a:	b9 01       	movw	r22, r18
    636c:	0e 94 32 31 	call	0x6264	; 0x6264 <prvProcessExpiredTimer>
    6370:	25 c0       	rjmp	.+74     	; 0x63bc <prvProcessTimerOrBlockTask+0x9c>
                     * time has not been reached yet.  This task should therefore
                     * block to wait for the next expire time or a command to be
                     * received - whichever comes first.  The following line cannot
                     * be reached unless xNextExpireTime > xTimeNow, except in the
                     * case when the current timer list is empty. */
                    if( xListWasEmpty != pdFALSE )
    6372:	8e 81       	ldd	r24, Y+6	; 0x06
    6374:	88 23       	and	r24, r24
    6376:	51 f0       	breq	.+20     	; 0x638c <prvProcessTimerOrBlockTask+0x6c>
                    {
                        /* The current timer list is empty - is the overflow list
                         * also empty? */
                        xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
    6378:	e0 91 e2 08 	lds	r30, 0x08E2
    637c:	f0 91 e3 08 	lds	r31, 0x08E3
    6380:	80 81       	ld	r24, Z
    6382:	1e 82       	std	Y+6, r1	; 0x06
    6384:	88 23       	and	r24, r24
    6386:	11 f4       	brne	.+4      	; 0x638c <prvProcessTimerOrBlockTask+0x6c>
    6388:	81 e0       	ldi	r24, 0x01	; 1
    638a:	8e 83       	std	Y+6, r24	; 0x06
                    }

                    vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ), xListWasEmpty );
    638c:	40 91 c8 08 	lds	r20, 0x08C8
    6390:	50 91 c9 08 	lds	r21, 0x08C9
    6394:	2c 81       	ldd	r18, Y+4	; 0x04
    6396:	3d 81       	ldd	r19, Y+5	; 0x05
    6398:	89 81       	ldd	r24, Y+1	; 0x01
    639a:	9a 81       	ldd	r25, Y+2	; 0x02
    639c:	28 1b       	sub	r18, r24
    639e:	39 0b       	sbc	r19, r25
    63a0:	ca 01       	movw	r24, r20
    63a2:	b9 01       	movw	r22, r18
    63a4:	4e 81       	ldd	r20, Y+6	; 0x06
    63a6:	0e 94 f4 1a 	call	0x35e8	; 0x35e8 <vQueueWaitForMessageRestricted>

                    if( xTaskResumeAll() == pdFALSE )
    63aa:	0e 94 94 1e 	call	0x3d28	; 0x3d28 <xTaskResumeAll>
    63ae:	88 23       	and	r24, r24
    63b0:	29 f4       	brne	.+10     	; 0x63bc <prvProcessTimerOrBlockTask+0x9c>
                    {
                        /* Yield to wait for either a command to arrive, or the
                         * block time to expire.  If a command arrived between the
                         * critical section being exited and this yield then the yield
                         * will not cause the task to block. */
                        portYIELD_WITHIN_API();
    63b2:	0e 94 72 09 	call	0x12e4	; 0x12e4 <vPortYield>
    63b6:	02 c0       	rjmp	.+4      	; 0x63bc <prvProcessTimerOrBlockTask+0x9c>
                    }
                }
            }
            else
            {
                ( void ) xTaskResumeAll();
    63b8:	0e 94 94 1e 	call	0x3d28	; 0x3d28 <xTaskResumeAll>
            }
        }
    }
    63bc:	26 96       	adiw	r28, 0x06	; 6
    63be:	0f b6       	in	r0, 0x3f	; 63
    63c0:	f8 94       	cli
    63c2:	de bf       	out	0x3e, r29	; 62
    63c4:	0f be       	out	0x3f, r0	; 63
    63c6:	cd bf       	out	0x3d, r28	; 61
    63c8:	cf 91       	pop	r28
    63ca:	df 91       	pop	r29
    63cc:	08 95       	ret

000063ce <prvGetNextExpireTime>:
/*-----------------------------------------------------------*/

    static TickType_t prvGetNextExpireTime( BaseType_t * const pxListWasEmpty )
    {
    63ce:	df 93       	push	r29
    63d0:	cf 93       	push	r28
    63d2:	00 d0       	rcall	.+0      	; 0x63d4 <prvGetNextExpireTime+0x6>
    63d4:	00 d0       	rcall	.+0      	; 0x63d6 <prvGetNextExpireTime+0x8>
    63d6:	0f 92       	push	r0
    63d8:	cd b7       	in	r28, 0x3d	; 61
    63da:	de b7       	in	r29, 0x3e	; 62
    63dc:	9c 83       	std	Y+4, r25	; 0x04
    63de:	8b 83       	std	Y+3, r24	; 0x03
         * the timer with the nearest expiry time will expire.  If there are no
         * active timers then just set the next expire time to 0.  That will cause
         * this task to unblock when the tick count overflows, at which point the
         * timer lists will be switched and the next expiry time can be
         * re-assessed.  */
        *pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
    63e0:	e0 91 e0 08 	lds	r30, 0x08E0
    63e4:	f0 91 e1 08 	lds	r31, 0x08E1
    63e8:	80 81       	ld	r24, Z
    63ea:	1d 82       	std	Y+5, r1	; 0x05
    63ec:	88 23       	and	r24, r24
    63ee:	11 f4       	brne	.+4      	; 0x63f4 <prvGetNextExpireTime+0x26>
    63f0:	81 e0       	ldi	r24, 0x01	; 1
    63f2:	8d 83       	std	Y+5, r24	; 0x05
    63f4:	eb 81       	ldd	r30, Y+3	; 0x03
    63f6:	fc 81       	ldd	r31, Y+4	; 0x04
    63f8:	8d 81       	ldd	r24, Y+5	; 0x05
    63fa:	80 83       	st	Z, r24

        if( *pxListWasEmpty == pdFALSE )
    63fc:	eb 81       	ldd	r30, Y+3	; 0x03
    63fe:	fc 81       	ldd	r31, Y+4	; 0x04
    6400:	80 81       	ld	r24, Z
    6402:	88 23       	and	r24, r24
    6404:	61 f4       	brne	.+24     	; 0x641e <prvGetNextExpireTime+0x50>
        {
            xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    6406:	e0 91 e0 08 	lds	r30, 0x08E0
    640a:	f0 91 e1 08 	lds	r31, 0x08E1
    640e:	05 80       	ldd	r0, Z+5	; 0x05
    6410:	f6 81       	ldd	r31, Z+6	; 0x06
    6412:	e0 2d       	mov	r30, r0
    6414:	80 81       	ld	r24, Z
    6416:	91 81       	ldd	r25, Z+1	; 0x01
    6418:	9a 83       	std	Y+2, r25	; 0x02
    641a:	89 83       	std	Y+1, r24	; 0x01
    641c:	02 c0       	rjmp	.+4      	; 0x6422 <prvGetNextExpireTime+0x54>
        }
        else
        {
            /* Ensure the task unblocks when the tick count rolls over. */
            xNextExpireTime = ( TickType_t ) 0U;
    641e:	1a 82       	std	Y+2, r1	; 0x02
    6420:	19 82       	std	Y+1, r1	; 0x01
        }

        return xNextExpireTime;
    6422:	89 81       	ldd	r24, Y+1	; 0x01
    6424:	9a 81       	ldd	r25, Y+2	; 0x02
    }
    6426:	0f 90       	pop	r0
    6428:	0f 90       	pop	r0
    642a:	0f 90       	pop	r0
    642c:	0f 90       	pop	r0
    642e:	0f 90       	pop	r0
    6430:	cf 91       	pop	r28
    6432:	df 91       	pop	r29
    6434:	08 95       	ret

00006436 <prvSampleTimeNow>:
/*-----------------------------------------------------------*/

    static TickType_t prvSampleTimeNow( BaseType_t * const pxTimerListsWereSwitched )
    {
    6436:	df 93       	push	r29
    6438:	cf 93       	push	r28
    643a:	00 d0       	rcall	.+0      	; 0x643c <prvSampleTimeNow+0x6>
    643c:	00 d0       	rcall	.+0      	; 0x643e <prvSampleTimeNow+0x8>
    643e:	cd b7       	in	r28, 0x3d	; 61
    6440:	de b7       	in	r29, 0x3e	; 62
    6442:	9c 83       	std	Y+4, r25	; 0x04
    6444:	8b 83       	std	Y+3, r24	; 0x03
        TickType_t xTimeNow;
        PRIVILEGED_DATA static TickType_t xLastTime = ( TickType_t ) 0U; /*lint !e956 Variable is only accessible to one task. */

        xTimeNow = xTaskGetTickCount();
    6446:	0e 94 e4 1f 	call	0x3fc8	; 0x3fc8 <xTaskGetTickCount>
    644a:	9a 83       	std	Y+2, r25	; 0x02
    644c:	89 83       	std	Y+1, r24	; 0x01

        if( xTimeNow < xLastTime )
    644e:	20 91 cc 08 	lds	r18, 0x08CC
    6452:	30 91 cd 08 	lds	r19, 0x08CD
    6456:	89 81       	ldd	r24, Y+1	; 0x01
    6458:	9a 81       	ldd	r25, Y+2	; 0x02
    645a:	82 17       	cp	r24, r18
    645c:	93 07       	cpc	r25, r19
    645e:	38 f4       	brcc	.+14     	; 0x646e <prvSampleTimeNow+0x38>
        {
            prvSwitchTimerLists();
    6460:	0e 94 ac 33 	call	0x6758	; 0x6758 <prvSwitchTimerLists>
            *pxTimerListsWereSwitched = pdTRUE;
    6464:	eb 81       	ldd	r30, Y+3	; 0x03
    6466:	fc 81       	ldd	r31, Y+4	; 0x04
    6468:	81 e0       	ldi	r24, 0x01	; 1
    646a:	80 83       	st	Z, r24
    646c:	03 c0       	rjmp	.+6      	; 0x6474 <prvSampleTimeNow+0x3e>
        }
        else
        {
            *pxTimerListsWereSwitched = pdFALSE;
    646e:	eb 81       	ldd	r30, Y+3	; 0x03
    6470:	fc 81       	ldd	r31, Y+4	; 0x04
    6472:	10 82       	st	Z, r1
        }

        xLastTime = xTimeNow;
    6474:	89 81       	ldd	r24, Y+1	; 0x01
    6476:	9a 81       	ldd	r25, Y+2	; 0x02
    6478:	90 93 cd 08 	sts	0x08CD, r25
    647c:	80 93 cc 08 	sts	0x08CC, r24

        return xTimeNow;
    6480:	89 81       	ldd	r24, Y+1	; 0x01
    6482:	9a 81       	ldd	r25, Y+2	; 0x02
    }
    6484:	0f 90       	pop	r0
    6486:	0f 90       	pop	r0
    6488:	0f 90       	pop	r0
    648a:	0f 90       	pop	r0
    648c:	cf 91       	pop	r28
    648e:	df 91       	pop	r29
    6490:	08 95       	ret

00006492 <prvInsertTimerInActiveList>:

    static BaseType_t prvInsertTimerInActiveList( Timer_t * const pxTimer,
                                                  const TickType_t xNextExpiryTime,
                                                  const TickType_t xTimeNow,
                                                  const TickType_t xCommandTime )
    {
    6492:	df 93       	push	r29
    6494:	cf 93       	push	r28
    6496:	cd b7       	in	r28, 0x3d	; 61
    6498:	de b7       	in	r29, 0x3e	; 62
    649a:	29 97       	sbiw	r28, 0x09	; 9
    649c:	0f b6       	in	r0, 0x3f	; 63
    649e:	f8 94       	cli
    64a0:	de bf       	out	0x3e, r29	; 62
    64a2:	0f be       	out	0x3f, r0	; 63
    64a4:	cd bf       	out	0x3d, r28	; 61
    64a6:	9b 83       	std	Y+3, r25	; 0x03
    64a8:	8a 83       	std	Y+2, r24	; 0x02
    64aa:	7d 83       	std	Y+5, r23	; 0x05
    64ac:	6c 83       	std	Y+4, r22	; 0x04
    64ae:	5f 83       	std	Y+7, r21	; 0x07
    64b0:	4e 83       	std	Y+6, r20	; 0x06
    64b2:	39 87       	std	Y+9, r19	; 0x09
    64b4:	28 87       	std	Y+8, r18	; 0x08
        BaseType_t xProcessTimerNow = pdFALSE;
    64b6:	19 82       	std	Y+1, r1	; 0x01

        listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xNextExpiryTime );
    64b8:	ea 81       	ldd	r30, Y+2	; 0x02
    64ba:	fb 81       	ldd	r31, Y+3	; 0x03
    64bc:	8c 81       	ldd	r24, Y+4	; 0x04
    64be:	9d 81       	ldd	r25, Y+5	; 0x05
    64c0:	93 83       	std	Z+3, r25	; 0x03
    64c2:	82 83       	std	Z+2, r24	; 0x02
        listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
    64c4:	ea 81       	ldd	r30, Y+2	; 0x02
    64c6:	fb 81       	ldd	r31, Y+3	; 0x03
    64c8:	8a 81       	ldd	r24, Y+2	; 0x02
    64ca:	9b 81       	ldd	r25, Y+3	; 0x03
    64cc:	91 87       	std	Z+9, r25	; 0x09
    64ce:	80 87       	std	Z+8, r24	; 0x08

        if( xNextExpiryTime <= xTimeNow )
    64d0:	2c 81       	ldd	r18, Y+4	; 0x04
    64d2:	3d 81       	ldd	r19, Y+5	; 0x05
    64d4:	8e 81       	ldd	r24, Y+6	; 0x06
    64d6:	9f 81       	ldd	r25, Y+7	; 0x07
    64d8:	82 17       	cp	r24, r18
    64da:	93 07       	cpc	r25, r19
    64dc:	e0 f0       	brcs	.+56     	; 0x6516 <prvInsertTimerInActiveList+0x84>
        {
            /* Has the expiry time elapsed between the command to start/reset a
             * timer was issued, and the time the command was processed? */
            if( ( ( TickType_t ) ( xTimeNow - xCommandTime ) ) >= pxTimer->xTimerPeriodInTicks ) /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    64de:	2e 81       	ldd	r18, Y+6	; 0x06
    64e0:	3f 81       	ldd	r19, Y+7	; 0x07
    64e2:	88 85       	ldd	r24, Y+8	; 0x08
    64e4:	99 85       	ldd	r25, Y+9	; 0x09
    64e6:	28 1b       	sub	r18, r24
    64e8:	39 0b       	sbc	r19, r25
    64ea:	ea 81       	ldd	r30, Y+2	; 0x02
    64ec:	fb 81       	ldd	r31, Y+3	; 0x03
    64ee:	84 85       	ldd	r24, Z+12	; 0x0c
    64f0:	95 85       	ldd	r25, Z+13	; 0x0d
    64f2:	28 17       	cp	r18, r24
    64f4:	39 07       	cpc	r19, r25
    64f6:	18 f0       	brcs	.+6      	; 0x64fe <prvInsertTimerInActiveList+0x6c>
            {
                /* The time between a command being issued and the command being
                 * processed actually exceeds the timers period.  */
                xProcessTimerNow = pdTRUE;
    64f8:	81 e0       	ldi	r24, 0x01	; 1
    64fa:	89 83       	std	Y+1, r24	; 0x01
    64fc:	28 c0       	rjmp	.+80     	; 0x654e <prvInsertTimerInActiveList+0xbc>
            }
            else
            {
                vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
    64fe:	80 91 e2 08 	lds	r24, 0x08E2
    6502:	90 91 e3 08 	lds	r25, 0x08E3
    6506:	2a 81       	ldd	r18, Y+2	; 0x02
    6508:	3b 81       	ldd	r19, Y+3	; 0x03
    650a:	2e 5f       	subi	r18, 0xFE	; 254
    650c:	3f 4f       	sbci	r19, 0xFF	; 255
    650e:	b9 01       	movw	r22, r18
    6510:	0e 94 29 11 	call	0x2252	; 0x2252 <vListInsert>
    6514:	1c c0       	rjmp	.+56     	; 0x654e <prvInsertTimerInActiveList+0xbc>
            }
        }
        else
        {
            if( ( xTimeNow < xCommandTime ) && ( xNextExpiryTime >= xCommandTime ) )
    6516:	2e 81       	ldd	r18, Y+6	; 0x06
    6518:	3f 81       	ldd	r19, Y+7	; 0x07
    651a:	88 85       	ldd	r24, Y+8	; 0x08
    651c:	99 85       	ldd	r25, Y+9	; 0x09
    651e:	28 17       	cp	r18, r24
    6520:	39 07       	cpc	r19, r25
    6522:	50 f4       	brcc	.+20     	; 0x6538 <prvInsertTimerInActiveList+0xa6>
    6524:	2c 81       	ldd	r18, Y+4	; 0x04
    6526:	3d 81       	ldd	r19, Y+5	; 0x05
    6528:	88 85       	ldd	r24, Y+8	; 0x08
    652a:	99 85       	ldd	r25, Y+9	; 0x09
    652c:	28 17       	cp	r18, r24
    652e:	39 07       	cpc	r19, r25
    6530:	18 f0       	brcs	.+6      	; 0x6538 <prvInsertTimerInActiveList+0xa6>
            {
                /* If, since the command was issued, the tick count has overflowed
                 * but the expiry time has not, then the timer must have already passed
                 * its expiry time and should be processed immediately. */
                xProcessTimerNow = pdTRUE;
    6532:	81 e0       	ldi	r24, 0x01	; 1
    6534:	89 83       	std	Y+1, r24	; 0x01
    6536:	0b c0       	rjmp	.+22     	; 0x654e <prvInsertTimerInActiveList+0xbc>
            }
            else
            {
                vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
    6538:	80 91 e0 08 	lds	r24, 0x08E0
    653c:	90 91 e1 08 	lds	r25, 0x08E1
    6540:	2a 81       	ldd	r18, Y+2	; 0x02
    6542:	3b 81       	ldd	r19, Y+3	; 0x03
    6544:	2e 5f       	subi	r18, 0xFE	; 254
    6546:	3f 4f       	sbci	r19, 0xFF	; 255
    6548:	b9 01       	movw	r22, r18
    654a:	0e 94 29 11 	call	0x2252	; 0x2252 <vListInsert>
            }
        }

        return xProcessTimerNow;
    654e:	89 81       	ldd	r24, Y+1	; 0x01
    }
    6550:	29 96       	adiw	r28, 0x09	; 9
    6552:	0f b6       	in	r0, 0x3f	; 63
    6554:	f8 94       	cli
    6556:	de bf       	out	0x3e, r29	; 62
    6558:	0f be       	out	0x3f, r0	; 63
    655a:	cd bf       	out	0x3d, r28	; 61
    655c:	cf 91       	pop	r28
    655e:	df 91       	pop	r29
    6560:	08 95       	ret

00006562 <prvProcessReceivedCommands>:
/*-----------------------------------------------------------*/

    static void prvProcessReceivedCommands( void )
    {
    6562:	df 93       	push	r29
    6564:	cf 93       	push	r28
    6566:	cd b7       	in	r28, 0x3d	; 61
    6568:	de b7       	in	r29, 0x3e	; 62
    656a:	2c 97       	sbiw	r28, 0x0c	; 12
    656c:	0f b6       	in	r0, 0x3f	; 63
    656e:	f8 94       	cli
    6570:	de bf       	out	0x3e, r29	; 62
    6572:	0f be       	out	0x3f, r0	; 63
    6574:	cd bf       	out	0x3d, r28	; 61
    6576:	d8 c0       	rjmp	.+432    	; 0x6728 <prvProcessReceivedCommands+0x1c6>
                }
            #endif /* INCLUDE_xTimerPendFunctionCall */

            /* Commands that are positive are timer commands rather than pended
             * function calls. */
            if( xMessage.xMessageID >= ( BaseType_t ) 0 )
    6578:	8d 81       	ldd	r24, Y+5	; 0x05
    657a:	88 23       	and	r24, r24
    657c:	0c f4       	brge	.+2      	; 0x6580 <prvProcessReceivedCommands+0x1e>
    657e:	d4 c0       	rjmp	.+424    	; 0x6728 <prvProcessReceivedCommands+0x1c6>
            {
                /* The messages uses the xTimerParameters member to work on a
                 * software timer. */
                pxTimer = xMessage.u.xTimerParameters.pxTimer;
    6580:	88 85       	ldd	r24, Y+8	; 0x08
    6582:	99 85       	ldd	r25, Y+9	; 0x09
    6584:	9c 83       	std	Y+4, r25	; 0x04
    6586:	8b 83       	std	Y+3, r24	; 0x03

                if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdFALSE ) /*lint !e961. The cast is only redundant when NULL is passed into the macro. */
    6588:	eb 81       	ldd	r30, Y+3	; 0x03
    658a:	fc 81       	ldd	r31, Y+4	; 0x04
    658c:	82 85       	ldd	r24, Z+10	; 0x0a
    658e:	93 85       	ldd	r25, Z+11	; 0x0b
    6590:	00 97       	sbiw	r24, 0x00	; 0
    6592:	29 f0       	breq	.+10     	; 0x659e <prvProcessReceivedCommands+0x3c>
                {
                    /* The timer is in a list, remove it. */
                    ( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    6594:	8b 81       	ldd	r24, Y+3	; 0x03
    6596:	9c 81       	ldd	r25, Y+4	; 0x04
    6598:	02 96       	adiw	r24, 0x02	; 2
    659a:	0e 94 95 11 	call	0x232a	; 0x232a <uxListRemove>
                 *  it must be present in the function call.  prvSampleTimeNow() must be
                 *  called after the message is received from xTimerQueue so there is no
                 *  possibility of a higher priority task adding a message to the message
                 *  queue with a time that is ahead of the timer daemon task (because it
                 *  pre-empted the timer daemon task after the xTimeNow value was set). */
                xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    659e:	ce 01       	movw	r24, r28
    65a0:	0a 96       	adiw	r24, 0x0a	; 10
    65a2:	0e 94 1b 32 	call	0x6436	; 0x6436 <prvSampleTimeNow>
    65a6:	9a 83       	std	Y+2, r25	; 0x02
    65a8:	89 83       	std	Y+1, r24	; 0x01

                switch( xMessage.xMessageID )
    65aa:	8d 81       	ldd	r24, Y+5	; 0x05
    65ac:	28 2f       	mov	r18, r24
    65ae:	33 27       	eor	r19, r19
    65b0:	27 fd       	sbrc	r18, 7
    65b2:	30 95       	com	r19
    65b4:	3c 87       	std	Y+12, r19	; 0x0c
    65b6:	2b 87       	std	Y+11, r18	; 0x0b
    65b8:	8b 85       	ldd	r24, Y+11	; 0x0b
    65ba:	9c 85       	ldd	r25, Y+12	; 0x0c
    65bc:	85 30       	cpi	r24, 0x05	; 5
    65be:	91 05       	cpc	r25, r1
    65c0:	09 f4       	brne	.+2      	; 0x65c4 <prvProcessReceivedCommands+0x62>
    65c2:	9d c0       	rjmp	.+314    	; 0x66fe <prvProcessReceivedCommands+0x19c>
    65c4:	2b 85       	ldd	r18, Y+11	; 0x0b
    65c6:	3c 85       	ldd	r19, Y+12	; 0x0c
    65c8:	26 30       	cpi	r18, 0x06	; 6
    65ca:	31 05       	cpc	r19, r1
    65cc:	9c f4       	brge	.+38     	; 0x65f4 <prvProcessReceivedCommands+0x92>
    65ce:	8b 85       	ldd	r24, Y+11	; 0x0b
    65d0:	9c 85       	ldd	r25, Y+12	; 0x0c
    65d2:	83 30       	cpi	r24, 0x03	; 3
    65d4:	91 05       	cpc	r25, r1
    65d6:	09 f4       	brne	.+2      	; 0x65da <prvProcessReceivedCommands+0x78>
    65d8:	68 c0       	rjmp	.+208    	; 0x66aa <prvProcessReceivedCommands+0x148>
    65da:	2b 85       	ldd	r18, Y+11	; 0x0b
    65dc:	3c 85       	ldd	r19, Y+12	; 0x0c
    65de:	24 30       	cpi	r18, 0x04	; 4
    65e0:	31 05       	cpc	r19, r1
    65e2:	0c f0       	brlt	.+2      	; 0x65e6 <prvProcessReceivedCommands+0x84>
    65e4:	6a c0       	rjmp	.+212    	; 0x66ba <prvProcessReceivedCommands+0x158>
    65e6:	8b 85       	ldd	r24, Y+11	; 0x0b
    65e8:	9c 85       	ldd	r25, Y+12	; 0x0c
    65ea:	81 30       	cpi	r24, 0x01	; 1
    65ec:	91 05       	cpc	r25, r1
    65ee:	0c f4       	brge	.+2      	; 0x65f2 <prvProcessReceivedCommands+0x90>
    65f0:	9b c0       	rjmp	.+310    	; 0x6728 <prvProcessReceivedCommands+0x1c6>
    65f2:	12 c0       	rjmp	.+36     	; 0x6618 <prvProcessReceivedCommands+0xb6>
    65f4:	2b 85       	ldd	r18, Y+11	; 0x0b
    65f6:	3c 85       	ldd	r19, Y+12	; 0x0c
    65f8:	28 30       	cpi	r18, 0x08	; 8
    65fa:	31 05       	cpc	r19, r1
    65fc:	09 f4       	brne	.+2      	; 0x6600 <prvProcessReceivedCommands+0x9e>
    65fe:	55 c0       	rjmp	.+170    	; 0x66aa <prvProcessReceivedCommands+0x148>
    6600:	8b 85       	ldd	r24, Y+11	; 0x0b
    6602:	9c 85       	ldd	r25, Y+12	; 0x0c
    6604:	88 30       	cpi	r24, 0x08	; 8
    6606:	91 05       	cpc	r25, r1
    6608:	3c f0       	brlt	.+14     	; 0x6618 <prvProcessReceivedCommands+0xb6>
    660a:	2b 85       	ldd	r18, Y+11	; 0x0b
    660c:	3c 85       	ldd	r19, Y+12	; 0x0c
    660e:	29 30       	cpi	r18, 0x09	; 9
    6610:	31 05       	cpc	r19, r1
    6612:	09 f4       	brne	.+2      	; 0x6616 <prvProcessReceivedCommands+0xb4>
    6614:	52 c0       	rjmp	.+164    	; 0x66ba <prvProcessReceivedCommands+0x158>
    6616:	88 c0       	rjmp	.+272    	; 0x6728 <prvProcessReceivedCommands+0x1c6>
                    case tmrCOMMAND_START:
                    case tmrCOMMAND_START_FROM_ISR:
                    case tmrCOMMAND_RESET:
                    case tmrCOMMAND_RESET_FROM_ISR:
                        /* Start or restart a timer. */
                        pxTimer->ucStatus |= tmrSTATUS_IS_ACTIVE;
    6618:	eb 81       	ldd	r30, Y+3	; 0x03
    661a:	fc 81       	ldd	r31, Y+4	; 0x04
    661c:	82 89       	ldd	r24, Z+18	; 0x12
    661e:	81 60       	ori	r24, 0x01	; 1
    6620:	eb 81       	ldd	r30, Y+3	; 0x03
    6622:	fc 81       	ldd	r31, Y+4	; 0x04
    6624:	82 8b       	std	Z+18, r24	; 0x12

                        if( prvInsertTimerInActiveList( pxTimer, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.u.xTimerParameters.xMessageValue ) != pdFALSE )
    6626:	2e 81       	ldd	r18, Y+6	; 0x06
    6628:	3f 81       	ldd	r19, Y+7	; 0x07
    662a:	eb 81       	ldd	r30, Y+3	; 0x03
    662c:	fc 81       	ldd	r31, Y+4	; 0x04
    662e:	84 85       	ldd	r24, Z+12	; 0x0c
    6630:	95 85       	ldd	r25, Z+13	; 0x0d
    6632:	a9 01       	movw	r20, r18
    6634:	48 0f       	add	r20, r24
    6636:	59 1f       	adc	r21, r25
    6638:	ee 81       	ldd	r30, Y+6	; 0x06
    663a:	ff 81       	ldd	r31, Y+7	; 0x07
    663c:	8b 81       	ldd	r24, Y+3	; 0x03
    663e:	9c 81       	ldd	r25, Y+4	; 0x04
    6640:	29 81       	ldd	r18, Y+1	; 0x01
    6642:	3a 81       	ldd	r19, Y+2	; 0x02
    6644:	ba 01       	movw	r22, r20
    6646:	a9 01       	movw	r20, r18
    6648:	9f 01       	movw	r18, r30
    664a:	0e 94 49 32 	call	0x6492	; 0x6492 <prvInsertTimerInActiveList>
    664e:	88 23       	and	r24, r24
    6650:	09 f4       	brne	.+2      	; 0x6654 <prvProcessReceivedCommands+0xf2>
    6652:	6a c0       	rjmp	.+212    	; 0x6728 <prvProcessReceivedCommands+0x1c6>
                        {
                            /* The timer expired before it was added to the active
                             * timer list.  Process it now. */
                            if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
    6654:	eb 81       	ldd	r30, Y+3	; 0x03
    6656:	fc 81       	ldd	r31, Y+4	; 0x04
    6658:	82 89       	ldd	r24, Z+18	; 0x12
    665a:	88 2f       	mov	r24, r24
    665c:	90 e0       	ldi	r25, 0x00	; 0
    665e:	84 70       	andi	r24, 0x04	; 4
    6660:	90 70       	andi	r25, 0x00	; 0
    6662:	00 97       	sbiw	r24, 0x00	; 0
    6664:	91 f0       	breq	.+36     	; 0x668a <prvProcessReceivedCommands+0x128>
                            {
                                prvReloadTimer( pxTimer, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow );
    6666:	2e 81       	ldd	r18, Y+6	; 0x06
    6668:	3f 81       	ldd	r19, Y+7	; 0x07
    666a:	eb 81       	ldd	r30, Y+3	; 0x03
    666c:	fc 81       	ldd	r31, Y+4	; 0x04
    666e:	84 85       	ldd	r24, Z+12	; 0x0c
    6670:	95 85       	ldd	r25, Z+13	; 0x0d
    6672:	a9 01       	movw	r20, r18
    6674:	48 0f       	add	r20, r24
    6676:	59 1f       	adc	r21, r25
    6678:	8b 81       	ldd	r24, Y+3	; 0x03
    667a:	9c 81       	ldd	r25, Y+4	; 0x04
    667c:	29 81       	ldd	r18, Y+1	; 0x01
    667e:	3a 81       	ldd	r19, Y+2	; 0x02
    6680:	ba 01       	movw	r22, r20
    6682:	a9 01       	movw	r20, r18
    6684:	0e 94 f3 30 	call	0x61e6	; 0x61e6 <prvReloadTimer>
    6688:	07 c0       	rjmp	.+14     	; 0x6698 <prvProcessReceivedCommands+0x136>
                            }
                            else
                            {
                                pxTimer->ucStatus &= ( ( uint8_t ) ~tmrSTATUS_IS_ACTIVE );
    668a:	eb 81       	ldd	r30, Y+3	; 0x03
    668c:	fc 81       	ldd	r31, Y+4	; 0x04
    668e:	82 89       	ldd	r24, Z+18	; 0x12
    6690:	8e 7f       	andi	r24, 0xFE	; 254
    6692:	eb 81       	ldd	r30, Y+3	; 0x03
    6694:	fc 81       	ldd	r31, Y+4	; 0x04
    6696:	82 8b       	std	Z+18, r24	; 0x12
                            }

                            /* Call the timer callback. */
                            traceTIMER_EXPIRED( pxTimer );
                            pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    6698:	eb 81       	ldd	r30, Y+3	; 0x03
    669a:	fc 81       	ldd	r31, Y+4	; 0x04
    669c:	00 88       	ldd	r0, Z+16	; 0x10
    669e:	f1 89       	ldd	r31, Z+17	; 0x11
    66a0:	e0 2d       	mov	r30, r0
    66a2:	8b 81       	ldd	r24, Y+3	; 0x03
    66a4:	9c 81       	ldd	r25, Y+4	; 0x04
    66a6:	09 95       	icall
    66a8:	3f c0       	rjmp	.+126    	; 0x6728 <prvProcessReceivedCommands+0x1c6>
                        break;

                    case tmrCOMMAND_STOP:
                    case tmrCOMMAND_STOP_FROM_ISR:
                        /* The timer has already been removed from the active list. */
                        pxTimer->ucStatus &= ( ( uint8_t ) ~tmrSTATUS_IS_ACTIVE );
    66aa:	eb 81       	ldd	r30, Y+3	; 0x03
    66ac:	fc 81       	ldd	r31, Y+4	; 0x04
    66ae:	82 89       	ldd	r24, Z+18	; 0x12
    66b0:	8e 7f       	andi	r24, 0xFE	; 254
    66b2:	eb 81       	ldd	r30, Y+3	; 0x03
    66b4:	fc 81       	ldd	r31, Y+4	; 0x04
    66b6:	82 8b       	std	Z+18, r24	; 0x12
    66b8:	37 c0       	rjmp	.+110    	; 0x6728 <prvProcessReceivedCommands+0x1c6>
                        break;

                    case tmrCOMMAND_CHANGE_PERIOD:
                    case tmrCOMMAND_CHANGE_PERIOD_FROM_ISR:
                        pxTimer->ucStatus |= tmrSTATUS_IS_ACTIVE;
    66ba:	eb 81       	ldd	r30, Y+3	; 0x03
    66bc:	fc 81       	ldd	r31, Y+4	; 0x04
    66be:	82 89       	ldd	r24, Z+18	; 0x12
    66c0:	81 60       	ori	r24, 0x01	; 1
    66c2:	eb 81       	ldd	r30, Y+3	; 0x03
    66c4:	fc 81       	ldd	r31, Y+4	; 0x04
    66c6:	82 8b       	std	Z+18, r24	; 0x12
                        pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
    66c8:	8e 81       	ldd	r24, Y+6	; 0x06
    66ca:	9f 81       	ldd	r25, Y+7	; 0x07
    66cc:	eb 81       	ldd	r30, Y+3	; 0x03
    66ce:	fc 81       	ldd	r31, Y+4	; 0x04
    66d0:	95 87       	std	Z+13, r25	; 0x0d
    66d2:	84 87       	std	Z+12, r24	; 0x0c
                         * be longer or shorter than the old one.  The command time is
                         * therefore set to the current time, and as the period cannot
                         * be zero the next expiry time can only be in the future,
                         * meaning (unlike for the xTimerStart() case above) there is
                         * no fail case that needs to be handled here. */
                        ( void ) prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
    66d4:	eb 81       	ldd	r30, Y+3	; 0x03
    66d6:	fc 81       	ldd	r31, Y+4	; 0x04
    66d8:	24 85       	ldd	r18, Z+12	; 0x0c
    66da:	35 85       	ldd	r19, Z+13	; 0x0d
    66dc:	89 81       	ldd	r24, Y+1	; 0x01
    66de:	9a 81       	ldd	r25, Y+2	; 0x02
    66e0:	a9 01       	movw	r20, r18
    66e2:	48 0f       	add	r20, r24
    66e4:	59 1f       	adc	r21, r25
    66e6:	8b 81       	ldd	r24, Y+3	; 0x03
    66e8:	9c 81       	ldd	r25, Y+4	; 0x04
    66ea:	29 81       	ldd	r18, Y+1	; 0x01
    66ec:	3a 81       	ldd	r19, Y+2	; 0x02
    66ee:	e9 81       	ldd	r30, Y+1	; 0x01
    66f0:	fa 81       	ldd	r31, Y+2	; 0x02
    66f2:	ba 01       	movw	r22, r20
    66f4:	a9 01       	movw	r20, r18
    66f6:	9f 01       	movw	r18, r30
    66f8:	0e 94 49 32 	call	0x6492	; 0x6492 <prvInsertTimerInActiveList>
    66fc:	15 c0       	rjmp	.+42     	; 0x6728 <prvProcessReceivedCommands+0x1c6>
                        #if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
                            {
                                /* The timer has already been removed from the active list,
                                 * just free up the memory if the memory was dynamically
                                 * allocated. */
                                if( ( pxTimer->ucStatus & tmrSTATUS_IS_STATICALLY_ALLOCATED ) == ( uint8_t ) 0 )
    66fe:	eb 81       	ldd	r30, Y+3	; 0x03
    6700:	fc 81       	ldd	r31, Y+4	; 0x04
    6702:	82 89       	ldd	r24, Z+18	; 0x12
    6704:	88 2f       	mov	r24, r24
    6706:	90 e0       	ldi	r25, 0x00	; 0
    6708:	82 70       	andi	r24, 0x02	; 2
    670a:	90 70       	andi	r25, 0x00	; 0
    670c:	00 97       	sbiw	r24, 0x00	; 0
    670e:	29 f4       	brne	.+10     	; 0x671a <prvProcessReceivedCommands+0x1b8>
                                {
                                    vPortFree( pxTimer );
    6710:	8b 81       	ldd	r24, Y+3	; 0x03
    6712:	9c 81       	ldd	r25, Y+4	; 0x04
    6714:	0e 94 8d 07 	call	0xf1a	; 0xf1a <vPortFree>
    6718:	07 c0       	rjmp	.+14     	; 0x6728 <prvProcessReceivedCommands+0x1c6>
                                }
                                else
                                {
                                    pxTimer->ucStatus &= ( ( uint8_t ) ~tmrSTATUS_IS_ACTIVE );
    671a:	eb 81       	ldd	r30, Y+3	; 0x03
    671c:	fc 81       	ldd	r31, Y+4	; 0x04
    671e:	82 89       	ldd	r24, Z+18	; 0x12
    6720:	8e 7f       	andi	r24, 0xFE	; 254
    6722:	eb 81       	ldd	r30, Y+3	; 0x03
    6724:	fc 81       	ldd	r31, Y+4	; 0x04
    6726:	82 8b       	std	Z+18, r24	; 0x12
        DaemonTaskMessage_t xMessage;
        Timer_t * pxTimer;
        BaseType_t xTimerListsWereSwitched;
        TickType_t xTimeNow;

        while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
    6728:	80 91 c8 08 	lds	r24, 0x08C8
    672c:	90 91 c9 08 	lds	r25, 0x08C9
    6730:	9e 01       	movw	r18, r28
    6732:	2b 5f       	subi	r18, 0xFB	; 251
    6734:	3f 4f       	sbci	r19, 0xFF	; 255
    6736:	b9 01       	movw	r22, r18
    6738:	40 e0       	ldi	r20, 0x00	; 0
    673a:	50 e0       	ldi	r21, 0x00	; 0
    673c:	0e 94 94 14 	call	0x2928	; 0x2928 <xQueueReceive>
    6740:	88 23       	and	r24, r24
    6742:	09 f0       	breq	.+2      	; 0x6746 <prvProcessReceivedCommands+0x1e4>
    6744:	19 cf       	rjmp	.-462    	; 0x6578 <prvProcessReceivedCommands+0x16>
                        /* Don't expect to get here. */
                        break;
                }
            }
        }
    }
    6746:	2c 96       	adiw	r28, 0x0c	; 12
    6748:	0f b6       	in	r0, 0x3f	; 63
    674a:	f8 94       	cli
    674c:	de bf       	out	0x3e, r29	; 62
    674e:	0f be       	out	0x3f, r0	; 63
    6750:	cd bf       	out	0x3d, r28	; 61
    6752:	cf 91       	pop	r28
    6754:	df 91       	pop	r29
    6756:	08 95       	ret

00006758 <prvSwitchTimerLists>:
/*-----------------------------------------------------------*/

    static void prvSwitchTimerLists( void )
    {
    6758:	df 93       	push	r29
    675a:	cf 93       	push	r28
    675c:	00 d0       	rcall	.+0      	; 0x675e <prvSwitchTimerLists+0x6>
    675e:	00 d0       	rcall	.+0      	; 0x6760 <prvSwitchTimerLists+0x8>
    6760:	cd b7       	in	r28, 0x3d	; 61
    6762:	de b7       	in	r29, 0x3e	; 62
    6764:	11 c0       	rjmp	.+34     	; 0x6788 <prvSwitchTimerLists+0x30>
         * If there are any timers still referenced from the current timer list
         * then they must have expired and should be processed before the lists
         * are switched. */
        while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
        {
            xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    6766:	e0 91 e0 08 	lds	r30, 0x08E0
    676a:	f0 91 e1 08 	lds	r31, 0x08E1
    676e:	05 80       	ldd	r0, Z+5	; 0x05
    6770:	f6 81       	ldd	r31, Z+6	; 0x06
    6772:	e0 2d       	mov	r30, r0
    6774:	80 81       	ld	r24, Z
    6776:	91 81       	ldd	r25, Z+1	; 0x01
    6778:	9c 83       	std	Y+4, r25	; 0x04
    677a:	8b 83       	std	Y+3, r24	; 0x03

            /* Process the expired timer.  For auto-reload timers, be careful to
             * process only expirations that occur on the current list.  Further
             * expirations must wait until after the lists are switched. */
            prvProcessExpiredTimer( xNextExpireTime, tmrMAX_TIME_BEFORE_OVERFLOW );
    677c:	8b 81       	ldd	r24, Y+3	; 0x03
    677e:	9c 81       	ldd	r25, Y+4	; 0x04
    6780:	6f ef       	ldi	r22, 0xFF	; 255
    6782:	7f ef       	ldi	r23, 0xFF	; 255
    6784:	0e 94 32 31 	call	0x6264	; 0x6264 <prvProcessExpiredTimer>

        /* The tick count has overflowed.  The timer lists must be switched.
         * If there are any timers still referenced from the current timer list
         * then they must have expired and should be processed before the lists
         * are switched. */
        while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
    6788:	e0 91 e0 08 	lds	r30, 0x08E0
    678c:	f0 91 e1 08 	lds	r31, 0x08E1
    6790:	80 81       	ld	r24, Z
    6792:	88 23       	and	r24, r24
    6794:	41 f7       	brne	.-48     	; 0x6766 <prvSwitchTimerLists+0xe>
             * process only expirations that occur on the current list.  Further
             * expirations must wait until after the lists are switched. */
            prvProcessExpiredTimer( xNextExpireTime, tmrMAX_TIME_BEFORE_OVERFLOW );
        }

        pxTemp = pxCurrentTimerList;
    6796:	80 91 e0 08 	lds	r24, 0x08E0
    679a:	90 91 e1 08 	lds	r25, 0x08E1
    679e:	9a 83       	std	Y+2, r25	; 0x02
    67a0:	89 83       	std	Y+1, r24	; 0x01
        pxCurrentTimerList = pxOverflowTimerList;
    67a2:	80 91 e2 08 	lds	r24, 0x08E2
    67a6:	90 91 e3 08 	lds	r25, 0x08E3
    67aa:	90 93 e1 08 	sts	0x08E1, r25
    67ae:	80 93 e0 08 	sts	0x08E0, r24
        pxOverflowTimerList = pxTemp;
    67b2:	89 81       	ldd	r24, Y+1	; 0x01
    67b4:	9a 81       	ldd	r25, Y+2	; 0x02
    67b6:	90 93 e3 08 	sts	0x08E3, r25
    67ba:	80 93 e2 08 	sts	0x08E2, r24
    }
    67be:	0f 90       	pop	r0
    67c0:	0f 90       	pop	r0
    67c2:	0f 90       	pop	r0
    67c4:	0f 90       	pop	r0
    67c6:	cf 91       	pop	r28
    67c8:	df 91       	pop	r29
    67ca:	08 95       	ret

000067cc <prvCheckForValidListAndQueue>:
/*-----------------------------------------------------------*/

    static void prvCheckForValidListAndQueue( void )
    {
    67cc:	df 93       	push	r29
    67ce:	cf 93       	push	r28
    67d0:	cd b7       	in	r28, 0x3d	; 61
    67d2:	de b7       	in	r29, 0x3e	; 62
        /* Check that the list from which active timers are referenced, and the
         * queue used to communicate with the timer service, have been
         * initialised. */
        taskENTER_CRITICAL();
    67d4:	0f b6       	in	r0, 0x3f	; 63
    67d6:	f8 94       	cli
    67d8:	0f 92       	push	r0
        {
            if( xTimerQueue == NULL )
    67da:	80 91 c8 08 	lds	r24, 0x08C8
    67de:	90 91 c9 08 	lds	r25, 0x08C9
    67e2:	00 97       	sbiw	r24, 0x00	; 0
    67e4:	e9 f4       	brne	.+58     	; 0x6820 <prvCheckForValidListAndQueue+0x54>
            {
                vListInitialise( &xActiveTimerList1 );
    67e6:	8e ec       	ldi	r24, 0xCE	; 206
    67e8:	98 e0       	ldi	r25, 0x08	; 8
    67ea:	0e 94 ab 10 	call	0x2156	; 0x2156 <vListInitialise>
                vListInitialise( &xActiveTimerList2 );
    67ee:	87 ed       	ldi	r24, 0xD7	; 215
    67f0:	98 e0       	ldi	r25, 0x08	; 8
    67f2:	0e 94 ab 10 	call	0x2156	; 0x2156 <vListInitialise>
                pxCurrentTimerList = &xActiveTimerList1;
    67f6:	8e ec       	ldi	r24, 0xCE	; 206
    67f8:	98 e0       	ldi	r25, 0x08	; 8
    67fa:	90 93 e1 08 	sts	0x08E1, r25
    67fe:	80 93 e0 08 	sts	0x08E0, r24
                pxOverflowTimerList = &xActiveTimerList2;
    6802:	87 ed       	ldi	r24, 0xD7	; 215
    6804:	98 e0       	ldi	r25, 0x08	; 8
    6806:	90 93 e3 08 	sts	0x08E3, r25
    680a:	80 93 e2 08 	sts	0x08E2, r24

                        xTimerQueue = xQueueCreateStatic( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, ( UBaseType_t ) sizeof( DaemonTaskMessage_t ), &( ucStaticTimerQueueStorage[ 0 ] ), &xStaticTimerQueue );
                    }
                #else
                    {
                        xTimerQueue = xQueueCreate( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, sizeof( DaemonTaskMessage_t ) );
    680e:	8a e0       	ldi	r24, 0x0A	; 10
    6810:	65 e0       	ldi	r22, 0x05	; 5
    6812:	40 e0       	ldi	r20, 0x00	; 0
    6814:	0e 94 8c 12 	call	0x2518	; 0x2518 <xQueueGenericCreate>
    6818:	90 93 c9 08 	sts	0x08C9, r25
    681c:	80 93 c8 08 	sts	0x08C8, r24
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        taskEXIT_CRITICAL();
    6820:	0f 90       	pop	r0
    6822:	0f be       	out	0x3f, r0	; 63
    }
    6824:	cf 91       	pop	r28
    6826:	df 91       	pop	r29
    6828:	08 95       	ret

0000682a <xTimerIsTimerActive>:
/*-----------------------------------------------------------*/

    BaseType_t xTimerIsTimerActive( TimerHandle_t xTimer )
    {
    682a:	df 93       	push	r29
    682c:	cf 93       	push	r28
    682e:	00 d0       	rcall	.+0      	; 0x6830 <xTimerIsTimerActive+0x6>
    6830:	00 d0       	rcall	.+0      	; 0x6832 <xTimerIsTimerActive+0x8>
    6832:	0f 92       	push	r0
    6834:	cd b7       	in	r28, 0x3d	; 61
    6836:	de b7       	in	r29, 0x3e	; 62
    6838:	9d 83       	std	Y+5, r25	; 0x05
    683a:	8c 83       	std	Y+4, r24	; 0x04
        BaseType_t xReturn;
        Timer_t * pxTimer = xTimer;
    683c:	8c 81       	ldd	r24, Y+4	; 0x04
    683e:	9d 81       	ldd	r25, Y+5	; 0x05
    6840:	9a 83       	std	Y+2, r25	; 0x02
    6842:	89 83       	std	Y+1, r24	; 0x01

        configASSERT( xTimer );

        /* Is the timer in the list of active timers? */
        taskENTER_CRITICAL();
    6844:	0f b6       	in	r0, 0x3f	; 63
    6846:	f8 94       	cli
    6848:	0f 92       	push	r0
        {
            if( ( pxTimer->ucStatus & tmrSTATUS_IS_ACTIVE ) == 0 )
    684a:	e9 81       	ldd	r30, Y+1	; 0x01
    684c:	fa 81       	ldd	r31, Y+2	; 0x02
    684e:	82 89       	ldd	r24, Z+18	; 0x12
    6850:	88 2f       	mov	r24, r24
    6852:	90 e0       	ldi	r25, 0x00	; 0
    6854:	81 70       	andi	r24, 0x01	; 1
    6856:	90 70       	andi	r25, 0x00	; 0
    6858:	00 97       	sbiw	r24, 0x00	; 0
    685a:	11 f4       	brne	.+4      	; 0x6860 <xTimerIsTimerActive+0x36>
            {
                xReturn = pdFALSE;
    685c:	1b 82       	std	Y+3, r1	; 0x03
    685e:	02 c0       	rjmp	.+4      	; 0x6864 <xTimerIsTimerActive+0x3a>
            }
            else
            {
                xReturn = pdTRUE;
    6860:	81 e0       	ldi	r24, 0x01	; 1
    6862:	8b 83       	std	Y+3, r24	; 0x03
            }
        }
        taskEXIT_CRITICAL();
    6864:	0f 90       	pop	r0
    6866:	0f be       	out	0x3f, r0	; 63

        return xReturn;
    6868:	8b 81       	ldd	r24, Y+3	; 0x03
    } /*lint !e818 Can't be pointer to const due to the typedef. */
    686a:	0f 90       	pop	r0
    686c:	0f 90       	pop	r0
    686e:	0f 90       	pop	r0
    6870:	0f 90       	pop	r0
    6872:	0f 90       	pop	r0
    6874:	cf 91       	pop	r28
    6876:	df 91       	pop	r29
    6878:	08 95       	ret

0000687a <pvTimerGetTimerID>:
/*-----------------------------------------------------------*/

    void * pvTimerGetTimerID( const TimerHandle_t xTimer )
    {
    687a:	df 93       	push	r29
    687c:	cf 93       	push	r28
    687e:	00 d0       	rcall	.+0      	; 0x6880 <pvTimerGetTimerID+0x6>
    6880:	00 d0       	rcall	.+0      	; 0x6882 <pvTimerGetTimerID+0x8>
    6882:	00 d0       	rcall	.+0      	; 0x6884 <pvTimerGetTimerID+0xa>
    6884:	cd b7       	in	r28, 0x3d	; 61
    6886:	de b7       	in	r29, 0x3e	; 62
    6888:	9e 83       	std	Y+6, r25	; 0x06
    688a:	8d 83       	std	Y+5, r24	; 0x05
        Timer_t * const pxTimer = xTimer;
    688c:	8d 81       	ldd	r24, Y+5	; 0x05
    688e:	9e 81       	ldd	r25, Y+6	; 0x06
    6890:	9c 83       	std	Y+4, r25	; 0x04
    6892:	8b 83       	std	Y+3, r24	; 0x03
        void * pvReturn;

        configASSERT( xTimer );

        taskENTER_CRITICAL();
    6894:	0f b6       	in	r0, 0x3f	; 63
    6896:	f8 94       	cli
    6898:	0f 92       	push	r0
        {
            pvReturn = pxTimer->pvTimerID;
    689a:	eb 81       	ldd	r30, Y+3	; 0x03
    689c:	fc 81       	ldd	r31, Y+4	; 0x04
    689e:	86 85       	ldd	r24, Z+14	; 0x0e
    68a0:	97 85       	ldd	r25, Z+15	; 0x0f
    68a2:	9a 83       	std	Y+2, r25	; 0x02
    68a4:	89 83       	std	Y+1, r24	; 0x01
        }
        taskEXIT_CRITICAL();
    68a6:	0f 90       	pop	r0
    68a8:	0f be       	out	0x3f, r0	; 63

        return pvReturn;
    68aa:	89 81       	ldd	r24, Y+1	; 0x01
    68ac:	9a 81       	ldd	r25, Y+2	; 0x02
    }
    68ae:	26 96       	adiw	r28, 0x06	; 6
    68b0:	0f b6       	in	r0, 0x3f	; 63
    68b2:	f8 94       	cli
    68b4:	de bf       	out	0x3e, r29	; 62
    68b6:	0f be       	out	0x3f, r0	; 63
    68b8:	cd bf       	out	0x3d, r28	; 61
    68ba:	cf 91       	pop	r28
    68bc:	df 91       	pop	r29
    68be:	08 95       	ret

000068c0 <vTimerSetTimerID>:
/*-----------------------------------------------------------*/

    void vTimerSetTimerID( TimerHandle_t xTimer,
                           void * pvNewID )
    {
    68c0:	df 93       	push	r29
    68c2:	cf 93       	push	r28
    68c4:	00 d0       	rcall	.+0      	; 0x68c6 <vTimerSetTimerID+0x6>
    68c6:	00 d0       	rcall	.+0      	; 0x68c8 <vTimerSetTimerID+0x8>
    68c8:	00 d0       	rcall	.+0      	; 0x68ca <vTimerSetTimerID+0xa>
    68ca:	cd b7       	in	r28, 0x3d	; 61
    68cc:	de b7       	in	r29, 0x3e	; 62
    68ce:	9c 83       	std	Y+4, r25	; 0x04
    68d0:	8b 83       	std	Y+3, r24	; 0x03
    68d2:	7e 83       	std	Y+6, r23	; 0x06
    68d4:	6d 83       	std	Y+5, r22	; 0x05
        Timer_t * const pxTimer = xTimer;
    68d6:	8b 81       	ldd	r24, Y+3	; 0x03
    68d8:	9c 81       	ldd	r25, Y+4	; 0x04
    68da:	9a 83       	std	Y+2, r25	; 0x02
    68dc:	89 83       	std	Y+1, r24	; 0x01

        configASSERT( xTimer );

        taskENTER_CRITICAL();
    68de:	0f b6       	in	r0, 0x3f	; 63
    68e0:	f8 94       	cli
    68e2:	0f 92       	push	r0
        {
            pxTimer->pvTimerID = pvNewID;
    68e4:	e9 81       	ldd	r30, Y+1	; 0x01
    68e6:	fa 81       	ldd	r31, Y+2	; 0x02
    68e8:	8d 81       	ldd	r24, Y+5	; 0x05
    68ea:	9e 81       	ldd	r25, Y+6	; 0x06
    68ec:	97 87       	std	Z+15, r25	; 0x0f
    68ee:	86 87       	std	Z+14, r24	; 0x0e
        }
        taskEXIT_CRITICAL();
    68f0:	0f 90       	pop	r0
    68f2:	0f be       	out	0x3f, r0	; 63
    }
    68f4:	26 96       	adiw	r28, 0x06	; 6
    68f6:	0f b6       	in	r0, 0x3f	; 63
    68f8:	f8 94       	cli
    68fa:	de bf       	out	0x3e, r29	; 62
    68fc:	0f be       	out	0x3f, r0	; 63
    68fe:	cd bf       	out	0x3d, r28	; 61
    6900:	cf 91       	pop	r28
    6902:	df 91       	pop	r29
    6904:	08 95       	ret

00006906 <Handle_data>:
#define WAIT_TIME_PER_DUTY_CHANGE	30
//uint8_t ignitionState = LOGIC_LOW;
unsigned char state;

void Handle_data(States_GroupType *Sates_Ptr)
{
    6906:	df 93       	push	r29
    6908:	cf 93       	push	r28
    690a:	00 d0       	rcall	.+0      	; 0x690c <Handle_data+0x6>
    690c:	cd b7       	in	r28, 0x3d	; 61
    690e:	de b7       	in	r29, 0x3e	; 62
    6910:	9a 83       	std	Y+2, r25	; 0x02
    6912:	89 83       	std	Y+1, r24	; 0x01

	LCD_moveCursor(0, 0);
    6914:	80 e0       	ldi	r24, 0x00	; 0
    6916:	60 e0       	ldi	r22, 0x00	; 0
    6918:	0e 94 ab 47 	call	0x8f56	; 0x8f56 <LCD_moveCursor>
	LCD_displayString("H:"); //hazard button
    691c:	8d e0       	ldi	r24, 0x0D	; 13
    691e:	91 e0       	ldi	r25, 0x01	; 1
    6920:	0e 94 82 47 	call	0x8f04	; 0x8f04 <LCD_displayString>
	LCD_intgerToString(Sates_Ptr->hazard_Btn);
    6924:	e9 81       	ldd	r30, Y+1	; 0x01
    6926:	fa 81       	ldd	r31, Y+2	; 0x02
    6928:	83 81       	ldd	r24, Z+3	; 0x03
    692a:	88 2f       	mov	r24, r24
    692c:	90 e0       	ldi	r25, 0x00	; 0
    692e:	0e 94 06 48 	call	0x900c	; 0x900c <LCD_intgerToString>
	LCD_displayString(" L:");	//left indicator
    6932:	80 e1       	ldi	r24, 0x10	; 16
    6934:	91 e0       	ldi	r25, 0x01	; 1
    6936:	0e 94 82 47 	call	0x8f04	; 0x8f04 <LCD_displayString>
	LCD_intgerToString(Sates_Ptr->leftIndicator);
    693a:	e9 81       	ldd	r30, Y+1	; 0x01
    693c:	fa 81       	ldd	r31, Y+2	; 0x02
    693e:	82 81       	ldd	r24, Z+2	; 0x02
    6940:	88 2f       	mov	r24, r24
    6942:	90 e0       	ldi	r25, 0x00	; 0
    6944:	0e 94 06 48 	call	0x900c	; 0x900c <LCD_intgerToString>
	LCD_moveCursor(1, 0);
    6948:	81 e0       	ldi	r24, 0x01	; 1
    694a:	60 e0       	ldi	r22, 0x00	; 0
    694c:	0e 94 ab 47 	call	0x8f56	; 0x8f56 <LCD_moveCursor>
	LCD_displayString(" R:");	//right indicator
    6950:	84 e1       	ldi	r24, 0x14	; 20
    6952:	91 e0       	ldi	r25, 0x01	; 1
    6954:	0e 94 82 47 	call	0x8f04	; 0x8f04 <LCD_displayString>
	LCD_intgerToString(Sates_Ptr->rightIndicator);
    6958:	e9 81       	ldd	r30, Y+1	; 0x01
    695a:	fa 81       	ldd	r31, Y+2	; 0x02
    695c:	81 81       	ldd	r24, Z+1	; 0x01
    695e:	88 2f       	mov	r24, r24
    6960:	90 e0       	ldi	r25, 0x00	; 0
    6962:	0e 94 06 48 	call	0x900c	; 0x900c <LCD_intgerToString>
	LCD_displayString(" I:");	//ignition button
    6966:	88 e1       	ldi	r24, 0x18	; 24
    6968:	91 e0       	ldi	r25, 0x01	; 1
    696a:	0e 94 82 47 	call	0x8f04	; 0x8f04 <LCD_displayString>
	LCD_intgerToString(Sates_Ptr->ignition_key);
    696e:	e9 81       	ldd	r30, Y+1	; 0x01
    6970:	fa 81       	ldd	r31, Y+2	; 0x02
    6972:	80 81       	ld	r24, Z
    6974:	88 2f       	mov	r24, r24
    6976:	90 e0       	ldi	r25, 0x00	; 0
    6978:	0e 94 06 48 	call	0x900c	; 0x900c <LCD_intgerToString>

	if(Sates_Ptr->ignition_key==TRUE)
    697c:	e9 81       	ldd	r30, Y+1	; 0x01
    697e:	fa 81       	ldd	r31, Y+2	; 0x02
    6980:	80 81       	ld	r24, Z
    6982:	81 30       	cpi	r24, 0x01	; 1
    6984:	b1 f4       	brne	.+44     	; 0x69b2 <Handle_data+0xac>
	{
		if(Sates_Ptr->rightIndicator==TRUE)
    6986:	e9 81       	ldd	r30, Y+1	; 0x01
    6988:	fa 81       	ldd	r31, Y+2	; 0x02
    698a:	81 81       	ldd	r24, Z+1	; 0x01
    698c:	81 30       	cpi	r24, 0x01	; 1
    698e:	21 f4       	brne	.+8      	; 0x6998 <Handle_data+0x92>
		{
			state = RIGHT_INDICATOR;
    6990:	81 e0       	ldi	r24, 0x01	; 1
    6992:	80 93 fb 08 	sts	0x08FB, r24
    6996:	10 c0       	rjmp	.+32     	; 0x69b8 <Handle_data+0xb2>
		}
		else if(Sates_Ptr->leftIndicator==TRUE)
    6998:	e9 81       	ldd	r30, Y+1	; 0x01
    699a:	fa 81       	ldd	r31, Y+2	; 0x02
    699c:	82 81       	ldd	r24, Z+2	; 0x02
    699e:	81 30       	cpi	r24, 0x01	; 1
    69a0:	21 f4       	brne	.+8      	; 0x69aa <Handle_data+0xa4>
		{
			state = LEFT_INDICATOR;
    69a2:	82 e0       	ldi	r24, 0x02	; 2
    69a4:	80 93 fb 08 	sts	0x08FB, r24
    69a8:	07 c0       	rjmp	.+14     	; 0x69b8 <Handle_data+0xb2>
		}
		else{
			state = NO_INDICATOR;
    69aa:	83 e0       	ldi	r24, 0x03	; 3
    69ac:	80 93 fb 08 	sts	0x08FB, r24
    69b0:	03 c0       	rjmp	.+6      	; 0x69b8 <Handle_data+0xb2>
		}
	}
	else{
		state = NO_INDICATOR;
    69b2:	83 e0       	ldi	r24, 0x03	; 3
    69b4:	80 93 fb 08 	sts	0x08FB, r24
	}

	if(Sates_Ptr->hazard_Btn==TRUE)
    69b8:	e9 81       	ldd	r30, Y+1	; 0x01
    69ba:	fa 81       	ldd	r31, Y+2	; 0x02
    69bc:	83 81       	ldd	r24, Z+3	; 0x03
    69be:	81 30       	cpi	r24, 0x01	; 1
    69c0:	19 f4       	brne	.+6      	; 0x69c8 <Handle_data+0xc2>
	{
		state = HAZARD_BUTTON;
    69c2:	84 e0       	ldi	r24, 0x04	; 4
    69c4:	80 93 fb 08 	sts	0x08FB, r24
	}



	State_Handler();
    69c8:	0e 94 eb 34 	call	0x69d6	; 0x69d6 <State_Handler>
}
    69cc:	0f 90       	pop	r0
    69ce:	0f 90       	pop	r0
    69d0:	cf 91       	pop	r28
    69d2:	df 91       	pop	r29
    69d4:	08 95       	ret

000069d6 <State_Handler>:

void State_Handler(void)
{
    69d6:	df 93       	push	r29
    69d8:	cf 93       	push	r28
    69da:	00 d0       	rcall	.+0      	; 0x69dc <State_Handler+0x6>
    69dc:	cd b7       	in	r28, 0x3d	; 61
    69de:	de b7       	in	r29, 0x3e	; 62
	switch(state)
    69e0:	80 91 fb 08 	lds	r24, 0x08FB
    69e4:	28 2f       	mov	r18, r24
    69e6:	30 e0       	ldi	r19, 0x00	; 0
    69e8:	3a 83       	std	Y+2, r19	; 0x02
    69ea:	29 83       	std	Y+1, r18	; 0x01
    69ec:	89 81       	ldd	r24, Y+1	; 0x01
    69ee:	9a 81       	ldd	r25, Y+2	; 0x02
    69f0:	82 30       	cpi	r24, 0x02	; 2
    69f2:	91 05       	cpc	r25, r1
    69f4:	e1 f0       	breq	.+56     	; 0x6a2e <State_Handler+0x58>
    69f6:	29 81       	ldd	r18, Y+1	; 0x01
    69f8:	3a 81       	ldd	r19, Y+2	; 0x02
    69fa:	23 30       	cpi	r18, 0x03	; 3
    69fc:	31 05       	cpc	r19, r1
    69fe:	34 f4       	brge	.+12     	; 0x6a0c <State_Handler+0x36>
    6a00:	89 81       	ldd	r24, Y+1	; 0x01
    6a02:	9a 81       	ldd	r25, Y+2	; 0x02
    6a04:	81 30       	cpi	r24, 0x01	; 1
    6a06:	91 05       	cpc	r25, r1
    6a08:	79 f0       	breq	.+30     	; 0x6a28 <State_Handler+0x52>
    6a0a:	16 c0       	rjmp	.+44     	; 0x6a38 <State_Handler+0x62>
    6a0c:	29 81       	ldd	r18, Y+1	; 0x01
    6a0e:	3a 81       	ldd	r19, Y+2	; 0x02
    6a10:	23 30       	cpi	r18, 0x03	; 3
    6a12:	31 05       	cpc	r19, r1
    6a14:	31 f0       	breq	.+12     	; 0x6a22 <State_Handler+0x4c>
    6a16:	89 81       	ldd	r24, Y+1	; 0x01
    6a18:	9a 81       	ldd	r25, Y+2	; 0x02
    6a1a:	84 30       	cpi	r24, 0x04	; 4
    6a1c:	91 05       	cpc	r25, r1
    6a1e:	51 f0       	breq	.+20     	; 0x6a34 <State_Handler+0x5e>
    6a20:	0b c0       	rjmp	.+22     	; 0x6a38 <State_Handler+0x62>
	{
	case NO_INDICATOR:
		NoLED_Blink();
    6a22:	0e 94 e7 35 	call	0x6bce	; 0x6bce <NoLED_Blink>
    6a26:	08 c0       	rjmp	.+16     	; 0x6a38 <State_Handler+0x62>
		break;
	case RIGHT_INDICATOR:
		RightLED_Blink();
    6a28:	0e 94 21 35 	call	0x6a42	; 0x6a42 <RightLED_Blink>
    6a2c:	05 c0       	rjmp	.+10     	; 0x6a38 <State_Handler+0x62>
		break;
	case LEFT_INDICATOR:
		LeftLED_Blink();
    6a2e:	0e 94 64 35 	call	0x6ac8	; 0x6ac8 <LeftLED_Blink>
    6a32:	02 c0       	rjmp	.+4      	; 0x6a38 <State_Handler+0x62>
		break;
	case HAZARD_BUTTON:
		BothLEDS_Blink();
    6a34:	0e 94 a7 35 	call	0x6b4e	; 0x6b4e <BothLEDS_Blink>
		break;

	}

}
    6a38:	0f 90       	pop	r0
    6a3a:	0f 90       	pop	r0
    6a3c:	cf 91       	pop	r28
    6a3e:	df 91       	pop	r29
    6a40:	08 95       	ret

00006a42 <RightLED_Blink>:


void RightLED_Blink(void)
{
    6a42:	df 93       	push	r29
    6a44:	cf 93       	push	r28
    6a46:	00 d0       	rcall	.+0      	; 0x6a48 <RightLED_Blink+0x6>
    6a48:	cd b7       	in	r28, 0x3d	; 61
    6a4a:	de b7       	in	r29, 0x3e	; 62
	int i = 0;
    6a4c:	1a 82       	std	Y+2, r1	; 0x02
    6a4e:	19 82       	std	Y+1, r1	; 0x01
	timer1_SetPWM_A(0);
    6a50:	80 e0       	ldi	r24, 0x00	; 0
    6a52:	0e 94 72 36 	call	0x6ce4	; 0x6ce4 <timer1_SetPWM_A>
	for(i = 2 ; i < 17 ; i++){
    6a56:	82 e0       	ldi	r24, 0x02	; 2
    6a58:	90 e0       	ldi	r25, 0x00	; 0
    6a5a:	9a 83       	std	Y+2, r25	; 0x02
    6a5c:	89 83       	std	Y+1, r24	; 0x01
    6a5e:	10 c0       	rjmp	.+32     	; 0x6a80 <RightLED_Blink+0x3e>

		timer1_SetPWM_B((i*5));
    6a60:	29 81       	ldd	r18, Y+1	; 0x01
    6a62:	3a 81       	ldd	r19, Y+2	; 0x02
    6a64:	c9 01       	movw	r24, r18
    6a66:	88 0f       	add	r24, r24
    6a68:	99 1f       	adc	r25, r25
    6a6a:	88 0f       	add	r24, r24
    6a6c:	99 1f       	adc	r25, r25
    6a6e:	82 0f       	add	r24, r18
    6a70:	93 1f       	adc	r25, r19
    6a72:	0e 94 1f 36 	call	0x6c3e	; 0x6c3e <timer1_SetPWM_B>

void RightLED_Blink(void)
{
	int i = 0;
	timer1_SetPWM_A(0);
	for(i = 2 ; i < 17 ; i++){
    6a76:	89 81       	ldd	r24, Y+1	; 0x01
    6a78:	9a 81       	ldd	r25, Y+2	; 0x02
    6a7a:	01 96       	adiw	r24, 0x01	; 1
    6a7c:	9a 83       	std	Y+2, r25	; 0x02
    6a7e:	89 83       	std	Y+1, r24	; 0x01
    6a80:	89 81       	ldd	r24, Y+1	; 0x01
    6a82:	9a 81       	ldd	r25, Y+2	; 0x02
    6a84:	81 31       	cpi	r24, 0x11	; 17
    6a86:	91 05       	cpc	r25, r1
    6a88:	5c f3       	brlt	.-42     	; 0x6a60 <RightLED_Blink+0x1e>

		timer1_SetPWM_B((i*5));
//		vTaskDelay(WAIT_TIME_PER_DUTY_CHANGE/portTICK_PERIOD_MS);
	}
	for(i = 16 ; i > 1 ; i--){
    6a8a:	80 e1       	ldi	r24, 0x10	; 16
    6a8c:	90 e0       	ldi	r25, 0x00	; 0
    6a8e:	9a 83       	std	Y+2, r25	; 0x02
    6a90:	89 83       	std	Y+1, r24	; 0x01
    6a92:	10 c0       	rjmp	.+32     	; 0x6ab4 <RightLED_Blink+0x72>

		timer1_SetPWM_B((i*5));
    6a94:	29 81       	ldd	r18, Y+1	; 0x01
    6a96:	3a 81       	ldd	r19, Y+2	; 0x02
    6a98:	c9 01       	movw	r24, r18
    6a9a:	88 0f       	add	r24, r24
    6a9c:	99 1f       	adc	r25, r25
    6a9e:	88 0f       	add	r24, r24
    6aa0:	99 1f       	adc	r25, r25
    6aa2:	82 0f       	add	r24, r18
    6aa4:	93 1f       	adc	r25, r19
    6aa6:	0e 94 1f 36 	call	0x6c3e	; 0x6c3e <timer1_SetPWM_B>
	for(i = 2 ; i < 17 ; i++){

		timer1_SetPWM_B((i*5));
//		vTaskDelay(WAIT_TIME_PER_DUTY_CHANGE/portTICK_PERIOD_MS);
	}
	for(i = 16 ; i > 1 ; i--){
    6aaa:	89 81       	ldd	r24, Y+1	; 0x01
    6aac:	9a 81       	ldd	r25, Y+2	; 0x02
    6aae:	01 97       	sbiw	r24, 0x01	; 1
    6ab0:	9a 83       	std	Y+2, r25	; 0x02
    6ab2:	89 83       	std	Y+1, r24	; 0x01
    6ab4:	89 81       	ldd	r24, Y+1	; 0x01
    6ab6:	9a 81       	ldd	r25, Y+2	; 0x02
    6ab8:	82 30       	cpi	r24, 0x02	; 2
    6aba:	91 05       	cpc	r25, r1
    6abc:	5c f7       	brge	.-42     	; 0x6a94 <RightLED_Blink+0x52>

		timer1_SetPWM_B((i*5));
//		vTaskDelay(WAIT_TIME_PER_DUTY_CHANGE/portTICK_PERIOD_MS);
	}
}
    6abe:	0f 90       	pop	r0
    6ac0:	0f 90       	pop	r0
    6ac2:	cf 91       	pop	r28
    6ac4:	df 91       	pop	r29
    6ac6:	08 95       	ret

00006ac8 <LeftLED_Blink>:

void LeftLED_Blink(void)
{
    6ac8:	df 93       	push	r29
    6aca:	cf 93       	push	r28
    6acc:	00 d0       	rcall	.+0      	; 0x6ace <LeftLED_Blink+0x6>
    6ace:	cd b7       	in	r28, 0x3d	; 61
    6ad0:	de b7       	in	r29, 0x3e	; 62
	int i = 0;
    6ad2:	1a 82       	std	Y+2, r1	; 0x02
    6ad4:	19 82       	std	Y+1, r1	; 0x01
	timer1_SetPWM_B(0);
    6ad6:	80 e0       	ldi	r24, 0x00	; 0
    6ad8:	0e 94 1f 36 	call	0x6c3e	; 0x6c3e <timer1_SetPWM_B>
	for(i = 2 ; i < 17 ; i++){
    6adc:	82 e0       	ldi	r24, 0x02	; 2
    6ade:	90 e0       	ldi	r25, 0x00	; 0
    6ae0:	9a 83       	std	Y+2, r25	; 0x02
    6ae2:	89 83       	std	Y+1, r24	; 0x01
    6ae4:	10 c0       	rjmp	.+32     	; 0x6b06 <LeftLED_Blink+0x3e>
		timer1_SetPWM_A((i*5));
    6ae6:	29 81       	ldd	r18, Y+1	; 0x01
    6ae8:	3a 81       	ldd	r19, Y+2	; 0x02
    6aea:	c9 01       	movw	r24, r18
    6aec:	88 0f       	add	r24, r24
    6aee:	99 1f       	adc	r25, r25
    6af0:	88 0f       	add	r24, r24
    6af2:	99 1f       	adc	r25, r25
    6af4:	82 0f       	add	r24, r18
    6af6:	93 1f       	adc	r25, r19
    6af8:	0e 94 72 36 	call	0x6ce4	; 0x6ce4 <timer1_SetPWM_A>

void LeftLED_Blink(void)
{
	int i = 0;
	timer1_SetPWM_B(0);
	for(i = 2 ; i < 17 ; i++){
    6afc:	89 81       	ldd	r24, Y+1	; 0x01
    6afe:	9a 81       	ldd	r25, Y+2	; 0x02
    6b00:	01 96       	adiw	r24, 0x01	; 1
    6b02:	9a 83       	std	Y+2, r25	; 0x02
    6b04:	89 83       	std	Y+1, r24	; 0x01
    6b06:	89 81       	ldd	r24, Y+1	; 0x01
    6b08:	9a 81       	ldd	r25, Y+2	; 0x02
    6b0a:	81 31       	cpi	r24, 0x11	; 17
    6b0c:	91 05       	cpc	r25, r1
    6b0e:	5c f3       	brlt	.-42     	; 0x6ae6 <LeftLED_Blink+0x1e>
		timer1_SetPWM_A((i*5));

//		vTaskDelay(WAIT_TIME_PER_DUTY_CHANGE/portTICK_PERIOD_MS);
	}
	for(i = 16 ; i > 1 ; i--){
    6b10:	80 e1       	ldi	r24, 0x10	; 16
    6b12:	90 e0       	ldi	r25, 0x00	; 0
    6b14:	9a 83       	std	Y+2, r25	; 0x02
    6b16:	89 83       	std	Y+1, r24	; 0x01
    6b18:	10 c0       	rjmp	.+32     	; 0x6b3a <LeftLED_Blink+0x72>
		timer1_SetPWM_A((i*5));
    6b1a:	29 81       	ldd	r18, Y+1	; 0x01
    6b1c:	3a 81       	ldd	r19, Y+2	; 0x02
    6b1e:	c9 01       	movw	r24, r18
    6b20:	88 0f       	add	r24, r24
    6b22:	99 1f       	adc	r25, r25
    6b24:	88 0f       	add	r24, r24
    6b26:	99 1f       	adc	r25, r25
    6b28:	82 0f       	add	r24, r18
    6b2a:	93 1f       	adc	r25, r19
    6b2c:	0e 94 72 36 	call	0x6ce4	; 0x6ce4 <timer1_SetPWM_A>
	for(i = 2 ; i < 17 ; i++){
		timer1_SetPWM_A((i*5));

//		vTaskDelay(WAIT_TIME_PER_DUTY_CHANGE/portTICK_PERIOD_MS);
	}
	for(i = 16 ; i > 1 ; i--){
    6b30:	89 81       	ldd	r24, Y+1	; 0x01
    6b32:	9a 81       	ldd	r25, Y+2	; 0x02
    6b34:	01 97       	sbiw	r24, 0x01	; 1
    6b36:	9a 83       	std	Y+2, r25	; 0x02
    6b38:	89 83       	std	Y+1, r24	; 0x01
    6b3a:	89 81       	ldd	r24, Y+1	; 0x01
    6b3c:	9a 81       	ldd	r25, Y+2	; 0x02
    6b3e:	82 30       	cpi	r24, 0x02	; 2
    6b40:	91 05       	cpc	r25, r1
    6b42:	5c f7       	brge	.-42     	; 0x6b1a <LeftLED_Blink+0x52>
		timer1_SetPWM_A((i*5));

//		vTaskDelay(WAIT_TIME_PER_DUTY_CHANGE/portTICK_PERIOD_MS);
	}
}
    6b44:	0f 90       	pop	r0
    6b46:	0f 90       	pop	r0
    6b48:	cf 91       	pop	r28
    6b4a:	df 91       	pop	r29
    6b4c:	08 95       	ret

00006b4e <BothLEDS_Blink>:

void BothLEDS_Blink(void)
{
    6b4e:	df 93       	push	r29
    6b50:	cf 93       	push	r28
    6b52:	00 d0       	rcall	.+0      	; 0x6b54 <BothLEDS_Blink+0x6>
    6b54:	cd b7       	in	r28, 0x3d	; 61
    6b56:	de b7       	in	r29, 0x3e	; 62
	int i = 0;
    6b58:	1a 82       	std	Y+2, r1	; 0x02
    6b5a:	19 82       	std	Y+1, r1	; 0x01
	for(i = 2 ; i < 17 ; i++){
    6b5c:	82 e0       	ldi	r24, 0x02	; 2
    6b5e:	90 e0       	ldi	r25, 0x00	; 0
    6b60:	9a 83       	std	Y+2, r25	; 0x02
    6b62:	89 83       	std	Y+1, r24	; 0x01
    6b64:	10 c0       	rjmp	.+32     	; 0x6b86 <BothLEDS_Blink+0x38>
		timer1_SetPWM_A_B(i*5);
    6b66:	29 81       	ldd	r18, Y+1	; 0x01
    6b68:	3a 81       	ldd	r19, Y+2	; 0x02
    6b6a:	c9 01       	movw	r24, r18
    6b6c:	88 0f       	add	r24, r24
    6b6e:	99 1f       	adc	r25, r25
    6b70:	88 0f       	add	r24, r24
    6b72:	99 1f       	adc	r25, r25
    6b74:	82 0f       	add	r24, r18
    6b76:	93 1f       	adc	r25, r19
    6b78:	0e 94 c5 36 	call	0x6d8a	; 0x6d8a <timer1_SetPWM_A_B>
}

void BothLEDS_Blink(void)
{
	int i = 0;
	for(i = 2 ; i < 17 ; i++){
    6b7c:	89 81       	ldd	r24, Y+1	; 0x01
    6b7e:	9a 81       	ldd	r25, Y+2	; 0x02
    6b80:	01 96       	adiw	r24, 0x01	; 1
    6b82:	9a 83       	std	Y+2, r25	; 0x02
    6b84:	89 83       	std	Y+1, r24	; 0x01
    6b86:	89 81       	ldd	r24, Y+1	; 0x01
    6b88:	9a 81       	ldd	r25, Y+2	; 0x02
    6b8a:	81 31       	cpi	r24, 0x11	; 17
    6b8c:	91 05       	cpc	r25, r1
    6b8e:	5c f3       	brlt	.-42     	; 0x6b66 <BothLEDS_Blink+0x18>
		timer1_SetPWM_A_B(i*5);
//		vTaskDelay(WAIT_TIME_PER_DUTY_CHANGE/portTICK_PERIOD_MS);
	}
	for(i = 16 ; i > 1 ; i--){
    6b90:	80 e1       	ldi	r24, 0x10	; 16
    6b92:	90 e0       	ldi	r25, 0x00	; 0
    6b94:	9a 83       	std	Y+2, r25	; 0x02
    6b96:	89 83       	std	Y+1, r24	; 0x01
    6b98:	10 c0       	rjmp	.+32     	; 0x6bba <BothLEDS_Blink+0x6c>
		timer1_SetPWM_A_B(i*5);
    6b9a:	29 81       	ldd	r18, Y+1	; 0x01
    6b9c:	3a 81       	ldd	r19, Y+2	; 0x02
    6b9e:	c9 01       	movw	r24, r18
    6ba0:	88 0f       	add	r24, r24
    6ba2:	99 1f       	adc	r25, r25
    6ba4:	88 0f       	add	r24, r24
    6ba6:	99 1f       	adc	r25, r25
    6ba8:	82 0f       	add	r24, r18
    6baa:	93 1f       	adc	r25, r19
    6bac:	0e 94 c5 36 	call	0x6d8a	; 0x6d8a <timer1_SetPWM_A_B>
	int i = 0;
	for(i = 2 ; i < 17 ; i++){
		timer1_SetPWM_A_B(i*5);
//		vTaskDelay(WAIT_TIME_PER_DUTY_CHANGE/portTICK_PERIOD_MS);
	}
	for(i = 16 ; i > 1 ; i--){
    6bb0:	89 81       	ldd	r24, Y+1	; 0x01
    6bb2:	9a 81       	ldd	r25, Y+2	; 0x02
    6bb4:	01 97       	sbiw	r24, 0x01	; 1
    6bb6:	9a 83       	std	Y+2, r25	; 0x02
    6bb8:	89 83       	std	Y+1, r24	; 0x01
    6bba:	89 81       	ldd	r24, Y+1	; 0x01
    6bbc:	9a 81       	ldd	r25, Y+2	; 0x02
    6bbe:	82 30       	cpi	r24, 0x02	; 2
    6bc0:	91 05       	cpc	r25, r1
    6bc2:	5c f7       	brge	.-42     	; 0x6b9a <BothLEDS_Blink+0x4c>
		timer1_SetPWM_A_B(i*5);
//		vTaskDelay(WAIT_TIME_PER_DUTY_CHANGE/portTICK_PERIOD_MS);
	}

}
    6bc4:	0f 90       	pop	r0
    6bc6:	0f 90       	pop	r0
    6bc8:	cf 91       	pop	r28
    6bca:	df 91       	pop	r29
    6bcc:	08 95       	ret

00006bce <NoLED_Blink>:


void NoLED_Blink(void){
    6bce:	df 93       	push	r29
    6bd0:	cf 93       	push	r28
    6bd2:	cd b7       	in	r28, 0x3d	; 61
    6bd4:	de b7       	in	r29, 0x3e	; 62
	timer1_SetPWM_A_B(0);
    6bd6:	80 e0       	ldi	r24, 0x00	; 0
    6bd8:	0e 94 c5 36 	call	0x6d8a	; 0x6d8a <timer1_SetPWM_A_B>
}
    6bdc:	cf 91       	pop	r28
    6bde:	df 91       	pop	r29
    6be0:	08 95       	ret

00006be2 <timer1_PWM_Init>:
#include <avr/io.h>
#include "Timer1_PWM.h"

unsigned long TopValue = 0;

void timer1_PWM_Init(void){
    6be2:	df 93       	push	r29
    6be4:	cf 93       	push	r28
    6be6:	cd b7       	in	r28, 0x3d	; 61
    6be8:	de b7       	in	r29, 0x3e	; 62
	TCCR1A = (1 << COM1A1) | (1 << COM1B1) | (1<< WGM11);
    6bea:	ef e4       	ldi	r30, 0x4F	; 79
    6bec:	f0 e0       	ldi	r31, 0x00	; 0
    6bee:	82 ea       	ldi	r24, 0xA2	; 162
    6bf0:	80 83       	st	Z, r24
	TCCR1B = (1<<WGM13) | (1<<WGM12) | (1<<CS10);
    6bf2:	ee e4       	ldi	r30, 0x4E	; 78
    6bf4:	f0 e0       	ldi	r31, 0x00	; 0
    6bf6:	89 e1       	ldi	r24, 0x19	; 25
    6bf8:	80 83       	st	Z, r24
	TopValue = ((float)100/PWM_FREQUENCY_IN_KHZ)*160;
    6bfa:	80 e4       	ldi	r24, 0x40	; 64
    6bfc:	91 e0       	ldi	r25, 0x01	; 1
    6bfe:	a0 e0       	ldi	r26, 0x00	; 0
    6c00:	b0 e0       	ldi	r27, 0x00	; 0
    6c02:	80 93 e4 08 	sts	0x08E4, r24
    6c06:	90 93 e5 08 	sts	0x08E5, r25
    6c0a:	a0 93 e6 08 	sts	0x08E6, r26
    6c0e:	b0 93 e7 08 	sts	0x08E7, r27
	ICR1 = TopValue;
    6c12:	e6 e4       	ldi	r30, 0x46	; 70
    6c14:	f0 e0       	ldi	r31, 0x00	; 0
    6c16:	80 91 e4 08 	lds	r24, 0x08E4
    6c1a:	90 91 e5 08 	lds	r25, 0x08E5
    6c1e:	a0 91 e6 08 	lds	r26, 0x08E6
    6c22:	b0 91 e7 08 	lds	r27, 0x08E7
    6c26:	91 83       	std	Z+1, r25	; 0x01
    6c28:	80 83       	st	Z, r24
//	OCR1A = 20000;
//	OCR1B = 45500;
	DDRB |= (1<<PB5) | (1<<PB6);
    6c2a:	a7 e3       	ldi	r26, 0x37	; 55
    6c2c:	b0 e0       	ldi	r27, 0x00	; 0
    6c2e:	e7 e3       	ldi	r30, 0x37	; 55
    6c30:	f0 e0       	ldi	r31, 0x00	; 0
    6c32:	80 81       	ld	r24, Z
    6c34:	80 66       	ori	r24, 0x60	; 96
    6c36:	8c 93       	st	X, r24

}
    6c38:	cf 91       	pop	r28
    6c3a:	df 91       	pop	r29
    6c3c:	08 95       	ret

00006c3e <timer1_SetPWM_B>:

void timer1_SetPWM_B(unsigned char dutyB){
    6c3e:	ef 92       	push	r14
    6c40:	ff 92       	push	r15
    6c42:	0f 93       	push	r16
    6c44:	1f 93       	push	r17
    6c46:	df 93       	push	r29
    6c48:	cf 93       	push	r28
    6c4a:	00 d0       	rcall	.+0      	; 0x6c4c <timer1_SetPWM_B+0xe>
    6c4c:	00 d0       	rcall	.+0      	; 0x6c4e <timer1_SetPWM_B+0x10>
    6c4e:	0f 92       	push	r0
    6c50:	cd b7       	in	r28, 0x3d	; 61
    6c52:	de b7       	in	r29, 0x3e	; 62
    6c54:	8d 83       	std	Y+5, r24	; 0x05
	unsigned long actualDuty = (unsigned long)(((float)dutyB/100)*(TopValue));
    6c56:	8d 81       	ldd	r24, Y+5	; 0x05
    6c58:	88 2f       	mov	r24, r24
    6c5a:	90 e0       	ldi	r25, 0x00	; 0
    6c5c:	a0 e0       	ldi	r26, 0x00	; 0
    6c5e:	b0 e0       	ldi	r27, 0x00	; 0
    6c60:	bc 01       	movw	r22, r24
    6c62:	cd 01       	movw	r24, r26
    6c64:	0e 94 c5 04 	call	0x98a	; 0x98a <__floatunsisf>
    6c68:	dc 01       	movw	r26, r24
    6c6a:	cb 01       	movw	r24, r22
    6c6c:	bc 01       	movw	r22, r24
    6c6e:	cd 01       	movw	r24, r26
    6c70:	20 e0       	ldi	r18, 0x00	; 0
    6c72:	30 e0       	ldi	r19, 0x00	; 0
    6c74:	48 ec       	ldi	r20, 0xC8	; 200
    6c76:	52 e4       	ldi	r21, 0x42	; 66
    6c78:	0e 94 35 03 	call	0x66a	; 0x66a <__divsf3>
    6c7c:	dc 01       	movw	r26, r24
    6c7e:	cb 01       	movw	r24, r22
    6c80:	7c 01       	movw	r14, r24
    6c82:	8d 01       	movw	r16, r26
    6c84:	80 91 e4 08 	lds	r24, 0x08E4
    6c88:	90 91 e5 08 	lds	r25, 0x08E5
    6c8c:	a0 91 e6 08 	lds	r26, 0x08E6
    6c90:	b0 91 e7 08 	lds	r27, 0x08E7
    6c94:	bc 01       	movw	r22, r24
    6c96:	cd 01       	movw	r24, r26
    6c98:	0e 94 c5 04 	call	0x98a	; 0x98a <__floatunsisf>
    6c9c:	9b 01       	movw	r18, r22
    6c9e:	ac 01       	movw	r20, r24
    6ca0:	c8 01       	movw	r24, r16
    6ca2:	b7 01       	movw	r22, r14
    6ca4:	0e 94 3b 02 	call	0x476	; 0x476 <__mulsf3>
    6ca8:	dc 01       	movw	r26, r24
    6caa:	cb 01       	movw	r24, r22
    6cac:	bc 01       	movw	r22, r24
    6cae:	cd 01       	movw	r24, r26
    6cb0:	0e 94 65 00 	call	0xca	; 0xca <__fixunssfsi>
    6cb4:	dc 01       	movw	r26, r24
    6cb6:	cb 01       	movw	r24, r22
    6cb8:	89 83       	std	Y+1, r24	; 0x01
    6cba:	9a 83       	std	Y+2, r25	; 0x02
    6cbc:	ab 83       	std	Y+3, r26	; 0x03
    6cbe:	bc 83       	std	Y+4, r27	; 0x04
	OCR1B = actualDuty;
    6cc0:	e8 e4       	ldi	r30, 0x48	; 72
    6cc2:	f0 e0       	ldi	r31, 0x00	; 0
    6cc4:	89 81       	ldd	r24, Y+1	; 0x01
    6cc6:	9a 81       	ldd	r25, Y+2	; 0x02
    6cc8:	91 83       	std	Z+1, r25	; 0x01
    6cca:	80 83       	st	Z, r24
}
    6ccc:	0f 90       	pop	r0
    6cce:	0f 90       	pop	r0
    6cd0:	0f 90       	pop	r0
    6cd2:	0f 90       	pop	r0
    6cd4:	0f 90       	pop	r0
    6cd6:	cf 91       	pop	r28
    6cd8:	df 91       	pop	r29
    6cda:	1f 91       	pop	r17
    6cdc:	0f 91       	pop	r16
    6cde:	ff 90       	pop	r15
    6ce0:	ef 90       	pop	r14
    6ce2:	08 95       	ret

00006ce4 <timer1_SetPWM_A>:


void timer1_SetPWM_A(unsigned char dutyA){
    6ce4:	ef 92       	push	r14
    6ce6:	ff 92       	push	r15
    6ce8:	0f 93       	push	r16
    6cea:	1f 93       	push	r17
    6cec:	df 93       	push	r29
    6cee:	cf 93       	push	r28
    6cf0:	00 d0       	rcall	.+0      	; 0x6cf2 <timer1_SetPWM_A+0xe>
    6cf2:	00 d0       	rcall	.+0      	; 0x6cf4 <timer1_SetPWM_A+0x10>
    6cf4:	0f 92       	push	r0
    6cf6:	cd b7       	in	r28, 0x3d	; 61
    6cf8:	de b7       	in	r29, 0x3e	; 62
    6cfa:	8d 83       	std	Y+5, r24	; 0x05
	unsigned long actualDuty = (unsigned long)(((float)dutyA/100)*(TopValue));
    6cfc:	8d 81       	ldd	r24, Y+5	; 0x05
    6cfe:	88 2f       	mov	r24, r24
    6d00:	90 e0       	ldi	r25, 0x00	; 0
    6d02:	a0 e0       	ldi	r26, 0x00	; 0
    6d04:	b0 e0       	ldi	r27, 0x00	; 0
    6d06:	bc 01       	movw	r22, r24
    6d08:	cd 01       	movw	r24, r26
    6d0a:	0e 94 c5 04 	call	0x98a	; 0x98a <__floatunsisf>
    6d0e:	dc 01       	movw	r26, r24
    6d10:	cb 01       	movw	r24, r22
    6d12:	bc 01       	movw	r22, r24
    6d14:	cd 01       	movw	r24, r26
    6d16:	20 e0       	ldi	r18, 0x00	; 0
    6d18:	30 e0       	ldi	r19, 0x00	; 0
    6d1a:	48 ec       	ldi	r20, 0xC8	; 200
    6d1c:	52 e4       	ldi	r21, 0x42	; 66
    6d1e:	0e 94 35 03 	call	0x66a	; 0x66a <__divsf3>
    6d22:	dc 01       	movw	r26, r24
    6d24:	cb 01       	movw	r24, r22
    6d26:	7c 01       	movw	r14, r24
    6d28:	8d 01       	movw	r16, r26
    6d2a:	80 91 e4 08 	lds	r24, 0x08E4
    6d2e:	90 91 e5 08 	lds	r25, 0x08E5
    6d32:	a0 91 e6 08 	lds	r26, 0x08E6
    6d36:	b0 91 e7 08 	lds	r27, 0x08E7
    6d3a:	bc 01       	movw	r22, r24
    6d3c:	cd 01       	movw	r24, r26
    6d3e:	0e 94 c5 04 	call	0x98a	; 0x98a <__floatunsisf>
    6d42:	9b 01       	movw	r18, r22
    6d44:	ac 01       	movw	r20, r24
    6d46:	c8 01       	movw	r24, r16
    6d48:	b7 01       	movw	r22, r14
    6d4a:	0e 94 3b 02 	call	0x476	; 0x476 <__mulsf3>
    6d4e:	dc 01       	movw	r26, r24
    6d50:	cb 01       	movw	r24, r22
    6d52:	bc 01       	movw	r22, r24
    6d54:	cd 01       	movw	r24, r26
    6d56:	0e 94 65 00 	call	0xca	; 0xca <__fixunssfsi>
    6d5a:	dc 01       	movw	r26, r24
    6d5c:	cb 01       	movw	r24, r22
    6d5e:	89 83       	std	Y+1, r24	; 0x01
    6d60:	9a 83       	std	Y+2, r25	; 0x02
    6d62:	ab 83       	std	Y+3, r26	; 0x03
    6d64:	bc 83       	std	Y+4, r27	; 0x04
	OCR1A = actualDuty;
    6d66:	ea e4       	ldi	r30, 0x4A	; 74
    6d68:	f0 e0       	ldi	r31, 0x00	; 0
    6d6a:	89 81       	ldd	r24, Y+1	; 0x01
    6d6c:	9a 81       	ldd	r25, Y+2	; 0x02
    6d6e:	91 83       	std	Z+1, r25	; 0x01
    6d70:	80 83       	st	Z, r24
}
    6d72:	0f 90       	pop	r0
    6d74:	0f 90       	pop	r0
    6d76:	0f 90       	pop	r0
    6d78:	0f 90       	pop	r0
    6d7a:	0f 90       	pop	r0
    6d7c:	cf 91       	pop	r28
    6d7e:	df 91       	pop	r29
    6d80:	1f 91       	pop	r17
    6d82:	0f 91       	pop	r16
    6d84:	ff 90       	pop	r15
    6d86:	ef 90       	pop	r14
    6d88:	08 95       	ret

00006d8a <timer1_SetPWM_A_B>:


void timer1_SetPWM_A_B(unsigned char dutyA_B){
    6d8a:	ef 92       	push	r14
    6d8c:	ff 92       	push	r15
    6d8e:	0f 93       	push	r16
    6d90:	1f 93       	push	r17
    6d92:	df 93       	push	r29
    6d94:	cf 93       	push	r28
    6d96:	00 d0       	rcall	.+0      	; 0x6d98 <timer1_SetPWM_A_B+0xe>
    6d98:	00 d0       	rcall	.+0      	; 0x6d9a <timer1_SetPWM_A_B+0x10>
    6d9a:	0f 92       	push	r0
    6d9c:	cd b7       	in	r28, 0x3d	; 61
    6d9e:	de b7       	in	r29, 0x3e	; 62
    6da0:	8d 83       	std	Y+5, r24	; 0x05
	unsigned long actualDuty = (unsigned long)(((float)dutyA_B/100)*(TopValue));
    6da2:	8d 81       	ldd	r24, Y+5	; 0x05
    6da4:	88 2f       	mov	r24, r24
    6da6:	90 e0       	ldi	r25, 0x00	; 0
    6da8:	a0 e0       	ldi	r26, 0x00	; 0
    6daa:	b0 e0       	ldi	r27, 0x00	; 0
    6dac:	bc 01       	movw	r22, r24
    6dae:	cd 01       	movw	r24, r26
    6db0:	0e 94 c5 04 	call	0x98a	; 0x98a <__floatunsisf>
    6db4:	dc 01       	movw	r26, r24
    6db6:	cb 01       	movw	r24, r22
    6db8:	bc 01       	movw	r22, r24
    6dba:	cd 01       	movw	r24, r26
    6dbc:	20 e0       	ldi	r18, 0x00	; 0
    6dbe:	30 e0       	ldi	r19, 0x00	; 0
    6dc0:	48 ec       	ldi	r20, 0xC8	; 200
    6dc2:	52 e4       	ldi	r21, 0x42	; 66
    6dc4:	0e 94 35 03 	call	0x66a	; 0x66a <__divsf3>
    6dc8:	dc 01       	movw	r26, r24
    6dca:	cb 01       	movw	r24, r22
    6dcc:	7c 01       	movw	r14, r24
    6dce:	8d 01       	movw	r16, r26
    6dd0:	80 91 e4 08 	lds	r24, 0x08E4
    6dd4:	90 91 e5 08 	lds	r25, 0x08E5
    6dd8:	a0 91 e6 08 	lds	r26, 0x08E6
    6ddc:	b0 91 e7 08 	lds	r27, 0x08E7
    6de0:	bc 01       	movw	r22, r24
    6de2:	cd 01       	movw	r24, r26
    6de4:	0e 94 c5 04 	call	0x98a	; 0x98a <__floatunsisf>
    6de8:	9b 01       	movw	r18, r22
    6dea:	ac 01       	movw	r20, r24
    6dec:	c8 01       	movw	r24, r16
    6dee:	b7 01       	movw	r22, r14
    6df0:	0e 94 3b 02 	call	0x476	; 0x476 <__mulsf3>
    6df4:	dc 01       	movw	r26, r24
    6df6:	cb 01       	movw	r24, r22
    6df8:	bc 01       	movw	r22, r24
    6dfa:	cd 01       	movw	r24, r26
    6dfc:	0e 94 65 00 	call	0xca	; 0xca <__fixunssfsi>
    6e00:	dc 01       	movw	r26, r24
    6e02:	cb 01       	movw	r24, r22
    6e04:	89 83       	std	Y+1, r24	; 0x01
    6e06:	9a 83       	std	Y+2, r25	; 0x02
    6e08:	ab 83       	std	Y+3, r26	; 0x03
    6e0a:	bc 83       	std	Y+4, r27	; 0x04
	OCR1A = actualDuty;
    6e0c:	ea e4       	ldi	r30, 0x4A	; 74
    6e0e:	f0 e0       	ldi	r31, 0x00	; 0
    6e10:	89 81       	ldd	r24, Y+1	; 0x01
    6e12:	9a 81       	ldd	r25, Y+2	; 0x02
    6e14:	91 83       	std	Z+1, r25	; 0x01
    6e16:	80 83       	st	Z, r24
	OCR1B = actualDuty;
    6e18:	e8 e4       	ldi	r30, 0x48	; 72
    6e1a:	f0 e0       	ldi	r31, 0x00	; 0
    6e1c:	89 81       	ldd	r24, Y+1	; 0x01
    6e1e:	9a 81       	ldd	r25, Y+2	; 0x02
    6e20:	91 83       	std	Z+1, r25	; 0x01
    6e22:	80 83       	st	Z, r24
}
    6e24:	0f 90       	pop	r0
    6e26:	0f 90       	pop	r0
    6e28:	0f 90       	pop	r0
    6e2a:	0f 90       	pop	r0
    6e2c:	0f 90       	pop	r0
    6e2e:	cf 91       	pop	r28
    6e30:	df 91       	pop	r29
    6e32:	1f 91       	pop	r17
    6e34:	0f 91       	pop	r16
    6e36:	ff 90       	pop	r15
    6e38:	ef 90       	pop	r14
    6e3a:	08 95       	ret

00006e3c <Timer2_Init_CTC_Mode>:
 */

#include "avr/io.h"

void Timer2_Init_CTC_Mode(unsigned char tick)
{
    6e3c:	df 93       	push	r29
    6e3e:	cf 93       	push	r28
    6e40:	0f 92       	push	r0
    6e42:	cd b7       	in	r28, 0x3d	; 61
    6e44:	de b7       	in	r29, 0x3e	; 62
    6e46:	89 83       	std	Y+1, r24	; 0x01
	TCNT2 = 0;    // Set Timer initial value to 0
    6e48:	e4 e4       	ldi	r30, 0x44	; 68
    6e4a:	f0 e0       	ldi	r31, 0x00	; 0
    6e4c:	10 82       	st	Z, r1
	OCR2  = tick; // Set Compare Value
    6e4e:	e3 e4       	ldi	r30, 0x43	; 67
    6e50:	f0 e0       	ldi	r31, 0x00	; 0
    6e52:	89 81       	ldd	r24, Y+1	; 0x01
    6e54:	80 83       	st	Z, r24
	TIMSK |= (1<<OCIE2); // Enable Timer2 Compare Interrupt
    6e56:	a7 e5       	ldi	r26, 0x57	; 87
    6e58:	b0 e0       	ldi	r27, 0x00	; 0
    6e5a:	e7 e5       	ldi	r30, 0x57	; 87
    6e5c:	f0 e0       	ldi	r31, 0x00	; 0
    6e5e:	80 81       	ld	r24, Z
    6e60:	80 68       	ori	r24, 0x80	; 128
    6e62:	8c 93       	st	X, r24
	 * 1. Non PWM mode FOC0=1
	 * 2. CTC Mode WGM01=1 & WGM00=0
	 * 3. No need for OC0 in this example so COM00=0 & COM01=0
	 * 4. clock = F_CPU/8 CS22=0 CS21=1 CS20=0
	 */
	TCCR2 = (1<<FOC2) | (1<<WGM21) | (1<<CS21);
    6e64:	e5 e4       	ldi	r30, 0x45	; 69
    6e66:	f0 e0       	ldi	r31, 0x00	; 0
    6e68:	8a e8       	ldi	r24, 0x8A	; 138
    6e6a:	80 83       	st	Z, r24
}
    6e6c:	0f 90       	pop	r0
    6e6e:	cf 91       	pop	r28
    6e70:	df 91       	pop	r29
    6e72:	08 95       	ret

00006e74 <Get_Data>:
unsigned char rightBtn_counter = 0;
unsigned char leftBtn_counter = 0;


States_GroupType Get_Data(void)
{
    6e74:	df 93       	push	r29
    6e76:	cf 93       	push	r28
    6e78:	0f 92       	push	r0
    6e7a:	cd b7       	in	r28, 0x3d	; 61
    6e7c:	de b7       	in	r29, 0x3e	; 62
//	SET_BIT(PORTB,6);
	static unsigned char hazardBtn_releaseFlag = TRUE;
	static States_GroupType ButtonState = {0,0,0,0};

	if(GPIO_readPin(dio_config_array[HAZARD_BUTTON_ID].port_id,dio_config_array[HAZARD_BUTTON_ID].pin_num) ){
    6e7e:	80 91 3d 02 	lds	r24, 0x023D
    6e82:	90 91 3e 02 	lds	r25, 0x023E
    6e86:	69 2f       	mov	r22, r25
    6e88:	0e 94 95 3a 	call	0x752a	; 0x752a <GPIO_readPin>
    6e8c:	88 23       	and	r24, r24
    6e8e:	89 f0       	breq	.+34     	; 0x6eb2 <Get_Data+0x3e>
		if(hazardBtn_releaseFlag == TRUE){
    6e90:	80 91 38 02 	lds	r24, 0x0238
    6e94:	81 30       	cpi	r24, 0x01	; 1
    6e96:	81 f4       	brne	.+32     	; 0x6eb8 <Get_Data+0x44>
			hazardBtn_releaseFlag = FALSE;
    6e98:	10 92 38 02 	sts	0x0238, r1
			ButtonState.hazard_Btn = !ButtonState.hazard_Btn;
    6e9c:	80 91 ee 08 	lds	r24, 0x08EE
    6ea0:	19 82       	std	Y+1, r1	; 0x01
    6ea2:	88 23       	and	r24, r24
    6ea4:	11 f4       	brne	.+4      	; 0x6eaa <Get_Data+0x36>
    6ea6:	81 e0       	ldi	r24, 0x01	; 1
    6ea8:	89 83       	std	Y+1, r24	; 0x01
    6eaa:	89 81       	ldd	r24, Y+1	; 0x01
    6eac:	80 93 ee 08 	sts	0x08EE, r24
    6eb0:	03 c0       	rjmp	.+6      	; 0x6eb8 <Get_Data+0x44>
		}

	}
	else{
		hazardBtn_releaseFlag = TRUE;
    6eb2:	81 e0       	ldi	r24, 0x01	; 1
    6eb4:	80 93 38 02 	sts	0x0238, r24
	}




	if(!GPIO_readPin(dio_config_array[RIGHT_INDICATOR_BUTTON_ID].port_id,dio_config_array[RIGHT_INDICATOR_BUTTON_ID].pin_num) && !GPIO_readPin(dio_config_array[IGNITION_SWICH_ID].port_id,dio_config_array[IGNITION_SWICH_ID].pin_num)){
    6eb8:	80 91 40 02 	lds	r24, 0x0240
    6ebc:	90 91 41 02 	lds	r25, 0x0241
    6ec0:	69 2f       	mov	r22, r25
    6ec2:	0e 94 95 3a 	call	0x752a	; 0x752a <GPIO_readPin>
    6ec6:	88 23       	and	r24, r24
    6ec8:	51 f5       	brne	.+84     	; 0x6f1e <Get_Data+0xaa>
    6eca:	80 91 46 02 	lds	r24, 0x0246
    6ece:	90 91 47 02 	lds	r25, 0x0247
    6ed2:	69 2f       	mov	r22, r25
    6ed4:	0e 94 95 3a 	call	0x752a	; 0x752a <GPIO_readPin>
    6ed8:	88 23       	and	r24, r24
    6eda:	09 f5       	brne	.+66     	; 0x6f1e <Get_Data+0xaa>
//		vTaskDelay(1/portTICK_PERIOD_MS);
//		vTaskDelay(pdMS_TO_TICKS( 5 ));
//		if(rightBtn_counter % 5 == 0)
//		{
//		rightBtn_counter = 0;
		if(!GPIO_readPin(dio_config_array[IGNITION_SWICH_ID].port_id,dio_config_array[IGNITION_SWICH_ID].pin_num)){
    6edc:	80 91 46 02 	lds	r24, 0x0246
    6ee0:	90 91 47 02 	lds	r25, 0x0247
    6ee4:	69 2f       	mov	r22, r25
    6ee6:	0e 94 95 3a 	call	0x752a	; 0x752a <GPIO_readPin>
    6eea:	88 23       	and	r24, r24
    6eec:	99 f4       	brne	.+38     	; 0x6f14 <Get_Data+0xa0>
			ButtonState.ignition_key = 1;
    6eee:	81 e0       	ldi	r24, 0x01	; 1
    6ef0:	80 93 eb 08 	sts	0x08EB, r24
			if(!GPIO_readPin(dio_config_array[RIGHT_INDICATOR_BUTTON_ID].port_id,dio_config_array[RIGHT_INDICATOR_BUTTON_ID].pin_num)){
    6ef4:	80 91 40 02 	lds	r24, 0x0240
    6ef8:	90 91 41 02 	lds	r25, 0x0241
    6efc:	69 2f       	mov	r22, r25
    6efe:	0e 94 95 3a 	call	0x752a	; 0x752a <GPIO_readPin>
    6f02:	88 23       	and	r24, r24
    6f04:	21 f4       	brne	.+8      	; 0x6f0e <Get_Data+0x9a>
				ButtonState.rightIndicator = 1;
    6f06:	81 e0       	ldi	r24, 0x01	; 1
    6f08:	80 93 ec 08 	sts	0x08EC, r24
    6f0c:	62 c0       	rjmp	.+196    	; 0x6fd2 <Get_Data+0x15e>
			}
			else{
				ButtonState.rightIndicator = 0;
    6f0e:	10 92 ec 08 	sts	0x08EC, r1
    6f12:	5f c0       	rjmp	.+190    	; 0x6fd2 <Get_Data+0x15e>
			}
		}
		else{
			ButtonState.ignition_key = 0;
    6f14:	10 92 eb 08 	sts	0x08EB, r1
			ButtonState.rightIndicator = 0;
    6f18:	10 92 ec 08 	sts	0x08EC, r1
    6f1c:	5a c0       	rjmp	.+180    	; 0x6fd2 <Get_Data+0x15e>
//		else
//		{
//			rightBtn_counter++;
//		}
	}
	else if(!GPIO_readPin(dio_config_array[LEFT_INDICATOR_BUTTON_ID].port_id,dio_config_array[LEFT_INDICATOR_BUTTON_ID].pin_num) && !GPIO_readPin(dio_config_array[IGNITION_SWICH_ID].port_id,dio_config_array[IGNITION_SWICH_ID].pin_num)){
    6f1e:	80 91 43 02 	lds	r24, 0x0243
    6f22:	90 91 44 02 	lds	r25, 0x0244
    6f26:	69 2f       	mov	r22, r25
    6f28:	0e 94 95 3a 	call	0x752a	; 0x752a <GPIO_readPin>
    6f2c:	88 23       	and	r24, r24
    6f2e:	51 f5       	brne	.+84     	; 0x6f84 <Get_Data+0x110>
    6f30:	80 91 46 02 	lds	r24, 0x0246
    6f34:	90 91 47 02 	lds	r25, 0x0247
    6f38:	69 2f       	mov	r22, r25
    6f3a:	0e 94 95 3a 	call	0x752a	; 0x752a <GPIO_readPin>
    6f3e:	88 23       	and	r24, r24
    6f40:	09 f5       	brne	.+66     	; 0x6f84 <Get_Data+0x110>
//		vTaskDelay(50/portTICK_PERIOD_MS);
//		vTaskDelay(pdMS_TO_TICKS( 5 ));

		if(!GPIO_readPin(dio_config_array[IGNITION_SWICH_ID].port_id,dio_config_array[IGNITION_SWICH_ID].pin_num)){
    6f42:	80 91 46 02 	lds	r24, 0x0246
    6f46:	90 91 47 02 	lds	r25, 0x0247
    6f4a:	69 2f       	mov	r22, r25
    6f4c:	0e 94 95 3a 	call	0x752a	; 0x752a <GPIO_readPin>
    6f50:	88 23       	and	r24, r24
    6f52:	99 f4       	brne	.+38     	; 0x6f7a <Get_Data+0x106>
			ButtonState.ignition_key = 1;
    6f54:	81 e0       	ldi	r24, 0x01	; 1
    6f56:	80 93 eb 08 	sts	0x08EB, r24
			if(!GPIO_readPin(dio_config_array[LEFT_INDICATOR_BUTTON_ID].port_id,dio_config_array[LEFT_INDICATOR_BUTTON_ID].pin_num)){
    6f5a:	80 91 43 02 	lds	r24, 0x0243
    6f5e:	90 91 44 02 	lds	r25, 0x0244
    6f62:	69 2f       	mov	r22, r25
    6f64:	0e 94 95 3a 	call	0x752a	; 0x752a <GPIO_readPin>
    6f68:	88 23       	and	r24, r24
    6f6a:	21 f4       	brne	.+8      	; 0x6f74 <Get_Data+0x100>
				ButtonState.leftIndicator = 1;
    6f6c:	81 e0       	ldi	r24, 0x01	; 1
    6f6e:	80 93 ed 08 	sts	0x08ED, r24
    6f72:	2f c0       	rjmp	.+94     	; 0x6fd2 <Get_Data+0x15e>
			}
			else{
				ButtonState.leftIndicator = 0;
    6f74:	10 92 ed 08 	sts	0x08ED, r1
    6f78:	2c c0       	rjmp	.+88     	; 0x6fd2 <Get_Data+0x15e>
			}
		}
		else{
			ButtonState.ignition_key = 0;
    6f7a:	10 92 eb 08 	sts	0x08EB, r1
			ButtonState.leftIndicator = 0;
    6f7e:	10 92 ed 08 	sts	0x08ED, r1
    6f82:	27 c0       	rjmp	.+78     	; 0x6fd2 <Get_Data+0x15e>
		}
	}
	else if(!GPIO_readPin(dio_config_array[IGNITION_SWICH_ID].port_id,dio_config_array[IGNITION_SWICH_ID].pin_num)){
    6f84:	80 91 46 02 	lds	r24, 0x0246
    6f88:	90 91 47 02 	lds	r25, 0x0247
    6f8c:	69 2f       	mov	r22, r25
    6f8e:	0e 94 95 3a 	call	0x752a	; 0x752a <GPIO_readPin>
    6f92:	88 23       	and	r24, r24
    6f94:	c1 f4       	brne	.+48     	; 0x6fc6 <Get_Data+0x152>
//		vTaskDelay(50/portTICK_PERIOD_MS);
//		vTaskDelay(pdMS_TO_TICKS( 5 ));

		if(!GPIO_readPin(dio_config_array[IGNITION_SWICH_ID].port_id,dio_config_array[IGNITION_SWICH_ID].pin_num)){
    6f96:	80 91 46 02 	lds	r24, 0x0246
    6f9a:	90 91 47 02 	lds	r25, 0x0247
    6f9e:	69 2f       	mov	r22, r25
    6fa0:	0e 94 95 3a 	call	0x752a	; 0x752a <GPIO_readPin>
    6fa4:	88 23       	and	r24, r24
    6fa6:	41 f4       	brne	.+16     	; 0x6fb8 <Get_Data+0x144>
			ButtonState.ignition_key = 1;
    6fa8:	81 e0       	ldi	r24, 0x01	; 1
    6faa:	80 93 eb 08 	sts	0x08EB, r24
			ButtonState.rightIndicator = 0;
    6fae:	10 92 ec 08 	sts	0x08EC, r1
			ButtonState.leftIndicator = 0;
    6fb2:	10 92 ed 08 	sts	0x08ED, r1
    6fb6:	0d c0       	rjmp	.+26     	; 0x6fd2 <Get_Data+0x15e>
		}
		else{
			ButtonState.ignition_key = 0;
    6fb8:	10 92 eb 08 	sts	0x08EB, r1
			ButtonState.rightIndicator = 0;
    6fbc:	10 92 ec 08 	sts	0x08EC, r1
			ButtonState.leftIndicator = 0;
    6fc0:	10 92 ed 08 	sts	0x08ED, r1
    6fc4:	06 c0       	rjmp	.+12     	; 0x6fd2 <Get_Data+0x15e>
		}
	}
	else{
		ButtonState.ignition_key = 0;
    6fc6:	10 92 eb 08 	sts	0x08EB, r1
		ButtonState.rightIndicator = 0;
    6fca:	10 92 ec 08 	sts	0x08EC, r1
		ButtonState.leftIndicator = 0;
    6fce:	10 92 ed 08 	sts	0x08ED, r1
	//	else{
	//		ButtonState.ignition_key = 0;
	//	}


	return ButtonState;
    6fd2:	80 91 eb 08 	lds	r24, 0x08EB
    6fd6:	90 91 ec 08 	lds	r25, 0x08EC
    6fda:	a0 91 ed 08 	lds	r26, 0x08ED
    6fde:	b0 91 ee 08 	lds	r27, 0x08EE
}
    6fe2:	bc 01       	movw	r22, r24
    6fe4:	cd 01       	movw	r24, r26
    6fe6:	0f 90       	pop	r0
    6fe8:	cf 91       	pop	r28
    6fea:	df 91       	pop	r29
    6fec:	08 95       	ret

00006fee <GPIO_setupPinDirection>:
 * Description :
 * Setup the direction of the required pin input/output.
 * If the input port number or pin number are not correct, The function will not handle the request.
 */
void GPIO_setupPinDirection(uint8 port_num, uint8 pin_num, GPIO_PinDirectionType direction)
{
    6fee:	df 93       	push	r29
    6ff0:	cf 93       	push	r28
    6ff2:	00 d0       	rcall	.+0      	; 0x6ff4 <GPIO_setupPinDirection+0x6>
    6ff4:	00 d0       	rcall	.+0      	; 0x6ff6 <GPIO_setupPinDirection+0x8>
    6ff6:	0f 92       	push	r0
    6ff8:	cd b7       	in	r28, 0x3d	; 61
    6ffa:	de b7       	in	r29, 0x3e	; 62
    6ffc:	89 83       	std	Y+1, r24	; 0x01
    6ffe:	6a 83       	std	Y+2, r22	; 0x02
    7000:	4b 83       	std	Y+3, r20	; 0x03
	/*
	 * Check if the input port number is greater than NUM_OF_PINS_PER_PORT value.
	 * Or if the input pin number is greater than NUM_OF_PINS_PER_PORT value.
	 * In this case the input is not valid port/pin number
	 */
	if((pin_num >= NUM_OF_PINS_PER_PORT) || (port_num >= NUM_OF_PORTS))
    7002:	8a 81       	ldd	r24, Y+2	; 0x02
    7004:	88 30       	cpi	r24, 0x08	; 8
    7006:	08 f0       	brcs	.+2      	; 0x700a <GPIO_setupPinDirection+0x1c>
    7008:	39 c1       	rjmp	.+626    	; 0x727c <GPIO_setupPinDirection+0x28e>
    700a:	89 81       	ldd	r24, Y+1	; 0x01
    700c:	86 30       	cpi	r24, 0x06	; 6
    700e:	08 f0       	brcs	.+2      	; 0x7012 <GPIO_setupPinDirection+0x24>
    7010:	35 c1       	rjmp	.+618    	; 0x727c <GPIO_setupPinDirection+0x28e>
		/* Do Nothing */
	}
	else
	{
		/* Setup the pin direction as required */
		switch(port_num)
    7012:	89 81       	ldd	r24, Y+1	; 0x01
    7014:	28 2f       	mov	r18, r24
    7016:	30 e0       	ldi	r19, 0x00	; 0
    7018:	3d 83       	std	Y+5, r19	; 0x05
    701a:	2c 83       	std	Y+4, r18	; 0x04
    701c:	8c 81       	ldd	r24, Y+4	; 0x04
    701e:	9d 81       	ldd	r25, Y+5	; 0x05
    7020:	82 30       	cpi	r24, 0x02	; 2
    7022:	91 05       	cpc	r25, r1
    7024:	09 f4       	brne	.+2      	; 0x7028 <GPIO_setupPinDirection+0x3a>
    7026:	7b c0       	rjmp	.+246    	; 0x711e <GPIO_setupPinDirection+0x130>
    7028:	2c 81       	ldd	r18, Y+4	; 0x04
    702a:	3d 81       	ldd	r19, Y+5	; 0x05
    702c:	23 30       	cpi	r18, 0x03	; 3
    702e:	31 05       	cpc	r19, r1
    7030:	5c f4       	brge	.+22     	; 0x7048 <GPIO_setupPinDirection+0x5a>
    7032:	8c 81       	ldd	r24, Y+4	; 0x04
    7034:	9d 81       	ldd	r25, Y+5	; 0x05
    7036:	00 97       	sbiw	r24, 0x00	; 0
    7038:	d1 f0       	breq	.+52     	; 0x706e <GPIO_setupPinDirection+0x80>
    703a:	2c 81       	ldd	r18, Y+4	; 0x04
    703c:	3d 81       	ldd	r19, Y+5	; 0x05
    703e:	21 30       	cpi	r18, 0x01	; 1
    7040:	31 05       	cpc	r19, r1
    7042:	09 f4       	brne	.+2      	; 0x7046 <GPIO_setupPinDirection+0x58>
    7044:	40 c0       	rjmp	.+128    	; 0x70c6 <GPIO_setupPinDirection+0xd8>
    7046:	1a c1       	rjmp	.+564    	; 0x727c <GPIO_setupPinDirection+0x28e>
    7048:	8c 81       	ldd	r24, Y+4	; 0x04
    704a:	9d 81       	ldd	r25, Y+5	; 0x05
    704c:	84 30       	cpi	r24, 0x04	; 4
    704e:	91 05       	cpc	r25, r1
    7050:	09 f4       	brne	.+2      	; 0x7054 <GPIO_setupPinDirection+0x66>
    7052:	bd c0       	rjmp	.+378    	; 0x71ce <GPIO_setupPinDirection+0x1e0>
    7054:	2c 81       	ldd	r18, Y+4	; 0x04
    7056:	3d 81       	ldd	r19, Y+5	; 0x05
    7058:	24 30       	cpi	r18, 0x04	; 4
    705a:	31 05       	cpc	r19, r1
    705c:	0c f4       	brge	.+2      	; 0x7060 <GPIO_setupPinDirection+0x72>
    705e:	8b c0       	rjmp	.+278    	; 0x7176 <GPIO_setupPinDirection+0x188>
    7060:	8c 81       	ldd	r24, Y+4	; 0x04
    7062:	9d 81       	ldd	r25, Y+5	; 0x05
    7064:	85 30       	cpi	r24, 0x05	; 5
    7066:	91 05       	cpc	r25, r1
    7068:	09 f4       	brne	.+2      	; 0x706c <GPIO_setupPinDirection+0x7e>
    706a:	dd c0       	rjmp	.+442    	; 0x7226 <GPIO_setupPinDirection+0x238>
    706c:	07 c1       	rjmp	.+526    	; 0x727c <GPIO_setupPinDirection+0x28e>
		{
		case PORTA_ID:
			if(direction == PIN_OUTPUT)
    706e:	8b 81       	ldd	r24, Y+3	; 0x03
    7070:	81 30       	cpi	r24, 0x01	; 1
    7072:	a1 f4       	brne	.+40     	; 0x709c <GPIO_setupPinDirection+0xae>
			{
				SET_BIT(DDRA,pin_num);
    7074:	aa e3       	ldi	r26, 0x3A	; 58
    7076:	b0 e0       	ldi	r27, 0x00	; 0
    7078:	ea e3       	ldi	r30, 0x3A	; 58
    707a:	f0 e0       	ldi	r31, 0x00	; 0
    707c:	80 81       	ld	r24, Z
    707e:	48 2f       	mov	r20, r24
    7080:	8a 81       	ldd	r24, Y+2	; 0x02
    7082:	28 2f       	mov	r18, r24
    7084:	30 e0       	ldi	r19, 0x00	; 0
    7086:	81 e0       	ldi	r24, 0x01	; 1
    7088:	90 e0       	ldi	r25, 0x00	; 0
    708a:	02 2e       	mov	r0, r18
    708c:	02 c0       	rjmp	.+4      	; 0x7092 <GPIO_setupPinDirection+0xa4>
    708e:	88 0f       	add	r24, r24
    7090:	99 1f       	adc	r25, r25
    7092:	0a 94       	dec	r0
    7094:	e2 f7       	brpl	.-8      	; 0x708e <GPIO_setupPinDirection+0xa0>
    7096:	84 2b       	or	r24, r20
    7098:	8c 93       	st	X, r24
    709a:	f0 c0       	rjmp	.+480    	; 0x727c <GPIO_setupPinDirection+0x28e>
			}
			else
			{
				CLEAR_BIT(DDRA,pin_num);
    709c:	aa e3       	ldi	r26, 0x3A	; 58
    709e:	b0 e0       	ldi	r27, 0x00	; 0
    70a0:	ea e3       	ldi	r30, 0x3A	; 58
    70a2:	f0 e0       	ldi	r31, 0x00	; 0
    70a4:	80 81       	ld	r24, Z
    70a6:	48 2f       	mov	r20, r24
    70a8:	8a 81       	ldd	r24, Y+2	; 0x02
    70aa:	28 2f       	mov	r18, r24
    70ac:	30 e0       	ldi	r19, 0x00	; 0
    70ae:	81 e0       	ldi	r24, 0x01	; 1
    70b0:	90 e0       	ldi	r25, 0x00	; 0
    70b2:	02 2e       	mov	r0, r18
    70b4:	02 c0       	rjmp	.+4      	; 0x70ba <GPIO_setupPinDirection+0xcc>
    70b6:	88 0f       	add	r24, r24
    70b8:	99 1f       	adc	r25, r25
    70ba:	0a 94       	dec	r0
    70bc:	e2 f7       	brpl	.-8      	; 0x70b6 <GPIO_setupPinDirection+0xc8>
    70be:	80 95       	com	r24
    70c0:	84 23       	and	r24, r20
    70c2:	8c 93       	st	X, r24
    70c4:	db c0       	rjmp	.+438    	; 0x727c <GPIO_setupPinDirection+0x28e>
			}
			break;
		case PORTB_ID:
			if(direction == PIN_OUTPUT)
    70c6:	8b 81       	ldd	r24, Y+3	; 0x03
    70c8:	81 30       	cpi	r24, 0x01	; 1
    70ca:	a1 f4       	brne	.+40     	; 0x70f4 <GPIO_setupPinDirection+0x106>
			{
				SET_BIT(DDRB,pin_num);
    70cc:	a7 e3       	ldi	r26, 0x37	; 55
    70ce:	b0 e0       	ldi	r27, 0x00	; 0
    70d0:	e7 e3       	ldi	r30, 0x37	; 55
    70d2:	f0 e0       	ldi	r31, 0x00	; 0
    70d4:	80 81       	ld	r24, Z
    70d6:	48 2f       	mov	r20, r24
    70d8:	8a 81       	ldd	r24, Y+2	; 0x02
    70da:	28 2f       	mov	r18, r24
    70dc:	30 e0       	ldi	r19, 0x00	; 0
    70de:	81 e0       	ldi	r24, 0x01	; 1
    70e0:	90 e0       	ldi	r25, 0x00	; 0
    70e2:	02 2e       	mov	r0, r18
    70e4:	02 c0       	rjmp	.+4      	; 0x70ea <GPIO_setupPinDirection+0xfc>
    70e6:	88 0f       	add	r24, r24
    70e8:	99 1f       	adc	r25, r25
    70ea:	0a 94       	dec	r0
    70ec:	e2 f7       	brpl	.-8      	; 0x70e6 <GPIO_setupPinDirection+0xf8>
    70ee:	84 2b       	or	r24, r20
    70f0:	8c 93       	st	X, r24
    70f2:	c4 c0       	rjmp	.+392    	; 0x727c <GPIO_setupPinDirection+0x28e>
			}
			else
			{
				CLEAR_BIT(DDRB,pin_num);
    70f4:	a7 e3       	ldi	r26, 0x37	; 55
    70f6:	b0 e0       	ldi	r27, 0x00	; 0
    70f8:	e7 e3       	ldi	r30, 0x37	; 55
    70fa:	f0 e0       	ldi	r31, 0x00	; 0
    70fc:	80 81       	ld	r24, Z
    70fe:	48 2f       	mov	r20, r24
    7100:	8a 81       	ldd	r24, Y+2	; 0x02
    7102:	28 2f       	mov	r18, r24
    7104:	30 e0       	ldi	r19, 0x00	; 0
    7106:	81 e0       	ldi	r24, 0x01	; 1
    7108:	90 e0       	ldi	r25, 0x00	; 0
    710a:	02 2e       	mov	r0, r18
    710c:	02 c0       	rjmp	.+4      	; 0x7112 <GPIO_setupPinDirection+0x124>
    710e:	88 0f       	add	r24, r24
    7110:	99 1f       	adc	r25, r25
    7112:	0a 94       	dec	r0
    7114:	e2 f7       	brpl	.-8      	; 0x710e <GPIO_setupPinDirection+0x120>
    7116:	80 95       	com	r24
    7118:	84 23       	and	r24, r20
    711a:	8c 93       	st	X, r24
    711c:	af c0       	rjmp	.+350    	; 0x727c <GPIO_setupPinDirection+0x28e>
			}
			break;
		case PORTC_ID:
			if(direction == PIN_OUTPUT)
    711e:	8b 81       	ldd	r24, Y+3	; 0x03
    7120:	81 30       	cpi	r24, 0x01	; 1
    7122:	a1 f4       	brne	.+40     	; 0x714c <GPIO_setupPinDirection+0x15e>
			{
				SET_BIT(DDRC,pin_num);
    7124:	a4 e3       	ldi	r26, 0x34	; 52
    7126:	b0 e0       	ldi	r27, 0x00	; 0
    7128:	e4 e3       	ldi	r30, 0x34	; 52
    712a:	f0 e0       	ldi	r31, 0x00	; 0
    712c:	80 81       	ld	r24, Z
    712e:	48 2f       	mov	r20, r24
    7130:	8a 81       	ldd	r24, Y+2	; 0x02
    7132:	28 2f       	mov	r18, r24
    7134:	30 e0       	ldi	r19, 0x00	; 0
    7136:	81 e0       	ldi	r24, 0x01	; 1
    7138:	90 e0       	ldi	r25, 0x00	; 0
    713a:	02 2e       	mov	r0, r18
    713c:	02 c0       	rjmp	.+4      	; 0x7142 <GPIO_setupPinDirection+0x154>
    713e:	88 0f       	add	r24, r24
    7140:	99 1f       	adc	r25, r25
    7142:	0a 94       	dec	r0
    7144:	e2 f7       	brpl	.-8      	; 0x713e <GPIO_setupPinDirection+0x150>
    7146:	84 2b       	or	r24, r20
    7148:	8c 93       	st	X, r24
    714a:	98 c0       	rjmp	.+304    	; 0x727c <GPIO_setupPinDirection+0x28e>
			}
			else
			{
				CLEAR_BIT(DDRC,pin_num);
    714c:	a4 e3       	ldi	r26, 0x34	; 52
    714e:	b0 e0       	ldi	r27, 0x00	; 0
    7150:	e4 e3       	ldi	r30, 0x34	; 52
    7152:	f0 e0       	ldi	r31, 0x00	; 0
    7154:	80 81       	ld	r24, Z
    7156:	48 2f       	mov	r20, r24
    7158:	8a 81       	ldd	r24, Y+2	; 0x02
    715a:	28 2f       	mov	r18, r24
    715c:	30 e0       	ldi	r19, 0x00	; 0
    715e:	81 e0       	ldi	r24, 0x01	; 1
    7160:	90 e0       	ldi	r25, 0x00	; 0
    7162:	02 2e       	mov	r0, r18
    7164:	02 c0       	rjmp	.+4      	; 0x716a <GPIO_setupPinDirection+0x17c>
    7166:	88 0f       	add	r24, r24
    7168:	99 1f       	adc	r25, r25
    716a:	0a 94       	dec	r0
    716c:	e2 f7       	brpl	.-8      	; 0x7166 <GPIO_setupPinDirection+0x178>
    716e:	80 95       	com	r24
    7170:	84 23       	and	r24, r20
    7172:	8c 93       	st	X, r24
    7174:	83 c0       	rjmp	.+262    	; 0x727c <GPIO_setupPinDirection+0x28e>
			}
			break;
		case PORTD_ID:
			if(direction == PIN_OUTPUT)
    7176:	8b 81       	ldd	r24, Y+3	; 0x03
    7178:	81 30       	cpi	r24, 0x01	; 1
    717a:	a1 f4       	brne	.+40     	; 0x71a4 <GPIO_setupPinDirection+0x1b6>
			{
				SET_BIT(DDRD,pin_num);
    717c:	a1 e3       	ldi	r26, 0x31	; 49
    717e:	b0 e0       	ldi	r27, 0x00	; 0
    7180:	e1 e3       	ldi	r30, 0x31	; 49
    7182:	f0 e0       	ldi	r31, 0x00	; 0
    7184:	80 81       	ld	r24, Z
    7186:	48 2f       	mov	r20, r24
    7188:	8a 81       	ldd	r24, Y+2	; 0x02
    718a:	28 2f       	mov	r18, r24
    718c:	30 e0       	ldi	r19, 0x00	; 0
    718e:	81 e0       	ldi	r24, 0x01	; 1
    7190:	90 e0       	ldi	r25, 0x00	; 0
    7192:	02 2e       	mov	r0, r18
    7194:	02 c0       	rjmp	.+4      	; 0x719a <GPIO_setupPinDirection+0x1ac>
    7196:	88 0f       	add	r24, r24
    7198:	99 1f       	adc	r25, r25
    719a:	0a 94       	dec	r0
    719c:	e2 f7       	brpl	.-8      	; 0x7196 <GPIO_setupPinDirection+0x1a8>
    719e:	84 2b       	or	r24, r20
    71a0:	8c 93       	st	X, r24
    71a2:	6c c0       	rjmp	.+216    	; 0x727c <GPIO_setupPinDirection+0x28e>
			}
			else
			{
				CLEAR_BIT(DDRD,pin_num);
    71a4:	a1 e3       	ldi	r26, 0x31	; 49
    71a6:	b0 e0       	ldi	r27, 0x00	; 0
    71a8:	e1 e3       	ldi	r30, 0x31	; 49
    71aa:	f0 e0       	ldi	r31, 0x00	; 0
    71ac:	80 81       	ld	r24, Z
    71ae:	48 2f       	mov	r20, r24
    71b0:	8a 81       	ldd	r24, Y+2	; 0x02
    71b2:	28 2f       	mov	r18, r24
    71b4:	30 e0       	ldi	r19, 0x00	; 0
    71b6:	81 e0       	ldi	r24, 0x01	; 1
    71b8:	90 e0       	ldi	r25, 0x00	; 0
    71ba:	02 2e       	mov	r0, r18
    71bc:	02 c0       	rjmp	.+4      	; 0x71c2 <GPIO_setupPinDirection+0x1d4>
    71be:	88 0f       	add	r24, r24
    71c0:	99 1f       	adc	r25, r25
    71c2:	0a 94       	dec	r0
    71c4:	e2 f7       	brpl	.-8      	; 0x71be <GPIO_setupPinDirection+0x1d0>
    71c6:	80 95       	com	r24
    71c8:	84 23       	and	r24, r20
    71ca:	8c 93       	st	X, r24
    71cc:	57 c0       	rjmp	.+174    	; 0x727c <GPIO_setupPinDirection+0x28e>
			}
			break;
		case PORTE_ID:
			if(direction == PIN_OUTPUT)
    71ce:	8b 81       	ldd	r24, Y+3	; 0x03
    71d0:	81 30       	cpi	r24, 0x01	; 1
    71d2:	a1 f4       	brne	.+40     	; 0x71fc <GPIO_setupPinDirection+0x20e>
			{
				SET_BIT(DDRE,pin_num);
    71d4:	a2 e2       	ldi	r26, 0x22	; 34
    71d6:	b0 e0       	ldi	r27, 0x00	; 0
    71d8:	e2 e2       	ldi	r30, 0x22	; 34
    71da:	f0 e0       	ldi	r31, 0x00	; 0
    71dc:	80 81       	ld	r24, Z
    71de:	48 2f       	mov	r20, r24
    71e0:	8a 81       	ldd	r24, Y+2	; 0x02
    71e2:	28 2f       	mov	r18, r24
    71e4:	30 e0       	ldi	r19, 0x00	; 0
    71e6:	81 e0       	ldi	r24, 0x01	; 1
    71e8:	90 e0       	ldi	r25, 0x00	; 0
    71ea:	02 2e       	mov	r0, r18
    71ec:	02 c0       	rjmp	.+4      	; 0x71f2 <GPIO_setupPinDirection+0x204>
    71ee:	88 0f       	add	r24, r24
    71f0:	99 1f       	adc	r25, r25
    71f2:	0a 94       	dec	r0
    71f4:	e2 f7       	brpl	.-8      	; 0x71ee <GPIO_setupPinDirection+0x200>
    71f6:	84 2b       	or	r24, r20
    71f8:	8c 93       	st	X, r24
    71fa:	40 c0       	rjmp	.+128    	; 0x727c <GPIO_setupPinDirection+0x28e>
			}
			else
			{
				CLEAR_BIT(DDRE,pin_num);
    71fc:	a2 e2       	ldi	r26, 0x22	; 34
    71fe:	b0 e0       	ldi	r27, 0x00	; 0
    7200:	e2 e2       	ldi	r30, 0x22	; 34
    7202:	f0 e0       	ldi	r31, 0x00	; 0
    7204:	80 81       	ld	r24, Z
    7206:	48 2f       	mov	r20, r24
    7208:	8a 81       	ldd	r24, Y+2	; 0x02
    720a:	28 2f       	mov	r18, r24
    720c:	30 e0       	ldi	r19, 0x00	; 0
    720e:	81 e0       	ldi	r24, 0x01	; 1
    7210:	90 e0       	ldi	r25, 0x00	; 0
    7212:	02 2e       	mov	r0, r18
    7214:	02 c0       	rjmp	.+4      	; 0x721a <GPIO_setupPinDirection+0x22c>
    7216:	88 0f       	add	r24, r24
    7218:	99 1f       	adc	r25, r25
    721a:	0a 94       	dec	r0
    721c:	e2 f7       	brpl	.-8      	; 0x7216 <GPIO_setupPinDirection+0x228>
    721e:	80 95       	com	r24
    7220:	84 23       	and	r24, r20
    7222:	8c 93       	st	X, r24
    7224:	2b c0       	rjmp	.+86     	; 0x727c <GPIO_setupPinDirection+0x28e>
			}
			break;
		case PORTF_ID:
			if(direction == PIN_OUTPUT)
    7226:	8b 81       	ldd	r24, Y+3	; 0x03
    7228:	81 30       	cpi	r24, 0x01	; 1
    722a:	a1 f4       	brne	.+40     	; 0x7254 <GPIO_setupPinDirection+0x266>
			{
				SET_BIT(DDRF,pin_num);
    722c:	a1 e6       	ldi	r26, 0x61	; 97
    722e:	b0 e0       	ldi	r27, 0x00	; 0
    7230:	e1 e6       	ldi	r30, 0x61	; 97
    7232:	f0 e0       	ldi	r31, 0x00	; 0
    7234:	80 81       	ld	r24, Z
    7236:	48 2f       	mov	r20, r24
    7238:	8a 81       	ldd	r24, Y+2	; 0x02
    723a:	28 2f       	mov	r18, r24
    723c:	30 e0       	ldi	r19, 0x00	; 0
    723e:	81 e0       	ldi	r24, 0x01	; 1
    7240:	90 e0       	ldi	r25, 0x00	; 0
    7242:	02 2e       	mov	r0, r18
    7244:	02 c0       	rjmp	.+4      	; 0x724a <GPIO_setupPinDirection+0x25c>
    7246:	88 0f       	add	r24, r24
    7248:	99 1f       	adc	r25, r25
    724a:	0a 94       	dec	r0
    724c:	e2 f7       	brpl	.-8      	; 0x7246 <GPIO_setupPinDirection+0x258>
    724e:	84 2b       	or	r24, r20
    7250:	8c 93       	st	X, r24
    7252:	14 c0       	rjmp	.+40     	; 0x727c <GPIO_setupPinDirection+0x28e>
			}
			else
			{
				CLEAR_BIT(DDRF,pin_num);
    7254:	a1 e6       	ldi	r26, 0x61	; 97
    7256:	b0 e0       	ldi	r27, 0x00	; 0
    7258:	e1 e6       	ldi	r30, 0x61	; 97
    725a:	f0 e0       	ldi	r31, 0x00	; 0
    725c:	80 81       	ld	r24, Z
    725e:	48 2f       	mov	r20, r24
    7260:	8a 81       	ldd	r24, Y+2	; 0x02
    7262:	28 2f       	mov	r18, r24
    7264:	30 e0       	ldi	r19, 0x00	; 0
    7266:	81 e0       	ldi	r24, 0x01	; 1
    7268:	90 e0       	ldi	r25, 0x00	; 0
    726a:	02 2e       	mov	r0, r18
    726c:	02 c0       	rjmp	.+4      	; 0x7272 <GPIO_setupPinDirection+0x284>
    726e:	88 0f       	add	r24, r24
    7270:	99 1f       	adc	r25, r25
    7272:	0a 94       	dec	r0
    7274:	e2 f7       	brpl	.-8      	; 0x726e <GPIO_setupPinDirection+0x280>
    7276:	80 95       	com	r24
    7278:	84 23       	and	r24, r20
    727a:	8c 93       	st	X, r24
			}
			break;
		}
	}
}
    727c:	0f 90       	pop	r0
    727e:	0f 90       	pop	r0
    7280:	0f 90       	pop	r0
    7282:	0f 90       	pop	r0
    7284:	0f 90       	pop	r0
    7286:	cf 91       	pop	r28
    7288:	df 91       	pop	r29
    728a:	08 95       	ret

0000728c <GPIO_writePin>:
 * Write the value Logic High or Logic Low on the required pin.
 * If the input port number or pin number are not correct, The function will not handle the request.
 * If the pin is input, this function will enable/disable the internal pull-up resistor.
 */
void GPIO_writePin(uint8 port_num, uint8 pin_num, uint8 value)
{
    728c:	df 93       	push	r29
    728e:	cf 93       	push	r28
    7290:	00 d0       	rcall	.+0      	; 0x7292 <GPIO_writePin+0x6>
    7292:	00 d0       	rcall	.+0      	; 0x7294 <GPIO_writePin+0x8>
    7294:	0f 92       	push	r0
    7296:	cd b7       	in	r28, 0x3d	; 61
    7298:	de b7       	in	r29, 0x3e	; 62
    729a:	89 83       	std	Y+1, r24	; 0x01
    729c:	6a 83       	std	Y+2, r22	; 0x02
    729e:	4b 83       	std	Y+3, r20	; 0x03
	/*
	 * Check if the input port number is greater than NUM_OF_PINS_PER_PORT value.
	 * Or if the input pin number is greater than NUM_OF_PINS_PER_PORT value.
	 * In this case the input is not valid port/pin number
	 */
	if((pin_num >= NUM_OF_PINS_PER_PORT) || (port_num >= NUM_OF_PORTS))
    72a0:	8a 81       	ldd	r24, Y+2	; 0x02
    72a2:	88 30       	cpi	r24, 0x08	; 8
    72a4:	08 f0       	brcs	.+2      	; 0x72a8 <GPIO_writePin+0x1c>
    72a6:	39 c1       	rjmp	.+626    	; 0x751a <GPIO_writePin+0x28e>
    72a8:	89 81       	ldd	r24, Y+1	; 0x01
    72aa:	86 30       	cpi	r24, 0x06	; 6
    72ac:	08 f0       	brcs	.+2      	; 0x72b0 <GPIO_writePin+0x24>
    72ae:	35 c1       	rjmp	.+618    	; 0x751a <GPIO_writePin+0x28e>
		/* Do Nothing */
	}
	else
	{
		/* Write the pin value as required */
		switch(port_num)
    72b0:	89 81       	ldd	r24, Y+1	; 0x01
    72b2:	28 2f       	mov	r18, r24
    72b4:	30 e0       	ldi	r19, 0x00	; 0
    72b6:	3d 83       	std	Y+5, r19	; 0x05
    72b8:	2c 83       	std	Y+4, r18	; 0x04
    72ba:	8c 81       	ldd	r24, Y+4	; 0x04
    72bc:	9d 81       	ldd	r25, Y+5	; 0x05
    72be:	82 30       	cpi	r24, 0x02	; 2
    72c0:	91 05       	cpc	r25, r1
    72c2:	09 f4       	brne	.+2      	; 0x72c6 <GPIO_writePin+0x3a>
    72c4:	7b c0       	rjmp	.+246    	; 0x73bc <GPIO_writePin+0x130>
    72c6:	2c 81       	ldd	r18, Y+4	; 0x04
    72c8:	3d 81       	ldd	r19, Y+5	; 0x05
    72ca:	23 30       	cpi	r18, 0x03	; 3
    72cc:	31 05       	cpc	r19, r1
    72ce:	5c f4       	brge	.+22     	; 0x72e6 <GPIO_writePin+0x5a>
    72d0:	8c 81       	ldd	r24, Y+4	; 0x04
    72d2:	9d 81       	ldd	r25, Y+5	; 0x05
    72d4:	00 97       	sbiw	r24, 0x00	; 0
    72d6:	d1 f0       	breq	.+52     	; 0x730c <GPIO_writePin+0x80>
    72d8:	2c 81       	ldd	r18, Y+4	; 0x04
    72da:	3d 81       	ldd	r19, Y+5	; 0x05
    72dc:	21 30       	cpi	r18, 0x01	; 1
    72de:	31 05       	cpc	r19, r1
    72e0:	09 f4       	brne	.+2      	; 0x72e4 <GPIO_writePin+0x58>
    72e2:	40 c0       	rjmp	.+128    	; 0x7364 <GPIO_writePin+0xd8>
    72e4:	1a c1       	rjmp	.+564    	; 0x751a <GPIO_writePin+0x28e>
    72e6:	8c 81       	ldd	r24, Y+4	; 0x04
    72e8:	9d 81       	ldd	r25, Y+5	; 0x05
    72ea:	84 30       	cpi	r24, 0x04	; 4
    72ec:	91 05       	cpc	r25, r1
    72ee:	09 f4       	brne	.+2      	; 0x72f2 <GPIO_writePin+0x66>
    72f0:	bd c0       	rjmp	.+378    	; 0x746c <GPIO_writePin+0x1e0>
    72f2:	2c 81       	ldd	r18, Y+4	; 0x04
    72f4:	3d 81       	ldd	r19, Y+5	; 0x05
    72f6:	24 30       	cpi	r18, 0x04	; 4
    72f8:	31 05       	cpc	r19, r1
    72fa:	0c f4       	brge	.+2      	; 0x72fe <GPIO_writePin+0x72>
    72fc:	8b c0       	rjmp	.+278    	; 0x7414 <GPIO_writePin+0x188>
    72fe:	8c 81       	ldd	r24, Y+4	; 0x04
    7300:	9d 81       	ldd	r25, Y+5	; 0x05
    7302:	85 30       	cpi	r24, 0x05	; 5
    7304:	91 05       	cpc	r25, r1
    7306:	09 f4       	brne	.+2      	; 0x730a <GPIO_writePin+0x7e>
    7308:	dd c0       	rjmp	.+442    	; 0x74c4 <GPIO_writePin+0x238>
    730a:	07 c1       	rjmp	.+526    	; 0x751a <GPIO_writePin+0x28e>
		{
		case PORTA_ID:
			if(value == LOGIC_HIGH)
    730c:	8b 81       	ldd	r24, Y+3	; 0x03
    730e:	81 30       	cpi	r24, 0x01	; 1
    7310:	a1 f4       	brne	.+40     	; 0x733a <GPIO_writePin+0xae>
			{
				SET_BIT(PORTA,pin_num);
    7312:	ab e3       	ldi	r26, 0x3B	; 59
    7314:	b0 e0       	ldi	r27, 0x00	; 0
    7316:	eb e3       	ldi	r30, 0x3B	; 59
    7318:	f0 e0       	ldi	r31, 0x00	; 0
    731a:	80 81       	ld	r24, Z
    731c:	48 2f       	mov	r20, r24
    731e:	8a 81       	ldd	r24, Y+2	; 0x02
    7320:	28 2f       	mov	r18, r24
    7322:	30 e0       	ldi	r19, 0x00	; 0
    7324:	81 e0       	ldi	r24, 0x01	; 1
    7326:	90 e0       	ldi	r25, 0x00	; 0
    7328:	02 2e       	mov	r0, r18
    732a:	02 c0       	rjmp	.+4      	; 0x7330 <GPIO_writePin+0xa4>
    732c:	88 0f       	add	r24, r24
    732e:	99 1f       	adc	r25, r25
    7330:	0a 94       	dec	r0
    7332:	e2 f7       	brpl	.-8      	; 0x732c <GPIO_writePin+0xa0>
    7334:	84 2b       	or	r24, r20
    7336:	8c 93       	st	X, r24
    7338:	f0 c0       	rjmp	.+480    	; 0x751a <GPIO_writePin+0x28e>
			}
			else
			{
				CLEAR_BIT(PORTA,pin_num);
    733a:	ab e3       	ldi	r26, 0x3B	; 59
    733c:	b0 e0       	ldi	r27, 0x00	; 0
    733e:	eb e3       	ldi	r30, 0x3B	; 59
    7340:	f0 e0       	ldi	r31, 0x00	; 0
    7342:	80 81       	ld	r24, Z
    7344:	48 2f       	mov	r20, r24
    7346:	8a 81       	ldd	r24, Y+2	; 0x02
    7348:	28 2f       	mov	r18, r24
    734a:	30 e0       	ldi	r19, 0x00	; 0
    734c:	81 e0       	ldi	r24, 0x01	; 1
    734e:	90 e0       	ldi	r25, 0x00	; 0
    7350:	02 2e       	mov	r0, r18
    7352:	02 c0       	rjmp	.+4      	; 0x7358 <GPIO_writePin+0xcc>
    7354:	88 0f       	add	r24, r24
    7356:	99 1f       	adc	r25, r25
    7358:	0a 94       	dec	r0
    735a:	e2 f7       	brpl	.-8      	; 0x7354 <GPIO_writePin+0xc8>
    735c:	80 95       	com	r24
    735e:	84 23       	and	r24, r20
    7360:	8c 93       	st	X, r24
    7362:	db c0       	rjmp	.+438    	; 0x751a <GPIO_writePin+0x28e>
			}
			break;
		case PORTB_ID:
			if(value == LOGIC_HIGH)
    7364:	8b 81       	ldd	r24, Y+3	; 0x03
    7366:	81 30       	cpi	r24, 0x01	; 1
    7368:	a1 f4       	brne	.+40     	; 0x7392 <GPIO_writePin+0x106>
			{
				SET_BIT(PORTB,pin_num);
    736a:	a8 e3       	ldi	r26, 0x38	; 56
    736c:	b0 e0       	ldi	r27, 0x00	; 0
    736e:	e8 e3       	ldi	r30, 0x38	; 56
    7370:	f0 e0       	ldi	r31, 0x00	; 0
    7372:	80 81       	ld	r24, Z
    7374:	48 2f       	mov	r20, r24
    7376:	8a 81       	ldd	r24, Y+2	; 0x02
    7378:	28 2f       	mov	r18, r24
    737a:	30 e0       	ldi	r19, 0x00	; 0
    737c:	81 e0       	ldi	r24, 0x01	; 1
    737e:	90 e0       	ldi	r25, 0x00	; 0
    7380:	02 2e       	mov	r0, r18
    7382:	02 c0       	rjmp	.+4      	; 0x7388 <GPIO_writePin+0xfc>
    7384:	88 0f       	add	r24, r24
    7386:	99 1f       	adc	r25, r25
    7388:	0a 94       	dec	r0
    738a:	e2 f7       	brpl	.-8      	; 0x7384 <GPIO_writePin+0xf8>
    738c:	84 2b       	or	r24, r20
    738e:	8c 93       	st	X, r24
    7390:	c4 c0       	rjmp	.+392    	; 0x751a <GPIO_writePin+0x28e>
			}
			else
			{
				CLEAR_BIT(PORTB,pin_num);
    7392:	a8 e3       	ldi	r26, 0x38	; 56
    7394:	b0 e0       	ldi	r27, 0x00	; 0
    7396:	e8 e3       	ldi	r30, 0x38	; 56
    7398:	f0 e0       	ldi	r31, 0x00	; 0
    739a:	80 81       	ld	r24, Z
    739c:	48 2f       	mov	r20, r24
    739e:	8a 81       	ldd	r24, Y+2	; 0x02
    73a0:	28 2f       	mov	r18, r24
    73a2:	30 e0       	ldi	r19, 0x00	; 0
    73a4:	81 e0       	ldi	r24, 0x01	; 1
    73a6:	90 e0       	ldi	r25, 0x00	; 0
    73a8:	02 2e       	mov	r0, r18
    73aa:	02 c0       	rjmp	.+4      	; 0x73b0 <GPIO_writePin+0x124>
    73ac:	88 0f       	add	r24, r24
    73ae:	99 1f       	adc	r25, r25
    73b0:	0a 94       	dec	r0
    73b2:	e2 f7       	brpl	.-8      	; 0x73ac <GPIO_writePin+0x120>
    73b4:	80 95       	com	r24
    73b6:	84 23       	and	r24, r20
    73b8:	8c 93       	st	X, r24
    73ba:	af c0       	rjmp	.+350    	; 0x751a <GPIO_writePin+0x28e>
			}
			break;
		case PORTC_ID:
			if(value == LOGIC_HIGH)
    73bc:	8b 81       	ldd	r24, Y+3	; 0x03
    73be:	81 30       	cpi	r24, 0x01	; 1
    73c0:	a1 f4       	brne	.+40     	; 0x73ea <GPIO_writePin+0x15e>
			{
				SET_BIT(PORTC,pin_num);
    73c2:	a5 e3       	ldi	r26, 0x35	; 53
    73c4:	b0 e0       	ldi	r27, 0x00	; 0
    73c6:	e5 e3       	ldi	r30, 0x35	; 53
    73c8:	f0 e0       	ldi	r31, 0x00	; 0
    73ca:	80 81       	ld	r24, Z
    73cc:	48 2f       	mov	r20, r24
    73ce:	8a 81       	ldd	r24, Y+2	; 0x02
    73d0:	28 2f       	mov	r18, r24
    73d2:	30 e0       	ldi	r19, 0x00	; 0
    73d4:	81 e0       	ldi	r24, 0x01	; 1
    73d6:	90 e0       	ldi	r25, 0x00	; 0
    73d8:	02 2e       	mov	r0, r18
    73da:	02 c0       	rjmp	.+4      	; 0x73e0 <GPIO_writePin+0x154>
    73dc:	88 0f       	add	r24, r24
    73de:	99 1f       	adc	r25, r25
    73e0:	0a 94       	dec	r0
    73e2:	e2 f7       	brpl	.-8      	; 0x73dc <GPIO_writePin+0x150>
    73e4:	84 2b       	or	r24, r20
    73e6:	8c 93       	st	X, r24
    73e8:	98 c0       	rjmp	.+304    	; 0x751a <GPIO_writePin+0x28e>
			}
			else
			{
				CLEAR_BIT(PORTC,pin_num);
    73ea:	a5 e3       	ldi	r26, 0x35	; 53
    73ec:	b0 e0       	ldi	r27, 0x00	; 0
    73ee:	e5 e3       	ldi	r30, 0x35	; 53
    73f0:	f0 e0       	ldi	r31, 0x00	; 0
    73f2:	80 81       	ld	r24, Z
    73f4:	48 2f       	mov	r20, r24
    73f6:	8a 81       	ldd	r24, Y+2	; 0x02
    73f8:	28 2f       	mov	r18, r24
    73fa:	30 e0       	ldi	r19, 0x00	; 0
    73fc:	81 e0       	ldi	r24, 0x01	; 1
    73fe:	90 e0       	ldi	r25, 0x00	; 0
    7400:	02 2e       	mov	r0, r18
    7402:	02 c0       	rjmp	.+4      	; 0x7408 <GPIO_writePin+0x17c>
    7404:	88 0f       	add	r24, r24
    7406:	99 1f       	adc	r25, r25
    7408:	0a 94       	dec	r0
    740a:	e2 f7       	brpl	.-8      	; 0x7404 <GPIO_writePin+0x178>
    740c:	80 95       	com	r24
    740e:	84 23       	and	r24, r20
    7410:	8c 93       	st	X, r24
    7412:	83 c0       	rjmp	.+262    	; 0x751a <GPIO_writePin+0x28e>
			}
			break;
		case PORTD_ID:
			if(value == LOGIC_HIGH)
    7414:	8b 81       	ldd	r24, Y+3	; 0x03
    7416:	81 30       	cpi	r24, 0x01	; 1
    7418:	a1 f4       	brne	.+40     	; 0x7442 <GPIO_writePin+0x1b6>
			{
				SET_BIT(PORTD,pin_num);
    741a:	a2 e3       	ldi	r26, 0x32	; 50
    741c:	b0 e0       	ldi	r27, 0x00	; 0
    741e:	e2 e3       	ldi	r30, 0x32	; 50
    7420:	f0 e0       	ldi	r31, 0x00	; 0
    7422:	80 81       	ld	r24, Z
    7424:	48 2f       	mov	r20, r24
    7426:	8a 81       	ldd	r24, Y+2	; 0x02
    7428:	28 2f       	mov	r18, r24
    742a:	30 e0       	ldi	r19, 0x00	; 0
    742c:	81 e0       	ldi	r24, 0x01	; 1
    742e:	90 e0       	ldi	r25, 0x00	; 0
    7430:	02 2e       	mov	r0, r18
    7432:	02 c0       	rjmp	.+4      	; 0x7438 <GPIO_writePin+0x1ac>
    7434:	88 0f       	add	r24, r24
    7436:	99 1f       	adc	r25, r25
    7438:	0a 94       	dec	r0
    743a:	e2 f7       	brpl	.-8      	; 0x7434 <GPIO_writePin+0x1a8>
    743c:	84 2b       	or	r24, r20
    743e:	8c 93       	st	X, r24
    7440:	6c c0       	rjmp	.+216    	; 0x751a <GPIO_writePin+0x28e>
			}
			else
			{
				CLEAR_BIT(PORTD,pin_num);
    7442:	a2 e3       	ldi	r26, 0x32	; 50
    7444:	b0 e0       	ldi	r27, 0x00	; 0
    7446:	e2 e3       	ldi	r30, 0x32	; 50
    7448:	f0 e0       	ldi	r31, 0x00	; 0
    744a:	80 81       	ld	r24, Z
    744c:	48 2f       	mov	r20, r24
    744e:	8a 81       	ldd	r24, Y+2	; 0x02
    7450:	28 2f       	mov	r18, r24
    7452:	30 e0       	ldi	r19, 0x00	; 0
    7454:	81 e0       	ldi	r24, 0x01	; 1
    7456:	90 e0       	ldi	r25, 0x00	; 0
    7458:	02 2e       	mov	r0, r18
    745a:	02 c0       	rjmp	.+4      	; 0x7460 <GPIO_writePin+0x1d4>
    745c:	88 0f       	add	r24, r24
    745e:	99 1f       	adc	r25, r25
    7460:	0a 94       	dec	r0
    7462:	e2 f7       	brpl	.-8      	; 0x745c <GPIO_writePin+0x1d0>
    7464:	80 95       	com	r24
    7466:	84 23       	and	r24, r20
    7468:	8c 93       	st	X, r24
    746a:	57 c0       	rjmp	.+174    	; 0x751a <GPIO_writePin+0x28e>
			}
			break;
		case PORTE_ID:
			if(value == LOGIC_HIGH)
    746c:	8b 81       	ldd	r24, Y+3	; 0x03
    746e:	81 30       	cpi	r24, 0x01	; 1
    7470:	a1 f4       	brne	.+40     	; 0x749a <GPIO_writePin+0x20e>
			{
				SET_BIT(PORTE,pin_num);
    7472:	a3 e2       	ldi	r26, 0x23	; 35
    7474:	b0 e0       	ldi	r27, 0x00	; 0
    7476:	e3 e2       	ldi	r30, 0x23	; 35
    7478:	f0 e0       	ldi	r31, 0x00	; 0
    747a:	80 81       	ld	r24, Z
    747c:	48 2f       	mov	r20, r24
    747e:	8a 81       	ldd	r24, Y+2	; 0x02
    7480:	28 2f       	mov	r18, r24
    7482:	30 e0       	ldi	r19, 0x00	; 0
    7484:	81 e0       	ldi	r24, 0x01	; 1
    7486:	90 e0       	ldi	r25, 0x00	; 0
    7488:	02 2e       	mov	r0, r18
    748a:	02 c0       	rjmp	.+4      	; 0x7490 <GPIO_writePin+0x204>
    748c:	88 0f       	add	r24, r24
    748e:	99 1f       	adc	r25, r25
    7490:	0a 94       	dec	r0
    7492:	e2 f7       	brpl	.-8      	; 0x748c <GPIO_writePin+0x200>
    7494:	84 2b       	or	r24, r20
    7496:	8c 93       	st	X, r24
    7498:	40 c0       	rjmp	.+128    	; 0x751a <GPIO_writePin+0x28e>
			}
			else
			{
				CLEAR_BIT(PORTE,pin_num);
    749a:	a3 e2       	ldi	r26, 0x23	; 35
    749c:	b0 e0       	ldi	r27, 0x00	; 0
    749e:	e3 e2       	ldi	r30, 0x23	; 35
    74a0:	f0 e0       	ldi	r31, 0x00	; 0
    74a2:	80 81       	ld	r24, Z
    74a4:	48 2f       	mov	r20, r24
    74a6:	8a 81       	ldd	r24, Y+2	; 0x02
    74a8:	28 2f       	mov	r18, r24
    74aa:	30 e0       	ldi	r19, 0x00	; 0
    74ac:	81 e0       	ldi	r24, 0x01	; 1
    74ae:	90 e0       	ldi	r25, 0x00	; 0
    74b0:	02 2e       	mov	r0, r18
    74b2:	02 c0       	rjmp	.+4      	; 0x74b8 <GPIO_writePin+0x22c>
    74b4:	88 0f       	add	r24, r24
    74b6:	99 1f       	adc	r25, r25
    74b8:	0a 94       	dec	r0
    74ba:	e2 f7       	brpl	.-8      	; 0x74b4 <GPIO_writePin+0x228>
    74bc:	80 95       	com	r24
    74be:	84 23       	and	r24, r20
    74c0:	8c 93       	st	X, r24
    74c2:	2b c0       	rjmp	.+86     	; 0x751a <GPIO_writePin+0x28e>
			}
			break;
		case PORTF_ID:
			if(value == LOGIC_HIGH)
    74c4:	8b 81       	ldd	r24, Y+3	; 0x03
    74c6:	81 30       	cpi	r24, 0x01	; 1
    74c8:	a1 f4       	brne	.+40     	; 0x74f2 <GPIO_writePin+0x266>
			{
				SET_BIT(PORTF,pin_num);
    74ca:	a2 e6       	ldi	r26, 0x62	; 98
    74cc:	b0 e0       	ldi	r27, 0x00	; 0
    74ce:	e2 e6       	ldi	r30, 0x62	; 98
    74d0:	f0 e0       	ldi	r31, 0x00	; 0
    74d2:	80 81       	ld	r24, Z
    74d4:	48 2f       	mov	r20, r24
    74d6:	8a 81       	ldd	r24, Y+2	; 0x02
    74d8:	28 2f       	mov	r18, r24
    74da:	30 e0       	ldi	r19, 0x00	; 0
    74dc:	81 e0       	ldi	r24, 0x01	; 1
    74de:	90 e0       	ldi	r25, 0x00	; 0
    74e0:	02 2e       	mov	r0, r18
    74e2:	02 c0       	rjmp	.+4      	; 0x74e8 <GPIO_writePin+0x25c>
    74e4:	88 0f       	add	r24, r24
    74e6:	99 1f       	adc	r25, r25
    74e8:	0a 94       	dec	r0
    74ea:	e2 f7       	brpl	.-8      	; 0x74e4 <GPIO_writePin+0x258>
    74ec:	84 2b       	or	r24, r20
    74ee:	8c 93       	st	X, r24
    74f0:	14 c0       	rjmp	.+40     	; 0x751a <GPIO_writePin+0x28e>
			}
			else
			{
				CLEAR_BIT(PORTF,pin_num);
    74f2:	a2 e6       	ldi	r26, 0x62	; 98
    74f4:	b0 e0       	ldi	r27, 0x00	; 0
    74f6:	e2 e6       	ldi	r30, 0x62	; 98
    74f8:	f0 e0       	ldi	r31, 0x00	; 0
    74fa:	80 81       	ld	r24, Z
    74fc:	48 2f       	mov	r20, r24
    74fe:	8a 81       	ldd	r24, Y+2	; 0x02
    7500:	28 2f       	mov	r18, r24
    7502:	30 e0       	ldi	r19, 0x00	; 0
    7504:	81 e0       	ldi	r24, 0x01	; 1
    7506:	90 e0       	ldi	r25, 0x00	; 0
    7508:	02 2e       	mov	r0, r18
    750a:	02 c0       	rjmp	.+4      	; 0x7510 <GPIO_writePin+0x284>
    750c:	88 0f       	add	r24, r24
    750e:	99 1f       	adc	r25, r25
    7510:	0a 94       	dec	r0
    7512:	e2 f7       	brpl	.-8      	; 0x750c <GPIO_writePin+0x280>
    7514:	80 95       	com	r24
    7516:	84 23       	and	r24, r20
    7518:	8c 93       	st	X, r24
			}
			break;
		}
	}
}
    751a:	0f 90       	pop	r0
    751c:	0f 90       	pop	r0
    751e:	0f 90       	pop	r0
    7520:	0f 90       	pop	r0
    7522:	0f 90       	pop	r0
    7524:	cf 91       	pop	r28
    7526:	df 91       	pop	r29
    7528:	08 95       	ret

0000752a <GPIO_readPin>:
 * Description :
 * Read and return the value for the required pin, it should be Logic High or Logic Low.
 * If the input port number or pin number are not correct, The function will return Logic Low.
 */
uint8 GPIO_readPin(uint8 port_num, uint8 pin_num)
{
    752a:	df 93       	push	r29
    752c:	cf 93       	push	r28
    752e:	00 d0       	rcall	.+0      	; 0x7530 <GPIO_readPin+0x6>
    7530:	00 d0       	rcall	.+0      	; 0x7532 <GPIO_readPin+0x8>
    7532:	0f 92       	push	r0
    7534:	cd b7       	in	r28, 0x3d	; 61
    7536:	de b7       	in	r29, 0x3e	; 62
    7538:	8a 83       	std	Y+2, r24	; 0x02
    753a:	6b 83       	std	Y+3, r22	; 0x03
	uint8 pin_value = LOGIC_LOW;
    753c:	19 82       	std	Y+1, r1	; 0x01
	/*
	 * Check if the input port number is greater than NUM_OF_PINS_PER_PORT value.
	 * Or if the input pin number is greater than NUM_OF_PINS_PER_PORT value.
	 * In this case the input is not valid port/pin number
	 */
	if((pin_num >= NUM_OF_PINS_PER_PORT) || (port_num >= NUM_OF_PORTS))
    753e:	8b 81       	ldd	r24, Y+3	; 0x03
    7540:	88 30       	cpi	r24, 0x08	; 8
    7542:	08 f0       	brcs	.+2      	; 0x7546 <GPIO_readPin+0x1c>
    7544:	c1 c0       	rjmp	.+386    	; 0x76c8 <GPIO_readPin+0x19e>
    7546:	8a 81       	ldd	r24, Y+2	; 0x02
    7548:	86 30       	cpi	r24, 0x06	; 6
    754a:	08 f0       	brcs	.+2      	; 0x754e <GPIO_readPin+0x24>
    754c:	bd c0       	rjmp	.+378    	; 0x76c8 <GPIO_readPin+0x19e>
		/* Do Nothing */
	}
	else
	{
		/* Read the pin value as required */
		switch(port_num)
    754e:	8a 81       	ldd	r24, Y+2	; 0x02
    7550:	28 2f       	mov	r18, r24
    7552:	30 e0       	ldi	r19, 0x00	; 0
    7554:	3d 83       	std	Y+5, r19	; 0x05
    7556:	2c 83       	std	Y+4, r18	; 0x04
    7558:	4c 81       	ldd	r20, Y+4	; 0x04
    755a:	5d 81       	ldd	r21, Y+5	; 0x05
    755c:	42 30       	cpi	r20, 0x02	; 2
    755e:	51 05       	cpc	r21, r1
    7560:	09 f4       	brne	.+2      	; 0x7564 <GPIO_readPin+0x3a>
    7562:	53 c0       	rjmp	.+166    	; 0x760a <GPIO_readPin+0xe0>
    7564:	8c 81       	ldd	r24, Y+4	; 0x04
    7566:	9d 81       	ldd	r25, Y+5	; 0x05
    7568:	83 30       	cpi	r24, 0x03	; 3
    756a:	91 05       	cpc	r25, r1
    756c:	5c f4       	brge	.+22     	; 0x7584 <GPIO_readPin+0x5a>
    756e:	2c 81       	ldd	r18, Y+4	; 0x04
    7570:	3d 81       	ldd	r19, Y+5	; 0x05
    7572:	21 15       	cp	r18, r1
    7574:	31 05       	cpc	r19, r1
    7576:	c9 f0       	breq	.+50     	; 0x75aa <GPIO_readPin+0x80>
    7578:	4c 81       	ldd	r20, Y+4	; 0x04
    757a:	5d 81       	ldd	r21, Y+5	; 0x05
    757c:	41 30       	cpi	r20, 0x01	; 1
    757e:	51 05       	cpc	r21, r1
    7580:	61 f1       	breq	.+88     	; 0x75da <GPIO_readPin+0xb0>
    7582:	a2 c0       	rjmp	.+324    	; 0x76c8 <GPIO_readPin+0x19e>
    7584:	8c 81       	ldd	r24, Y+4	; 0x04
    7586:	9d 81       	ldd	r25, Y+5	; 0x05
    7588:	84 30       	cpi	r24, 0x04	; 4
    758a:	91 05       	cpc	r25, r1
    758c:	09 f4       	brne	.+2      	; 0x7590 <GPIO_readPin+0x66>
    758e:	6d c0       	rjmp	.+218    	; 0x766a <GPIO_readPin+0x140>
    7590:	2c 81       	ldd	r18, Y+4	; 0x04
    7592:	3d 81       	ldd	r19, Y+5	; 0x05
    7594:	24 30       	cpi	r18, 0x04	; 4
    7596:	31 05       	cpc	r19, r1
    7598:	0c f4       	brge	.+2      	; 0x759c <GPIO_readPin+0x72>
    759a:	4f c0       	rjmp	.+158    	; 0x763a <GPIO_readPin+0x110>
    759c:	4c 81       	ldd	r20, Y+4	; 0x04
    759e:	5d 81       	ldd	r21, Y+5	; 0x05
    75a0:	45 30       	cpi	r20, 0x05	; 5
    75a2:	51 05       	cpc	r21, r1
    75a4:	09 f4       	brne	.+2      	; 0x75a8 <GPIO_readPin+0x7e>
    75a6:	79 c0       	rjmp	.+242    	; 0x769a <GPIO_readPin+0x170>
    75a8:	8f c0       	rjmp	.+286    	; 0x76c8 <GPIO_readPin+0x19e>
		{
		case PORTA_ID:
			if(BIT_IS_SET(PINA,pin_num))
    75aa:	e9 e3       	ldi	r30, 0x39	; 57
    75ac:	f0 e0       	ldi	r31, 0x00	; 0
    75ae:	80 81       	ld	r24, Z
    75b0:	28 2f       	mov	r18, r24
    75b2:	30 e0       	ldi	r19, 0x00	; 0
    75b4:	8b 81       	ldd	r24, Y+3	; 0x03
    75b6:	88 2f       	mov	r24, r24
    75b8:	90 e0       	ldi	r25, 0x00	; 0
    75ba:	a9 01       	movw	r20, r18
    75bc:	02 c0       	rjmp	.+4      	; 0x75c2 <GPIO_readPin+0x98>
    75be:	55 95       	asr	r21
    75c0:	47 95       	ror	r20
    75c2:	8a 95       	dec	r24
    75c4:	e2 f7       	brpl	.-8      	; 0x75be <GPIO_readPin+0x94>
    75c6:	ca 01       	movw	r24, r20
    75c8:	81 70       	andi	r24, 0x01	; 1
    75ca:	90 70       	andi	r25, 0x00	; 0
    75cc:	88 23       	and	r24, r24
    75ce:	19 f0       	breq	.+6      	; 0x75d6 <GPIO_readPin+0xac>
			{
				pin_value = LOGIC_HIGH;
    75d0:	81 e0       	ldi	r24, 0x01	; 1
    75d2:	89 83       	std	Y+1, r24	; 0x01
    75d4:	79 c0       	rjmp	.+242    	; 0x76c8 <GPIO_readPin+0x19e>
			}
			else
			{
				pin_value = LOGIC_LOW;
    75d6:	19 82       	std	Y+1, r1	; 0x01
    75d8:	77 c0       	rjmp	.+238    	; 0x76c8 <GPIO_readPin+0x19e>
			}
			break;
		case PORTB_ID:
			if(BIT_IS_SET(PINB,pin_num))
    75da:	e6 e3       	ldi	r30, 0x36	; 54
    75dc:	f0 e0       	ldi	r31, 0x00	; 0
    75de:	80 81       	ld	r24, Z
    75e0:	28 2f       	mov	r18, r24
    75e2:	30 e0       	ldi	r19, 0x00	; 0
    75e4:	8b 81       	ldd	r24, Y+3	; 0x03
    75e6:	88 2f       	mov	r24, r24
    75e8:	90 e0       	ldi	r25, 0x00	; 0
    75ea:	a9 01       	movw	r20, r18
    75ec:	02 c0       	rjmp	.+4      	; 0x75f2 <GPIO_readPin+0xc8>
    75ee:	55 95       	asr	r21
    75f0:	47 95       	ror	r20
    75f2:	8a 95       	dec	r24
    75f4:	e2 f7       	brpl	.-8      	; 0x75ee <GPIO_readPin+0xc4>
    75f6:	ca 01       	movw	r24, r20
    75f8:	81 70       	andi	r24, 0x01	; 1
    75fa:	90 70       	andi	r25, 0x00	; 0
    75fc:	88 23       	and	r24, r24
    75fe:	19 f0       	breq	.+6      	; 0x7606 <GPIO_readPin+0xdc>
			{
				pin_value = LOGIC_HIGH;
    7600:	81 e0       	ldi	r24, 0x01	; 1
    7602:	89 83       	std	Y+1, r24	; 0x01
    7604:	61 c0       	rjmp	.+194    	; 0x76c8 <GPIO_readPin+0x19e>
			}
			else
			{
				pin_value = LOGIC_LOW;
    7606:	19 82       	std	Y+1, r1	; 0x01
    7608:	5f c0       	rjmp	.+190    	; 0x76c8 <GPIO_readPin+0x19e>
			}
			break;
		case PORTC_ID:
			if(BIT_IS_SET(PINC,pin_num))
    760a:	e3 e3       	ldi	r30, 0x33	; 51
    760c:	f0 e0       	ldi	r31, 0x00	; 0
    760e:	80 81       	ld	r24, Z
    7610:	28 2f       	mov	r18, r24
    7612:	30 e0       	ldi	r19, 0x00	; 0
    7614:	8b 81       	ldd	r24, Y+3	; 0x03
    7616:	88 2f       	mov	r24, r24
    7618:	90 e0       	ldi	r25, 0x00	; 0
    761a:	a9 01       	movw	r20, r18
    761c:	02 c0       	rjmp	.+4      	; 0x7622 <GPIO_readPin+0xf8>
    761e:	55 95       	asr	r21
    7620:	47 95       	ror	r20
    7622:	8a 95       	dec	r24
    7624:	e2 f7       	brpl	.-8      	; 0x761e <GPIO_readPin+0xf4>
    7626:	ca 01       	movw	r24, r20
    7628:	81 70       	andi	r24, 0x01	; 1
    762a:	90 70       	andi	r25, 0x00	; 0
    762c:	88 23       	and	r24, r24
    762e:	19 f0       	breq	.+6      	; 0x7636 <GPIO_readPin+0x10c>
			{
				pin_value = LOGIC_HIGH;
    7630:	81 e0       	ldi	r24, 0x01	; 1
    7632:	89 83       	std	Y+1, r24	; 0x01
    7634:	49 c0       	rjmp	.+146    	; 0x76c8 <GPIO_readPin+0x19e>
			}
			else
			{
				pin_value = LOGIC_LOW;
    7636:	19 82       	std	Y+1, r1	; 0x01
    7638:	47 c0       	rjmp	.+142    	; 0x76c8 <GPIO_readPin+0x19e>
			}
			break;
		case PORTD_ID:
			if(BIT_IS_SET(PIND,pin_num))
    763a:	e0 e3       	ldi	r30, 0x30	; 48
    763c:	f0 e0       	ldi	r31, 0x00	; 0
    763e:	80 81       	ld	r24, Z
    7640:	28 2f       	mov	r18, r24
    7642:	30 e0       	ldi	r19, 0x00	; 0
    7644:	8b 81       	ldd	r24, Y+3	; 0x03
    7646:	88 2f       	mov	r24, r24
    7648:	90 e0       	ldi	r25, 0x00	; 0
    764a:	a9 01       	movw	r20, r18
    764c:	02 c0       	rjmp	.+4      	; 0x7652 <GPIO_readPin+0x128>
    764e:	55 95       	asr	r21
    7650:	47 95       	ror	r20
    7652:	8a 95       	dec	r24
    7654:	e2 f7       	brpl	.-8      	; 0x764e <GPIO_readPin+0x124>
    7656:	ca 01       	movw	r24, r20
    7658:	81 70       	andi	r24, 0x01	; 1
    765a:	90 70       	andi	r25, 0x00	; 0
    765c:	88 23       	and	r24, r24
    765e:	19 f0       	breq	.+6      	; 0x7666 <GPIO_readPin+0x13c>
			{
				pin_value = LOGIC_HIGH;
    7660:	81 e0       	ldi	r24, 0x01	; 1
    7662:	89 83       	std	Y+1, r24	; 0x01
    7664:	31 c0       	rjmp	.+98     	; 0x76c8 <GPIO_readPin+0x19e>
			}
			else
			{
				pin_value = LOGIC_LOW;
    7666:	19 82       	std	Y+1, r1	; 0x01
    7668:	2f c0       	rjmp	.+94     	; 0x76c8 <GPIO_readPin+0x19e>
			}
			break;
		case PORTE_ID:
			if(BIT_IS_SET(PINE,pin_num))
    766a:	e1 e2       	ldi	r30, 0x21	; 33
    766c:	f0 e0       	ldi	r31, 0x00	; 0
    766e:	80 81       	ld	r24, Z
    7670:	28 2f       	mov	r18, r24
    7672:	30 e0       	ldi	r19, 0x00	; 0
    7674:	8b 81       	ldd	r24, Y+3	; 0x03
    7676:	88 2f       	mov	r24, r24
    7678:	90 e0       	ldi	r25, 0x00	; 0
    767a:	a9 01       	movw	r20, r18
    767c:	02 c0       	rjmp	.+4      	; 0x7682 <GPIO_readPin+0x158>
    767e:	55 95       	asr	r21
    7680:	47 95       	ror	r20
    7682:	8a 95       	dec	r24
    7684:	e2 f7       	brpl	.-8      	; 0x767e <GPIO_readPin+0x154>
    7686:	ca 01       	movw	r24, r20
    7688:	81 70       	andi	r24, 0x01	; 1
    768a:	90 70       	andi	r25, 0x00	; 0
    768c:	88 23       	and	r24, r24
    768e:	19 f0       	breq	.+6      	; 0x7696 <GPIO_readPin+0x16c>
			{
				pin_value = LOGIC_HIGH;
    7690:	81 e0       	ldi	r24, 0x01	; 1
    7692:	89 83       	std	Y+1, r24	; 0x01
    7694:	19 c0       	rjmp	.+50     	; 0x76c8 <GPIO_readPin+0x19e>
			}
			else
			{
				pin_value = LOGIC_LOW;
    7696:	19 82       	std	Y+1, r1	; 0x01
    7698:	17 c0       	rjmp	.+46     	; 0x76c8 <GPIO_readPin+0x19e>
			}
			break;
		case PORTF_ID:
			if(BIT_IS_SET(PINF,pin_num))
    769a:	e0 e2       	ldi	r30, 0x20	; 32
    769c:	f0 e0       	ldi	r31, 0x00	; 0
    769e:	80 81       	ld	r24, Z
    76a0:	28 2f       	mov	r18, r24
    76a2:	30 e0       	ldi	r19, 0x00	; 0
    76a4:	8b 81       	ldd	r24, Y+3	; 0x03
    76a6:	88 2f       	mov	r24, r24
    76a8:	90 e0       	ldi	r25, 0x00	; 0
    76aa:	a9 01       	movw	r20, r18
    76ac:	02 c0       	rjmp	.+4      	; 0x76b2 <GPIO_readPin+0x188>
    76ae:	55 95       	asr	r21
    76b0:	47 95       	ror	r20
    76b2:	8a 95       	dec	r24
    76b4:	e2 f7       	brpl	.-8      	; 0x76ae <GPIO_readPin+0x184>
    76b6:	ca 01       	movw	r24, r20
    76b8:	81 70       	andi	r24, 0x01	; 1
    76ba:	90 70       	andi	r25, 0x00	; 0
    76bc:	88 23       	and	r24, r24
    76be:	19 f0       	breq	.+6      	; 0x76c6 <GPIO_readPin+0x19c>
			{
				pin_value = LOGIC_HIGH;
    76c0:	81 e0       	ldi	r24, 0x01	; 1
    76c2:	89 83       	std	Y+1, r24	; 0x01
    76c4:	01 c0       	rjmp	.+2      	; 0x76c8 <GPIO_readPin+0x19e>
			}
			else
			{
				pin_value = LOGIC_LOW;
    76c6:	19 82       	std	Y+1, r1	; 0x01
			}
			break;
		}
	}

	return pin_value;
    76c8:	89 81       	ldd	r24, Y+1	; 0x01
}
    76ca:	0f 90       	pop	r0
    76cc:	0f 90       	pop	r0
    76ce:	0f 90       	pop	r0
    76d0:	0f 90       	pop	r0
    76d2:	0f 90       	pop	r0
    76d4:	cf 91       	pop	r28
    76d6:	df 91       	pop	r29
    76d8:	08 95       	ret

000076da <GPIO_setupPortDirection>:
 * If the direction value is PORT_INPUT all pins in this port should be input pins.
 * If the direction value is PORT_OUTPUT all pins in this port should be output pins.
 * If the input port number is not correct, The function will not handle the request.
 */
void GPIO_setupPortDirection(uint8 port_num, GPIO_PortDirectionType direction)
{
    76da:	df 93       	push	r29
    76dc:	cf 93       	push	r28
    76de:	00 d0       	rcall	.+0      	; 0x76e0 <GPIO_setupPortDirection+0x6>
    76e0:	00 d0       	rcall	.+0      	; 0x76e2 <GPIO_setupPortDirection+0x8>
    76e2:	cd b7       	in	r28, 0x3d	; 61
    76e4:	de b7       	in	r29, 0x3e	; 62
    76e6:	89 83       	std	Y+1, r24	; 0x01
    76e8:	6a 83       	std	Y+2, r22	; 0x02
	/*
	 * Check if the input number is greater than NUM_OF_PORTS value.
	 * In this case the input is not valid port number
	 */
	if(port_num >= NUM_OF_PORTS)
    76ea:	89 81       	ldd	r24, Y+1	; 0x01
    76ec:	86 30       	cpi	r24, 0x06	; 6
    76ee:	08 f0       	brcs	.+2      	; 0x76f2 <GPIO_setupPortDirection+0x18>
    76f0:	46 c0       	rjmp	.+140    	; 0x777e <GPIO_setupPortDirection+0xa4>
		/* Do Nothing */
	}
	else
	{
		/* Setup the port direction as required */
		switch(port_num)
    76f2:	89 81       	ldd	r24, Y+1	; 0x01
    76f4:	28 2f       	mov	r18, r24
    76f6:	30 e0       	ldi	r19, 0x00	; 0
    76f8:	3c 83       	std	Y+4, r19	; 0x04
    76fa:	2b 83       	std	Y+3, r18	; 0x03
    76fc:	8b 81       	ldd	r24, Y+3	; 0x03
    76fe:	9c 81       	ldd	r25, Y+4	; 0x04
    7700:	82 30       	cpi	r24, 0x02	; 2
    7702:	91 05       	cpc	r25, r1
    7704:	49 f1       	breq	.+82     	; 0x7758 <GPIO_setupPortDirection+0x7e>
    7706:	2b 81       	ldd	r18, Y+3	; 0x03
    7708:	3c 81       	ldd	r19, Y+4	; 0x04
    770a:	23 30       	cpi	r18, 0x03	; 3
    770c:	31 05       	cpc	r19, r1
    770e:	54 f4       	brge	.+20     	; 0x7724 <GPIO_setupPortDirection+0x4a>
    7710:	8b 81       	ldd	r24, Y+3	; 0x03
    7712:	9c 81       	ldd	r25, Y+4	; 0x04
    7714:	00 97       	sbiw	r24, 0x00	; 0
    7716:	b1 f0       	breq	.+44     	; 0x7744 <GPIO_setupPortDirection+0x6a>
    7718:	2b 81       	ldd	r18, Y+3	; 0x03
    771a:	3c 81       	ldd	r19, Y+4	; 0x04
    771c:	21 30       	cpi	r18, 0x01	; 1
    771e:	31 05       	cpc	r19, r1
    7720:	b1 f0       	breq	.+44     	; 0x774e <GPIO_setupPortDirection+0x74>
    7722:	2d c0       	rjmp	.+90     	; 0x777e <GPIO_setupPortDirection+0xa4>
    7724:	8b 81       	ldd	r24, Y+3	; 0x03
    7726:	9c 81       	ldd	r25, Y+4	; 0x04
    7728:	84 30       	cpi	r24, 0x04	; 4
    772a:	91 05       	cpc	r25, r1
    772c:	f9 f0       	breq	.+62     	; 0x776c <GPIO_setupPortDirection+0x92>
    772e:	2b 81       	ldd	r18, Y+3	; 0x03
    7730:	3c 81       	ldd	r19, Y+4	; 0x04
    7732:	24 30       	cpi	r18, 0x04	; 4
    7734:	31 05       	cpc	r19, r1
    7736:	ac f0       	brlt	.+42     	; 0x7762 <GPIO_setupPortDirection+0x88>
    7738:	8b 81       	ldd	r24, Y+3	; 0x03
    773a:	9c 81       	ldd	r25, Y+4	; 0x04
    773c:	85 30       	cpi	r24, 0x05	; 5
    773e:	91 05       	cpc	r25, r1
    7740:	d1 f0       	breq	.+52     	; 0x7776 <GPIO_setupPortDirection+0x9c>
    7742:	1d c0       	rjmp	.+58     	; 0x777e <GPIO_setupPortDirection+0xa4>
		{
		case PORTA_ID:
			DDRA = direction;
    7744:	ea e3       	ldi	r30, 0x3A	; 58
    7746:	f0 e0       	ldi	r31, 0x00	; 0
    7748:	8a 81       	ldd	r24, Y+2	; 0x02
    774a:	80 83       	st	Z, r24
    774c:	18 c0       	rjmp	.+48     	; 0x777e <GPIO_setupPortDirection+0xa4>
			break;
		case PORTB_ID:
			DDRB = direction;
    774e:	e7 e3       	ldi	r30, 0x37	; 55
    7750:	f0 e0       	ldi	r31, 0x00	; 0
    7752:	8a 81       	ldd	r24, Y+2	; 0x02
    7754:	80 83       	st	Z, r24
    7756:	13 c0       	rjmp	.+38     	; 0x777e <GPIO_setupPortDirection+0xa4>
			break;
		case PORTC_ID:
			DDRC = direction;
    7758:	e4 e3       	ldi	r30, 0x34	; 52
    775a:	f0 e0       	ldi	r31, 0x00	; 0
    775c:	8a 81       	ldd	r24, Y+2	; 0x02
    775e:	80 83       	st	Z, r24
    7760:	0e c0       	rjmp	.+28     	; 0x777e <GPIO_setupPortDirection+0xa4>
			break;
		case PORTD_ID:
			DDRD = direction;
    7762:	e1 e3       	ldi	r30, 0x31	; 49
    7764:	f0 e0       	ldi	r31, 0x00	; 0
    7766:	8a 81       	ldd	r24, Y+2	; 0x02
    7768:	80 83       	st	Z, r24
    776a:	09 c0       	rjmp	.+18     	; 0x777e <GPIO_setupPortDirection+0xa4>
			break;
		case PORTE_ID:
			DDRE = direction;
    776c:	e2 e2       	ldi	r30, 0x22	; 34
    776e:	f0 e0       	ldi	r31, 0x00	; 0
    7770:	8a 81       	ldd	r24, Y+2	; 0x02
    7772:	80 83       	st	Z, r24
    7774:	04 c0       	rjmp	.+8      	; 0x777e <GPIO_setupPortDirection+0xa4>
			break;
		case PORTF_ID:
			DDRF = direction;
    7776:	e1 e6       	ldi	r30, 0x61	; 97
    7778:	f0 e0       	ldi	r31, 0x00	; 0
    777a:	8a 81       	ldd	r24, Y+2	; 0x02
    777c:	80 83       	st	Z, r24
			break;
		}
	}
}
    777e:	0f 90       	pop	r0
    7780:	0f 90       	pop	r0
    7782:	0f 90       	pop	r0
    7784:	0f 90       	pop	r0
    7786:	cf 91       	pop	r28
    7788:	df 91       	pop	r29
    778a:	08 95       	ret

0000778c <GPIO_writePort>:
 * If any pin in the port is output pin the value will be written.
 * If any pin in the port is input pin this will activate/deactivate the internal pull-up resistor.
 * If the input port number is not correct, The function will not handle the request.
 */
void GPIO_writePort(uint8 port_num, uint8 value)
{
    778c:	df 93       	push	r29
    778e:	cf 93       	push	r28
    7790:	00 d0       	rcall	.+0      	; 0x7792 <GPIO_writePort+0x6>
    7792:	00 d0       	rcall	.+0      	; 0x7794 <GPIO_writePort+0x8>
    7794:	cd b7       	in	r28, 0x3d	; 61
    7796:	de b7       	in	r29, 0x3e	; 62
    7798:	89 83       	std	Y+1, r24	; 0x01
    779a:	6a 83       	std	Y+2, r22	; 0x02
	/*
	 * Check if the input number is greater than NUM_OF_PORTS value.
	 * In this case the input is not valid port number
	 */
	if(port_num >= NUM_OF_PORTS)
    779c:	89 81       	ldd	r24, Y+1	; 0x01
    779e:	86 30       	cpi	r24, 0x06	; 6
    77a0:	08 f0       	brcs	.+2      	; 0x77a4 <GPIO_writePort+0x18>
    77a2:	46 c0       	rjmp	.+140    	; 0x7830 <GPIO_writePort+0xa4>
		/* Do Nothing */
	}
	else
	{
		/* Write the port value as required */
		switch(port_num)
    77a4:	89 81       	ldd	r24, Y+1	; 0x01
    77a6:	28 2f       	mov	r18, r24
    77a8:	30 e0       	ldi	r19, 0x00	; 0
    77aa:	3c 83       	std	Y+4, r19	; 0x04
    77ac:	2b 83       	std	Y+3, r18	; 0x03
    77ae:	8b 81       	ldd	r24, Y+3	; 0x03
    77b0:	9c 81       	ldd	r25, Y+4	; 0x04
    77b2:	82 30       	cpi	r24, 0x02	; 2
    77b4:	91 05       	cpc	r25, r1
    77b6:	49 f1       	breq	.+82     	; 0x780a <GPIO_writePort+0x7e>
    77b8:	2b 81       	ldd	r18, Y+3	; 0x03
    77ba:	3c 81       	ldd	r19, Y+4	; 0x04
    77bc:	23 30       	cpi	r18, 0x03	; 3
    77be:	31 05       	cpc	r19, r1
    77c0:	54 f4       	brge	.+20     	; 0x77d6 <GPIO_writePort+0x4a>
    77c2:	8b 81       	ldd	r24, Y+3	; 0x03
    77c4:	9c 81       	ldd	r25, Y+4	; 0x04
    77c6:	00 97       	sbiw	r24, 0x00	; 0
    77c8:	b1 f0       	breq	.+44     	; 0x77f6 <GPIO_writePort+0x6a>
    77ca:	2b 81       	ldd	r18, Y+3	; 0x03
    77cc:	3c 81       	ldd	r19, Y+4	; 0x04
    77ce:	21 30       	cpi	r18, 0x01	; 1
    77d0:	31 05       	cpc	r19, r1
    77d2:	b1 f0       	breq	.+44     	; 0x7800 <GPIO_writePort+0x74>
    77d4:	2d c0       	rjmp	.+90     	; 0x7830 <GPIO_writePort+0xa4>
    77d6:	8b 81       	ldd	r24, Y+3	; 0x03
    77d8:	9c 81       	ldd	r25, Y+4	; 0x04
    77da:	84 30       	cpi	r24, 0x04	; 4
    77dc:	91 05       	cpc	r25, r1
    77de:	f9 f0       	breq	.+62     	; 0x781e <GPIO_writePort+0x92>
    77e0:	2b 81       	ldd	r18, Y+3	; 0x03
    77e2:	3c 81       	ldd	r19, Y+4	; 0x04
    77e4:	24 30       	cpi	r18, 0x04	; 4
    77e6:	31 05       	cpc	r19, r1
    77e8:	ac f0       	brlt	.+42     	; 0x7814 <GPIO_writePort+0x88>
    77ea:	8b 81       	ldd	r24, Y+3	; 0x03
    77ec:	9c 81       	ldd	r25, Y+4	; 0x04
    77ee:	85 30       	cpi	r24, 0x05	; 5
    77f0:	91 05       	cpc	r25, r1
    77f2:	d1 f0       	breq	.+52     	; 0x7828 <GPIO_writePort+0x9c>
    77f4:	1d c0       	rjmp	.+58     	; 0x7830 <GPIO_writePort+0xa4>
		{
		case PORTA_ID:
			PORTA = value;
    77f6:	eb e3       	ldi	r30, 0x3B	; 59
    77f8:	f0 e0       	ldi	r31, 0x00	; 0
    77fa:	8a 81       	ldd	r24, Y+2	; 0x02
    77fc:	80 83       	st	Z, r24
    77fe:	18 c0       	rjmp	.+48     	; 0x7830 <GPIO_writePort+0xa4>
			break;
		case PORTB_ID:
			PORTB = value;
    7800:	e8 e3       	ldi	r30, 0x38	; 56
    7802:	f0 e0       	ldi	r31, 0x00	; 0
    7804:	8a 81       	ldd	r24, Y+2	; 0x02
    7806:	80 83       	st	Z, r24
    7808:	13 c0       	rjmp	.+38     	; 0x7830 <GPIO_writePort+0xa4>
			break;
		case PORTC_ID:
			PORTC = value;
    780a:	e5 e3       	ldi	r30, 0x35	; 53
    780c:	f0 e0       	ldi	r31, 0x00	; 0
    780e:	8a 81       	ldd	r24, Y+2	; 0x02
    7810:	80 83       	st	Z, r24
    7812:	0e c0       	rjmp	.+28     	; 0x7830 <GPIO_writePort+0xa4>
			break;
		case PORTD_ID:
			PORTD = value;
    7814:	e2 e3       	ldi	r30, 0x32	; 50
    7816:	f0 e0       	ldi	r31, 0x00	; 0
    7818:	8a 81       	ldd	r24, Y+2	; 0x02
    781a:	80 83       	st	Z, r24
    781c:	09 c0       	rjmp	.+18     	; 0x7830 <GPIO_writePort+0xa4>
			break;
		case PORTE_ID:
			PORTE = value;
    781e:	e3 e2       	ldi	r30, 0x23	; 35
    7820:	f0 e0       	ldi	r31, 0x00	; 0
    7822:	8a 81       	ldd	r24, Y+2	; 0x02
    7824:	80 83       	st	Z, r24
    7826:	04 c0       	rjmp	.+8      	; 0x7830 <GPIO_writePort+0xa4>
			break;
		case PORTF_ID:
			PORTF = value;
    7828:	e2 e6       	ldi	r30, 0x62	; 98
    782a:	f0 e0       	ldi	r31, 0x00	; 0
    782c:	8a 81       	ldd	r24, Y+2	; 0x02
    782e:	80 83       	st	Z, r24
			break;
		}
	}
}
    7830:	0f 90       	pop	r0
    7832:	0f 90       	pop	r0
    7834:	0f 90       	pop	r0
    7836:	0f 90       	pop	r0
    7838:	cf 91       	pop	r28
    783a:	df 91       	pop	r29
    783c:	08 95       	ret

0000783e <GPIO_readPort>:
 * Description :
 * Read and return the value of the required port.
 * If the input port number is not correct, The function will return ZERO value.
 */
uint8 GPIO_readPort(uint8 port_num)
{
    783e:	df 93       	push	r29
    7840:	cf 93       	push	r28
    7842:	00 d0       	rcall	.+0      	; 0x7844 <GPIO_readPort+0x6>
    7844:	00 d0       	rcall	.+0      	; 0x7846 <GPIO_readPort+0x8>
    7846:	cd b7       	in	r28, 0x3d	; 61
    7848:	de b7       	in	r29, 0x3e	; 62
    784a:	8a 83       	std	Y+2, r24	; 0x02
	uint8 value = LOGIC_LOW;
    784c:	19 82       	std	Y+1, r1	; 0x01

	/*
	 * Check if the input number is greater than NUM_OF_PORTS value.
	 * In this case the input is not valid port number
	 */
	if(port_num >= NUM_OF_PORTS)
    784e:	8a 81       	ldd	r24, Y+2	; 0x02
    7850:	86 30       	cpi	r24, 0x06	; 6
    7852:	08 f0       	brcs	.+2      	; 0x7856 <GPIO_readPort+0x18>
    7854:	46 c0       	rjmp	.+140    	; 0x78e2 <GPIO_readPort+0xa4>
		/* Do Nothing */
	}
	else
	{
		/* Read the port value as required */
		switch(port_num)
    7856:	8a 81       	ldd	r24, Y+2	; 0x02
    7858:	28 2f       	mov	r18, r24
    785a:	30 e0       	ldi	r19, 0x00	; 0
    785c:	3c 83       	std	Y+4, r19	; 0x04
    785e:	2b 83       	std	Y+3, r18	; 0x03
    7860:	8b 81       	ldd	r24, Y+3	; 0x03
    7862:	9c 81       	ldd	r25, Y+4	; 0x04
    7864:	82 30       	cpi	r24, 0x02	; 2
    7866:	91 05       	cpc	r25, r1
    7868:	49 f1       	breq	.+82     	; 0x78bc <GPIO_readPort+0x7e>
    786a:	2b 81       	ldd	r18, Y+3	; 0x03
    786c:	3c 81       	ldd	r19, Y+4	; 0x04
    786e:	23 30       	cpi	r18, 0x03	; 3
    7870:	31 05       	cpc	r19, r1
    7872:	54 f4       	brge	.+20     	; 0x7888 <GPIO_readPort+0x4a>
    7874:	8b 81       	ldd	r24, Y+3	; 0x03
    7876:	9c 81       	ldd	r25, Y+4	; 0x04
    7878:	00 97       	sbiw	r24, 0x00	; 0
    787a:	b1 f0       	breq	.+44     	; 0x78a8 <GPIO_readPort+0x6a>
    787c:	2b 81       	ldd	r18, Y+3	; 0x03
    787e:	3c 81       	ldd	r19, Y+4	; 0x04
    7880:	21 30       	cpi	r18, 0x01	; 1
    7882:	31 05       	cpc	r19, r1
    7884:	b1 f0       	breq	.+44     	; 0x78b2 <GPIO_readPort+0x74>
    7886:	2d c0       	rjmp	.+90     	; 0x78e2 <GPIO_readPort+0xa4>
    7888:	8b 81       	ldd	r24, Y+3	; 0x03
    788a:	9c 81       	ldd	r25, Y+4	; 0x04
    788c:	84 30       	cpi	r24, 0x04	; 4
    788e:	91 05       	cpc	r25, r1
    7890:	f9 f0       	breq	.+62     	; 0x78d0 <GPIO_readPort+0x92>
    7892:	2b 81       	ldd	r18, Y+3	; 0x03
    7894:	3c 81       	ldd	r19, Y+4	; 0x04
    7896:	24 30       	cpi	r18, 0x04	; 4
    7898:	31 05       	cpc	r19, r1
    789a:	ac f0       	brlt	.+42     	; 0x78c6 <GPIO_readPort+0x88>
    789c:	8b 81       	ldd	r24, Y+3	; 0x03
    789e:	9c 81       	ldd	r25, Y+4	; 0x04
    78a0:	85 30       	cpi	r24, 0x05	; 5
    78a2:	91 05       	cpc	r25, r1
    78a4:	d1 f0       	breq	.+52     	; 0x78da <GPIO_readPort+0x9c>
    78a6:	1d c0       	rjmp	.+58     	; 0x78e2 <GPIO_readPort+0xa4>
		{
		case PORTA_ID:
			value = PINA;
    78a8:	e9 e3       	ldi	r30, 0x39	; 57
    78aa:	f0 e0       	ldi	r31, 0x00	; 0
    78ac:	80 81       	ld	r24, Z
    78ae:	89 83       	std	Y+1, r24	; 0x01
    78b0:	18 c0       	rjmp	.+48     	; 0x78e2 <GPIO_readPort+0xa4>
			break;
		case PORTB_ID:
			value = PINB;
    78b2:	e6 e3       	ldi	r30, 0x36	; 54
    78b4:	f0 e0       	ldi	r31, 0x00	; 0
    78b6:	80 81       	ld	r24, Z
    78b8:	89 83       	std	Y+1, r24	; 0x01
    78ba:	13 c0       	rjmp	.+38     	; 0x78e2 <GPIO_readPort+0xa4>
			break;
		case PORTC_ID:
			value = PINC;
    78bc:	e3 e3       	ldi	r30, 0x33	; 51
    78be:	f0 e0       	ldi	r31, 0x00	; 0
    78c0:	80 81       	ld	r24, Z
    78c2:	89 83       	std	Y+1, r24	; 0x01
    78c4:	0e c0       	rjmp	.+28     	; 0x78e2 <GPIO_readPort+0xa4>
			break;
		case PORTD_ID:
			value = PIND;
    78c6:	e0 e3       	ldi	r30, 0x30	; 48
    78c8:	f0 e0       	ldi	r31, 0x00	; 0
    78ca:	80 81       	ld	r24, Z
    78cc:	89 83       	std	Y+1, r24	; 0x01
    78ce:	09 c0       	rjmp	.+18     	; 0x78e2 <GPIO_readPort+0xa4>
			break;
		case PORTE_ID:
			value = PINE;
    78d0:	e1 e2       	ldi	r30, 0x21	; 33
    78d2:	f0 e0       	ldi	r31, 0x00	; 0
    78d4:	80 81       	ld	r24, Z
    78d6:	89 83       	std	Y+1, r24	; 0x01
    78d8:	04 c0       	rjmp	.+8      	; 0x78e2 <GPIO_readPort+0xa4>
			break;
		case PORTF_ID:
			value = PINF;
    78da:	e0 e2       	ldi	r30, 0x20	; 32
    78dc:	f0 e0       	ldi	r31, 0x00	; 0
    78de:	80 81       	ld	r24, Z
    78e0:	89 83       	std	Y+1, r24	; 0x01
			break;
		}
	}

	return value;
    78e2:	89 81       	ldd	r24, Y+1	; 0x01
}
    78e4:	0f 90       	pop	r0
    78e6:	0f 90       	pop	r0
    78e8:	0f 90       	pop	r0
    78ea:	0f 90       	pop	r0
    78ec:	cf 91       	pop	r28
    78ee:	df 91       	pop	r29
    78f0:	08 95       	ret

000078f2 <DIO_init>:


void DIO_init(void)
{
    78f2:	df 93       	push	r29
    78f4:	cf 93       	push	r28
    78f6:	00 d0       	rcall	.+0      	; 0x78f8 <DIO_init+0x6>
    78f8:	00 d0       	rcall	.+0      	; 0x78fa <DIO_init+0x8>
    78fa:	cd b7       	in	r28, 0x3d	; 61
    78fc:	de b7       	in	r29, 0x3e	; 62
	uint8_t loop;
	for(loop=0u; loop < DIO_NUM_OF_CHANNELS ; loop++ ){
    78fe:	1c 82       	std	Y+4, r1	; 0x04
    7900:	2f c0       	rjmp	.+94     	; 0x7960 <DIO_init+0x6e>
		uint8_t portid=dio_config_array[loop].port_id;
    7902:	8c 81       	ldd	r24, Y+4	; 0x04
    7904:	28 2f       	mov	r18, r24
    7906:	30 e0       	ldi	r19, 0x00	; 0
    7908:	c9 01       	movw	r24, r18
    790a:	88 0f       	add	r24, r24
    790c:	99 1f       	adc	r25, r25
    790e:	82 0f       	add	r24, r18
    7910:	93 1f       	adc	r25, r19
    7912:	fc 01       	movw	r30, r24
    7914:	e3 5c       	subi	r30, 0xC3	; 195
    7916:	fd 4f       	sbci	r31, 0xFD	; 253
    7918:	80 81       	ld	r24, Z
    791a:	8b 83       	std	Y+3, r24	; 0x03
		uint8_t pin_num=dio_config_array[loop].pin_num;
    791c:	8c 81       	ldd	r24, Y+4	; 0x04
    791e:	28 2f       	mov	r18, r24
    7920:	30 e0       	ldi	r19, 0x00	; 0
    7922:	c9 01       	movw	r24, r18
    7924:	88 0f       	add	r24, r24
    7926:	99 1f       	adc	r25, r25
    7928:	82 0f       	add	r24, r18
    792a:	93 1f       	adc	r25, r19
    792c:	fc 01       	movw	r30, r24
    792e:	e2 5c       	subi	r30, 0xC2	; 194
    7930:	fd 4f       	sbci	r31, 0xFD	; 253
    7932:	80 81       	ld	r24, Z
    7934:	8a 83       	std	Y+2, r24	; 0x02
		uint8_t direction=dio_config_array[loop].direction;
    7936:	8c 81       	ldd	r24, Y+4	; 0x04
    7938:	28 2f       	mov	r18, r24
    793a:	30 e0       	ldi	r19, 0x00	; 0
    793c:	c9 01       	movw	r24, r18
    793e:	88 0f       	add	r24, r24
    7940:	99 1f       	adc	r25, r25
    7942:	82 0f       	add	r24, r18
    7944:	93 1f       	adc	r25, r19
    7946:	fc 01       	movw	r30, r24
    7948:	e1 5c       	subi	r30, 0xC1	; 193
    794a:	fd 4f       	sbci	r31, 0xFD	; 253
    794c:	80 81       	ld	r24, Z
    794e:	89 83       	std	Y+1, r24	; 0x01
		GPIO_setupPinDirection(portid,pin_num,direction);
    7950:	8b 81       	ldd	r24, Y+3	; 0x03
    7952:	6a 81       	ldd	r22, Y+2	; 0x02
    7954:	49 81       	ldd	r20, Y+1	; 0x01
    7956:	0e 94 f7 37 	call	0x6fee	; 0x6fee <GPIO_setupPinDirection>


void DIO_init(void)
{
	uint8_t loop;
	for(loop=0u; loop < DIO_NUM_OF_CHANNELS ; loop++ ){
    795a:	8c 81       	ldd	r24, Y+4	; 0x04
    795c:	8f 5f       	subi	r24, 0xFF	; 255
    795e:	8c 83       	std	Y+4, r24	; 0x04
    7960:	8c 81       	ldd	r24, Y+4	; 0x04
    7962:	86 30       	cpi	r24, 0x06	; 6
    7964:	70 f2       	brcs	.-100    	; 0x7902 <DIO_init+0x10>
		uint8_t portid=dio_config_array[loop].port_id;
		uint8_t pin_num=dio_config_array[loop].pin_num;
		uint8_t direction=dio_config_array[loop].direction;
		GPIO_setupPinDirection(portid,pin_num,direction);
	}
}
    7966:	0f 90       	pop	r0
    7968:	0f 90       	pop	r0
    796a:	0f 90       	pop	r0
    796c:	0f 90       	pop	r0
    796e:	cf 91       	pop	r28
    7970:	df 91       	pop	r29
    7972:	08 95       	ret

00007974 <DIO_ChannelGroupWrite>:


void DIO_ChannelGroupWrite(ChannelGroupType channel_group_variabe , uint8_t data)
{
    7974:	af 92       	push	r10
    7976:	cf 92       	push	r12
    7978:	df 92       	push	r13
    797a:	ef 92       	push	r14
    797c:	ff 92       	push	r15
    797e:	0f 93       	push	r16
    7980:	1f 93       	push	r17
    7982:	df 93       	push	r29
    7984:	cf 93       	push	r28
    7986:	cd b7       	in	r28, 0x3d	; 61
    7988:	de b7       	in	r29, 0x3e	; 62
    798a:	65 97       	sbiw	r28, 0x15	; 21
    798c:	0f b6       	in	r0, 0x3f	; 63
    798e:	f8 94       	cli
    7990:	de bf       	out	0x3e, r29	; 62
    7992:	0f be       	out	0x3f, r0	; 63
    7994:	cd bf       	out	0x3d, r28	; 61
    7996:	cf 82       	std	Y+7, r12	; 0x07
    7998:	d8 86       	std	Y+8, r13	; 0x08
    799a:	e9 86       	std	Y+9, r14	; 0x09
    799c:	fa 86       	std	Y+10, r15	; 0x0a
    799e:	0b 87       	std	Y+11, r16	; 0x0b
    79a0:	1c 87       	std	Y+12, r17	; 0x0c
    79a2:	2d 87       	std	Y+13, r18	; 0x0d
    79a4:	3e 87       	std	Y+14, r19	; 0x0e
    79a6:	4f 87       	std	Y+15, r20	; 0x0f
    79a8:	58 8b       	std	Y+16, r21	; 0x10
    79aa:	69 8b       	std	Y+17, r22	; 0x11
    79ac:	7a 8b       	std	Y+18, r23	; 0x12
    79ae:	8b 8b       	std	Y+19, r24	; 0x13
    79b0:	9c 8b       	std	Y+20, r25	; 0x14
    79b2:	ad 8a       	std	Y+21, r10	; 0x15
	uint8_t loop;
	uint8_t to=channel_group_variabe.no_of_channels;
    79b4:	8f 81       	ldd	r24, Y+7	; 0x07
    79b6:	98 85       	ldd	r25, Y+8	; 0x08
    79b8:	8d 83       	std	Y+5, r24	; 0x05

	for(loop=0u; loop <to ; loop++ ){
    79ba:	1e 82       	std	Y+6, r1	; 0x06
    79bc:	4c c0       	rjmp	.+152    	; 0x7a56 <DIO_ChannelGroupWrite+0xe2>
		uint8_t channel_id=channel_group_variabe.group_ids[loop];
    79be:	8e 81       	ldd	r24, Y+6	; 0x06
    79c0:	88 2f       	mov	r24, r24
    79c2:	90 e0       	ldi	r25, 0x00	; 0
    79c4:	01 96       	adiw	r24, 0x01	; 1
    79c6:	9c 01       	movw	r18, r24
    79c8:	22 0f       	add	r18, r18
    79ca:	33 1f       	adc	r19, r19
    79cc:	ce 01       	movw	r24, r28
    79ce:	01 96       	adiw	r24, 0x01	; 1
    79d0:	82 0f       	add	r24, r18
    79d2:	93 1f       	adc	r25, r19
    79d4:	fc 01       	movw	r30, r24
    79d6:	36 96       	adiw	r30, 0x06	; 6
    79d8:	80 81       	ld	r24, Z
    79da:	91 81       	ldd	r25, Z+1	; 0x01
    79dc:	8c 83       	std	Y+4, r24	; 0x04
		uint8_t portid=dio_config_array[channel_id].port_id;
    79de:	8c 81       	ldd	r24, Y+4	; 0x04
    79e0:	28 2f       	mov	r18, r24
    79e2:	30 e0       	ldi	r19, 0x00	; 0
    79e4:	c9 01       	movw	r24, r18
    79e6:	88 0f       	add	r24, r24
    79e8:	99 1f       	adc	r25, r25
    79ea:	82 0f       	add	r24, r18
    79ec:	93 1f       	adc	r25, r19
    79ee:	fc 01       	movw	r30, r24
    79f0:	e3 5c       	subi	r30, 0xC3	; 195
    79f2:	fd 4f       	sbci	r31, 0xFD	; 253
    79f4:	80 81       	ld	r24, Z
    79f6:	8b 83       	std	Y+3, r24	; 0x03
		uint8_t pin_num=dio_config_array[channel_id].pin_num;
    79f8:	8c 81       	ldd	r24, Y+4	; 0x04
    79fa:	28 2f       	mov	r18, r24
    79fc:	30 e0       	ldi	r19, 0x00	; 0
    79fe:	c9 01       	movw	r24, r18
    7a00:	88 0f       	add	r24, r24
    7a02:	99 1f       	adc	r25, r25
    7a04:	82 0f       	add	r24, r18
    7a06:	93 1f       	adc	r25, r19
    7a08:	fc 01       	movw	r30, r24
    7a0a:	e2 5c       	subi	r30, 0xC2	; 194
    7a0c:	fd 4f       	sbci	r31, 0xFD	; 253
    7a0e:	80 81       	ld	r24, Z
    7a10:	8a 83       	std	Y+2, r24	; 0x02
		uint8_t bit_data=READ_BIT(data,loop);
    7a12:	8e 81       	ldd	r24, Y+6	; 0x06
    7a14:	28 2f       	mov	r18, r24
    7a16:	30 e0       	ldi	r19, 0x00	; 0
    7a18:	81 e0       	ldi	r24, 0x01	; 1
    7a1a:	90 e0       	ldi	r25, 0x00	; 0
    7a1c:	02 c0       	rjmp	.+4      	; 0x7a22 <DIO_ChannelGroupWrite+0xae>
    7a1e:	88 0f       	add	r24, r24
    7a20:	99 1f       	adc	r25, r25
    7a22:	2a 95       	dec	r18
    7a24:	e2 f7       	brpl	.-8      	; 0x7a1e <DIO_ChannelGroupWrite+0xaa>
    7a26:	98 2f       	mov	r25, r24
    7a28:	8d 89       	ldd	r24, Y+21	; 0x15
    7a2a:	89 23       	and	r24, r25
    7a2c:	28 2f       	mov	r18, r24
    7a2e:	30 e0       	ldi	r19, 0x00	; 0
    7a30:	8e 81       	ldd	r24, Y+6	; 0x06
    7a32:	88 2f       	mov	r24, r24
    7a34:	90 e0       	ldi	r25, 0x00	; 0
    7a36:	a9 01       	movw	r20, r18
    7a38:	02 c0       	rjmp	.+4      	; 0x7a3e <DIO_ChannelGroupWrite+0xca>
    7a3a:	55 95       	asr	r21
    7a3c:	47 95       	ror	r20
    7a3e:	8a 95       	dec	r24
    7a40:	e2 f7       	brpl	.-8      	; 0x7a3a <DIO_ChannelGroupWrite+0xc6>
    7a42:	ca 01       	movw	r24, r20
    7a44:	89 83       	std	Y+1, r24	; 0x01
		GPIO_writePin(portid,pin_num,bit_data);
    7a46:	8b 81       	ldd	r24, Y+3	; 0x03
    7a48:	6a 81       	ldd	r22, Y+2	; 0x02
    7a4a:	49 81       	ldd	r20, Y+1	; 0x01
    7a4c:	0e 94 46 39 	call	0x728c	; 0x728c <GPIO_writePin>
void DIO_ChannelGroupWrite(ChannelGroupType channel_group_variabe , uint8_t data)
{
	uint8_t loop;
	uint8_t to=channel_group_variabe.no_of_channels;

	for(loop=0u; loop <to ; loop++ ){
    7a50:	8e 81       	ldd	r24, Y+6	; 0x06
    7a52:	8f 5f       	subi	r24, 0xFF	; 255
    7a54:	8e 83       	std	Y+6, r24	; 0x06
    7a56:	9e 81       	ldd	r25, Y+6	; 0x06
    7a58:	8d 81       	ldd	r24, Y+5	; 0x05
    7a5a:	98 17       	cp	r25, r24
    7a5c:	08 f4       	brcc	.+2      	; 0x7a60 <DIO_ChannelGroupWrite+0xec>
    7a5e:	af cf       	rjmp	.-162    	; 0x79be <DIO_ChannelGroupWrite+0x4a>
		GPIO_writePin(portid,pin_num,bit_data);

	}


}
    7a60:	65 96       	adiw	r28, 0x15	; 21
    7a62:	0f b6       	in	r0, 0x3f	; 63
    7a64:	f8 94       	cli
    7a66:	de bf       	out	0x3e, r29	; 62
    7a68:	0f be       	out	0x3f, r0	; 63
    7a6a:	cd bf       	out	0x3d, r28	; 61
    7a6c:	cf 91       	pop	r28
    7a6e:	df 91       	pop	r29
    7a70:	1f 91       	pop	r17
    7a72:	0f 91       	pop	r16
    7a74:	ff 90       	pop	r15
    7a76:	ef 90       	pop	r14
    7a78:	df 90       	pop	r13
    7a7a:	cf 90       	pop	r12
    7a7c:	af 90       	pop	r10
    7a7e:	08 95       	ret

00007a80 <DIO_ChannelGroupRead>:


void DIO_ChannelGroupRead(ChannelGroupType channel_group_variabe ,uint8_t * data_ptr)
{
    7a80:	af 92       	push	r10
    7a82:	bf 92       	push	r11
    7a84:	cf 92       	push	r12
    7a86:	df 92       	push	r13
    7a88:	ef 92       	push	r14
    7a8a:	ff 92       	push	r15
    7a8c:	0f 93       	push	r16
    7a8e:	1f 93       	push	r17
    7a90:	df 93       	push	r29
    7a92:	cf 93       	push	r28
    7a94:	cd b7       	in	r28, 0x3d	; 61
    7a96:	de b7       	in	r29, 0x3e	; 62
    7a98:	66 97       	sbiw	r28, 0x16	; 22
    7a9a:	0f b6       	in	r0, 0x3f	; 63
    7a9c:	f8 94       	cli
    7a9e:	de bf       	out	0x3e, r29	; 62
    7aa0:	0f be       	out	0x3f, r0	; 63
    7aa2:	cd bf       	out	0x3d, r28	; 61
    7aa4:	cf 82       	std	Y+7, r12	; 0x07
    7aa6:	d8 86       	std	Y+8, r13	; 0x08
    7aa8:	e9 86       	std	Y+9, r14	; 0x09
    7aaa:	fa 86       	std	Y+10, r15	; 0x0a
    7aac:	0b 87       	std	Y+11, r16	; 0x0b
    7aae:	1c 87       	std	Y+12, r17	; 0x0c
    7ab0:	2d 87       	std	Y+13, r18	; 0x0d
    7ab2:	3e 87       	std	Y+14, r19	; 0x0e
    7ab4:	4f 87       	std	Y+15, r20	; 0x0f
    7ab6:	58 8b       	std	Y+16, r21	; 0x10
    7ab8:	69 8b       	std	Y+17, r22	; 0x11
    7aba:	7a 8b       	std	Y+18, r23	; 0x12
    7abc:	8b 8b       	std	Y+19, r24	; 0x13
    7abe:	9c 8b       	std	Y+20, r25	; 0x14
    7ac0:	be 8a       	std	Y+22, r11	; 0x16
    7ac2:	ad 8a       	std	Y+21, r10	; 0x15

	uint8_t loop;
	uint8_t to=channel_group_variabe.no_of_channels;
    7ac4:	8f 81       	ldd	r24, Y+7	; 0x07
    7ac6:	98 85       	ldd	r25, Y+8	; 0x08
    7ac8:	8d 83       	std	Y+5, r24	; 0x05

	for(loop=0u; loop <to ; loop++ ){
    7aca:	1e 82       	std	Y+6, r1	; 0x06
    7acc:	5d c0       	rjmp	.+186    	; 0x7b88 <DIO_ChannelGroupRead+0x108>
		uint8_t channel_id=channel_group_variabe.group_ids[loop];
    7ace:	8e 81       	ldd	r24, Y+6	; 0x06
    7ad0:	88 2f       	mov	r24, r24
    7ad2:	90 e0       	ldi	r25, 0x00	; 0
    7ad4:	01 96       	adiw	r24, 0x01	; 1
    7ad6:	9c 01       	movw	r18, r24
    7ad8:	22 0f       	add	r18, r18
    7ada:	33 1f       	adc	r19, r19
    7adc:	ce 01       	movw	r24, r28
    7ade:	01 96       	adiw	r24, 0x01	; 1
    7ae0:	82 0f       	add	r24, r18
    7ae2:	93 1f       	adc	r25, r19
    7ae4:	fc 01       	movw	r30, r24
    7ae6:	36 96       	adiw	r30, 0x06	; 6
    7ae8:	80 81       	ld	r24, Z
    7aea:	91 81       	ldd	r25, Z+1	; 0x01
    7aec:	8c 83       	std	Y+4, r24	; 0x04
		uint8_t portid=dio_config_array[channel_id].port_id;
    7aee:	8c 81       	ldd	r24, Y+4	; 0x04
    7af0:	28 2f       	mov	r18, r24
    7af2:	30 e0       	ldi	r19, 0x00	; 0
    7af4:	c9 01       	movw	r24, r18
    7af6:	88 0f       	add	r24, r24
    7af8:	99 1f       	adc	r25, r25
    7afa:	82 0f       	add	r24, r18
    7afc:	93 1f       	adc	r25, r19
    7afe:	fc 01       	movw	r30, r24
    7b00:	e3 5c       	subi	r30, 0xC3	; 195
    7b02:	fd 4f       	sbci	r31, 0xFD	; 253
    7b04:	80 81       	ld	r24, Z
    7b06:	8b 83       	std	Y+3, r24	; 0x03
		uint8_t pin_num=dio_config_array[channel_id].pin_num;
    7b08:	8c 81       	ldd	r24, Y+4	; 0x04
    7b0a:	28 2f       	mov	r18, r24
    7b0c:	30 e0       	ldi	r19, 0x00	; 0
    7b0e:	c9 01       	movw	r24, r18
    7b10:	88 0f       	add	r24, r24
    7b12:	99 1f       	adc	r25, r25
    7b14:	82 0f       	add	r24, r18
    7b16:	93 1f       	adc	r25, r19
    7b18:	fc 01       	movw	r30, r24
    7b1a:	e2 5c       	subi	r30, 0xC2	; 194
    7b1c:	fd 4f       	sbci	r31, 0xFD	; 253
    7b1e:	80 81       	ld	r24, Z
    7b20:	8a 83       	std	Y+2, r24	; 0x02
		uint8_t data = GPIO_readPin(portid, pin_num);
    7b22:	8b 81       	ldd	r24, Y+3	; 0x03
    7b24:	6a 81       	ldd	r22, Y+2	; 0x02
    7b26:	0e 94 95 3a 	call	0x752a	; 0x752a <GPIO_readPin>
    7b2a:	89 83       	std	Y+1, r24	; 0x01
		if(data == LOGIC_HIGH){
    7b2c:	89 81       	ldd	r24, Y+1	; 0x01
    7b2e:	81 30       	cpi	r24, 0x01	; 1
    7b30:	a1 f4       	brne	.+40     	; 0x7b5a <DIO_ChannelGroupRead+0xda>
			SET_BIT(* data_ptr,loop);
    7b32:	ed 89       	ldd	r30, Y+21	; 0x15
    7b34:	fe 89       	ldd	r31, Y+22	; 0x16
    7b36:	80 81       	ld	r24, Z
    7b38:	48 2f       	mov	r20, r24
    7b3a:	8e 81       	ldd	r24, Y+6	; 0x06
    7b3c:	28 2f       	mov	r18, r24
    7b3e:	30 e0       	ldi	r19, 0x00	; 0
    7b40:	81 e0       	ldi	r24, 0x01	; 1
    7b42:	90 e0       	ldi	r25, 0x00	; 0
    7b44:	02 2e       	mov	r0, r18
    7b46:	02 c0       	rjmp	.+4      	; 0x7b4c <DIO_ChannelGroupRead+0xcc>
    7b48:	88 0f       	add	r24, r24
    7b4a:	99 1f       	adc	r25, r25
    7b4c:	0a 94       	dec	r0
    7b4e:	e2 f7       	brpl	.-8      	; 0x7b48 <DIO_ChannelGroupRead+0xc8>
    7b50:	84 2b       	or	r24, r20
    7b52:	ed 89       	ldd	r30, Y+21	; 0x15
    7b54:	fe 89       	ldd	r31, Y+22	; 0x16
    7b56:	80 83       	st	Z, r24
    7b58:	14 c0       	rjmp	.+40     	; 0x7b82 <DIO_ChannelGroupRead+0x102>
		}else{
			CLEAR_BIT(* data_ptr,loop);
    7b5a:	ed 89       	ldd	r30, Y+21	; 0x15
    7b5c:	fe 89       	ldd	r31, Y+22	; 0x16
    7b5e:	80 81       	ld	r24, Z
    7b60:	48 2f       	mov	r20, r24
    7b62:	8e 81       	ldd	r24, Y+6	; 0x06
    7b64:	28 2f       	mov	r18, r24
    7b66:	30 e0       	ldi	r19, 0x00	; 0
    7b68:	81 e0       	ldi	r24, 0x01	; 1
    7b6a:	90 e0       	ldi	r25, 0x00	; 0
    7b6c:	02 2e       	mov	r0, r18
    7b6e:	02 c0       	rjmp	.+4      	; 0x7b74 <DIO_ChannelGroupRead+0xf4>
    7b70:	88 0f       	add	r24, r24
    7b72:	99 1f       	adc	r25, r25
    7b74:	0a 94       	dec	r0
    7b76:	e2 f7       	brpl	.-8      	; 0x7b70 <DIO_ChannelGroupRead+0xf0>
    7b78:	80 95       	com	r24
    7b7a:	84 23       	and	r24, r20
    7b7c:	ed 89       	ldd	r30, Y+21	; 0x15
    7b7e:	fe 89       	ldd	r31, Y+22	; 0x16
    7b80:	80 83       	st	Z, r24
{

	uint8_t loop;
	uint8_t to=channel_group_variabe.no_of_channels;

	for(loop=0u; loop <to ; loop++ ){
    7b82:	8e 81       	ldd	r24, Y+6	; 0x06
    7b84:	8f 5f       	subi	r24, 0xFF	; 255
    7b86:	8e 83       	std	Y+6, r24	; 0x06
    7b88:	9e 81       	ldd	r25, Y+6	; 0x06
    7b8a:	8d 81       	ldd	r24, Y+5	; 0x05
    7b8c:	98 17       	cp	r25, r24
    7b8e:	08 f4       	brcc	.+2      	; 0x7b92 <DIO_ChannelGroupRead+0x112>
    7b90:	9e cf       	rjmp	.-196    	; 0x7ace <DIO_ChannelGroupRead+0x4e>
		}else{
			CLEAR_BIT(* data_ptr,loop);
		}
	}

}
    7b92:	66 96       	adiw	r28, 0x16	; 22
    7b94:	0f b6       	in	r0, 0x3f	; 63
    7b96:	f8 94       	cli
    7b98:	de bf       	out	0x3e, r29	; 62
    7b9a:	0f be       	out	0x3f, r0	; 63
    7b9c:	cd bf       	out	0x3d, r28	; 61
    7b9e:	cf 91       	pop	r28
    7ba0:	df 91       	pop	r29
    7ba2:	1f 91       	pop	r17
    7ba4:	0f 91       	pop	r16
    7ba6:	ff 90       	pop	r15
    7ba8:	ef 90       	pop	r14
    7baa:	df 90       	pop	r13
    7bac:	cf 90       	pop	r12
    7bae:	bf 90       	pop	r11
    7bb0:	af 90       	pop	r10
    7bb2:	08 95       	ret

00007bb4 <LCD_init>:
 * Initialize the LCD:
 * 1. Setup the LCD pins directions by use the GPIO driver.
 * 2. Setup the LCD Data Mode 4-bits or 8-bits.
 */
void LCD_init(void)
{
    7bb4:	df 93       	push	r29
    7bb6:	cf 93       	push	r28
    7bb8:	cd b7       	in	r28, 0x3d	; 61
    7bba:	de b7       	in	r29, 0x3e	; 62
    7bbc:	2e 97       	sbiw	r28, 0x0e	; 14
    7bbe:	0f b6       	in	r0, 0x3f	; 63
    7bc0:	f8 94       	cli
    7bc2:	de bf       	out	0x3e, r29	; 62
    7bc4:	0f be       	out	0x3f, r0	; 63
    7bc6:	cd bf       	out	0x3d, r28	; 61
	/* Configure the direction for RS and E pins as output pins */
	GPIO_setupPinDirection(LCD_RS_PORT_ID,LCD_RS_PIN_ID,PIN_OUTPUT);
    7bc8:	83 e0       	ldi	r24, 0x03	; 3
    7bca:	60 e0       	ldi	r22, 0x00	; 0
    7bcc:	41 e0       	ldi	r20, 0x01	; 1
    7bce:	0e 94 f7 37 	call	0x6fee	; 0x6fee <GPIO_setupPinDirection>
	GPIO_setupPinDirection(LCD_E_PORT_ID,LCD_E_PIN_ID,PIN_OUTPUT);
    7bd2:	83 e0       	ldi	r24, 0x03	; 3
    7bd4:	62 e0       	ldi	r22, 0x02	; 2
    7bd6:	41 e0       	ldi	r20, 0x01	; 1
    7bd8:	0e 94 f7 37 	call	0x6fee	; 0x6fee <GPIO_setupPinDirection>
    7bdc:	80 e0       	ldi	r24, 0x00	; 0
    7bde:	90 e0       	ldi	r25, 0x00	; 0
    7be0:	a0 ea       	ldi	r26, 0xA0	; 160
    7be2:	b1 e4       	ldi	r27, 0x41	; 65
    7be4:	8b 87       	std	Y+11, r24	; 0x0b
    7be6:	9c 87       	std	Y+12, r25	; 0x0c
    7be8:	ad 87       	std	Y+13, r26	; 0x0d
    7bea:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    7bec:	6b 85       	ldd	r22, Y+11	; 0x0b
    7bee:	7c 85       	ldd	r23, Y+12	; 0x0c
    7bf0:	8d 85       	ldd	r24, Y+13	; 0x0d
    7bf2:	9e 85       	ldd	r25, Y+14	; 0x0e
    7bf4:	20 e0       	ldi	r18, 0x00	; 0
    7bf6:	30 e0       	ldi	r19, 0x00	; 0
    7bf8:	4a e7       	ldi	r20, 0x7A	; 122
    7bfa:	55 e4       	ldi	r21, 0x45	; 69
    7bfc:	0e 94 3b 02 	call	0x476	; 0x476 <__mulsf3>
    7c00:	dc 01       	movw	r26, r24
    7c02:	cb 01       	movw	r24, r22
    7c04:	8f 83       	std	Y+7, r24	; 0x07
    7c06:	98 87       	std	Y+8, r25	; 0x08
    7c08:	a9 87       	std	Y+9, r26	; 0x09
    7c0a:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    7c0c:	6f 81       	ldd	r22, Y+7	; 0x07
    7c0e:	78 85       	ldd	r23, Y+8	; 0x08
    7c10:	89 85       	ldd	r24, Y+9	; 0x09
    7c12:	9a 85       	ldd	r25, Y+10	; 0x0a
    7c14:	20 e0       	ldi	r18, 0x00	; 0
    7c16:	30 e0       	ldi	r19, 0x00	; 0
    7c18:	40 e8       	ldi	r20, 0x80	; 128
    7c1a:	5f e3       	ldi	r21, 0x3F	; 63
    7c1c:	0e 94 41 04 	call	0x882	; 0x882 <__ltsf2>
    7c20:	88 23       	and	r24, r24
    7c22:	2c f4       	brge	.+10     	; 0x7c2e <LCD_init+0x7a>
		__ticks = 1;
    7c24:	81 e0       	ldi	r24, 0x01	; 1
    7c26:	90 e0       	ldi	r25, 0x00	; 0
    7c28:	9e 83       	std	Y+6, r25	; 0x06
    7c2a:	8d 83       	std	Y+5, r24	; 0x05
    7c2c:	3f c0       	rjmp	.+126    	; 0x7cac <LCD_init+0xf8>
	else if (__tmp > 65535)
    7c2e:	6f 81       	ldd	r22, Y+7	; 0x07
    7c30:	78 85       	ldd	r23, Y+8	; 0x08
    7c32:	89 85       	ldd	r24, Y+9	; 0x09
    7c34:	9a 85       	ldd	r25, Y+10	; 0x0a
    7c36:	20 e0       	ldi	r18, 0x00	; 0
    7c38:	3f ef       	ldi	r19, 0xFF	; 255
    7c3a:	4f e7       	ldi	r20, 0x7F	; 127
    7c3c:	57 e4       	ldi	r21, 0x47	; 71
    7c3e:	0e 94 e1 03 	call	0x7c2	; 0x7c2 <__gtsf2>
    7c42:	18 16       	cp	r1, r24
    7c44:	4c f5       	brge	.+82     	; 0x7c98 <LCD_init+0xe4>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    7c46:	6b 85       	ldd	r22, Y+11	; 0x0b
    7c48:	7c 85       	ldd	r23, Y+12	; 0x0c
    7c4a:	8d 85       	ldd	r24, Y+13	; 0x0d
    7c4c:	9e 85       	ldd	r25, Y+14	; 0x0e
    7c4e:	20 e0       	ldi	r18, 0x00	; 0
    7c50:	30 e0       	ldi	r19, 0x00	; 0
    7c52:	40 e2       	ldi	r20, 0x20	; 32
    7c54:	51 e4       	ldi	r21, 0x41	; 65
    7c56:	0e 94 3b 02 	call	0x476	; 0x476 <__mulsf3>
    7c5a:	dc 01       	movw	r26, r24
    7c5c:	cb 01       	movw	r24, r22
    7c5e:	bc 01       	movw	r22, r24
    7c60:	cd 01       	movw	r24, r26
    7c62:	0e 94 65 00 	call	0xca	; 0xca <__fixunssfsi>
    7c66:	dc 01       	movw	r26, r24
    7c68:	cb 01       	movw	r24, r22
    7c6a:	9e 83       	std	Y+6, r25	; 0x06
    7c6c:	8d 83       	std	Y+5, r24	; 0x05
    7c6e:	0f c0       	rjmp	.+30     	; 0x7c8e <LCD_init+0xda>
    7c70:	80 e9       	ldi	r24, 0x90	; 144
    7c72:	91 e0       	ldi	r25, 0x01	; 1
    7c74:	9c 83       	std	Y+4, r25	; 0x04
    7c76:	8b 83       	std	Y+3, r24	; 0x03
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    7c78:	8b 81       	ldd	r24, Y+3	; 0x03
    7c7a:	9c 81       	ldd	r25, Y+4	; 0x04
    7c7c:	01 97       	sbiw	r24, 0x01	; 1
    7c7e:	f1 f7       	brne	.-4      	; 0x7c7c <LCD_init+0xc8>
    7c80:	9c 83       	std	Y+4, r25	; 0x04
    7c82:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    7c84:	8d 81       	ldd	r24, Y+5	; 0x05
    7c86:	9e 81       	ldd	r25, Y+6	; 0x06
    7c88:	01 97       	sbiw	r24, 0x01	; 1
    7c8a:	9e 83       	std	Y+6, r25	; 0x06
    7c8c:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    7c8e:	8d 81       	ldd	r24, Y+5	; 0x05
    7c90:	9e 81       	ldd	r25, Y+6	; 0x06
    7c92:	00 97       	sbiw	r24, 0x00	; 0
    7c94:	69 f7       	brne	.-38     	; 0x7c70 <LCD_init+0xbc>
    7c96:	14 c0       	rjmp	.+40     	; 0x7cc0 <LCD_init+0x10c>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    7c98:	6f 81       	ldd	r22, Y+7	; 0x07
    7c9a:	78 85       	ldd	r23, Y+8	; 0x08
    7c9c:	89 85       	ldd	r24, Y+9	; 0x09
    7c9e:	9a 85       	ldd	r25, Y+10	; 0x0a
    7ca0:	0e 94 65 00 	call	0xca	; 0xca <__fixunssfsi>
    7ca4:	dc 01       	movw	r26, r24
    7ca6:	cb 01       	movw	r24, r22
    7ca8:	9e 83       	std	Y+6, r25	; 0x06
    7caa:	8d 83       	std	Y+5, r24	; 0x05
    7cac:	8d 81       	ldd	r24, Y+5	; 0x05
    7cae:	9e 81       	ldd	r25, Y+6	; 0x06
    7cb0:	9a 83       	std	Y+2, r25	; 0x02
    7cb2:	89 83       	std	Y+1, r24	; 0x01
    7cb4:	89 81       	ldd	r24, Y+1	; 0x01
    7cb6:	9a 81       	ldd	r25, Y+2	; 0x02
    7cb8:	01 97       	sbiw	r24, 0x01	; 1
    7cba:	f1 f7       	brne	.-4      	; 0x7cb8 <LCD_init+0x104>
    7cbc:	9a 83       	std	Y+2, r25	; 0x02
    7cbe:	89 83       	std	Y+1, r24	; 0x01

	_delay_ms(20);		/* LCD Power ON delay always > 15ms */

#if(LCD_DATA_BITS_MODE == 4)
	/* Configure 4 pins in the data port as output pins */
	GPIO_setupPinDirection(LCD_DATA_PORT_ID,LCD_DB4_PIN_ID,PIN_OUTPUT);
    7cc0:	83 e0       	ldi	r24, 0x03	; 3
    7cc2:	64 e0       	ldi	r22, 0x04	; 4
    7cc4:	41 e0       	ldi	r20, 0x01	; 1
    7cc6:	0e 94 f7 37 	call	0x6fee	; 0x6fee <GPIO_setupPinDirection>
	GPIO_setupPinDirection(LCD_DATA_PORT_ID,LCD_DB5_PIN_ID,PIN_OUTPUT);
    7cca:	83 e0       	ldi	r24, 0x03	; 3
    7ccc:	65 e0       	ldi	r22, 0x05	; 5
    7cce:	41 e0       	ldi	r20, 0x01	; 1
    7cd0:	0e 94 f7 37 	call	0x6fee	; 0x6fee <GPIO_setupPinDirection>
	GPIO_setupPinDirection(LCD_DATA_PORT_ID,LCD_DB6_PIN_ID,PIN_OUTPUT);
    7cd4:	83 e0       	ldi	r24, 0x03	; 3
    7cd6:	66 e0       	ldi	r22, 0x06	; 6
    7cd8:	41 e0       	ldi	r20, 0x01	; 1
    7cda:	0e 94 f7 37 	call	0x6fee	; 0x6fee <GPIO_setupPinDirection>
	GPIO_setupPinDirection(LCD_DATA_PORT_ID,LCD_DB7_PIN_ID,PIN_OUTPUT);
    7cde:	83 e0       	ldi	r24, 0x03	; 3
    7ce0:	67 e0       	ldi	r22, 0x07	; 7
    7ce2:	41 e0       	ldi	r20, 0x01	; 1
    7ce4:	0e 94 f7 37 	call	0x6fee	; 0x6fee <GPIO_setupPinDirection>

	/* Send for 4 bit initialization of LCD  */
	LCD_sendCommand(LCD_TWO_LINES_FOUR_BITS_MODE_INIT1);
    7ce8:	83 e3       	ldi	r24, 0x33	; 51
    7cea:	0e 94 8c 3e 	call	0x7d18	; 0x7d18 <LCD_sendCommand>
	LCD_sendCommand(LCD_TWO_LINES_FOUR_BITS_MODE_INIT2);
    7cee:	82 e3       	ldi	r24, 0x32	; 50
    7cf0:	0e 94 8c 3e 	call	0x7d18	; 0x7d18 <LCD_sendCommand>

	/* use 2-lines LCD + 4-bits Data Mode + 5*7 dot display Mode */
	LCD_sendCommand(LCD_TWO_LINES_FOUR_BITS_MODE);
    7cf4:	88 e2       	ldi	r24, 0x28	; 40
    7cf6:	0e 94 8c 3e 	call	0x7d18	; 0x7d18 <LCD_sendCommand>
	/* use 2-lines LCD + 8-bits Data Mode + 5*7 dot display Mode */
	LCD_sendCommand(LCD_TWO_LINES_EIGHT_BITS_MODE);

#endif

	LCD_sendCommand(LCD_CURSOR_OFF); /* cursor off */
    7cfa:	8c e0       	ldi	r24, 0x0C	; 12
    7cfc:	0e 94 8c 3e 	call	0x7d18	; 0x7d18 <LCD_sendCommand>
	LCD_sendCommand(LCD_CLEAR_COMMAND); /* clear LCD at the beginning */
    7d00:	81 e0       	ldi	r24, 0x01	; 1
    7d02:	0e 94 8c 3e 	call	0x7d18	; 0x7d18 <LCD_sendCommand>
}
    7d06:	2e 96       	adiw	r28, 0x0e	; 14
    7d08:	0f b6       	in	r0, 0x3f	; 63
    7d0a:	f8 94       	cli
    7d0c:	de bf       	out	0x3e, r29	; 62
    7d0e:	0f be       	out	0x3f, r0	; 63
    7d10:	cd bf       	out	0x3d, r28	; 61
    7d12:	cf 91       	pop	r28
    7d14:	df 91       	pop	r29
    7d16:	08 95       	ret

00007d18 <LCD_sendCommand>:
/*
 * Description :
 * Send the required command to the screen
 */
void LCD_sendCommand(uint8 command)
{
    7d18:	0f 93       	push	r16
    7d1a:	1f 93       	push	r17
    7d1c:	df 93       	push	r29
    7d1e:	cf 93       	push	r28
    7d20:	cd b7       	in	r28, 0x3d	; 61
    7d22:	de b7       	in	r29, 0x3e	; 62
    7d24:	c3 56       	subi	r28, 0x63	; 99
    7d26:	d0 40       	sbci	r29, 0x00	; 0
    7d28:	0f b6       	in	r0, 0x3f	; 63
    7d2a:	f8 94       	cli
    7d2c:	de bf       	out	0x3e, r29	; 62
    7d2e:	0f be       	out	0x3f, r0	; 63
    7d30:	cd bf       	out	0x3d, r28	; 61
    7d32:	fe 01       	movw	r30, r28
    7d34:	ed 59       	subi	r30, 0x9D	; 157
    7d36:	ff 4f       	sbci	r31, 0xFF	; 255
    7d38:	80 83       	st	Z, r24
	GPIO_writePin(LCD_RS_PORT_ID,LCD_RS_PIN_ID,LOGIC_LOW); /* Instruction Mode RS=0 */
    7d3a:	83 e0       	ldi	r24, 0x03	; 3
    7d3c:	60 e0       	ldi	r22, 0x00	; 0
    7d3e:	40 e0       	ldi	r20, 0x00	; 0
    7d40:	0e 94 46 39 	call	0x728c	; 0x728c <GPIO_writePin>
    7d44:	fe 01       	movw	r30, r28
    7d46:	e1 5a       	subi	r30, 0xA1	; 161
    7d48:	ff 4f       	sbci	r31, 0xFF	; 255
    7d4a:	80 e0       	ldi	r24, 0x00	; 0
    7d4c:	90 e0       	ldi	r25, 0x00	; 0
    7d4e:	a0 e8       	ldi	r26, 0x80	; 128
    7d50:	bf e3       	ldi	r27, 0x3F	; 63
    7d52:	80 83       	st	Z, r24
    7d54:	91 83       	std	Z+1, r25	; 0x01
    7d56:	a2 83       	std	Z+2, r26	; 0x02
    7d58:	b3 83       	std	Z+3, r27	; 0x03
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    7d5a:	8e 01       	movw	r16, r28
    7d5c:	05 5a       	subi	r16, 0xA5	; 165
    7d5e:	1f 4f       	sbci	r17, 0xFF	; 255
    7d60:	fe 01       	movw	r30, r28
    7d62:	e1 5a       	subi	r30, 0xA1	; 161
    7d64:	ff 4f       	sbci	r31, 0xFF	; 255
    7d66:	60 81       	ld	r22, Z
    7d68:	71 81       	ldd	r23, Z+1	; 0x01
    7d6a:	82 81       	ldd	r24, Z+2	; 0x02
    7d6c:	93 81       	ldd	r25, Z+3	; 0x03
    7d6e:	20 e0       	ldi	r18, 0x00	; 0
    7d70:	30 e0       	ldi	r19, 0x00	; 0
    7d72:	4a e7       	ldi	r20, 0x7A	; 122
    7d74:	55 e4       	ldi	r21, 0x45	; 69
    7d76:	0e 94 3b 02 	call	0x476	; 0x476 <__mulsf3>
    7d7a:	dc 01       	movw	r26, r24
    7d7c:	cb 01       	movw	r24, r22
    7d7e:	f8 01       	movw	r30, r16
    7d80:	80 83       	st	Z, r24
    7d82:	91 83       	std	Z+1, r25	; 0x01
    7d84:	a2 83       	std	Z+2, r26	; 0x02
    7d86:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    7d88:	fe 01       	movw	r30, r28
    7d8a:	e5 5a       	subi	r30, 0xA5	; 165
    7d8c:	ff 4f       	sbci	r31, 0xFF	; 255
    7d8e:	60 81       	ld	r22, Z
    7d90:	71 81       	ldd	r23, Z+1	; 0x01
    7d92:	82 81       	ldd	r24, Z+2	; 0x02
    7d94:	93 81       	ldd	r25, Z+3	; 0x03
    7d96:	20 e0       	ldi	r18, 0x00	; 0
    7d98:	30 e0       	ldi	r19, 0x00	; 0
    7d9a:	40 e8       	ldi	r20, 0x80	; 128
    7d9c:	5f e3       	ldi	r21, 0x3F	; 63
    7d9e:	0e 94 41 04 	call	0x882	; 0x882 <__ltsf2>
    7da2:	88 23       	and	r24, r24
    7da4:	44 f4       	brge	.+16     	; 0x7db6 <LCD_sendCommand+0x9e>
		__ticks = 1;
    7da6:	fe 01       	movw	r30, r28
    7da8:	e7 5a       	subi	r30, 0xA7	; 167
    7daa:	ff 4f       	sbci	r31, 0xFF	; 255
    7dac:	81 e0       	ldi	r24, 0x01	; 1
    7dae:	90 e0       	ldi	r25, 0x00	; 0
    7db0:	91 83       	std	Z+1, r25	; 0x01
    7db2:	80 83       	st	Z, r24
    7db4:	64 c0       	rjmp	.+200    	; 0x7e7e <LCD_sendCommand+0x166>
	else if (__tmp > 65535)
    7db6:	fe 01       	movw	r30, r28
    7db8:	e5 5a       	subi	r30, 0xA5	; 165
    7dba:	ff 4f       	sbci	r31, 0xFF	; 255
    7dbc:	60 81       	ld	r22, Z
    7dbe:	71 81       	ldd	r23, Z+1	; 0x01
    7dc0:	82 81       	ldd	r24, Z+2	; 0x02
    7dc2:	93 81       	ldd	r25, Z+3	; 0x03
    7dc4:	20 e0       	ldi	r18, 0x00	; 0
    7dc6:	3f ef       	ldi	r19, 0xFF	; 255
    7dc8:	4f e7       	ldi	r20, 0x7F	; 127
    7dca:	57 e4       	ldi	r21, 0x47	; 71
    7dcc:	0e 94 e1 03 	call	0x7c2	; 0x7c2 <__gtsf2>
    7dd0:	18 16       	cp	r1, r24
    7dd2:	0c f0       	brlt	.+2      	; 0x7dd6 <LCD_sendCommand+0xbe>
    7dd4:	43 c0       	rjmp	.+134    	; 0x7e5c <LCD_sendCommand+0x144>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    7dd6:	fe 01       	movw	r30, r28
    7dd8:	e1 5a       	subi	r30, 0xA1	; 161
    7dda:	ff 4f       	sbci	r31, 0xFF	; 255
    7ddc:	60 81       	ld	r22, Z
    7dde:	71 81       	ldd	r23, Z+1	; 0x01
    7de0:	82 81       	ldd	r24, Z+2	; 0x02
    7de2:	93 81       	ldd	r25, Z+3	; 0x03
    7de4:	20 e0       	ldi	r18, 0x00	; 0
    7de6:	30 e0       	ldi	r19, 0x00	; 0
    7de8:	40 e2       	ldi	r20, 0x20	; 32
    7dea:	51 e4       	ldi	r21, 0x41	; 65
    7dec:	0e 94 3b 02 	call	0x476	; 0x476 <__mulsf3>
    7df0:	dc 01       	movw	r26, r24
    7df2:	cb 01       	movw	r24, r22
    7df4:	8e 01       	movw	r16, r28
    7df6:	07 5a       	subi	r16, 0xA7	; 167
    7df8:	1f 4f       	sbci	r17, 0xFF	; 255
    7dfa:	bc 01       	movw	r22, r24
    7dfc:	cd 01       	movw	r24, r26
    7dfe:	0e 94 65 00 	call	0xca	; 0xca <__fixunssfsi>
    7e02:	dc 01       	movw	r26, r24
    7e04:	cb 01       	movw	r24, r22
    7e06:	f8 01       	movw	r30, r16
    7e08:	91 83       	std	Z+1, r25	; 0x01
    7e0a:	80 83       	st	Z, r24
    7e0c:	1f c0       	rjmp	.+62     	; 0x7e4c <LCD_sendCommand+0x134>
    7e0e:	fe 01       	movw	r30, r28
    7e10:	e9 5a       	subi	r30, 0xA9	; 169
    7e12:	ff 4f       	sbci	r31, 0xFF	; 255
    7e14:	80 e9       	ldi	r24, 0x90	; 144
    7e16:	91 e0       	ldi	r25, 0x01	; 1
    7e18:	91 83       	std	Z+1, r25	; 0x01
    7e1a:	80 83       	st	Z, r24
    7e1c:	fe 01       	movw	r30, r28
    7e1e:	e9 5a       	subi	r30, 0xA9	; 169
    7e20:	ff 4f       	sbci	r31, 0xFF	; 255
    7e22:	80 81       	ld	r24, Z
    7e24:	91 81       	ldd	r25, Z+1	; 0x01
    7e26:	01 97       	sbiw	r24, 0x01	; 1
    7e28:	f1 f7       	brne	.-4      	; 0x7e26 <LCD_sendCommand+0x10e>
    7e2a:	fe 01       	movw	r30, r28
    7e2c:	e9 5a       	subi	r30, 0xA9	; 169
    7e2e:	ff 4f       	sbci	r31, 0xFF	; 255
    7e30:	91 83       	std	Z+1, r25	; 0x01
    7e32:	80 83       	st	Z, r24
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    7e34:	de 01       	movw	r26, r28
    7e36:	a7 5a       	subi	r26, 0xA7	; 167
    7e38:	bf 4f       	sbci	r27, 0xFF	; 255
    7e3a:	fe 01       	movw	r30, r28
    7e3c:	e7 5a       	subi	r30, 0xA7	; 167
    7e3e:	ff 4f       	sbci	r31, 0xFF	; 255
    7e40:	80 81       	ld	r24, Z
    7e42:	91 81       	ldd	r25, Z+1	; 0x01
    7e44:	01 97       	sbiw	r24, 0x01	; 1
    7e46:	11 96       	adiw	r26, 0x01	; 1
    7e48:	9c 93       	st	X, r25
    7e4a:	8e 93       	st	-X, r24
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    7e4c:	fe 01       	movw	r30, r28
    7e4e:	e7 5a       	subi	r30, 0xA7	; 167
    7e50:	ff 4f       	sbci	r31, 0xFF	; 255
    7e52:	80 81       	ld	r24, Z
    7e54:	91 81       	ldd	r25, Z+1	; 0x01
    7e56:	00 97       	sbiw	r24, 0x00	; 0
    7e58:	d1 f6       	brne	.-76     	; 0x7e0e <LCD_sendCommand+0xf6>
    7e5a:	27 c0       	rjmp	.+78     	; 0x7eaa <LCD_sendCommand+0x192>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    7e5c:	8e 01       	movw	r16, r28
    7e5e:	07 5a       	subi	r16, 0xA7	; 167
    7e60:	1f 4f       	sbci	r17, 0xFF	; 255
    7e62:	fe 01       	movw	r30, r28
    7e64:	e5 5a       	subi	r30, 0xA5	; 165
    7e66:	ff 4f       	sbci	r31, 0xFF	; 255
    7e68:	60 81       	ld	r22, Z
    7e6a:	71 81       	ldd	r23, Z+1	; 0x01
    7e6c:	82 81       	ldd	r24, Z+2	; 0x02
    7e6e:	93 81       	ldd	r25, Z+3	; 0x03
    7e70:	0e 94 65 00 	call	0xca	; 0xca <__fixunssfsi>
    7e74:	dc 01       	movw	r26, r24
    7e76:	cb 01       	movw	r24, r22
    7e78:	f8 01       	movw	r30, r16
    7e7a:	91 83       	std	Z+1, r25	; 0x01
    7e7c:	80 83       	st	Z, r24
    7e7e:	de 01       	movw	r26, r28
    7e80:	ab 5a       	subi	r26, 0xAB	; 171
    7e82:	bf 4f       	sbci	r27, 0xFF	; 255
    7e84:	fe 01       	movw	r30, r28
    7e86:	e7 5a       	subi	r30, 0xA7	; 167
    7e88:	ff 4f       	sbci	r31, 0xFF	; 255
    7e8a:	80 81       	ld	r24, Z
    7e8c:	91 81       	ldd	r25, Z+1	; 0x01
    7e8e:	8d 93       	st	X+, r24
    7e90:	9c 93       	st	X, r25
    7e92:	fe 01       	movw	r30, r28
    7e94:	eb 5a       	subi	r30, 0xAB	; 171
    7e96:	ff 4f       	sbci	r31, 0xFF	; 255
    7e98:	80 81       	ld	r24, Z
    7e9a:	91 81       	ldd	r25, Z+1	; 0x01
    7e9c:	01 97       	sbiw	r24, 0x01	; 1
    7e9e:	f1 f7       	brne	.-4      	; 0x7e9c <LCD_sendCommand+0x184>
    7ea0:	fe 01       	movw	r30, r28
    7ea2:	eb 5a       	subi	r30, 0xAB	; 171
    7ea4:	ff 4f       	sbci	r31, 0xFF	; 255
    7ea6:	91 83       	std	Z+1, r25	; 0x01
    7ea8:	80 83       	st	Z, r24
	_delay_ms(1); /* delay for processing Tas = 50ns */
	GPIO_writePin(LCD_E_PORT_ID,LCD_E_PIN_ID,LOGIC_HIGH); /* Enable LCD E=1 */
    7eaa:	83 e0       	ldi	r24, 0x03	; 3
    7eac:	62 e0       	ldi	r22, 0x02	; 2
    7eae:	41 e0       	ldi	r20, 0x01	; 1
    7eb0:	0e 94 46 39 	call	0x728c	; 0x728c <GPIO_writePin>
    7eb4:	fe 01       	movw	r30, r28
    7eb6:	ef 5a       	subi	r30, 0xAF	; 175
    7eb8:	ff 4f       	sbci	r31, 0xFF	; 255
    7eba:	80 e0       	ldi	r24, 0x00	; 0
    7ebc:	90 e0       	ldi	r25, 0x00	; 0
    7ebe:	a0 e8       	ldi	r26, 0x80	; 128
    7ec0:	bf e3       	ldi	r27, 0x3F	; 63
    7ec2:	80 83       	st	Z, r24
    7ec4:	91 83       	std	Z+1, r25	; 0x01
    7ec6:	a2 83       	std	Z+2, r26	; 0x02
    7ec8:	b3 83       	std	Z+3, r27	; 0x03
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    7eca:	8e 01       	movw	r16, r28
    7ecc:	03 5b       	subi	r16, 0xB3	; 179
    7ece:	1f 4f       	sbci	r17, 0xFF	; 255
    7ed0:	fe 01       	movw	r30, r28
    7ed2:	ef 5a       	subi	r30, 0xAF	; 175
    7ed4:	ff 4f       	sbci	r31, 0xFF	; 255
    7ed6:	60 81       	ld	r22, Z
    7ed8:	71 81       	ldd	r23, Z+1	; 0x01
    7eda:	82 81       	ldd	r24, Z+2	; 0x02
    7edc:	93 81       	ldd	r25, Z+3	; 0x03
    7ede:	20 e0       	ldi	r18, 0x00	; 0
    7ee0:	30 e0       	ldi	r19, 0x00	; 0
    7ee2:	4a e7       	ldi	r20, 0x7A	; 122
    7ee4:	55 e4       	ldi	r21, 0x45	; 69
    7ee6:	0e 94 3b 02 	call	0x476	; 0x476 <__mulsf3>
    7eea:	dc 01       	movw	r26, r24
    7eec:	cb 01       	movw	r24, r22
    7eee:	f8 01       	movw	r30, r16
    7ef0:	80 83       	st	Z, r24
    7ef2:	91 83       	std	Z+1, r25	; 0x01
    7ef4:	a2 83       	std	Z+2, r26	; 0x02
    7ef6:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    7ef8:	fe 01       	movw	r30, r28
    7efa:	e3 5b       	subi	r30, 0xB3	; 179
    7efc:	ff 4f       	sbci	r31, 0xFF	; 255
    7efe:	60 81       	ld	r22, Z
    7f00:	71 81       	ldd	r23, Z+1	; 0x01
    7f02:	82 81       	ldd	r24, Z+2	; 0x02
    7f04:	93 81       	ldd	r25, Z+3	; 0x03
    7f06:	20 e0       	ldi	r18, 0x00	; 0
    7f08:	30 e0       	ldi	r19, 0x00	; 0
    7f0a:	40 e8       	ldi	r20, 0x80	; 128
    7f0c:	5f e3       	ldi	r21, 0x3F	; 63
    7f0e:	0e 94 41 04 	call	0x882	; 0x882 <__ltsf2>
    7f12:	88 23       	and	r24, r24
    7f14:	44 f4       	brge	.+16     	; 0x7f26 <LCD_sendCommand+0x20e>
		__ticks = 1;
    7f16:	fe 01       	movw	r30, r28
    7f18:	e5 5b       	subi	r30, 0xB5	; 181
    7f1a:	ff 4f       	sbci	r31, 0xFF	; 255
    7f1c:	81 e0       	ldi	r24, 0x01	; 1
    7f1e:	90 e0       	ldi	r25, 0x00	; 0
    7f20:	91 83       	std	Z+1, r25	; 0x01
    7f22:	80 83       	st	Z, r24
    7f24:	64 c0       	rjmp	.+200    	; 0x7fee <LCD_sendCommand+0x2d6>
	else if (__tmp > 65535)
    7f26:	fe 01       	movw	r30, r28
    7f28:	e3 5b       	subi	r30, 0xB3	; 179
    7f2a:	ff 4f       	sbci	r31, 0xFF	; 255
    7f2c:	60 81       	ld	r22, Z
    7f2e:	71 81       	ldd	r23, Z+1	; 0x01
    7f30:	82 81       	ldd	r24, Z+2	; 0x02
    7f32:	93 81       	ldd	r25, Z+3	; 0x03
    7f34:	20 e0       	ldi	r18, 0x00	; 0
    7f36:	3f ef       	ldi	r19, 0xFF	; 255
    7f38:	4f e7       	ldi	r20, 0x7F	; 127
    7f3a:	57 e4       	ldi	r21, 0x47	; 71
    7f3c:	0e 94 e1 03 	call	0x7c2	; 0x7c2 <__gtsf2>
    7f40:	18 16       	cp	r1, r24
    7f42:	0c f0       	brlt	.+2      	; 0x7f46 <LCD_sendCommand+0x22e>
    7f44:	43 c0       	rjmp	.+134    	; 0x7fcc <LCD_sendCommand+0x2b4>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    7f46:	fe 01       	movw	r30, r28
    7f48:	ef 5a       	subi	r30, 0xAF	; 175
    7f4a:	ff 4f       	sbci	r31, 0xFF	; 255
    7f4c:	60 81       	ld	r22, Z
    7f4e:	71 81       	ldd	r23, Z+1	; 0x01
    7f50:	82 81       	ldd	r24, Z+2	; 0x02
    7f52:	93 81       	ldd	r25, Z+3	; 0x03
    7f54:	20 e0       	ldi	r18, 0x00	; 0
    7f56:	30 e0       	ldi	r19, 0x00	; 0
    7f58:	40 e2       	ldi	r20, 0x20	; 32
    7f5a:	51 e4       	ldi	r21, 0x41	; 65
    7f5c:	0e 94 3b 02 	call	0x476	; 0x476 <__mulsf3>
    7f60:	dc 01       	movw	r26, r24
    7f62:	cb 01       	movw	r24, r22
    7f64:	8e 01       	movw	r16, r28
    7f66:	05 5b       	subi	r16, 0xB5	; 181
    7f68:	1f 4f       	sbci	r17, 0xFF	; 255
    7f6a:	bc 01       	movw	r22, r24
    7f6c:	cd 01       	movw	r24, r26
    7f6e:	0e 94 65 00 	call	0xca	; 0xca <__fixunssfsi>
    7f72:	dc 01       	movw	r26, r24
    7f74:	cb 01       	movw	r24, r22
    7f76:	f8 01       	movw	r30, r16
    7f78:	91 83       	std	Z+1, r25	; 0x01
    7f7a:	80 83       	st	Z, r24
    7f7c:	1f c0       	rjmp	.+62     	; 0x7fbc <LCD_sendCommand+0x2a4>
    7f7e:	fe 01       	movw	r30, r28
    7f80:	e7 5b       	subi	r30, 0xB7	; 183
    7f82:	ff 4f       	sbci	r31, 0xFF	; 255
    7f84:	80 e9       	ldi	r24, 0x90	; 144
    7f86:	91 e0       	ldi	r25, 0x01	; 1
    7f88:	91 83       	std	Z+1, r25	; 0x01
    7f8a:	80 83       	st	Z, r24
    7f8c:	fe 01       	movw	r30, r28
    7f8e:	e7 5b       	subi	r30, 0xB7	; 183
    7f90:	ff 4f       	sbci	r31, 0xFF	; 255
    7f92:	80 81       	ld	r24, Z
    7f94:	91 81       	ldd	r25, Z+1	; 0x01
    7f96:	01 97       	sbiw	r24, 0x01	; 1
    7f98:	f1 f7       	brne	.-4      	; 0x7f96 <LCD_sendCommand+0x27e>
    7f9a:	fe 01       	movw	r30, r28
    7f9c:	e7 5b       	subi	r30, 0xB7	; 183
    7f9e:	ff 4f       	sbci	r31, 0xFF	; 255
    7fa0:	91 83       	std	Z+1, r25	; 0x01
    7fa2:	80 83       	st	Z, r24
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    7fa4:	de 01       	movw	r26, r28
    7fa6:	a5 5b       	subi	r26, 0xB5	; 181
    7fa8:	bf 4f       	sbci	r27, 0xFF	; 255
    7faa:	fe 01       	movw	r30, r28
    7fac:	e5 5b       	subi	r30, 0xB5	; 181
    7fae:	ff 4f       	sbci	r31, 0xFF	; 255
    7fb0:	80 81       	ld	r24, Z
    7fb2:	91 81       	ldd	r25, Z+1	; 0x01
    7fb4:	01 97       	sbiw	r24, 0x01	; 1
    7fb6:	11 96       	adiw	r26, 0x01	; 1
    7fb8:	9c 93       	st	X, r25
    7fba:	8e 93       	st	-X, r24
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    7fbc:	fe 01       	movw	r30, r28
    7fbe:	e5 5b       	subi	r30, 0xB5	; 181
    7fc0:	ff 4f       	sbci	r31, 0xFF	; 255
    7fc2:	80 81       	ld	r24, Z
    7fc4:	91 81       	ldd	r25, Z+1	; 0x01
    7fc6:	00 97       	sbiw	r24, 0x00	; 0
    7fc8:	d1 f6       	brne	.-76     	; 0x7f7e <LCD_sendCommand+0x266>
    7fca:	27 c0       	rjmp	.+78     	; 0x801a <LCD_sendCommand+0x302>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    7fcc:	8e 01       	movw	r16, r28
    7fce:	05 5b       	subi	r16, 0xB5	; 181
    7fd0:	1f 4f       	sbci	r17, 0xFF	; 255
    7fd2:	fe 01       	movw	r30, r28
    7fd4:	e3 5b       	subi	r30, 0xB3	; 179
    7fd6:	ff 4f       	sbci	r31, 0xFF	; 255
    7fd8:	60 81       	ld	r22, Z
    7fda:	71 81       	ldd	r23, Z+1	; 0x01
    7fdc:	82 81       	ldd	r24, Z+2	; 0x02
    7fde:	93 81       	ldd	r25, Z+3	; 0x03
    7fe0:	0e 94 65 00 	call	0xca	; 0xca <__fixunssfsi>
    7fe4:	dc 01       	movw	r26, r24
    7fe6:	cb 01       	movw	r24, r22
    7fe8:	f8 01       	movw	r30, r16
    7fea:	91 83       	std	Z+1, r25	; 0x01
    7fec:	80 83       	st	Z, r24
    7fee:	de 01       	movw	r26, r28
    7ff0:	a9 5b       	subi	r26, 0xB9	; 185
    7ff2:	bf 4f       	sbci	r27, 0xFF	; 255
    7ff4:	fe 01       	movw	r30, r28
    7ff6:	e5 5b       	subi	r30, 0xB5	; 181
    7ff8:	ff 4f       	sbci	r31, 0xFF	; 255
    7ffa:	80 81       	ld	r24, Z
    7ffc:	91 81       	ldd	r25, Z+1	; 0x01
    7ffe:	8d 93       	st	X+, r24
    8000:	9c 93       	st	X, r25
    8002:	fe 01       	movw	r30, r28
    8004:	e9 5b       	subi	r30, 0xB9	; 185
    8006:	ff 4f       	sbci	r31, 0xFF	; 255
    8008:	80 81       	ld	r24, Z
    800a:	91 81       	ldd	r25, Z+1	; 0x01
    800c:	01 97       	sbiw	r24, 0x01	; 1
    800e:	f1 f7       	brne	.-4      	; 0x800c <LCD_sendCommand+0x2f4>
    8010:	fe 01       	movw	r30, r28
    8012:	e9 5b       	subi	r30, 0xB9	; 185
    8014:	ff 4f       	sbci	r31, 0xFF	; 255
    8016:	91 83       	std	Z+1, r25	; 0x01
    8018:	80 83       	st	Z, r24
	_delay_ms(1); /* delay for processing Tpw - Tdws = 190ns */

#if(LCD_DATA_BITS_MODE == 4)
	GPIO_writePin(LCD_DATA_PORT_ID,LCD_DB4_PIN_ID,GET_BIT(command,4));
    801a:	fe 01       	movw	r30, r28
    801c:	ed 59       	subi	r30, 0x9D	; 157
    801e:	ff 4f       	sbci	r31, 0xFF	; 255
    8020:	80 81       	ld	r24, Z
    8022:	88 2f       	mov	r24, r24
    8024:	90 e0       	ldi	r25, 0x00	; 0
    8026:	80 71       	andi	r24, 0x10	; 16
    8028:	90 70       	andi	r25, 0x00	; 0
    802a:	95 95       	asr	r25
    802c:	87 95       	ror	r24
    802e:	95 95       	asr	r25
    8030:	87 95       	ror	r24
    8032:	95 95       	asr	r25
    8034:	87 95       	ror	r24
    8036:	95 95       	asr	r25
    8038:	87 95       	ror	r24
    803a:	98 2f       	mov	r25, r24
    803c:	83 e0       	ldi	r24, 0x03	; 3
    803e:	64 e0       	ldi	r22, 0x04	; 4
    8040:	49 2f       	mov	r20, r25
    8042:	0e 94 46 39 	call	0x728c	; 0x728c <GPIO_writePin>
	GPIO_writePin(LCD_DATA_PORT_ID,LCD_DB5_PIN_ID,GET_BIT(command,5));
    8046:	fe 01       	movw	r30, r28
    8048:	ed 59       	subi	r30, 0x9D	; 157
    804a:	ff 4f       	sbci	r31, 0xFF	; 255
    804c:	80 81       	ld	r24, Z
    804e:	88 2f       	mov	r24, r24
    8050:	90 e0       	ldi	r25, 0x00	; 0
    8052:	80 72       	andi	r24, 0x20	; 32
    8054:	90 70       	andi	r25, 0x00	; 0
    8056:	95 95       	asr	r25
    8058:	87 95       	ror	r24
    805a:	95 95       	asr	r25
    805c:	87 95       	ror	r24
    805e:	95 95       	asr	r25
    8060:	87 95       	ror	r24
    8062:	95 95       	asr	r25
    8064:	87 95       	ror	r24
    8066:	95 95       	asr	r25
    8068:	87 95       	ror	r24
    806a:	98 2f       	mov	r25, r24
    806c:	83 e0       	ldi	r24, 0x03	; 3
    806e:	65 e0       	ldi	r22, 0x05	; 5
    8070:	49 2f       	mov	r20, r25
    8072:	0e 94 46 39 	call	0x728c	; 0x728c <GPIO_writePin>
	GPIO_writePin(LCD_DATA_PORT_ID,LCD_DB6_PIN_ID,GET_BIT(command,6));
    8076:	fe 01       	movw	r30, r28
    8078:	ed 59       	subi	r30, 0x9D	; 157
    807a:	ff 4f       	sbci	r31, 0xFF	; 255
    807c:	80 81       	ld	r24, Z
    807e:	88 2f       	mov	r24, r24
    8080:	90 e0       	ldi	r25, 0x00	; 0
    8082:	80 74       	andi	r24, 0x40	; 64
    8084:	90 70       	andi	r25, 0x00	; 0
    8086:	08 2e       	mov	r0, r24
    8088:	89 2f       	mov	r24, r25
    808a:	00 0c       	add	r0, r0
    808c:	88 1f       	adc	r24, r24
    808e:	99 0b       	sbc	r25, r25
    8090:	00 0c       	add	r0, r0
    8092:	88 1f       	adc	r24, r24
    8094:	99 1f       	adc	r25, r25
    8096:	98 2f       	mov	r25, r24
    8098:	83 e0       	ldi	r24, 0x03	; 3
    809a:	66 e0       	ldi	r22, 0x06	; 6
    809c:	49 2f       	mov	r20, r25
    809e:	0e 94 46 39 	call	0x728c	; 0x728c <GPIO_writePin>
	GPIO_writePin(LCD_DATA_PORT_ID,LCD_DB7_PIN_ID,GET_BIT(command,7));
    80a2:	fe 01       	movw	r30, r28
    80a4:	ed 59       	subi	r30, 0x9D	; 157
    80a6:	ff 4f       	sbci	r31, 0xFF	; 255
    80a8:	80 81       	ld	r24, Z
    80aa:	98 2f       	mov	r25, r24
    80ac:	99 1f       	adc	r25, r25
    80ae:	99 27       	eor	r25, r25
    80b0:	99 1f       	adc	r25, r25
    80b2:	83 e0       	ldi	r24, 0x03	; 3
    80b4:	67 e0       	ldi	r22, 0x07	; 7
    80b6:	49 2f       	mov	r20, r25
    80b8:	0e 94 46 39 	call	0x728c	; 0x728c <GPIO_writePin>
    80bc:	fe 01       	movw	r30, r28
    80be:	ed 5b       	subi	r30, 0xBD	; 189
    80c0:	ff 4f       	sbci	r31, 0xFF	; 255
    80c2:	80 e0       	ldi	r24, 0x00	; 0
    80c4:	90 e0       	ldi	r25, 0x00	; 0
    80c6:	a0 e8       	ldi	r26, 0x80	; 128
    80c8:	bf e3       	ldi	r27, 0x3F	; 63
    80ca:	80 83       	st	Z, r24
    80cc:	91 83       	std	Z+1, r25	; 0x01
    80ce:	a2 83       	std	Z+2, r26	; 0x02
    80d0:	b3 83       	std	Z+3, r27	; 0x03
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    80d2:	8e 01       	movw	r16, r28
    80d4:	01 5c       	subi	r16, 0xC1	; 193
    80d6:	1f 4f       	sbci	r17, 0xFF	; 255
    80d8:	fe 01       	movw	r30, r28
    80da:	ed 5b       	subi	r30, 0xBD	; 189
    80dc:	ff 4f       	sbci	r31, 0xFF	; 255
    80de:	60 81       	ld	r22, Z
    80e0:	71 81       	ldd	r23, Z+1	; 0x01
    80e2:	82 81       	ldd	r24, Z+2	; 0x02
    80e4:	93 81       	ldd	r25, Z+3	; 0x03
    80e6:	20 e0       	ldi	r18, 0x00	; 0
    80e8:	30 e0       	ldi	r19, 0x00	; 0
    80ea:	4a e7       	ldi	r20, 0x7A	; 122
    80ec:	55 e4       	ldi	r21, 0x45	; 69
    80ee:	0e 94 3b 02 	call	0x476	; 0x476 <__mulsf3>
    80f2:	dc 01       	movw	r26, r24
    80f4:	cb 01       	movw	r24, r22
    80f6:	f8 01       	movw	r30, r16
    80f8:	80 83       	st	Z, r24
    80fa:	91 83       	std	Z+1, r25	; 0x01
    80fc:	a2 83       	std	Z+2, r26	; 0x02
    80fe:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    8100:	fe 01       	movw	r30, r28
    8102:	ff 96       	adiw	r30, 0x3f	; 63
    8104:	60 81       	ld	r22, Z
    8106:	71 81       	ldd	r23, Z+1	; 0x01
    8108:	82 81       	ldd	r24, Z+2	; 0x02
    810a:	93 81       	ldd	r25, Z+3	; 0x03
    810c:	20 e0       	ldi	r18, 0x00	; 0
    810e:	30 e0       	ldi	r19, 0x00	; 0
    8110:	40 e8       	ldi	r20, 0x80	; 128
    8112:	5f e3       	ldi	r21, 0x3F	; 63
    8114:	0e 94 41 04 	call	0x882	; 0x882 <__ltsf2>
    8118:	88 23       	and	r24, r24
    811a:	2c f4       	brge	.+10     	; 0x8126 <LCD_sendCommand+0x40e>
		__ticks = 1;
    811c:	81 e0       	ldi	r24, 0x01	; 1
    811e:	90 e0       	ldi	r25, 0x00	; 0
    8120:	9e af       	std	Y+62, r25	; 0x3e
    8122:	8d af       	std	Y+61, r24	; 0x3d
    8124:	46 c0       	rjmp	.+140    	; 0x81b2 <LCD_sendCommand+0x49a>
	else if (__tmp > 65535)
    8126:	fe 01       	movw	r30, r28
    8128:	ff 96       	adiw	r30, 0x3f	; 63
    812a:	60 81       	ld	r22, Z
    812c:	71 81       	ldd	r23, Z+1	; 0x01
    812e:	82 81       	ldd	r24, Z+2	; 0x02
    8130:	93 81       	ldd	r25, Z+3	; 0x03
    8132:	20 e0       	ldi	r18, 0x00	; 0
    8134:	3f ef       	ldi	r19, 0xFF	; 255
    8136:	4f e7       	ldi	r20, 0x7F	; 127
    8138:	57 e4       	ldi	r21, 0x47	; 71
    813a:	0e 94 e1 03 	call	0x7c2	; 0x7c2 <__gtsf2>
    813e:	18 16       	cp	r1, r24
    8140:	64 f5       	brge	.+88     	; 0x819a <LCD_sendCommand+0x482>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    8142:	fe 01       	movw	r30, r28
    8144:	ed 5b       	subi	r30, 0xBD	; 189
    8146:	ff 4f       	sbci	r31, 0xFF	; 255
    8148:	60 81       	ld	r22, Z
    814a:	71 81       	ldd	r23, Z+1	; 0x01
    814c:	82 81       	ldd	r24, Z+2	; 0x02
    814e:	93 81       	ldd	r25, Z+3	; 0x03
    8150:	20 e0       	ldi	r18, 0x00	; 0
    8152:	30 e0       	ldi	r19, 0x00	; 0
    8154:	40 e2       	ldi	r20, 0x20	; 32
    8156:	51 e4       	ldi	r21, 0x41	; 65
    8158:	0e 94 3b 02 	call	0x476	; 0x476 <__mulsf3>
    815c:	dc 01       	movw	r26, r24
    815e:	cb 01       	movw	r24, r22
    8160:	bc 01       	movw	r22, r24
    8162:	cd 01       	movw	r24, r26
    8164:	0e 94 65 00 	call	0xca	; 0xca <__fixunssfsi>
    8168:	dc 01       	movw	r26, r24
    816a:	cb 01       	movw	r24, r22
    816c:	9e af       	std	Y+62, r25	; 0x3e
    816e:	8d af       	std	Y+61, r24	; 0x3d
    8170:	0f c0       	rjmp	.+30     	; 0x8190 <LCD_sendCommand+0x478>
    8172:	80 e9       	ldi	r24, 0x90	; 144
    8174:	91 e0       	ldi	r25, 0x01	; 1
    8176:	9c af       	std	Y+60, r25	; 0x3c
    8178:	8b af       	std	Y+59, r24	; 0x3b
    817a:	8b ad       	ldd	r24, Y+59	; 0x3b
    817c:	9c ad       	ldd	r25, Y+60	; 0x3c
    817e:	01 97       	sbiw	r24, 0x01	; 1
    8180:	f1 f7       	brne	.-4      	; 0x817e <LCD_sendCommand+0x466>
    8182:	9c af       	std	Y+60, r25	; 0x3c
    8184:	8b af       	std	Y+59, r24	; 0x3b
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    8186:	8d ad       	ldd	r24, Y+61	; 0x3d
    8188:	9e ad       	ldd	r25, Y+62	; 0x3e
    818a:	01 97       	sbiw	r24, 0x01	; 1
    818c:	9e af       	std	Y+62, r25	; 0x3e
    818e:	8d af       	std	Y+61, r24	; 0x3d
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    8190:	8d ad       	ldd	r24, Y+61	; 0x3d
    8192:	9e ad       	ldd	r25, Y+62	; 0x3e
    8194:	00 97       	sbiw	r24, 0x00	; 0
    8196:	69 f7       	brne	.-38     	; 0x8172 <LCD_sendCommand+0x45a>
    8198:	16 c0       	rjmp	.+44     	; 0x81c6 <LCD_sendCommand+0x4ae>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    819a:	fe 01       	movw	r30, r28
    819c:	ff 96       	adiw	r30, 0x3f	; 63
    819e:	60 81       	ld	r22, Z
    81a0:	71 81       	ldd	r23, Z+1	; 0x01
    81a2:	82 81       	ldd	r24, Z+2	; 0x02
    81a4:	93 81       	ldd	r25, Z+3	; 0x03
    81a6:	0e 94 65 00 	call	0xca	; 0xca <__fixunssfsi>
    81aa:	dc 01       	movw	r26, r24
    81ac:	cb 01       	movw	r24, r22
    81ae:	9e af       	std	Y+62, r25	; 0x3e
    81b0:	8d af       	std	Y+61, r24	; 0x3d
    81b2:	8d ad       	ldd	r24, Y+61	; 0x3d
    81b4:	9e ad       	ldd	r25, Y+62	; 0x3e
    81b6:	9a af       	std	Y+58, r25	; 0x3a
    81b8:	89 af       	std	Y+57, r24	; 0x39
    81ba:	89 ad       	ldd	r24, Y+57	; 0x39
    81bc:	9a ad       	ldd	r25, Y+58	; 0x3a
    81be:	01 97       	sbiw	r24, 0x01	; 1
    81c0:	f1 f7       	brne	.-4      	; 0x81be <LCD_sendCommand+0x4a6>
    81c2:	9a af       	std	Y+58, r25	; 0x3a
    81c4:	89 af       	std	Y+57, r24	; 0x39

	_delay_ms(1); /* delay for processing Tdsw = 100ns */
	GPIO_writePin(LCD_E_PORT_ID,LCD_E_PIN_ID,LOGIC_LOW); /* Disable LCD E=0 */
    81c6:	83 e0       	ldi	r24, 0x03	; 3
    81c8:	62 e0       	ldi	r22, 0x02	; 2
    81ca:	40 e0       	ldi	r20, 0x00	; 0
    81cc:	0e 94 46 39 	call	0x728c	; 0x728c <GPIO_writePin>
    81d0:	80 e0       	ldi	r24, 0x00	; 0
    81d2:	90 e0       	ldi	r25, 0x00	; 0
    81d4:	a0 e8       	ldi	r26, 0x80	; 128
    81d6:	bf e3       	ldi	r27, 0x3F	; 63
    81d8:	8d ab       	std	Y+53, r24	; 0x35
    81da:	9e ab       	std	Y+54, r25	; 0x36
    81dc:	af ab       	std	Y+55, r26	; 0x37
    81de:	b8 af       	std	Y+56, r27	; 0x38
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    81e0:	6d a9       	ldd	r22, Y+53	; 0x35
    81e2:	7e a9       	ldd	r23, Y+54	; 0x36
    81e4:	8f a9       	ldd	r24, Y+55	; 0x37
    81e6:	98 ad       	ldd	r25, Y+56	; 0x38
    81e8:	20 e0       	ldi	r18, 0x00	; 0
    81ea:	30 e0       	ldi	r19, 0x00	; 0
    81ec:	4a e7       	ldi	r20, 0x7A	; 122
    81ee:	55 e4       	ldi	r21, 0x45	; 69
    81f0:	0e 94 3b 02 	call	0x476	; 0x476 <__mulsf3>
    81f4:	dc 01       	movw	r26, r24
    81f6:	cb 01       	movw	r24, r22
    81f8:	89 ab       	std	Y+49, r24	; 0x31
    81fa:	9a ab       	std	Y+50, r25	; 0x32
    81fc:	ab ab       	std	Y+51, r26	; 0x33
    81fe:	bc ab       	std	Y+52, r27	; 0x34
	if (__tmp < 1.0)
    8200:	69 a9       	ldd	r22, Y+49	; 0x31
    8202:	7a a9       	ldd	r23, Y+50	; 0x32
    8204:	8b a9       	ldd	r24, Y+51	; 0x33
    8206:	9c a9       	ldd	r25, Y+52	; 0x34
    8208:	20 e0       	ldi	r18, 0x00	; 0
    820a:	30 e0       	ldi	r19, 0x00	; 0
    820c:	40 e8       	ldi	r20, 0x80	; 128
    820e:	5f e3       	ldi	r21, 0x3F	; 63
    8210:	0e 94 41 04 	call	0x882	; 0x882 <__ltsf2>
    8214:	88 23       	and	r24, r24
    8216:	2c f4       	brge	.+10     	; 0x8222 <LCD_sendCommand+0x50a>
		__ticks = 1;
    8218:	81 e0       	ldi	r24, 0x01	; 1
    821a:	90 e0       	ldi	r25, 0x00	; 0
    821c:	98 ab       	std	Y+48, r25	; 0x30
    821e:	8f a7       	std	Y+47, r24	; 0x2f
    8220:	3f c0       	rjmp	.+126    	; 0x82a0 <LCD_sendCommand+0x588>
	else if (__tmp > 65535)
    8222:	69 a9       	ldd	r22, Y+49	; 0x31
    8224:	7a a9       	ldd	r23, Y+50	; 0x32
    8226:	8b a9       	ldd	r24, Y+51	; 0x33
    8228:	9c a9       	ldd	r25, Y+52	; 0x34
    822a:	20 e0       	ldi	r18, 0x00	; 0
    822c:	3f ef       	ldi	r19, 0xFF	; 255
    822e:	4f e7       	ldi	r20, 0x7F	; 127
    8230:	57 e4       	ldi	r21, 0x47	; 71
    8232:	0e 94 e1 03 	call	0x7c2	; 0x7c2 <__gtsf2>
    8236:	18 16       	cp	r1, r24
    8238:	4c f5       	brge	.+82     	; 0x828c <LCD_sendCommand+0x574>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    823a:	6d a9       	ldd	r22, Y+53	; 0x35
    823c:	7e a9       	ldd	r23, Y+54	; 0x36
    823e:	8f a9       	ldd	r24, Y+55	; 0x37
    8240:	98 ad       	ldd	r25, Y+56	; 0x38
    8242:	20 e0       	ldi	r18, 0x00	; 0
    8244:	30 e0       	ldi	r19, 0x00	; 0
    8246:	40 e2       	ldi	r20, 0x20	; 32
    8248:	51 e4       	ldi	r21, 0x41	; 65
    824a:	0e 94 3b 02 	call	0x476	; 0x476 <__mulsf3>
    824e:	dc 01       	movw	r26, r24
    8250:	cb 01       	movw	r24, r22
    8252:	bc 01       	movw	r22, r24
    8254:	cd 01       	movw	r24, r26
    8256:	0e 94 65 00 	call	0xca	; 0xca <__fixunssfsi>
    825a:	dc 01       	movw	r26, r24
    825c:	cb 01       	movw	r24, r22
    825e:	98 ab       	std	Y+48, r25	; 0x30
    8260:	8f a7       	std	Y+47, r24	; 0x2f
    8262:	0f c0       	rjmp	.+30     	; 0x8282 <LCD_sendCommand+0x56a>
    8264:	80 e9       	ldi	r24, 0x90	; 144
    8266:	91 e0       	ldi	r25, 0x01	; 1
    8268:	9e a7       	std	Y+46, r25	; 0x2e
    826a:	8d a7       	std	Y+45, r24	; 0x2d
    826c:	8d a5       	ldd	r24, Y+45	; 0x2d
    826e:	9e a5       	ldd	r25, Y+46	; 0x2e
    8270:	01 97       	sbiw	r24, 0x01	; 1
    8272:	f1 f7       	brne	.-4      	; 0x8270 <LCD_sendCommand+0x558>
    8274:	9e a7       	std	Y+46, r25	; 0x2e
    8276:	8d a7       	std	Y+45, r24	; 0x2d
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    8278:	8f a5       	ldd	r24, Y+47	; 0x2f
    827a:	98 a9       	ldd	r25, Y+48	; 0x30
    827c:	01 97       	sbiw	r24, 0x01	; 1
    827e:	98 ab       	std	Y+48, r25	; 0x30
    8280:	8f a7       	std	Y+47, r24	; 0x2f
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    8282:	8f a5       	ldd	r24, Y+47	; 0x2f
    8284:	98 a9       	ldd	r25, Y+48	; 0x30
    8286:	00 97       	sbiw	r24, 0x00	; 0
    8288:	69 f7       	brne	.-38     	; 0x8264 <LCD_sendCommand+0x54c>
    828a:	14 c0       	rjmp	.+40     	; 0x82b4 <LCD_sendCommand+0x59c>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    828c:	69 a9       	ldd	r22, Y+49	; 0x31
    828e:	7a a9       	ldd	r23, Y+50	; 0x32
    8290:	8b a9       	ldd	r24, Y+51	; 0x33
    8292:	9c a9       	ldd	r25, Y+52	; 0x34
    8294:	0e 94 65 00 	call	0xca	; 0xca <__fixunssfsi>
    8298:	dc 01       	movw	r26, r24
    829a:	cb 01       	movw	r24, r22
    829c:	98 ab       	std	Y+48, r25	; 0x30
    829e:	8f a7       	std	Y+47, r24	; 0x2f
    82a0:	8f a5       	ldd	r24, Y+47	; 0x2f
    82a2:	98 a9       	ldd	r25, Y+48	; 0x30
    82a4:	9c a7       	std	Y+44, r25	; 0x2c
    82a6:	8b a7       	std	Y+43, r24	; 0x2b
    82a8:	8b a5       	ldd	r24, Y+43	; 0x2b
    82aa:	9c a5       	ldd	r25, Y+44	; 0x2c
    82ac:	01 97       	sbiw	r24, 0x01	; 1
    82ae:	f1 f7       	brne	.-4      	; 0x82ac <LCD_sendCommand+0x594>
    82b0:	9c a7       	std	Y+44, r25	; 0x2c
    82b2:	8b a7       	std	Y+43, r24	; 0x2b
	_delay_ms(1); /* delay for processing Th = 13ns */
	GPIO_writePin(LCD_E_PORT_ID,LCD_E_PIN_ID,LOGIC_HIGH); /* Enable LCD E=1 */
    82b4:	83 e0       	ldi	r24, 0x03	; 3
    82b6:	62 e0       	ldi	r22, 0x02	; 2
    82b8:	41 e0       	ldi	r20, 0x01	; 1
    82ba:	0e 94 46 39 	call	0x728c	; 0x728c <GPIO_writePin>
    82be:	80 e0       	ldi	r24, 0x00	; 0
    82c0:	90 e0       	ldi	r25, 0x00	; 0
    82c2:	a0 e8       	ldi	r26, 0x80	; 128
    82c4:	bf e3       	ldi	r27, 0x3F	; 63
    82c6:	8f a3       	std	Y+39, r24	; 0x27
    82c8:	98 a7       	std	Y+40, r25	; 0x28
    82ca:	a9 a7       	std	Y+41, r26	; 0x29
    82cc:	ba a7       	std	Y+42, r27	; 0x2a
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    82ce:	6f a1       	ldd	r22, Y+39	; 0x27
    82d0:	78 a5       	ldd	r23, Y+40	; 0x28
    82d2:	89 a5       	ldd	r24, Y+41	; 0x29
    82d4:	9a a5       	ldd	r25, Y+42	; 0x2a
    82d6:	20 e0       	ldi	r18, 0x00	; 0
    82d8:	30 e0       	ldi	r19, 0x00	; 0
    82da:	4a e7       	ldi	r20, 0x7A	; 122
    82dc:	55 e4       	ldi	r21, 0x45	; 69
    82de:	0e 94 3b 02 	call	0x476	; 0x476 <__mulsf3>
    82e2:	dc 01       	movw	r26, r24
    82e4:	cb 01       	movw	r24, r22
    82e6:	8b a3       	std	Y+35, r24	; 0x23
    82e8:	9c a3       	std	Y+36, r25	; 0x24
    82ea:	ad a3       	std	Y+37, r26	; 0x25
    82ec:	be a3       	std	Y+38, r27	; 0x26
	if (__tmp < 1.0)
    82ee:	6b a1       	ldd	r22, Y+35	; 0x23
    82f0:	7c a1       	ldd	r23, Y+36	; 0x24
    82f2:	8d a1       	ldd	r24, Y+37	; 0x25
    82f4:	9e a1       	ldd	r25, Y+38	; 0x26
    82f6:	20 e0       	ldi	r18, 0x00	; 0
    82f8:	30 e0       	ldi	r19, 0x00	; 0
    82fa:	40 e8       	ldi	r20, 0x80	; 128
    82fc:	5f e3       	ldi	r21, 0x3F	; 63
    82fe:	0e 94 41 04 	call	0x882	; 0x882 <__ltsf2>
    8302:	88 23       	and	r24, r24
    8304:	2c f4       	brge	.+10     	; 0x8310 <LCD_sendCommand+0x5f8>
		__ticks = 1;
    8306:	81 e0       	ldi	r24, 0x01	; 1
    8308:	90 e0       	ldi	r25, 0x00	; 0
    830a:	9a a3       	std	Y+34, r25	; 0x22
    830c:	89 a3       	std	Y+33, r24	; 0x21
    830e:	3f c0       	rjmp	.+126    	; 0x838e <LCD_sendCommand+0x676>
	else if (__tmp > 65535)
    8310:	6b a1       	ldd	r22, Y+35	; 0x23
    8312:	7c a1       	ldd	r23, Y+36	; 0x24
    8314:	8d a1       	ldd	r24, Y+37	; 0x25
    8316:	9e a1       	ldd	r25, Y+38	; 0x26
    8318:	20 e0       	ldi	r18, 0x00	; 0
    831a:	3f ef       	ldi	r19, 0xFF	; 255
    831c:	4f e7       	ldi	r20, 0x7F	; 127
    831e:	57 e4       	ldi	r21, 0x47	; 71
    8320:	0e 94 e1 03 	call	0x7c2	; 0x7c2 <__gtsf2>
    8324:	18 16       	cp	r1, r24
    8326:	4c f5       	brge	.+82     	; 0x837a <LCD_sendCommand+0x662>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    8328:	6f a1       	ldd	r22, Y+39	; 0x27
    832a:	78 a5       	ldd	r23, Y+40	; 0x28
    832c:	89 a5       	ldd	r24, Y+41	; 0x29
    832e:	9a a5       	ldd	r25, Y+42	; 0x2a
    8330:	20 e0       	ldi	r18, 0x00	; 0
    8332:	30 e0       	ldi	r19, 0x00	; 0
    8334:	40 e2       	ldi	r20, 0x20	; 32
    8336:	51 e4       	ldi	r21, 0x41	; 65
    8338:	0e 94 3b 02 	call	0x476	; 0x476 <__mulsf3>
    833c:	dc 01       	movw	r26, r24
    833e:	cb 01       	movw	r24, r22
    8340:	bc 01       	movw	r22, r24
    8342:	cd 01       	movw	r24, r26
    8344:	0e 94 65 00 	call	0xca	; 0xca <__fixunssfsi>
    8348:	dc 01       	movw	r26, r24
    834a:	cb 01       	movw	r24, r22
    834c:	9a a3       	std	Y+34, r25	; 0x22
    834e:	89 a3       	std	Y+33, r24	; 0x21
    8350:	0f c0       	rjmp	.+30     	; 0x8370 <LCD_sendCommand+0x658>
    8352:	80 e9       	ldi	r24, 0x90	; 144
    8354:	91 e0       	ldi	r25, 0x01	; 1
    8356:	98 a3       	std	Y+32, r25	; 0x20
    8358:	8f 8f       	std	Y+31, r24	; 0x1f
    835a:	8f 8d       	ldd	r24, Y+31	; 0x1f
    835c:	98 a1       	ldd	r25, Y+32	; 0x20
    835e:	01 97       	sbiw	r24, 0x01	; 1
    8360:	f1 f7       	brne	.-4      	; 0x835e <LCD_sendCommand+0x646>
    8362:	98 a3       	std	Y+32, r25	; 0x20
    8364:	8f 8f       	std	Y+31, r24	; 0x1f
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    8366:	89 a1       	ldd	r24, Y+33	; 0x21
    8368:	9a a1       	ldd	r25, Y+34	; 0x22
    836a:	01 97       	sbiw	r24, 0x01	; 1
    836c:	9a a3       	std	Y+34, r25	; 0x22
    836e:	89 a3       	std	Y+33, r24	; 0x21
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    8370:	89 a1       	ldd	r24, Y+33	; 0x21
    8372:	9a a1       	ldd	r25, Y+34	; 0x22
    8374:	00 97       	sbiw	r24, 0x00	; 0
    8376:	69 f7       	brne	.-38     	; 0x8352 <LCD_sendCommand+0x63a>
    8378:	14 c0       	rjmp	.+40     	; 0x83a2 <LCD_sendCommand+0x68a>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    837a:	6b a1       	ldd	r22, Y+35	; 0x23
    837c:	7c a1       	ldd	r23, Y+36	; 0x24
    837e:	8d a1       	ldd	r24, Y+37	; 0x25
    8380:	9e a1       	ldd	r25, Y+38	; 0x26
    8382:	0e 94 65 00 	call	0xca	; 0xca <__fixunssfsi>
    8386:	dc 01       	movw	r26, r24
    8388:	cb 01       	movw	r24, r22
    838a:	9a a3       	std	Y+34, r25	; 0x22
    838c:	89 a3       	std	Y+33, r24	; 0x21
    838e:	89 a1       	ldd	r24, Y+33	; 0x21
    8390:	9a a1       	ldd	r25, Y+34	; 0x22
    8392:	9e 8f       	std	Y+30, r25	; 0x1e
    8394:	8d 8f       	std	Y+29, r24	; 0x1d
    8396:	8d 8d       	ldd	r24, Y+29	; 0x1d
    8398:	9e 8d       	ldd	r25, Y+30	; 0x1e
    839a:	01 97       	sbiw	r24, 0x01	; 1
    839c:	f1 f7       	brne	.-4      	; 0x839a <LCD_sendCommand+0x682>
    839e:	9e 8f       	std	Y+30, r25	; 0x1e
    83a0:	8d 8f       	std	Y+29, r24	; 0x1d
	_delay_ms(1); /* delay for processing Tpw - Tdws = 190ns */

	GPIO_writePin(LCD_DATA_PORT_ID,LCD_DB4_PIN_ID,GET_BIT(command,0));
    83a2:	fe 01       	movw	r30, r28
    83a4:	ed 59       	subi	r30, 0x9D	; 157
    83a6:	ff 4f       	sbci	r31, 0xFF	; 255
    83a8:	80 81       	ld	r24, Z
    83aa:	98 2f       	mov	r25, r24
    83ac:	91 70       	andi	r25, 0x01	; 1
    83ae:	83 e0       	ldi	r24, 0x03	; 3
    83b0:	64 e0       	ldi	r22, 0x04	; 4
    83b2:	49 2f       	mov	r20, r25
    83b4:	0e 94 46 39 	call	0x728c	; 0x728c <GPIO_writePin>
	GPIO_writePin(LCD_DATA_PORT_ID,LCD_DB5_PIN_ID,GET_BIT(command,1));
    83b8:	fe 01       	movw	r30, r28
    83ba:	ed 59       	subi	r30, 0x9D	; 157
    83bc:	ff 4f       	sbci	r31, 0xFF	; 255
    83be:	80 81       	ld	r24, Z
    83c0:	88 2f       	mov	r24, r24
    83c2:	90 e0       	ldi	r25, 0x00	; 0
    83c4:	82 70       	andi	r24, 0x02	; 2
    83c6:	90 70       	andi	r25, 0x00	; 0
    83c8:	95 95       	asr	r25
    83ca:	87 95       	ror	r24
    83cc:	98 2f       	mov	r25, r24
    83ce:	83 e0       	ldi	r24, 0x03	; 3
    83d0:	65 e0       	ldi	r22, 0x05	; 5
    83d2:	49 2f       	mov	r20, r25
    83d4:	0e 94 46 39 	call	0x728c	; 0x728c <GPIO_writePin>
	GPIO_writePin(LCD_DATA_PORT_ID,LCD_DB6_PIN_ID,GET_BIT(command,2));
    83d8:	fe 01       	movw	r30, r28
    83da:	ed 59       	subi	r30, 0x9D	; 157
    83dc:	ff 4f       	sbci	r31, 0xFF	; 255
    83de:	80 81       	ld	r24, Z
    83e0:	88 2f       	mov	r24, r24
    83e2:	90 e0       	ldi	r25, 0x00	; 0
    83e4:	84 70       	andi	r24, 0x04	; 4
    83e6:	90 70       	andi	r25, 0x00	; 0
    83e8:	95 95       	asr	r25
    83ea:	87 95       	ror	r24
    83ec:	95 95       	asr	r25
    83ee:	87 95       	ror	r24
    83f0:	98 2f       	mov	r25, r24
    83f2:	83 e0       	ldi	r24, 0x03	; 3
    83f4:	66 e0       	ldi	r22, 0x06	; 6
    83f6:	49 2f       	mov	r20, r25
    83f8:	0e 94 46 39 	call	0x728c	; 0x728c <GPIO_writePin>
	GPIO_writePin(LCD_DATA_PORT_ID,LCD_DB7_PIN_ID,GET_BIT(command,3));
    83fc:	fe 01       	movw	r30, r28
    83fe:	ed 59       	subi	r30, 0x9D	; 157
    8400:	ff 4f       	sbci	r31, 0xFF	; 255
    8402:	80 81       	ld	r24, Z
    8404:	88 2f       	mov	r24, r24
    8406:	90 e0       	ldi	r25, 0x00	; 0
    8408:	88 70       	andi	r24, 0x08	; 8
    840a:	90 70       	andi	r25, 0x00	; 0
    840c:	95 95       	asr	r25
    840e:	87 95       	ror	r24
    8410:	95 95       	asr	r25
    8412:	87 95       	ror	r24
    8414:	95 95       	asr	r25
    8416:	87 95       	ror	r24
    8418:	98 2f       	mov	r25, r24
    841a:	83 e0       	ldi	r24, 0x03	; 3
    841c:	67 e0       	ldi	r22, 0x07	; 7
    841e:	49 2f       	mov	r20, r25
    8420:	0e 94 46 39 	call	0x728c	; 0x728c <GPIO_writePin>
    8424:	80 e0       	ldi	r24, 0x00	; 0
    8426:	90 e0       	ldi	r25, 0x00	; 0
    8428:	a0 e8       	ldi	r26, 0x80	; 128
    842a:	bf e3       	ldi	r27, 0x3F	; 63
    842c:	89 8f       	std	Y+25, r24	; 0x19
    842e:	9a 8f       	std	Y+26, r25	; 0x1a
    8430:	ab 8f       	std	Y+27, r26	; 0x1b
    8432:	bc 8f       	std	Y+28, r27	; 0x1c
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    8434:	69 8d       	ldd	r22, Y+25	; 0x19
    8436:	7a 8d       	ldd	r23, Y+26	; 0x1a
    8438:	8b 8d       	ldd	r24, Y+27	; 0x1b
    843a:	9c 8d       	ldd	r25, Y+28	; 0x1c
    843c:	20 e0       	ldi	r18, 0x00	; 0
    843e:	30 e0       	ldi	r19, 0x00	; 0
    8440:	4a e7       	ldi	r20, 0x7A	; 122
    8442:	55 e4       	ldi	r21, 0x45	; 69
    8444:	0e 94 3b 02 	call	0x476	; 0x476 <__mulsf3>
    8448:	dc 01       	movw	r26, r24
    844a:	cb 01       	movw	r24, r22
    844c:	8d 8b       	std	Y+21, r24	; 0x15
    844e:	9e 8b       	std	Y+22, r25	; 0x16
    8450:	af 8b       	std	Y+23, r26	; 0x17
    8452:	b8 8f       	std	Y+24, r27	; 0x18
	if (__tmp < 1.0)
    8454:	6d 89       	ldd	r22, Y+21	; 0x15
    8456:	7e 89       	ldd	r23, Y+22	; 0x16
    8458:	8f 89       	ldd	r24, Y+23	; 0x17
    845a:	98 8d       	ldd	r25, Y+24	; 0x18
    845c:	20 e0       	ldi	r18, 0x00	; 0
    845e:	30 e0       	ldi	r19, 0x00	; 0
    8460:	40 e8       	ldi	r20, 0x80	; 128
    8462:	5f e3       	ldi	r21, 0x3F	; 63
    8464:	0e 94 41 04 	call	0x882	; 0x882 <__ltsf2>
    8468:	88 23       	and	r24, r24
    846a:	2c f4       	brge	.+10     	; 0x8476 <LCD_sendCommand+0x75e>
		__ticks = 1;
    846c:	81 e0       	ldi	r24, 0x01	; 1
    846e:	90 e0       	ldi	r25, 0x00	; 0
    8470:	9c 8b       	std	Y+20, r25	; 0x14
    8472:	8b 8b       	std	Y+19, r24	; 0x13
    8474:	3f c0       	rjmp	.+126    	; 0x84f4 <LCD_sendCommand+0x7dc>
	else if (__tmp > 65535)
    8476:	6d 89       	ldd	r22, Y+21	; 0x15
    8478:	7e 89       	ldd	r23, Y+22	; 0x16
    847a:	8f 89       	ldd	r24, Y+23	; 0x17
    847c:	98 8d       	ldd	r25, Y+24	; 0x18
    847e:	20 e0       	ldi	r18, 0x00	; 0
    8480:	3f ef       	ldi	r19, 0xFF	; 255
    8482:	4f e7       	ldi	r20, 0x7F	; 127
    8484:	57 e4       	ldi	r21, 0x47	; 71
    8486:	0e 94 e1 03 	call	0x7c2	; 0x7c2 <__gtsf2>
    848a:	18 16       	cp	r1, r24
    848c:	4c f5       	brge	.+82     	; 0x84e0 <LCD_sendCommand+0x7c8>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    848e:	69 8d       	ldd	r22, Y+25	; 0x19
    8490:	7a 8d       	ldd	r23, Y+26	; 0x1a
    8492:	8b 8d       	ldd	r24, Y+27	; 0x1b
    8494:	9c 8d       	ldd	r25, Y+28	; 0x1c
    8496:	20 e0       	ldi	r18, 0x00	; 0
    8498:	30 e0       	ldi	r19, 0x00	; 0
    849a:	40 e2       	ldi	r20, 0x20	; 32
    849c:	51 e4       	ldi	r21, 0x41	; 65
    849e:	0e 94 3b 02 	call	0x476	; 0x476 <__mulsf3>
    84a2:	dc 01       	movw	r26, r24
    84a4:	cb 01       	movw	r24, r22
    84a6:	bc 01       	movw	r22, r24
    84a8:	cd 01       	movw	r24, r26
    84aa:	0e 94 65 00 	call	0xca	; 0xca <__fixunssfsi>
    84ae:	dc 01       	movw	r26, r24
    84b0:	cb 01       	movw	r24, r22
    84b2:	9c 8b       	std	Y+20, r25	; 0x14
    84b4:	8b 8b       	std	Y+19, r24	; 0x13
    84b6:	0f c0       	rjmp	.+30     	; 0x84d6 <LCD_sendCommand+0x7be>
    84b8:	80 e9       	ldi	r24, 0x90	; 144
    84ba:	91 e0       	ldi	r25, 0x01	; 1
    84bc:	9a 8b       	std	Y+18, r25	; 0x12
    84be:	89 8b       	std	Y+17, r24	; 0x11
    84c0:	89 89       	ldd	r24, Y+17	; 0x11
    84c2:	9a 89       	ldd	r25, Y+18	; 0x12
    84c4:	01 97       	sbiw	r24, 0x01	; 1
    84c6:	f1 f7       	brne	.-4      	; 0x84c4 <LCD_sendCommand+0x7ac>
    84c8:	9a 8b       	std	Y+18, r25	; 0x12
    84ca:	89 8b       	std	Y+17, r24	; 0x11
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    84cc:	8b 89       	ldd	r24, Y+19	; 0x13
    84ce:	9c 89       	ldd	r25, Y+20	; 0x14
    84d0:	01 97       	sbiw	r24, 0x01	; 1
    84d2:	9c 8b       	std	Y+20, r25	; 0x14
    84d4:	8b 8b       	std	Y+19, r24	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    84d6:	8b 89       	ldd	r24, Y+19	; 0x13
    84d8:	9c 89       	ldd	r25, Y+20	; 0x14
    84da:	00 97       	sbiw	r24, 0x00	; 0
    84dc:	69 f7       	brne	.-38     	; 0x84b8 <LCD_sendCommand+0x7a0>
    84de:	14 c0       	rjmp	.+40     	; 0x8508 <LCD_sendCommand+0x7f0>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    84e0:	6d 89       	ldd	r22, Y+21	; 0x15
    84e2:	7e 89       	ldd	r23, Y+22	; 0x16
    84e4:	8f 89       	ldd	r24, Y+23	; 0x17
    84e6:	98 8d       	ldd	r25, Y+24	; 0x18
    84e8:	0e 94 65 00 	call	0xca	; 0xca <__fixunssfsi>
    84ec:	dc 01       	movw	r26, r24
    84ee:	cb 01       	movw	r24, r22
    84f0:	9c 8b       	std	Y+20, r25	; 0x14
    84f2:	8b 8b       	std	Y+19, r24	; 0x13
    84f4:	8b 89       	ldd	r24, Y+19	; 0x13
    84f6:	9c 89       	ldd	r25, Y+20	; 0x14
    84f8:	98 8b       	std	Y+16, r25	; 0x10
    84fa:	8f 87       	std	Y+15, r24	; 0x0f
    84fc:	8f 85       	ldd	r24, Y+15	; 0x0f
    84fe:	98 89       	ldd	r25, Y+16	; 0x10
    8500:	01 97       	sbiw	r24, 0x01	; 1
    8502:	f1 f7       	brne	.-4      	; 0x8500 <LCD_sendCommand+0x7e8>
    8504:	98 8b       	std	Y+16, r25	; 0x10
    8506:	8f 87       	std	Y+15, r24	; 0x0f

	_delay_ms(1); /* delay for processing Tdsw = 100ns */
	GPIO_writePin(LCD_E_PORT_ID,LCD_E_PIN_ID,LOGIC_LOW); /* Disable LCD E=0 */
    8508:	83 e0       	ldi	r24, 0x03	; 3
    850a:	62 e0       	ldi	r22, 0x02	; 2
    850c:	40 e0       	ldi	r20, 0x00	; 0
    850e:	0e 94 46 39 	call	0x728c	; 0x728c <GPIO_writePin>
    8512:	80 e0       	ldi	r24, 0x00	; 0
    8514:	90 e0       	ldi	r25, 0x00	; 0
    8516:	a0 e8       	ldi	r26, 0x80	; 128
    8518:	bf e3       	ldi	r27, 0x3F	; 63
    851a:	8b 87       	std	Y+11, r24	; 0x0b
    851c:	9c 87       	std	Y+12, r25	; 0x0c
    851e:	ad 87       	std	Y+13, r26	; 0x0d
    8520:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    8522:	6b 85       	ldd	r22, Y+11	; 0x0b
    8524:	7c 85       	ldd	r23, Y+12	; 0x0c
    8526:	8d 85       	ldd	r24, Y+13	; 0x0d
    8528:	9e 85       	ldd	r25, Y+14	; 0x0e
    852a:	20 e0       	ldi	r18, 0x00	; 0
    852c:	30 e0       	ldi	r19, 0x00	; 0
    852e:	4a e7       	ldi	r20, 0x7A	; 122
    8530:	55 e4       	ldi	r21, 0x45	; 69
    8532:	0e 94 3b 02 	call	0x476	; 0x476 <__mulsf3>
    8536:	dc 01       	movw	r26, r24
    8538:	cb 01       	movw	r24, r22
    853a:	8f 83       	std	Y+7, r24	; 0x07
    853c:	98 87       	std	Y+8, r25	; 0x08
    853e:	a9 87       	std	Y+9, r26	; 0x09
    8540:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    8542:	6f 81       	ldd	r22, Y+7	; 0x07
    8544:	78 85       	ldd	r23, Y+8	; 0x08
    8546:	89 85       	ldd	r24, Y+9	; 0x09
    8548:	9a 85       	ldd	r25, Y+10	; 0x0a
    854a:	20 e0       	ldi	r18, 0x00	; 0
    854c:	30 e0       	ldi	r19, 0x00	; 0
    854e:	40 e8       	ldi	r20, 0x80	; 128
    8550:	5f e3       	ldi	r21, 0x3F	; 63
    8552:	0e 94 41 04 	call	0x882	; 0x882 <__ltsf2>
    8556:	88 23       	and	r24, r24
    8558:	2c f4       	brge	.+10     	; 0x8564 <LCD_sendCommand+0x84c>
		__ticks = 1;
    855a:	81 e0       	ldi	r24, 0x01	; 1
    855c:	90 e0       	ldi	r25, 0x00	; 0
    855e:	9e 83       	std	Y+6, r25	; 0x06
    8560:	8d 83       	std	Y+5, r24	; 0x05
    8562:	3f c0       	rjmp	.+126    	; 0x85e2 <LCD_sendCommand+0x8ca>
	else if (__tmp > 65535)
    8564:	6f 81       	ldd	r22, Y+7	; 0x07
    8566:	78 85       	ldd	r23, Y+8	; 0x08
    8568:	89 85       	ldd	r24, Y+9	; 0x09
    856a:	9a 85       	ldd	r25, Y+10	; 0x0a
    856c:	20 e0       	ldi	r18, 0x00	; 0
    856e:	3f ef       	ldi	r19, 0xFF	; 255
    8570:	4f e7       	ldi	r20, 0x7F	; 127
    8572:	57 e4       	ldi	r21, 0x47	; 71
    8574:	0e 94 e1 03 	call	0x7c2	; 0x7c2 <__gtsf2>
    8578:	18 16       	cp	r1, r24
    857a:	4c f5       	brge	.+82     	; 0x85ce <LCD_sendCommand+0x8b6>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    857c:	6b 85       	ldd	r22, Y+11	; 0x0b
    857e:	7c 85       	ldd	r23, Y+12	; 0x0c
    8580:	8d 85       	ldd	r24, Y+13	; 0x0d
    8582:	9e 85       	ldd	r25, Y+14	; 0x0e
    8584:	20 e0       	ldi	r18, 0x00	; 0
    8586:	30 e0       	ldi	r19, 0x00	; 0
    8588:	40 e2       	ldi	r20, 0x20	; 32
    858a:	51 e4       	ldi	r21, 0x41	; 65
    858c:	0e 94 3b 02 	call	0x476	; 0x476 <__mulsf3>
    8590:	dc 01       	movw	r26, r24
    8592:	cb 01       	movw	r24, r22
    8594:	bc 01       	movw	r22, r24
    8596:	cd 01       	movw	r24, r26
    8598:	0e 94 65 00 	call	0xca	; 0xca <__fixunssfsi>
    859c:	dc 01       	movw	r26, r24
    859e:	cb 01       	movw	r24, r22
    85a0:	9e 83       	std	Y+6, r25	; 0x06
    85a2:	8d 83       	std	Y+5, r24	; 0x05
    85a4:	0f c0       	rjmp	.+30     	; 0x85c4 <LCD_sendCommand+0x8ac>
    85a6:	80 e9       	ldi	r24, 0x90	; 144
    85a8:	91 e0       	ldi	r25, 0x01	; 1
    85aa:	9c 83       	std	Y+4, r25	; 0x04
    85ac:	8b 83       	std	Y+3, r24	; 0x03
    85ae:	8b 81       	ldd	r24, Y+3	; 0x03
    85b0:	9c 81       	ldd	r25, Y+4	; 0x04
    85b2:	01 97       	sbiw	r24, 0x01	; 1
    85b4:	f1 f7       	brne	.-4      	; 0x85b2 <LCD_sendCommand+0x89a>
    85b6:	9c 83       	std	Y+4, r25	; 0x04
    85b8:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    85ba:	8d 81       	ldd	r24, Y+5	; 0x05
    85bc:	9e 81       	ldd	r25, Y+6	; 0x06
    85be:	01 97       	sbiw	r24, 0x01	; 1
    85c0:	9e 83       	std	Y+6, r25	; 0x06
    85c2:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    85c4:	8d 81       	ldd	r24, Y+5	; 0x05
    85c6:	9e 81       	ldd	r25, Y+6	; 0x06
    85c8:	00 97       	sbiw	r24, 0x00	; 0
    85ca:	69 f7       	brne	.-38     	; 0x85a6 <LCD_sendCommand+0x88e>
    85cc:	14 c0       	rjmp	.+40     	; 0x85f6 <LCD_sendCommand+0x8de>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    85ce:	6f 81       	ldd	r22, Y+7	; 0x07
    85d0:	78 85       	ldd	r23, Y+8	; 0x08
    85d2:	89 85       	ldd	r24, Y+9	; 0x09
    85d4:	9a 85       	ldd	r25, Y+10	; 0x0a
    85d6:	0e 94 65 00 	call	0xca	; 0xca <__fixunssfsi>
    85da:	dc 01       	movw	r26, r24
    85dc:	cb 01       	movw	r24, r22
    85de:	9e 83       	std	Y+6, r25	; 0x06
    85e0:	8d 83       	std	Y+5, r24	; 0x05
    85e2:	8d 81       	ldd	r24, Y+5	; 0x05
    85e4:	9e 81       	ldd	r25, Y+6	; 0x06
    85e6:	9a 83       	std	Y+2, r25	; 0x02
    85e8:	89 83       	std	Y+1, r24	; 0x01
    85ea:	89 81       	ldd	r24, Y+1	; 0x01
    85ec:	9a 81       	ldd	r25, Y+2	; 0x02
    85ee:	01 97       	sbiw	r24, 0x01	; 1
    85f0:	f1 f7       	brne	.-4      	; 0x85ee <LCD_sendCommand+0x8d6>
    85f2:	9a 83       	std	Y+2, r25	; 0x02
    85f4:	89 83       	std	Y+1, r24	; 0x01
	GPIO_writePort(LCD_DATA_PORT_ID,command); /* out the required command to the data bus D0 --> D7 */
	_delay_ms(1); /* delay for processing Tdsw = 100ns */
	GPIO_writePin(LCD_E_PORT_ID,LCD_E_PIN_ID,LOGIC_LOW); /* Disable LCD E=0 */
	_delay_ms(1); /* delay for processing Th = 13ns */
#endif
}
    85f6:	cd 59       	subi	r28, 0x9D	; 157
    85f8:	df 4f       	sbci	r29, 0xFF	; 255
    85fa:	0f b6       	in	r0, 0x3f	; 63
    85fc:	f8 94       	cli
    85fe:	de bf       	out	0x3e, r29	; 62
    8600:	0f be       	out	0x3f, r0	; 63
    8602:	cd bf       	out	0x3d, r28	; 61
    8604:	cf 91       	pop	r28
    8606:	df 91       	pop	r29
    8608:	1f 91       	pop	r17
    860a:	0f 91       	pop	r16
    860c:	08 95       	ret

0000860e <LCD_displayCharacter>:
/*
 * Description :
 * Display the required character on the screen
 */
void LCD_displayCharacter(uint8 data)
{
    860e:	0f 93       	push	r16
    8610:	1f 93       	push	r17
    8612:	df 93       	push	r29
    8614:	cf 93       	push	r28
    8616:	cd b7       	in	r28, 0x3d	; 61
    8618:	de b7       	in	r29, 0x3e	; 62
    861a:	c3 56       	subi	r28, 0x63	; 99
    861c:	d0 40       	sbci	r29, 0x00	; 0
    861e:	0f b6       	in	r0, 0x3f	; 63
    8620:	f8 94       	cli
    8622:	de bf       	out	0x3e, r29	; 62
    8624:	0f be       	out	0x3f, r0	; 63
    8626:	cd bf       	out	0x3d, r28	; 61
    8628:	fe 01       	movw	r30, r28
    862a:	ed 59       	subi	r30, 0x9D	; 157
    862c:	ff 4f       	sbci	r31, 0xFF	; 255
    862e:	80 83       	st	Z, r24
	GPIO_writePin(LCD_RS_PORT_ID,LCD_RS_PIN_ID,LOGIC_HIGH); /* Data Mode RS=1 */
    8630:	83 e0       	ldi	r24, 0x03	; 3
    8632:	60 e0       	ldi	r22, 0x00	; 0
    8634:	41 e0       	ldi	r20, 0x01	; 1
    8636:	0e 94 46 39 	call	0x728c	; 0x728c <GPIO_writePin>
    863a:	fe 01       	movw	r30, r28
    863c:	e1 5a       	subi	r30, 0xA1	; 161
    863e:	ff 4f       	sbci	r31, 0xFF	; 255
    8640:	80 e0       	ldi	r24, 0x00	; 0
    8642:	90 e0       	ldi	r25, 0x00	; 0
    8644:	a0 e8       	ldi	r26, 0x80	; 128
    8646:	bf e3       	ldi	r27, 0x3F	; 63
    8648:	80 83       	st	Z, r24
    864a:	91 83       	std	Z+1, r25	; 0x01
    864c:	a2 83       	std	Z+2, r26	; 0x02
    864e:	b3 83       	std	Z+3, r27	; 0x03
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    8650:	8e 01       	movw	r16, r28
    8652:	05 5a       	subi	r16, 0xA5	; 165
    8654:	1f 4f       	sbci	r17, 0xFF	; 255
    8656:	fe 01       	movw	r30, r28
    8658:	e1 5a       	subi	r30, 0xA1	; 161
    865a:	ff 4f       	sbci	r31, 0xFF	; 255
    865c:	60 81       	ld	r22, Z
    865e:	71 81       	ldd	r23, Z+1	; 0x01
    8660:	82 81       	ldd	r24, Z+2	; 0x02
    8662:	93 81       	ldd	r25, Z+3	; 0x03
    8664:	20 e0       	ldi	r18, 0x00	; 0
    8666:	30 e0       	ldi	r19, 0x00	; 0
    8668:	4a e7       	ldi	r20, 0x7A	; 122
    866a:	55 e4       	ldi	r21, 0x45	; 69
    866c:	0e 94 3b 02 	call	0x476	; 0x476 <__mulsf3>
    8670:	dc 01       	movw	r26, r24
    8672:	cb 01       	movw	r24, r22
    8674:	f8 01       	movw	r30, r16
    8676:	80 83       	st	Z, r24
    8678:	91 83       	std	Z+1, r25	; 0x01
    867a:	a2 83       	std	Z+2, r26	; 0x02
    867c:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    867e:	fe 01       	movw	r30, r28
    8680:	e5 5a       	subi	r30, 0xA5	; 165
    8682:	ff 4f       	sbci	r31, 0xFF	; 255
    8684:	60 81       	ld	r22, Z
    8686:	71 81       	ldd	r23, Z+1	; 0x01
    8688:	82 81       	ldd	r24, Z+2	; 0x02
    868a:	93 81       	ldd	r25, Z+3	; 0x03
    868c:	20 e0       	ldi	r18, 0x00	; 0
    868e:	30 e0       	ldi	r19, 0x00	; 0
    8690:	40 e8       	ldi	r20, 0x80	; 128
    8692:	5f e3       	ldi	r21, 0x3F	; 63
    8694:	0e 94 41 04 	call	0x882	; 0x882 <__ltsf2>
    8698:	88 23       	and	r24, r24
    869a:	44 f4       	brge	.+16     	; 0x86ac <LCD_displayCharacter+0x9e>
		__ticks = 1;
    869c:	fe 01       	movw	r30, r28
    869e:	e7 5a       	subi	r30, 0xA7	; 167
    86a0:	ff 4f       	sbci	r31, 0xFF	; 255
    86a2:	81 e0       	ldi	r24, 0x01	; 1
    86a4:	90 e0       	ldi	r25, 0x00	; 0
    86a6:	91 83       	std	Z+1, r25	; 0x01
    86a8:	80 83       	st	Z, r24
    86aa:	64 c0       	rjmp	.+200    	; 0x8774 <LCD_displayCharacter+0x166>
	else if (__tmp > 65535)
    86ac:	fe 01       	movw	r30, r28
    86ae:	e5 5a       	subi	r30, 0xA5	; 165
    86b0:	ff 4f       	sbci	r31, 0xFF	; 255
    86b2:	60 81       	ld	r22, Z
    86b4:	71 81       	ldd	r23, Z+1	; 0x01
    86b6:	82 81       	ldd	r24, Z+2	; 0x02
    86b8:	93 81       	ldd	r25, Z+3	; 0x03
    86ba:	20 e0       	ldi	r18, 0x00	; 0
    86bc:	3f ef       	ldi	r19, 0xFF	; 255
    86be:	4f e7       	ldi	r20, 0x7F	; 127
    86c0:	57 e4       	ldi	r21, 0x47	; 71
    86c2:	0e 94 e1 03 	call	0x7c2	; 0x7c2 <__gtsf2>
    86c6:	18 16       	cp	r1, r24
    86c8:	0c f0       	brlt	.+2      	; 0x86cc <LCD_displayCharacter+0xbe>
    86ca:	43 c0       	rjmp	.+134    	; 0x8752 <LCD_displayCharacter+0x144>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    86cc:	fe 01       	movw	r30, r28
    86ce:	e1 5a       	subi	r30, 0xA1	; 161
    86d0:	ff 4f       	sbci	r31, 0xFF	; 255
    86d2:	60 81       	ld	r22, Z
    86d4:	71 81       	ldd	r23, Z+1	; 0x01
    86d6:	82 81       	ldd	r24, Z+2	; 0x02
    86d8:	93 81       	ldd	r25, Z+3	; 0x03
    86da:	20 e0       	ldi	r18, 0x00	; 0
    86dc:	30 e0       	ldi	r19, 0x00	; 0
    86de:	40 e2       	ldi	r20, 0x20	; 32
    86e0:	51 e4       	ldi	r21, 0x41	; 65
    86e2:	0e 94 3b 02 	call	0x476	; 0x476 <__mulsf3>
    86e6:	dc 01       	movw	r26, r24
    86e8:	cb 01       	movw	r24, r22
    86ea:	8e 01       	movw	r16, r28
    86ec:	07 5a       	subi	r16, 0xA7	; 167
    86ee:	1f 4f       	sbci	r17, 0xFF	; 255
    86f0:	bc 01       	movw	r22, r24
    86f2:	cd 01       	movw	r24, r26
    86f4:	0e 94 65 00 	call	0xca	; 0xca <__fixunssfsi>
    86f8:	dc 01       	movw	r26, r24
    86fa:	cb 01       	movw	r24, r22
    86fc:	f8 01       	movw	r30, r16
    86fe:	91 83       	std	Z+1, r25	; 0x01
    8700:	80 83       	st	Z, r24
    8702:	1f c0       	rjmp	.+62     	; 0x8742 <LCD_displayCharacter+0x134>
    8704:	fe 01       	movw	r30, r28
    8706:	e9 5a       	subi	r30, 0xA9	; 169
    8708:	ff 4f       	sbci	r31, 0xFF	; 255
    870a:	80 e9       	ldi	r24, 0x90	; 144
    870c:	91 e0       	ldi	r25, 0x01	; 1
    870e:	91 83       	std	Z+1, r25	; 0x01
    8710:	80 83       	st	Z, r24
    8712:	fe 01       	movw	r30, r28
    8714:	e9 5a       	subi	r30, 0xA9	; 169
    8716:	ff 4f       	sbci	r31, 0xFF	; 255
    8718:	80 81       	ld	r24, Z
    871a:	91 81       	ldd	r25, Z+1	; 0x01
    871c:	01 97       	sbiw	r24, 0x01	; 1
    871e:	f1 f7       	brne	.-4      	; 0x871c <LCD_displayCharacter+0x10e>
    8720:	fe 01       	movw	r30, r28
    8722:	e9 5a       	subi	r30, 0xA9	; 169
    8724:	ff 4f       	sbci	r31, 0xFF	; 255
    8726:	91 83       	std	Z+1, r25	; 0x01
    8728:	80 83       	st	Z, r24
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    872a:	de 01       	movw	r26, r28
    872c:	a7 5a       	subi	r26, 0xA7	; 167
    872e:	bf 4f       	sbci	r27, 0xFF	; 255
    8730:	fe 01       	movw	r30, r28
    8732:	e7 5a       	subi	r30, 0xA7	; 167
    8734:	ff 4f       	sbci	r31, 0xFF	; 255
    8736:	80 81       	ld	r24, Z
    8738:	91 81       	ldd	r25, Z+1	; 0x01
    873a:	01 97       	sbiw	r24, 0x01	; 1
    873c:	11 96       	adiw	r26, 0x01	; 1
    873e:	9c 93       	st	X, r25
    8740:	8e 93       	st	-X, r24
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    8742:	fe 01       	movw	r30, r28
    8744:	e7 5a       	subi	r30, 0xA7	; 167
    8746:	ff 4f       	sbci	r31, 0xFF	; 255
    8748:	80 81       	ld	r24, Z
    874a:	91 81       	ldd	r25, Z+1	; 0x01
    874c:	00 97       	sbiw	r24, 0x00	; 0
    874e:	d1 f6       	brne	.-76     	; 0x8704 <LCD_displayCharacter+0xf6>
    8750:	27 c0       	rjmp	.+78     	; 0x87a0 <LCD_displayCharacter+0x192>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    8752:	8e 01       	movw	r16, r28
    8754:	07 5a       	subi	r16, 0xA7	; 167
    8756:	1f 4f       	sbci	r17, 0xFF	; 255
    8758:	fe 01       	movw	r30, r28
    875a:	e5 5a       	subi	r30, 0xA5	; 165
    875c:	ff 4f       	sbci	r31, 0xFF	; 255
    875e:	60 81       	ld	r22, Z
    8760:	71 81       	ldd	r23, Z+1	; 0x01
    8762:	82 81       	ldd	r24, Z+2	; 0x02
    8764:	93 81       	ldd	r25, Z+3	; 0x03
    8766:	0e 94 65 00 	call	0xca	; 0xca <__fixunssfsi>
    876a:	dc 01       	movw	r26, r24
    876c:	cb 01       	movw	r24, r22
    876e:	f8 01       	movw	r30, r16
    8770:	91 83       	std	Z+1, r25	; 0x01
    8772:	80 83       	st	Z, r24
    8774:	de 01       	movw	r26, r28
    8776:	ab 5a       	subi	r26, 0xAB	; 171
    8778:	bf 4f       	sbci	r27, 0xFF	; 255
    877a:	fe 01       	movw	r30, r28
    877c:	e7 5a       	subi	r30, 0xA7	; 167
    877e:	ff 4f       	sbci	r31, 0xFF	; 255
    8780:	80 81       	ld	r24, Z
    8782:	91 81       	ldd	r25, Z+1	; 0x01
    8784:	8d 93       	st	X+, r24
    8786:	9c 93       	st	X, r25
    8788:	fe 01       	movw	r30, r28
    878a:	eb 5a       	subi	r30, 0xAB	; 171
    878c:	ff 4f       	sbci	r31, 0xFF	; 255
    878e:	80 81       	ld	r24, Z
    8790:	91 81       	ldd	r25, Z+1	; 0x01
    8792:	01 97       	sbiw	r24, 0x01	; 1
    8794:	f1 f7       	brne	.-4      	; 0x8792 <LCD_displayCharacter+0x184>
    8796:	fe 01       	movw	r30, r28
    8798:	eb 5a       	subi	r30, 0xAB	; 171
    879a:	ff 4f       	sbci	r31, 0xFF	; 255
    879c:	91 83       	std	Z+1, r25	; 0x01
    879e:	80 83       	st	Z, r24
	_delay_ms(1); /* delay for processing Tas = 50ns */
	GPIO_writePin(LCD_E_PORT_ID,LCD_E_PIN_ID,LOGIC_HIGH); /* Enable LCD E=1 */
    87a0:	83 e0       	ldi	r24, 0x03	; 3
    87a2:	62 e0       	ldi	r22, 0x02	; 2
    87a4:	41 e0       	ldi	r20, 0x01	; 1
    87a6:	0e 94 46 39 	call	0x728c	; 0x728c <GPIO_writePin>
    87aa:	fe 01       	movw	r30, r28
    87ac:	ef 5a       	subi	r30, 0xAF	; 175
    87ae:	ff 4f       	sbci	r31, 0xFF	; 255
    87b0:	80 e0       	ldi	r24, 0x00	; 0
    87b2:	90 e0       	ldi	r25, 0x00	; 0
    87b4:	a0 e8       	ldi	r26, 0x80	; 128
    87b6:	bf e3       	ldi	r27, 0x3F	; 63
    87b8:	80 83       	st	Z, r24
    87ba:	91 83       	std	Z+1, r25	; 0x01
    87bc:	a2 83       	std	Z+2, r26	; 0x02
    87be:	b3 83       	std	Z+3, r27	; 0x03
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    87c0:	8e 01       	movw	r16, r28
    87c2:	03 5b       	subi	r16, 0xB3	; 179
    87c4:	1f 4f       	sbci	r17, 0xFF	; 255
    87c6:	fe 01       	movw	r30, r28
    87c8:	ef 5a       	subi	r30, 0xAF	; 175
    87ca:	ff 4f       	sbci	r31, 0xFF	; 255
    87cc:	60 81       	ld	r22, Z
    87ce:	71 81       	ldd	r23, Z+1	; 0x01
    87d0:	82 81       	ldd	r24, Z+2	; 0x02
    87d2:	93 81       	ldd	r25, Z+3	; 0x03
    87d4:	20 e0       	ldi	r18, 0x00	; 0
    87d6:	30 e0       	ldi	r19, 0x00	; 0
    87d8:	4a e7       	ldi	r20, 0x7A	; 122
    87da:	55 e4       	ldi	r21, 0x45	; 69
    87dc:	0e 94 3b 02 	call	0x476	; 0x476 <__mulsf3>
    87e0:	dc 01       	movw	r26, r24
    87e2:	cb 01       	movw	r24, r22
    87e4:	f8 01       	movw	r30, r16
    87e6:	80 83       	st	Z, r24
    87e8:	91 83       	std	Z+1, r25	; 0x01
    87ea:	a2 83       	std	Z+2, r26	; 0x02
    87ec:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    87ee:	fe 01       	movw	r30, r28
    87f0:	e3 5b       	subi	r30, 0xB3	; 179
    87f2:	ff 4f       	sbci	r31, 0xFF	; 255
    87f4:	60 81       	ld	r22, Z
    87f6:	71 81       	ldd	r23, Z+1	; 0x01
    87f8:	82 81       	ldd	r24, Z+2	; 0x02
    87fa:	93 81       	ldd	r25, Z+3	; 0x03
    87fc:	20 e0       	ldi	r18, 0x00	; 0
    87fe:	30 e0       	ldi	r19, 0x00	; 0
    8800:	40 e8       	ldi	r20, 0x80	; 128
    8802:	5f e3       	ldi	r21, 0x3F	; 63
    8804:	0e 94 41 04 	call	0x882	; 0x882 <__ltsf2>
    8808:	88 23       	and	r24, r24
    880a:	44 f4       	brge	.+16     	; 0x881c <LCD_displayCharacter+0x20e>
		__ticks = 1;
    880c:	fe 01       	movw	r30, r28
    880e:	e5 5b       	subi	r30, 0xB5	; 181
    8810:	ff 4f       	sbci	r31, 0xFF	; 255
    8812:	81 e0       	ldi	r24, 0x01	; 1
    8814:	90 e0       	ldi	r25, 0x00	; 0
    8816:	91 83       	std	Z+1, r25	; 0x01
    8818:	80 83       	st	Z, r24
    881a:	64 c0       	rjmp	.+200    	; 0x88e4 <LCD_displayCharacter+0x2d6>
	else if (__tmp > 65535)
    881c:	fe 01       	movw	r30, r28
    881e:	e3 5b       	subi	r30, 0xB3	; 179
    8820:	ff 4f       	sbci	r31, 0xFF	; 255
    8822:	60 81       	ld	r22, Z
    8824:	71 81       	ldd	r23, Z+1	; 0x01
    8826:	82 81       	ldd	r24, Z+2	; 0x02
    8828:	93 81       	ldd	r25, Z+3	; 0x03
    882a:	20 e0       	ldi	r18, 0x00	; 0
    882c:	3f ef       	ldi	r19, 0xFF	; 255
    882e:	4f e7       	ldi	r20, 0x7F	; 127
    8830:	57 e4       	ldi	r21, 0x47	; 71
    8832:	0e 94 e1 03 	call	0x7c2	; 0x7c2 <__gtsf2>
    8836:	18 16       	cp	r1, r24
    8838:	0c f0       	brlt	.+2      	; 0x883c <LCD_displayCharacter+0x22e>
    883a:	43 c0       	rjmp	.+134    	; 0x88c2 <LCD_displayCharacter+0x2b4>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    883c:	fe 01       	movw	r30, r28
    883e:	ef 5a       	subi	r30, 0xAF	; 175
    8840:	ff 4f       	sbci	r31, 0xFF	; 255
    8842:	60 81       	ld	r22, Z
    8844:	71 81       	ldd	r23, Z+1	; 0x01
    8846:	82 81       	ldd	r24, Z+2	; 0x02
    8848:	93 81       	ldd	r25, Z+3	; 0x03
    884a:	20 e0       	ldi	r18, 0x00	; 0
    884c:	30 e0       	ldi	r19, 0x00	; 0
    884e:	40 e2       	ldi	r20, 0x20	; 32
    8850:	51 e4       	ldi	r21, 0x41	; 65
    8852:	0e 94 3b 02 	call	0x476	; 0x476 <__mulsf3>
    8856:	dc 01       	movw	r26, r24
    8858:	cb 01       	movw	r24, r22
    885a:	8e 01       	movw	r16, r28
    885c:	05 5b       	subi	r16, 0xB5	; 181
    885e:	1f 4f       	sbci	r17, 0xFF	; 255
    8860:	bc 01       	movw	r22, r24
    8862:	cd 01       	movw	r24, r26
    8864:	0e 94 65 00 	call	0xca	; 0xca <__fixunssfsi>
    8868:	dc 01       	movw	r26, r24
    886a:	cb 01       	movw	r24, r22
    886c:	f8 01       	movw	r30, r16
    886e:	91 83       	std	Z+1, r25	; 0x01
    8870:	80 83       	st	Z, r24
    8872:	1f c0       	rjmp	.+62     	; 0x88b2 <LCD_displayCharacter+0x2a4>
    8874:	fe 01       	movw	r30, r28
    8876:	e7 5b       	subi	r30, 0xB7	; 183
    8878:	ff 4f       	sbci	r31, 0xFF	; 255
    887a:	80 e9       	ldi	r24, 0x90	; 144
    887c:	91 e0       	ldi	r25, 0x01	; 1
    887e:	91 83       	std	Z+1, r25	; 0x01
    8880:	80 83       	st	Z, r24
    8882:	fe 01       	movw	r30, r28
    8884:	e7 5b       	subi	r30, 0xB7	; 183
    8886:	ff 4f       	sbci	r31, 0xFF	; 255
    8888:	80 81       	ld	r24, Z
    888a:	91 81       	ldd	r25, Z+1	; 0x01
    888c:	01 97       	sbiw	r24, 0x01	; 1
    888e:	f1 f7       	brne	.-4      	; 0x888c <LCD_displayCharacter+0x27e>
    8890:	fe 01       	movw	r30, r28
    8892:	e7 5b       	subi	r30, 0xB7	; 183
    8894:	ff 4f       	sbci	r31, 0xFF	; 255
    8896:	91 83       	std	Z+1, r25	; 0x01
    8898:	80 83       	st	Z, r24
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    889a:	de 01       	movw	r26, r28
    889c:	a5 5b       	subi	r26, 0xB5	; 181
    889e:	bf 4f       	sbci	r27, 0xFF	; 255
    88a0:	fe 01       	movw	r30, r28
    88a2:	e5 5b       	subi	r30, 0xB5	; 181
    88a4:	ff 4f       	sbci	r31, 0xFF	; 255
    88a6:	80 81       	ld	r24, Z
    88a8:	91 81       	ldd	r25, Z+1	; 0x01
    88aa:	01 97       	sbiw	r24, 0x01	; 1
    88ac:	11 96       	adiw	r26, 0x01	; 1
    88ae:	9c 93       	st	X, r25
    88b0:	8e 93       	st	-X, r24
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    88b2:	fe 01       	movw	r30, r28
    88b4:	e5 5b       	subi	r30, 0xB5	; 181
    88b6:	ff 4f       	sbci	r31, 0xFF	; 255
    88b8:	80 81       	ld	r24, Z
    88ba:	91 81       	ldd	r25, Z+1	; 0x01
    88bc:	00 97       	sbiw	r24, 0x00	; 0
    88be:	d1 f6       	brne	.-76     	; 0x8874 <LCD_displayCharacter+0x266>
    88c0:	27 c0       	rjmp	.+78     	; 0x8910 <LCD_displayCharacter+0x302>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    88c2:	8e 01       	movw	r16, r28
    88c4:	05 5b       	subi	r16, 0xB5	; 181
    88c6:	1f 4f       	sbci	r17, 0xFF	; 255
    88c8:	fe 01       	movw	r30, r28
    88ca:	e3 5b       	subi	r30, 0xB3	; 179
    88cc:	ff 4f       	sbci	r31, 0xFF	; 255
    88ce:	60 81       	ld	r22, Z
    88d0:	71 81       	ldd	r23, Z+1	; 0x01
    88d2:	82 81       	ldd	r24, Z+2	; 0x02
    88d4:	93 81       	ldd	r25, Z+3	; 0x03
    88d6:	0e 94 65 00 	call	0xca	; 0xca <__fixunssfsi>
    88da:	dc 01       	movw	r26, r24
    88dc:	cb 01       	movw	r24, r22
    88de:	f8 01       	movw	r30, r16
    88e0:	91 83       	std	Z+1, r25	; 0x01
    88e2:	80 83       	st	Z, r24
    88e4:	de 01       	movw	r26, r28
    88e6:	a9 5b       	subi	r26, 0xB9	; 185
    88e8:	bf 4f       	sbci	r27, 0xFF	; 255
    88ea:	fe 01       	movw	r30, r28
    88ec:	e5 5b       	subi	r30, 0xB5	; 181
    88ee:	ff 4f       	sbci	r31, 0xFF	; 255
    88f0:	80 81       	ld	r24, Z
    88f2:	91 81       	ldd	r25, Z+1	; 0x01
    88f4:	8d 93       	st	X+, r24
    88f6:	9c 93       	st	X, r25
    88f8:	fe 01       	movw	r30, r28
    88fa:	e9 5b       	subi	r30, 0xB9	; 185
    88fc:	ff 4f       	sbci	r31, 0xFF	; 255
    88fe:	80 81       	ld	r24, Z
    8900:	91 81       	ldd	r25, Z+1	; 0x01
    8902:	01 97       	sbiw	r24, 0x01	; 1
    8904:	f1 f7       	brne	.-4      	; 0x8902 <LCD_displayCharacter+0x2f4>
    8906:	fe 01       	movw	r30, r28
    8908:	e9 5b       	subi	r30, 0xB9	; 185
    890a:	ff 4f       	sbci	r31, 0xFF	; 255
    890c:	91 83       	std	Z+1, r25	; 0x01
    890e:	80 83       	st	Z, r24
	_delay_ms(1); /* delay for processing Tpw - Tdws = 190ns */

#if(LCD_DATA_BITS_MODE == 4)
	GPIO_writePin(LCD_DATA_PORT_ID,LCD_DB4_PIN_ID,GET_BIT(data,4));
    8910:	fe 01       	movw	r30, r28
    8912:	ed 59       	subi	r30, 0x9D	; 157
    8914:	ff 4f       	sbci	r31, 0xFF	; 255
    8916:	80 81       	ld	r24, Z
    8918:	88 2f       	mov	r24, r24
    891a:	90 e0       	ldi	r25, 0x00	; 0
    891c:	80 71       	andi	r24, 0x10	; 16
    891e:	90 70       	andi	r25, 0x00	; 0
    8920:	95 95       	asr	r25
    8922:	87 95       	ror	r24
    8924:	95 95       	asr	r25
    8926:	87 95       	ror	r24
    8928:	95 95       	asr	r25
    892a:	87 95       	ror	r24
    892c:	95 95       	asr	r25
    892e:	87 95       	ror	r24
    8930:	98 2f       	mov	r25, r24
    8932:	83 e0       	ldi	r24, 0x03	; 3
    8934:	64 e0       	ldi	r22, 0x04	; 4
    8936:	49 2f       	mov	r20, r25
    8938:	0e 94 46 39 	call	0x728c	; 0x728c <GPIO_writePin>
	GPIO_writePin(LCD_DATA_PORT_ID,LCD_DB5_PIN_ID,GET_BIT(data,5));
    893c:	fe 01       	movw	r30, r28
    893e:	ed 59       	subi	r30, 0x9D	; 157
    8940:	ff 4f       	sbci	r31, 0xFF	; 255
    8942:	80 81       	ld	r24, Z
    8944:	88 2f       	mov	r24, r24
    8946:	90 e0       	ldi	r25, 0x00	; 0
    8948:	80 72       	andi	r24, 0x20	; 32
    894a:	90 70       	andi	r25, 0x00	; 0
    894c:	95 95       	asr	r25
    894e:	87 95       	ror	r24
    8950:	95 95       	asr	r25
    8952:	87 95       	ror	r24
    8954:	95 95       	asr	r25
    8956:	87 95       	ror	r24
    8958:	95 95       	asr	r25
    895a:	87 95       	ror	r24
    895c:	95 95       	asr	r25
    895e:	87 95       	ror	r24
    8960:	98 2f       	mov	r25, r24
    8962:	83 e0       	ldi	r24, 0x03	; 3
    8964:	65 e0       	ldi	r22, 0x05	; 5
    8966:	49 2f       	mov	r20, r25
    8968:	0e 94 46 39 	call	0x728c	; 0x728c <GPIO_writePin>
	GPIO_writePin(LCD_DATA_PORT_ID,LCD_DB6_PIN_ID,GET_BIT(data,6));
    896c:	fe 01       	movw	r30, r28
    896e:	ed 59       	subi	r30, 0x9D	; 157
    8970:	ff 4f       	sbci	r31, 0xFF	; 255
    8972:	80 81       	ld	r24, Z
    8974:	88 2f       	mov	r24, r24
    8976:	90 e0       	ldi	r25, 0x00	; 0
    8978:	80 74       	andi	r24, 0x40	; 64
    897a:	90 70       	andi	r25, 0x00	; 0
    897c:	08 2e       	mov	r0, r24
    897e:	89 2f       	mov	r24, r25
    8980:	00 0c       	add	r0, r0
    8982:	88 1f       	adc	r24, r24
    8984:	99 0b       	sbc	r25, r25
    8986:	00 0c       	add	r0, r0
    8988:	88 1f       	adc	r24, r24
    898a:	99 1f       	adc	r25, r25
    898c:	98 2f       	mov	r25, r24
    898e:	83 e0       	ldi	r24, 0x03	; 3
    8990:	66 e0       	ldi	r22, 0x06	; 6
    8992:	49 2f       	mov	r20, r25
    8994:	0e 94 46 39 	call	0x728c	; 0x728c <GPIO_writePin>
	GPIO_writePin(LCD_DATA_PORT_ID,LCD_DB7_PIN_ID,GET_BIT(data,7));
    8998:	fe 01       	movw	r30, r28
    899a:	ed 59       	subi	r30, 0x9D	; 157
    899c:	ff 4f       	sbci	r31, 0xFF	; 255
    899e:	80 81       	ld	r24, Z
    89a0:	98 2f       	mov	r25, r24
    89a2:	99 1f       	adc	r25, r25
    89a4:	99 27       	eor	r25, r25
    89a6:	99 1f       	adc	r25, r25
    89a8:	83 e0       	ldi	r24, 0x03	; 3
    89aa:	67 e0       	ldi	r22, 0x07	; 7
    89ac:	49 2f       	mov	r20, r25
    89ae:	0e 94 46 39 	call	0x728c	; 0x728c <GPIO_writePin>
    89b2:	fe 01       	movw	r30, r28
    89b4:	ed 5b       	subi	r30, 0xBD	; 189
    89b6:	ff 4f       	sbci	r31, 0xFF	; 255
    89b8:	80 e0       	ldi	r24, 0x00	; 0
    89ba:	90 e0       	ldi	r25, 0x00	; 0
    89bc:	a0 e8       	ldi	r26, 0x80	; 128
    89be:	bf e3       	ldi	r27, 0x3F	; 63
    89c0:	80 83       	st	Z, r24
    89c2:	91 83       	std	Z+1, r25	; 0x01
    89c4:	a2 83       	std	Z+2, r26	; 0x02
    89c6:	b3 83       	std	Z+3, r27	; 0x03
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    89c8:	8e 01       	movw	r16, r28
    89ca:	01 5c       	subi	r16, 0xC1	; 193
    89cc:	1f 4f       	sbci	r17, 0xFF	; 255
    89ce:	fe 01       	movw	r30, r28
    89d0:	ed 5b       	subi	r30, 0xBD	; 189
    89d2:	ff 4f       	sbci	r31, 0xFF	; 255
    89d4:	60 81       	ld	r22, Z
    89d6:	71 81       	ldd	r23, Z+1	; 0x01
    89d8:	82 81       	ldd	r24, Z+2	; 0x02
    89da:	93 81       	ldd	r25, Z+3	; 0x03
    89dc:	20 e0       	ldi	r18, 0x00	; 0
    89de:	30 e0       	ldi	r19, 0x00	; 0
    89e0:	4a e7       	ldi	r20, 0x7A	; 122
    89e2:	55 e4       	ldi	r21, 0x45	; 69
    89e4:	0e 94 3b 02 	call	0x476	; 0x476 <__mulsf3>
    89e8:	dc 01       	movw	r26, r24
    89ea:	cb 01       	movw	r24, r22
    89ec:	f8 01       	movw	r30, r16
    89ee:	80 83       	st	Z, r24
    89f0:	91 83       	std	Z+1, r25	; 0x01
    89f2:	a2 83       	std	Z+2, r26	; 0x02
    89f4:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    89f6:	fe 01       	movw	r30, r28
    89f8:	ff 96       	adiw	r30, 0x3f	; 63
    89fa:	60 81       	ld	r22, Z
    89fc:	71 81       	ldd	r23, Z+1	; 0x01
    89fe:	82 81       	ldd	r24, Z+2	; 0x02
    8a00:	93 81       	ldd	r25, Z+3	; 0x03
    8a02:	20 e0       	ldi	r18, 0x00	; 0
    8a04:	30 e0       	ldi	r19, 0x00	; 0
    8a06:	40 e8       	ldi	r20, 0x80	; 128
    8a08:	5f e3       	ldi	r21, 0x3F	; 63
    8a0a:	0e 94 41 04 	call	0x882	; 0x882 <__ltsf2>
    8a0e:	88 23       	and	r24, r24
    8a10:	2c f4       	brge	.+10     	; 0x8a1c <LCD_displayCharacter+0x40e>
		__ticks = 1;
    8a12:	81 e0       	ldi	r24, 0x01	; 1
    8a14:	90 e0       	ldi	r25, 0x00	; 0
    8a16:	9e af       	std	Y+62, r25	; 0x3e
    8a18:	8d af       	std	Y+61, r24	; 0x3d
    8a1a:	46 c0       	rjmp	.+140    	; 0x8aa8 <LCD_displayCharacter+0x49a>
	else if (__tmp > 65535)
    8a1c:	fe 01       	movw	r30, r28
    8a1e:	ff 96       	adiw	r30, 0x3f	; 63
    8a20:	60 81       	ld	r22, Z
    8a22:	71 81       	ldd	r23, Z+1	; 0x01
    8a24:	82 81       	ldd	r24, Z+2	; 0x02
    8a26:	93 81       	ldd	r25, Z+3	; 0x03
    8a28:	20 e0       	ldi	r18, 0x00	; 0
    8a2a:	3f ef       	ldi	r19, 0xFF	; 255
    8a2c:	4f e7       	ldi	r20, 0x7F	; 127
    8a2e:	57 e4       	ldi	r21, 0x47	; 71
    8a30:	0e 94 e1 03 	call	0x7c2	; 0x7c2 <__gtsf2>
    8a34:	18 16       	cp	r1, r24
    8a36:	64 f5       	brge	.+88     	; 0x8a90 <LCD_displayCharacter+0x482>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    8a38:	fe 01       	movw	r30, r28
    8a3a:	ed 5b       	subi	r30, 0xBD	; 189
    8a3c:	ff 4f       	sbci	r31, 0xFF	; 255
    8a3e:	60 81       	ld	r22, Z
    8a40:	71 81       	ldd	r23, Z+1	; 0x01
    8a42:	82 81       	ldd	r24, Z+2	; 0x02
    8a44:	93 81       	ldd	r25, Z+3	; 0x03
    8a46:	20 e0       	ldi	r18, 0x00	; 0
    8a48:	30 e0       	ldi	r19, 0x00	; 0
    8a4a:	40 e2       	ldi	r20, 0x20	; 32
    8a4c:	51 e4       	ldi	r21, 0x41	; 65
    8a4e:	0e 94 3b 02 	call	0x476	; 0x476 <__mulsf3>
    8a52:	dc 01       	movw	r26, r24
    8a54:	cb 01       	movw	r24, r22
    8a56:	bc 01       	movw	r22, r24
    8a58:	cd 01       	movw	r24, r26
    8a5a:	0e 94 65 00 	call	0xca	; 0xca <__fixunssfsi>
    8a5e:	dc 01       	movw	r26, r24
    8a60:	cb 01       	movw	r24, r22
    8a62:	9e af       	std	Y+62, r25	; 0x3e
    8a64:	8d af       	std	Y+61, r24	; 0x3d
    8a66:	0f c0       	rjmp	.+30     	; 0x8a86 <LCD_displayCharacter+0x478>
    8a68:	80 e9       	ldi	r24, 0x90	; 144
    8a6a:	91 e0       	ldi	r25, 0x01	; 1
    8a6c:	9c af       	std	Y+60, r25	; 0x3c
    8a6e:	8b af       	std	Y+59, r24	; 0x3b
    8a70:	8b ad       	ldd	r24, Y+59	; 0x3b
    8a72:	9c ad       	ldd	r25, Y+60	; 0x3c
    8a74:	01 97       	sbiw	r24, 0x01	; 1
    8a76:	f1 f7       	brne	.-4      	; 0x8a74 <LCD_displayCharacter+0x466>
    8a78:	9c af       	std	Y+60, r25	; 0x3c
    8a7a:	8b af       	std	Y+59, r24	; 0x3b
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    8a7c:	8d ad       	ldd	r24, Y+61	; 0x3d
    8a7e:	9e ad       	ldd	r25, Y+62	; 0x3e
    8a80:	01 97       	sbiw	r24, 0x01	; 1
    8a82:	9e af       	std	Y+62, r25	; 0x3e
    8a84:	8d af       	std	Y+61, r24	; 0x3d
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    8a86:	8d ad       	ldd	r24, Y+61	; 0x3d
    8a88:	9e ad       	ldd	r25, Y+62	; 0x3e
    8a8a:	00 97       	sbiw	r24, 0x00	; 0
    8a8c:	69 f7       	brne	.-38     	; 0x8a68 <LCD_displayCharacter+0x45a>
    8a8e:	16 c0       	rjmp	.+44     	; 0x8abc <LCD_displayCharacter+0x4ae>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    8a90:	fe 01       	movw	r30, r28
    8a92:	ff 96       	adiw	r30, 0x3f	; 63
    8a94:	60 81       	ld	r22, Z
    8a96:	71 81       	ldd	r23, Z+1	; 0x01
    8a98:	82 81       	ldd	r24, Z+2	; 0x02
    8a9a:	93 81       	ldd	r25, Z+3	; 0x03
    8a9c:	0e 94 65 00 	call	0xca	; 0xca <__fixunssfsi>
    8aa0:	dc 01       	movw	r26, r24
    8aa2:	cb 01       	movw	r24, r22
    8aa4:	9e af       	std	Y+62, r25	; 0x3e
    8aa6:	8d af       	std	Y+61, r24	; 0x3d
    8aa8:	8d ad       	ldd	r24, Y+61	; 0x3d
    8aaa:	9e ad       	ldd	r25, Y+62	; 0x3e
    8aac:	9a af       	std	Y+58, r25	; 0x3a
    8aae:	89 af       	std	Y+57, r24	; 0x39
    8ab0:	89 ad       	ldd	r24, Y+57	; 0x39
    8ab2:	9a ad       	ldd	r25, Y+58	; 0x3a
    8ab4:	01 97       	sbiw	r24, 0x01	; 1
    8ab6:	f1 f7       	brne	.-4      	; 0x8ab4 <LCD_displayCharacter+0x4a6>
    8ab8:	9a af       	std	Y+58, r25	; 0x3a
    8aba:	89 af       	std	Y+57, r24	; 0x39

	_delay_ms(1); /* delay for processing Tdsw = 100ns */
	GPIO_writePin(LCD_E_PORT_ID,LCD_E_PIN_ID,LOGIC_LOW); /* Disable LCD E=0 */
    8abc:	83 e0       	ldi	r24, 0x03	; 3
    8abe:	62 e0       	ldi	r22, 0x02	; 2
    8ac0:	40 e0       	ldi	r20, 0x00	; 0
    8ac2:	0e 94 46 39 	call	0x728c	; 0x728c <GPIO_writePin>
    8ac6:	80 e0       	ldi	r24, 0x00	; 0
    8ac8:	90 e0       	ldi	r25, 0x00	; 0
    8aca:	a0 e8       	ldi	r26, 0x80	; 128
    8acc:	bf e3       	ldi	r27, 0x3F	; 63
    8ace:	8d ab       	std	Y+53, r24	; 0x35
    8ad0:	9e ab       	std	Y+54, r25	; 0x36
    8ad2:	af ab       	std	Y+55, r26	; 0x37
    8ad4:	b8 af       	std	Y+56, r27	; 0x38
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    8ad6:	6d a9       	ldd	r22, Y+53	; 0x35
    8ad8:	7e a9       	ldd	r23, Y+54	; 0x36
    8ada:	8f a9       	ldd	r24, Y+55	; 0x37
    8adc:	98 ad       	ldd	r25, Y+56	; 0x38
    8ade:	20 e0       	ldi	r18, 0x00	; 0
    8ae0:	30 e0       	ldi	r19, 0x00	; 0
    8ae2:	4a e7       	ldi	r20, 0x7A	; 122
    8ae4:	55 e4       	ldi	r21, 0x45	; 69
    8ae6:	0e 94 3b 02 	call	0x476	; 0x476 <__mulsf3>
    8aea:	dc 01       	movw	r26, r24
    8aec:	cb 01       	movw	r24, r22
    8aee:	89 ab       	std	Y+49, r24	; 0x31
    8af0:	9a ab       	std	Y+50, r25	; 0x32
    8af2:	ab ab       	std	Y+51, r26	; 0x33
    8af4:	bc ab       	std	Y+52, r27	; 0x34
	if (__tmp < 1.0)
    8af6:	69 a9       	ldd	r22, Y+49	; 0x31
    8af8:	7a a9       	ldd	r23, Y+50	; 0x32
    8afa:	8b a9       	ldd	r24, Y+51	; 0x33
    8afc:	9c a9       	ldd	r25, Y+52	; 0x34
    8afe:	20 e0       	ldi	r18, 0x00	; 0
    8b00:	30 e0       	ldi	r19, 0x00	; 0
    8b02:	40 e8       	ldi	r20, 0x80	; 128
    8b04:	5f e3       	ldi	r21, 0x3F	; 63
    8b06:	0e 94 41 04 	call	0x882	; 0x882 <__ltsf2>
    8b0a:	88 23       	and	r24, r24
    8b0c:	2c f4       	brge	.+10     	; 0x8b18 <LCD_displayCharacter+0x50a>
		__ticks = 1;
    8b0e:	81 e0       	ldi	r24, 0x01	; 1
    8b10:	90 e0       	ldi	r25, 0x00	; 0
    8b12:	98 ab       	std	Y+48, r25	; 0x30
    8b14:	8f a7       	std	Y+47, r24	; 0x2f
    8b16:	3f c0       	rjmp	.+126    	; 0x8b96 <LCD_displayCharacter+0x588>
	else if (__tmp > 65535)
    8b18:	69 a9       	ldd	r22, Y+49	; 0x31
    8b1a:	7a a9       	ldd	r23, Y+50	; 0x32
    8b1c:	8b a9       	ldd	r24, Y+51	; 0x33
    8b1e:	9c a9       	ldd	r25, Y+52	; 0x34
    8b20:	20 e0       	ldi	r18, 0x00	; 0
    8b22:	3f ef       	ldi	r19, 0xFF	; 255
    8b24:	4f e7       	ldi	r20, 0x7F	; 127
    8b26:	57 e4       	ldi	r21, 0x47	; 71
    8b28:	0e 94 e1 03 	call	0x7c2	; 0x7c2 <__gtsf2>
    8b2c:	18 16       	cp	r1, r24
    8b2e:	4c f5       	brge	.+82     	; 0x8b82 <LCD_displayCharacter+0x574>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    8b30:	6d a9       	ldd	r22, Y+53	; 0x35
    8b32:	7e a9       	ldd	r23, Y+54	; 0x36
    8b34:	8f a9       	ldd	r24, Y+55	; 0x37
    8b36:	98 ad       	ldd	r25, Y+56	; 0x38
    8b38:	20 e0       	ldi	r18, 0x00	; 0
    8b3a:	30 e0       	ldi	r19, 0x00	; 0
    8b3c:	40 e2       	ldi	r20, 0x20	; 32
    8b3e:	51 e4       	ldi	r21, 0x41	; 65
    8b40:	0e 94 3b 02 	call	0x476	; 0x476 <__mulsf3>
    8b44:	dc 01       	movw	r26, r24
    8b46:	cb 01       	movw	r24, r22
    8b48:	bc 01       	movw	r22, r24
    8b4a:	cd 01       	movw	r24, r26
    8b4c:	0e 94 65 00 	call	0xca	; 0xca <__fixunssfsi>
    8b50:	dc 01       	movw	r26, r24
    8b52:	cb 01       	movw	r24, r22
    8b54:	98 ab       	std	Y+48, r25	; 0x30
    8b56:	8f a7       	std	Y+47, r24	; 0x2f
    8b58:	0f c0       	rjmp	.+30     	; 0x8b78 <LCD_displayCharacter+0x56a>
    8b5a:	80 e9       	ldi	r24, 0x90	; 144
    8b5c:	91 e0       	ldi	r25, 0x01	; 1
    8b5e:	9e a7       	std	Y+46, r25	; 0x2e
    8b60:	8d a7       	std	Y+45, r24	; 0x2d
    8b62:	8d a5       	ldd	r24, Y+45	; 0x2d
    8b64:	9e a5       	ldd	r25, Y+46	; 0x2e
    8b66:	01 97       	sbiw	r24, 0x01	; 1
    8b68:	f1 f7       	brne	.-4      	; 0x8b66 <LCD_displayCharacter+0x558>
    8b6a:	9e a7       	std	Y+46, r25	; 0x2e
    8b6c:	8d a7       	std	Y+45, r24	; 0x2d
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    8b6e:	8f a5       	ldd	r24, Y+47	; 0x2f
    8b70:	98 a9       	ldd	r25, Y+48	; 0x30
    8b72:	01 97       	sbiw	r24, 0x01	; 1
    8b74:	98 ab       	std	Y+48, r25	; 0x30
    8b76:	8f a7       	std	Y+47, r24	; 0x2f
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    8b78:	8f a5       	ldd	r24, Y+47	; 0x2f
    8b7a:	98 a9       	ldd	r25, Y+48	; 0x30
    8b7c:	00 97       	sbiw	r24, 0x00	; 0
    8b7e:	69 f7       	brne	.-38     	; 0x8b5a <LCD_displayCharacter+0x54c>
    8b80:	14 c0       	rjmp	.+40     	; 0x8baa <LCD_displayCharacter+0x59c>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    8b82:	69 a9       	ldd	r22, Y+49	; 0x31
    8b84:	7a a9       	ldd	r23, Y+50	; 0x32
    8b86:	8b a9       	ldd	r24, Y+51	; 0x33
    8b88:	9c a9       	ldd	r25, Y+52	; 0x34
    8b8a:	0e 94 65 00 	call	0xca	; 0xca <__fixunssfsi>
    8b8e:	dc 01       	movw	r26, r24
    8b90:	cb 01       	movw	r24, r22
    8b92:	98 ab       	std	Y+48, r25	; 0x30
    8b94:	8f a7       	std	Y+47, r24	; 0x2f
    8b96:	8f a5       	ldd	r24, Y+47	; 0x2f
    8b98:	98 a9       	ldd	r25, Y+48	; 0x30
    8b9a:	9c a7       	std	Y+44, r25	; 0x2c
    8b9c:	8b a7       	std	Y+43, r24	; 0x2b
    8b9e:	8b a5       	ldd	r24, Y+43	; 0x2b
    8ba0:	9c a5       	ldd	r25, Y+44	; 0x2c
    8ba2:	01 97       	sbiw	r24, 0x01	; 1
    8ba4:	f1 f7       	brne	.-4      	; 0x8ba2 <LCD_displayCharacter+0x594>
    8ba6:	9c a7       	std	Y+44, r25	; 0x2c
    8ba8:	8b a7       	std	Y+43, r24	; 0x2b
	_delay_ms(1); /* delay for processing Th = 13ns */
	GPIO_writePin(LCD_E_PORT_ID,LCD_E_PIN_ID,LOGIC_HIGH); /* Enable LCD E=1 */
    8baa:	83 e0       	ldi	r24, 0x03	; 3
    8bac:	62 e0       	ldi	r22, 0x02	; 2
    8bae:	41 e0       	ldi	r20, 0x01	; 1
    8bb0:	0e 94 46 39 	call	0x728c	; 0x728c <GPIO_writePin>
    8bb4:	80 e0       	ldi	r24, 0x00	; 0
    8bb6:	90 e0       	ldi	r25, 0x00	; 0
    8bb8:	a0 e8       	ldi	r26, 0x80	; 128
    8bba:	bf e3       	ldi	r27, 0x3F	; 63
    8bbc:	8f a3       	std	Y+39, r24	; 0x27
    8bbe:	98 a7       	std	Y+40, r25	; 0x28
    8bc0:	a9 a7       	std	Y+41, r26	; 0x29
    8bc2:	ba a7       	std	Y+42, r27	; 0x2a
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    8bc4:	6f a1       	ldd	r22, Y+39	; 0x27
    8bc6:	78 a5       	ldd	r23, Y+40	; 0x28
    8bc8:	89 a5       	ldd	r24, Y+41	; 0x29
    8bca:	9a a5       	ldd	r25, Y+42	; 0x2a
    8bcc:	20 e0       	ldi	r18, 0x00	; 0
    8bce:	30 e0       	ldi	r19, 0x00	; 0
    8bd0:	4a e7       	ldi	r20, 0x7A	; 122
    8bd2:	55 e4       	ldi	r21, 0x45	; 69
    8bd4:	0e 94 3b 02 	call	0x476	; 0x476 <__mulsf3>
    8bd8:	dc 01       	movw	r26, r24
    8bda:	cb 01       	movw	r24, r22
    8bdc:	8b a3       	std	Y+35, r24	; 0x23
    8bde:	9c a3       	std	Y+36, r25	; 0x24
    8be0:	ad a3       	std	Y+37, r26	; 0x25
    8be2:	be a3       	std	Y+38, r27	; 0x26
	if (__tmp < 1.0)
    8be4:	6b a1       	ldd	r22, Y+35	; 0x23
    8be6:	7c a1       	ldd	r23, Y+36	; 0x24
    8be8:	8d a1       	ldd	r24, Y+37	; 0x25
    8bea:	9e a1       	ldd	r25, Y+38	; 0x26
    8bec:	20 e0       	ldi	r18, 0x00	; 0
    8bee:	30 e0       	ldi	r19, 0x00	; 0
    8bf0:	40 e8       	ldi	r20, 0x80	; 128
    8bf2:	5f e3       	ldi	r21, 0x3F	; 63
    8bf4:	0e 94 41 04 	call	0x882	; 0x882 <__ltsf2>
    8bf8:	88 23       	and	r24, r24
    8bfa:	2c f4       	brge	.+10     	; 0x8c06 <LCD_displayCharacter+0x5f8>
		__ticks = 1;
    8bfc:	81 e0       	ldi	r24, 0x01	; 1
    8bfe:	90 e0       	ldi	r25, 0x00	; 0
    8c00:	9a a3       	std	Y+34, r25	; 0x22
    8c02:	89 a3       	std	Y+33, r24	; 0x21
    8c04:	3f c0       	rjmp	.+126    	; 0x8c84 <LCD_displayCharacter+0x676>
	else if (__tmp > 65535)
    8c06:	6b a1       	ldd	r22, Y+35	; 0x23
    8c08:	7c a1       	ldd	r23, Y+36	; 0x24
    8c0a:	8d a1       	ldd	r24, Y+37	; 0x25
    8c0c:	9e a1       	ldd	r25, Y+38	; 0x26
    8c0e:	20 e0       	ldi	r18, 0x00	; 0
    8c10:	3f ef       	ldi	r19, 0xFF	; 255
    8c12:	4f e7       	ldi	r20, 0x7F	; 127
    8c14:	57 e4       	ldi	r21, 0x47	; 71
    8c16:	0e 94 e1 03 	call	0x7c2	; 0x7c2 <__gtsf2>
    8c1a:	18 16       	cp	r1, r24
    8c1c:	4c f5       	brge	.+82     	; 0x8c70 <LCD_displayCharacter+0x662>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    8c1e:	6f a1       	ldd	r22, Y+39	; 0x27
    8c20:	78 a5       	ldd	r23, Y+40	; 0x28
    8c22:	89 a5       	ldd	r24, Y+41	; 0x29
    8c24:	9a a5       	ldd	r25, Y+42	; 0x2a
    8c26:	20 e0       	ldi	r18, 0x00	; 0
    8c28:	30 e0       	ldi	r19, 0x00	; 0
    8c2a:	40 e2       	ldi	r20, 0x20	; 32
    8c2c:	51 e4       	ldi	r21, 0x41	; 65
    8c2e:	0e 94 3b 02 	call	0x476	; 0x476 <__mulsf3>
    8c32:	dc 01       	movw	r26, r24
    8c34:	cb 01       	movw	r24, r22
    8c36:	bc 01       	movw	r22, r24
    8c38:	cd 01       	movw	r24, r26
    8c3a:	0e 94 65 00 	call	0xca	; 0xca <__fixunssfsi>
    8c3e:	dc 01       	movw	r26, r24
    8c40:	cb 01       	movw	r24, r22
    8c42:	9a a3       	std	Y+34, r25	; 0x22
    8c44:	89 a3       	std	Y+33, r24	; 0x21
    8c46:	0f c0       	rjmp	.+30     	; 0x8c66 <LCD_displayCharacter+0x658>
    8c48:	80 e9       	ldi	r24, 0x90	; 144
    8c4a:	91 e0       	ldi	r25, 0x01	; 1
    8c4c:	98 a3       	std	Y+32, r25	; 0x20
    8c4e:	8f 8f       	std	Y+31, r24	; 0x1f
    8c50:	8f 8d       	ldd	r24, Y+31	; 0x1f
    8c52:	98 a1       	ldd	r25, Y+32	; 0x20
    8c54:	01 97       	sbiw	r24, 0x01	; 1
    8c56:	f1 f7       	brne	.-4      	; 0x8c54 <LCD_displayCharacter+0x646>
    8c58:	98 a3       	std	Y+32, r25	; 0x20
    8c5a:	8f 8f       	std	Y+31, r24	; 0x1f
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    8c5c:	89 a1       	ldd	r24, Y+33	; 0x21
    8c5e:	9a a1       	ldd	r25, Y+34	; 0x22
    8c60:	01 97       	sbiw	r24, 0x01	; 1
    8c62:	9a a3       	std	Y+34, r25	; 0x22
    8c64:	89 a3       	std	Y+33, r24	; 0x21
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    8c66:	89 a1       	ldd	r24, Y+33	; 0x21
    8c68:	9a a1       	ldd	r25, Y+34	; 0x22
    8c6a:	00 97       	sbiw	r24, 0x00	; 0
    8c6c:	69 f7       	brne	.-38     	; 0x8c48 <LCD_displayCharacter+0x63a>
    8c6e:	14 c0       	rjmp	.+40     	; 0x8c98 <LCD_displayCharacter+0x68a>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    8c70:	6b a1       	ldd	r22, Y+35	; 0x23
    8c72:	7c a1       	ldd	r23, Y+36	; 0x24
    8c74:	8d a1       	ldd	r24, Y+37	; 0x25
    8c76:	9e a1       	ldd	r25, Y+38	; 0x26
    8c78:	0e 94 65 00 	call	0xca	; 0xca <__fixunssfsi>
    8c7c:	dc 01       	movw	r26, r24
    8c7e:	cb 01       	movw	r24, r22
    8c80:	9a a3       	std	Y+34, r25	; 0x22
    8c82:	89 a3       	std	Y+33, r24	; 0x21
    8c84:	89 a1       	ldd	r24, Y+33	; 0x21
    8c86:	9a a1       	ldd	r25, Y+34	; 0x22
    8c88:	9e 8f       	std	Y+30, r25	; 0x1e
    8c8a:	8d 8f       	std	Y+29, r24	; 0x1d
    8c8c:	8d 8d       	ldd	r24, Y+29	; 0x1d
    8c8e:	9e 8d       	ldd	r25, Y+30	; 0x1e
    8c90:	01 97       	sbiw	r24, 0x01	; 1
    8c92:	f1 f7       	brne	.-4      	; 0x8c90 <LCD_displayCharacter+0x682>
    8c94:	9e 8f       	std	Y+30, r25	; 0x1e
    8c96:	8d 8f       	std	Y+29, r24	; 0x1d
	_delay_ms(1); /* delay for processing Tpw - Tdws = 190ns */

	GPIO_writePin(LCD_DATA_PORT_ID,LCD_DB4_PIN_ID,GET_BIT(data,0));
    8c98:	fe 01       	movw	r30, r28
    8c9a:	ed 59       	subi	r30, 0x9D	; 157
    8c9c:	ff 4f       	sbci	r31, 0xFF	; 255
    8c9e:	80 81       	ld	r24, Z
    8ca0:	98 2f       	mov	r25, r24
    8ca2:	91 70       	andi	r25, 0x01	; 1
    8ca4:	83 e0       	ldi	r24, 0x03	; 3
    8ca6:	64 e0       	ldi	r22, 0x04	; 4
    8ca8:	49 2f       	mov	r20, r25
    8caa:	0e 94 46 39 	call	0x728c	; 0x728c <GPIO_writePin>
	GPIO_writePin(LCD_DATA_PORT_ID,LCD_DB5_PIN_ID,GET_BIT(data,1));
    8cae:	fe 01       	movw	r30, r28
    8cb0:	ed 59       	subi	r30, 0x9D	; 157
    8cb2:	ff 4f       	sbci	r31, 0xFF	; 255
    8cb4:	80 81       	ld	r24, Z
    8cb6:	88 2f       	mov	r24, r24
    8cb8:	90 e0       	ldi	r25, 0x00	; 0
    8cba:	82 70       	andi	r24, 0x02	; 2
    8cbc:	90 70       	andi	r25, 0x00	; 0
    8cbe:	95 95       	asr	r25
    8cc0:	87 95       	ror	r24
    8cc2:	98 2f       	mov	r25, r24
    8cc4:	83 e0       	ldi	r24, 0x03	; 3
    8cc6:	65 e0       	ldi	r22, 0x05	; 5
    8cc8:	49 2f       	mov	r20, r25
    8cca:	0e 94 46 39 	call	0x728c	; 0x728c <GPIO_writePin>
	GPIO_writePin(LCD_DATA_PORT_ID,LCD_DB6_PIN_ID,GET_BIT(data,2));
    8cce:	fe 01       	movw	r30, r28
    8cd0:	ed 59       	subi	r30, 0x9D	; 157
    8cd2:	ff 4f       	sbci	r31, 0xFF	; 255
    8cd4:	80 81       	ld	r24, Z
    8cd6:	88 2f       	mov	r24, r24
    8cd8:	90 e0       	ldi	r25, 0x00	; 0
    8cda:	84 70       	andi	r24, 0x04	; 4
    8cdc:	90 70       	andi	r25, 0x00	; 0
    8cde:	95 95       	asr	r25
    8ce0:	87 95       	ror	r24
    8ce2:	95 95       	asr	r25
    8ce4:	87 95       	ror	r24
    8ce6:	98 2f       	mov	r25, r24
    8ce8:	83 e0       	ldi	r24, 0x03	; 3
    8cea:	66 e0       	ldi	r22, 0x06	; 6
    8cec:	49 2f       	mov	r20, r25
    8cee:	0e 94 46 39 	call	0x728c	; 0x728c <GPIO_writePin>
	GPIO_writePin(LCD_DATA_PORT_ID,LCD_DB7_PIN_ID,GET_BIT(data,3));
    8cf2:	fe 01       	movw	r30, r28
    8cf4:	ed 59       	subi	r30, 0x9D	; 157
    8cf6:	ff 4f       	sbci	r31, 0xFF	; 255
    8cf8:	80 81       	ld	r24, Z
    8cfa:	88 2f       	mov	r24, r24
    8cfc:	90 e0       	ldi	r25, 0x00	; 0
    8cfe:	88 70       	andi	r24, 0x08	; 8
    8d00:	90 70       	andi	r25, 0x00	; 0
    8d02:	95 95       	asr	r25
    8d04:	87 95       	ror	r24
    8d06:	95 95       	asr	r25
    8d08:	87 95       	ror	r24
    8d0a:	95 95       	asr	r25
    8d0c:	87 95       	ror	r24
    8d0e:	98 2f       	mov	r25, r24
    8d10:	83 e0       	ldi	r24, 0x03	; 3
    8d12:	67 e0       	ldi	r22, 0x07	; 7
    8d14:	49 2f       	mov	r20, r25
    8d16:	0e 94 46 39 	call	0x728c	; 0x728c <GPIO_writePin>
    8d1a:	80 e0       	ldi	r24, 0x00	; 0
    8d1c:	90 e0       	ldi	r25, 0x00	; 0
    8d1e:	a0 e8       	ldi	r26, 0x80	; 128
    8d20:	bf e3       	ldi	r27, 0x3F	; 63
    8d22:	89 8f       	std	Y+25, r24	; 0x19
    8d24:	9a 8f       	std	Y+26, r25	; 0x1a
    8d26:	ab 8f       	std	Y+27, r26	; 0x1b
    8d28:	bc 8f       	std	Y+28, r27	; 0x1c
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    8d2a:	69 8d       	ldd	r22, Y+25	; 0x19
    8d2c:	7a 8d       	ldd	r23, Y+26	; 0x1a
    8d2e:	8b 8d       	ldd	r24, Y+27	; 0x1b
    8d30:	9c 8d       	ldd	r25, Y+28	; 0x1c
    8d32:	20 e0       	ldi	r18, 0x00	; 0
    8d34:	30 e0       	ldi	r19, 0x00	; 0
    8d36:	4a e7       	ldi	r20, 0x7A	; 122
    8d38:	55 e4       	ldi	r21, 0x45	; 69
    8d3a:	0e 94 3b 02 	call	0x476	; 0x476 <__mulsf3>
    8d3e:	dc 01       	movw	r26, r24
    8d40:	cb 01       	movw	r24, r22
    8d42:	8d 8b       	std	Y+21, r24	; 0x15
    8d44:	9e 8b       	std	Y+22, r25	; 0x16
    8d46:	af 8b       	std	Y+23, r26	; 0x17
    8d48:	b8 8f       	std	Y+24, r27	; 0x18
	if (__tmp < 1.0)
    8d4a:	6d 89       	ldd	r22, Y+21	; 0x15
    8d4c:	7e 89       	ldd	r23, Y+22	; 0x16
    8d4e:	8f 89       	ldd	r24, Y+23	; 0x17
    8d50:	98 8d       	ldd	r25, Y+24	; 0x18
    8d52:	20 e0       	ldi	r18, 0x00	; 0
    8d54:	30 e0       	ldi	r19, 0x00	; 0
    8d56:	40 e8       	ldi	r20, 0x80	; 128
    8d58:	5f e3       	ldi	r21, 0x3F	; 63
    8d5a:	0e 94 41 04 	call	0x882	; 0x882 <__ltsf2>
    8d5e:	88 23       	and	r24, r24
    8d60:	2c f4       	brge	.+10     	; 0x8d6c <LCD_displayCharacter+0x75e>
		__ticks = 1;
    8d62:	81 e0       	ldi	r24, 0x01	; 1
    8d64:	90 e0       	ldi	r25, 0x00	; 0
    8d66:	9c 8b       	std	Y+20, r25	; 0x14
    8d68:	8b 8b       	std	Y+19, r24	; 0x13
    8d6a:	3f c0       	rjmp	.+126    	; 0x8dea <LCD_displayCharacter+0x7dc>
	else if (__tmp > 65535)
    8d6c:	6d 89       	ldd	r22, Y+21	; 0x15
    8d6e:	7e 89       	ldd	r23, Y+22	; 0x16
    8d70:	8f 89       	ldd	r24, Y+23	; 0x17
    8d72:	98 8d       	ldd	r25, Y+24	; 0x18
    8d74:	20 e0       	ldi	r18, 0x00	; 0
    8d76:	3f ef       	ldi	r19, 0xFF	; 255
    8d78:	4f e7       	ldi	r20, 0x7F	; 127
    8d7a:	57 e4       	ldi	r21, 0x47	; 71
    8d7c:	0e 94 e1 03 	call	0x7c2	; 0x7c2 <__gtsf2>
    8d80:	18 16       	cp	r1, r24
    8d82:	4c f5       	brge	.+82     	; 0x8dd6 <LCD_displayCharacter+0x7c8>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    8d84:	69 8d       	ldd	r22, Y+25	; 0x19
    8d86:	7a 8d       	ldd	r23, Y+26	; 0x1a
    8d88:	8b 8d       	ldd	r24, Y+27	; 0x1b
    8d8a:	9c 8d       	ldd	r25, Y+28	; 0x1c
    8d8c:	20 e0       	ldi	r18, 0x00	; 0
    8d8e:	30 e0       	ldi	r19, 0x00	; 0
    8d90:	40 e2       	ldi	r20, 0x20	; 32
    8d92:	51 e4       	ldi	r21, 0x41	; 65
    8d94:	0e 94 3b 02 	call	0x476	; 0x476 <__mulsf3>
    8d98:	dc 01       	movw	r26, r24
    8d9a:	cb 01       	movw	r24, r22
    8d9c:	bc 01       	movw	r22, r24
    8d9e:	cd 01       	movw	r24, r26
    8da0:	0e 94 65 00 	call	0xca	; 0xca <__fixunssfsi>
    8da4:	dc 01       	movw	r26, r24
    8da6:	cb 01       	movw	r24, r22
    8da8:	9c 8b       	std	Y+20, r25	; 0x14
    8daa:	8b 8b       	std	Y+19, r24	; 0x13
    8dac:	0f c0       	rjmp	.+30     	; 0x8dcc <LCD_displayCharacter+0x7be>
    8dae:	80 e9       	ldi	r24, 0x90	; 144
    8db0:	91 e0       	ldi	r25, 0x01	; 1
    8db2:	9a 8b       	std	Y+18, r25	; 0x12
    8db4:	89 8b       	std	Y+17, r24	; 0x11
    8db6:	89 89       	ldd	r24, Y+17	; 0x11
    8db8:	9a 89       	ldd	r25, Y+18	; 0x12
    8dba:	01 97       	sbiw	r24, 0x01	; 1
    8dbc:	f1 f7       	brne	.-4      	; 0x8dba <LCD_displayCharacter+0x7ac>
    8dbe:	9a 8b       	std	Y+18, r25	; 0x12
    8dc0:	89 8b       	std	Y+17, r24	; 0x11
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    8dc2:	8b 89       	ldd	r24, Y+19	; 0x13
    8dc4:	9c 89       	ldd	r25, Y+20	; 0x14
    8dc6:	01 97       	sbiw	r24, 0x01	; 1
    8dc8:	9c 8b       	std	Y+20, r25	; 0x14
    8dca:	8b 8b       	std	Y+19, r24	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    8dcc:	8b 89       	ldd	r24, Y+19	; 0x13
    8dce:	9c 89       	ldd	r25, Y+20	; 0x14
    8dd0:	00 97       	sbiw	r24, 0x00	; 0
    8dd2:	69 f7       	brne	.-38     	; 0x8dae <LCD_displayCharacter+0x7a0>
    8dd4:	14 c0       	rjmp	.+40     	; 0x8dfe <LCD_displayCharacter+0x7f0>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    8dd6:	6d 89       	ldd	r22, Y+21	; 0x15
    8dd8:	7e 89       	ldd	r23, Y+22	; 0x16
    8dda:	8f 89       	ldd	r24, Y+23	; 0x17
    8ddc:	98 8d       	ldd	r25, Y+24	; 0x18
    8dde:	0e 94 65 00 	call	0xca	; 0xca <__fixunssfsi>
    8de2:	dc 01       	movw	r26, r24
    8de4:	cb 01       	movw	r24, r22
    8de6:	9c 8b       	std	Y+20, r25	; 0x14
    8de8:	8b 8b       	std	Y+19, r24	; 0x13
    8dea:	8b 89       	ldd	r24, Y+19	; 0x13
    8dec:	9c 89       	ldd	r25, Y+20	; 0x14
    8dee:	98 8b       	std	Y+16, r25	; 0x10
    8df0:	8f 87       	std	Y+15, r24	; 0x0f
    8df2:	8f 85       	ldd	r24, Y+15	; 0x0f
    8df4:	98 89       	ldd	r25, Y+16	; 0x10
    8df6:	01 97       	sbiw	r24, 0x01	; 1
    8df8:	f1 f7       	brne	.-4      	; 0x8df6 <LCD_displayCharacter+0x7e8>
    8dfa:	98 8b       	std	Y+16, r25	; 0x10
    8dfc:	8f 87       	std	Y+15, r24	; 0x0f

	_delay_ms(1); /* delay for processing Tdsw = 100ns */
	GPIO_writePin(LCD_E_PORT_ID,LCD_E_PIN_ID,LOGIC_LOW); /* Disable LCD E=0 */
    8dfe:	83 e0       	ldi	r24, 0x03	; 3
    8e00:	62 e0       	ldi	r22, 0x02	; 2
    8e02:	40 e0       	ldi	r20, 0x00	; 0
    8e04:	0e 94 46 39 	call	0x728c	; 0x728c <GPIO_writePin>
    8e08:	80 e0       	ldi	r24, 0x00	; 0
    8e0a:	90 e0       	ldi	r25, 0x00	; 0
    8e0c:	a0 e8       	ldi	r26, 0x80	; 128
    8e0e:	bf e3       	ldi	r27, 0x3F	; 63
    8e10:	8b 87       	std	Y+11, r24	; 0x0b
    8e12:	9c 87       	std	Y+12, r25	; 0x0c
    8e14:	ad 87       	std	Y+13, r26	; 0x0d
    8e16:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    8e18:	6b 85       	ldd	r22, Y+11	; 0x0b
    8e1a:	7c 85       	ldd	r23, Y+12	; 0x0c
    8e1c:	8d 85       	ldd	r24, Y+13	; 0x0d
    8e1e:	9e 85       	ldd	r25, Y+14	; 0x0e
    8e20:	20 e0       	ldi	r18, 0x00	; 0
    8e22:	30 e0       	ldi	r19, 0x00	; 0
    8e24:	4a e7       	ldi	r20, 0x7A	; 122
    8e26:	55 e4       	ldi	r21, 0x45	; 69
    8e28:	0e 94 3b 02 	call	0x476	; 0x476 <__mulsf3>
    8e2c:	dc 01       	movw	r26, r24
    8e2e:	cb 01       	movw	r24, r22
    8e30:	8f 83       	std	Y+7, r24	; 0x07
    8e32:	98 87       	std	Y+8, r25	; 0x08
    8e34:	a9 87       	std	Y+9, r26	; 0x09
    8e36:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    8e38:	6f 81       	ldd	r22, Y+7	; 0x07
    8e3a:	78 85       	ldd	r23, Y+8	; 0x08
    8e3c:	89 85       	ldd	r24, Y+9	; 0x09
    8e3e:	9a 85       	ldd	r25, Y+10	; 0x0a
    8e40:	20 e0       	ldi	r18, 0x00	; 0
    8e42:	30 e0       	ldi	r19, 0x00	; 0
    8e44:	40 e8       	ldi	r20, 0x80	; 128
    8e46:	5f e3       	ldi	r21, 0x3F	; 63
    8e48:	0e 94 41 04 	call	0x882	; 0x882 <__ltsf2>
    8e4c:	88 23       	and	r24, r24
    8e4e:	2c f4       	brge	.+10     	; 0x8e5a <LCD_displayCharacter+0x84c>
		__ticks = 1;
    8e50:	81 e0       	ldi	r24, 0x01	; 1
    8e52:	90 e0       	ldi	r25, 0x00	; 0
    8e54:	9e 83       	std	Y+6, r25	; 0x06
    8e56:	8d 83       	std	Y+5, r24	; 0x05
    8e58:	3f c0       	rjmp	.+126    	; 0x8ed8 <LCD_displayCharacter+0x8ca>
	else if (__tmp > 65535)
    8e5a:	6f 81       	ldd	r22, Y+7	; 0x07
    8e5c:	78 85       	ldd	r23, Y+8	; 0x08
    8e5e:	89 85       	ldd	r24, Y+9	; 0x09
    8e60:	9a 85       	ldd	r25, Y+10	; 0x0a
    8e62:	20 e0       	ldi	r18, 0x00	; 0
    8e64:	3f ef       	ldi	r19, 0xFF	; 255
    8e66:	4f e7       	ldi	r20, 0x7F	; 127
    8e68:	57 e4       	ldi	r21, 0x47	; 71
    8e6a:	0e 94 e1 03 	call	0x7c2	; 0x7c2 <__gtsf2>
    8e6e:	18 16       	cp	r1, r24
    8e70:	4c f5       	brge	.+82     	; 0x8ec4 <LCD_displayCharacter+0x8b6>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    8e72:	6b 85       	ldd	r22, Y+11	; 0x0b
    8e74:	7c 85       	ldd	r23, Y+12	; 0x0c
    8e76:	8d 85       	ldd	r24, Y+13	; 0x0d
    8e78:	9e 85       	ldd	r25, Y+14	; 0x0e
    8e7a:	20 e0       	ldi	r18, 0x00	; 0
    8e7c:	30 e0       	ldi	r19, 0x00	; 0
    8e7e:	40 e2       	ldi	r20, 0x20	; 32
    8e80:	51 e4       	ldi	r21, 0x41	; 65
    8e82:	0e 94 3b 02 	call	0x476	; 0x476 <__mulsf3>
    8e86:	dc 01       	movw	r26, r24
    8e88:	cb 01       	movw	r24, r22
    8e8a:	bc 01       	movw	r22, r24
    8e8c:	cd 01       	movw	r24, r26
    8e8e:	0e 94 65 00 	call	0xca	; 0xca <__fixunssfsi>
    8e92:	dc 01       	movw	r26, r24
    8e94:	cb 01       	movw	r24, r22
    8e96:	9e 83       	std	Y+6, r25	; 0x06
    8e98:	8d 83       	std	Y+5, r24	; 0x05
    8e9a:	0f c0       	rjmp	.+30     	; 0x8eba <LCD_displayCharacter+0x8ac>
    8e9c:	80 e9       	ldi	r24, 0x90	; 144
    8e9e:	91 e0       	ldi	r25, 0x01	; 1
    8ea0:	9c 83       	std	Y+4, r25	; 0x04
    8ea2:	8b 83       	std	Y+3, r24	; 0x03
    8ea4:	8b 81       	ldd	r24, Y+3	; 0x03
    8ea6:	9c 81       	ldd	r25, Y+4	; 0x04
    8ea8:	01 97       	sbiw	r24, 0x01	; 1
    8eaa:	f1 f7       	brne	.-4      	; 0x8ea8 <LCD_displayCharacter+0x89a>
    8eac:	9c 83       	std	Y+4, r25	; 0x04
    8eae:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    8eb0:	8d 81       	ldd	r24, Y+5	; 0x05
    8eb2:	9e 81       	ldd	r25, Y+6	; 0x06
    8eb4:	01 97       	sbiw	r24, 0x01	; 1
    8eb6:	9e 83       	std	Y+6, r25	; 0x06
    8eb8:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    8eba:	8d 81       	ldd	r24, Y+5	; 0x05
    8ebc:	9e 81       	ldd	r25, Y+6	; 0x06
    8ebe:	00 97       	sbiw	r24, 0x00	; 0
    8ec0:	69 f7       	brne	.-38     	; 0x8e9c <LCD_displayCharacter+0x88e>
    8ec2:	14 c0       	rjmp	.+40     	; 0x8eec <LCD_displayCharacter+0x8de>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    8ec4:	6f 81       	ldd	r22, Y+7	; 0x07
    8ec6:	78 85       	ldd	r23, Y+8	; 0x08
    8ec8:	89 85       	ldd	r24, Y+9	; 0x09
    8eca:	9a 85       	ldd	r25, Y+10	; 0x0a
    8ecc:	0e 94 65 00 	call	0xca	; 0xca <__fixunssfsi>
    8ed0:	dc 01       	movw	r26, r24
    8ed2:	cb 01       	movw	r24, r22
    8ed4:	9e 83       	std	Y+6, r25	; 0x06
    8ed6:	8d 83       	std	Y+5, r24	; 0x05
    8ed8:	8d 81       	ldd	r24, Y+5	; 0x05
    8eda:	9e 81       	ldd	r25, Y+6	; 0x06
    8edc:	9a 83       	std	Y+2, r25	; 0x02
    8ede:	89 83       	std	Y+1, r24	; 0x01
    8ee0:	89 81       	ldd	r24, Y+1	; 0x01
    8ee2:	9a 81       	ldd	r25, Y+2	; 0x02
    8ee4:	01 97       	sbiw	r24, 0x01	; 1
    8ee6:	f1 f7       	brne	.-4      	; 0x8ee4 <LCD_displayCharacter+0x8d6>
    8ee8:	9a 83       	std	Y+2, r25	; 0x02
    8eea:	89 83       	std	Y+1, r24	; 0x01
	GPIO_writePort(LCD_DATA_PORT_ID,data); /* out the required command to the data bus D0 --> D7 */
	_delay_ms(1); /* delay for processing Tdsw = 100ns */
	GPIO_writePin(LCD_E_PORT_ID,LCD_E_PIN_ID,LOGIC_LOW); /* Disable LCD E=0 */
	_delay_ms(1); /* delay for processing Th = 13ns */
#endif
}
    8eec:	cd 59       	subi	r28, 0x9D	; 157
    8eee:	df 4f       	sbci	r29, 0xFF	; 255
    8ef0:	0f b6       	in	r0, 0x3f	; 63
    8ef2:	f8 94       	cli
    8ef4:	de bf       	out	0x3e, r29	; 62
    8ef6:	0f be       	out	0x3f, r0	; 63
    8ef8:	cd bf       	out	0x3d, r28	; 61
    8efa:	cf 91       	pop	r28
    8efc:	df 91       	pop	r29
    8efe:	1f 91       	pop	r17
    8f00:	0f 91       	pop	r16
    8f02:	08 95       	ret

00008f04 <LCD_displayString>:
/*
 * Description :
 * Display the required string on the screen
 */
void LCD_displayString(const char *Str)
{
    8f04:	df 93       	push	r29
    8f06:	cf 93       	push	r28
    8f08:	00 d0       	rcall	.+0      	; 0x8f0a <LCD_displayString+0x6>
    8f0a:	0f 92       	push	r0
    8f0c:	cd b7       	in	r28, 0x3d	; 61
    8f0e:	de b7       	in	r29, 0x3e	; 62
    8f10:	9b 83       	std	Y+3, r25	; 0x03
    8f12:	8a 83       	std	Y+2, r24	; 0x02
	uint8 i = 0;
    8f14:	19 82       	std	Y+1, r1	; 0x01
    8f16:	0e c0       	rjmp	.+28     	; 0x8f34 <LCD_displayString+0x30>
	while(Str[i] != '\0')
	{
		LCD_displayCharacter(Str[i]);
    8f18:	89 81       	ldd	r24, Y+1	; 0x01
    8f1a:	28 2f       	mov	r18, r24
    8f1c:	30 e0       	ldi	r19, 0x00	; 0
    8f1e:	8a 81       	ldd	r24, Y+2	; 0x02
    8f20:	9b 81       	ldd	r25, Y+3	; 0x03
    8f22:	fc 01       	movw	r30, r24
    8f24:	e2 0f       	add	r30, r18
    8f26:	f3 1f       	adc	r31, r19
    8f28:	80 81       	ld	r24, Z
    8f2a:	0e 94 07 43 	call	0x860e	; 0x860e <LCD_displayCharacter>
		i++;
    8f2e:	89 81       	ldd	r24, Y+1	; 0x01
    8f30:	8f 5f       	subi	r24, 0xFF	; 255
    8f32:	89 83       	std	Y+1, r24	; 0x01
 * Display the required string on the screen
 */
void LCD_displayString(const char *Str)
{
	uint8 i = 0;
	while(Str[i] != '\0')
    8f34:	89 81       	ldd	r24, Y+1	; 0x01
    8f36:	28 2f       	mov	r18, r24
    8f38:	30 e0       	ldi	r19, 0x00	; 0
    8f3a:	8a 81       	ldd	r24, Y+2	; 0x02
    8f3c:	9b 81       	ldd	r25, Y+3	; 0x03
    8f3e:	fc 01       	movw	r30, r24
    8f40:	e2 0f       	add	r30, r18
    8f42:	f3 1f       	adc	r31, r19
    8f44:	80 81       	ld	r24, Z
    8f46:	88 23       	and	r24, r24
    8f48:	39 f7       	brne	.-50     	; 0x8f18 <LCD_displayString+0x14>
	{
		LCD_displayCharacter(*Str);
		Str++;
	}		
	*********************************************************/
}
    8f4a:	0f 90       	pop	r0
    8f4c:	0f 90       	pop	r0
    8f4e:	0f 90       	pop	r0
    8f50:	cf 91       	pop	r28
    8f52:	df 91       	pop	r29
    8f54:	08 95       	ret

00008f56 <LCD_moveCursor>:
/*
 * Description :
 * Move the cursor to a specified row and column index on the screen
 */
void LCD_moveCursor(uint8 row,uint8 col)
{
    8f56:	df 93       	push	r29
    8f58:	cf 93       	push	r28
    8f5a:	00 d0       	rcall	.+0      	; 0x8f5c <LCD_moveCursor+0x6>
    8f5c:	00 d0       	rcall	.+0      	; 0x8f5e <LCD_moveCursor+0x8>
    8f5e:	0f 92       	push	r0
    8f60:	cd b7       	in	r28, 0x3d	; 61
    8f62:	de b7       	in	r29, 0x3e	; 62
    8f64:	8a 83       	std	Y+2, r24	; 0x02
    8f66:	6b 83       	std	Y+3, r22	; 0x03
	uint8 lcd_memory_address;
	
	/* Calculate the required address in the LCD DDRAM */
	switch(row)
    8f68:	8a 81       	ldd	r24, Y+2	; 0x02
    8f6a:	28 2f       	mov	r18, r24
    8f6c:	30 e0       	ldi	r19, 0x00	; 0
    8f6e:	3d 83       	std	Y+5, r19	; 0x05
    8f70:	2c 83       	std	Y+4, r18	; 0x04
    8f72:	8c 81       	ldd	r24, Y+4	; 0x04
    8f74:	9d 81       	ldd	r25, Y+5	; 0x05
    8f76:	81 30       	cpi	r24, 0x01	; 1
    8f78:	91 05       	cpc	r25, r1
    8f7a:	c1 f0       	breq	.+48     	; 0x8fac <LCD_moveCursor+0x56>
    8f7c:	2c 81       	ldd	r18, Y+4	; 0x04
    8f7e:	3d 81       	ldd	r19, Y+5	; 0x05
    8f80:	22 30       	cpi	r18, 0x02	; 2
    8f82:	31 05       	cpc	r19, r1
    8f84:	2c f4       	brge	.+10     	; 0x8f90 <LCD_moveCursor+0x3a>
    8f86:	8c 81       	ldd	r24, Y+4	; 0x04
    8f88:	9d 81       	ldd	r25, Y+5	; 0x05
    8f8a:	00 97       	sbiw	r24, 0x00	; 0
    8f8c:	61 f0       	breq	.+24     	; 0x8fa6 <LCD_moveCursor+0x50>
    8f8e:	19 c0       	rjmp	.+50     	; 0x8fc2 <LCD_moveCursor+0x6c>
    8f90:	2c 81       	ldd	r18, Y+4	; 0x04
    8f92:	3d 81       	ldd	r19, Y+5	; 0x05
    8f94:	22 30       	cpi	r18, 0x02	; 2
    8f96:	31 05       	cpc	r19, r1
    8f98:	69 f0       	breq	.+26     	; 0x8fb4 <LCD_moveCursor+0x5e>
    8f9a:	8c 81       	ldd	r24, Y+4	; 0x04
    8f9c:	9d 81       	ldd	r25, Y+5	; 0x05
    8f9e:	83 30       	cpi	r24, 0x03	; 3
    8fa0:	91 05       	cpc	r25, r1
    8fa2:	61 f0       	breq	.+24     	; 0x8fbc <LCD_moveCursor+0x66>
    8fa4:	0e c0       	rjmp	.+28     	; 0x8fc2 <LCD_moveCursor+0x6c>
	{
		case 0:
			lcd_memory_address=col;
    8fa6:	8b 81       	ldd	r24, Y+3	; 0x03
    8fa8:	89 83       	std	Y+1, r24	; 0x01
    8faa:	0b c0       	rjmp	.+22     	; 0x8fc2 <LCD_moveCursor+0x6c>
				break;
		case 1:
			lcd_memory_address=col+0x40;
    8fac:	8b 81       	ldd	r24, Y+3	; 0x03
    8fae:	80 5c       	subi	r24, 0xC0	; 192
    8fb0:	89 83       	std	Y+1, r24	; 0x01
    8fb2:	07 c0       	rjmp	.+14     	; 0x8fc2 <LCD_moveCursor+0x6c>
				break;
		case 2:
			lcd_memory_address=col+0x10;
    8fb4:	8b 81       	ldd	r24, Y+3	; 0x03
    8fb6:	80 5f       	subi	r24, 0xF0	; 240
    8fb8:	89 83       	std	Y+1, r24	; 0x01
    8fba:	03 c0       	rjmp	.+6      	; 0x8fc2 <LCD_moveCursor+0x6c>
				break;
		case 3:
			lcd_memory_address=col+0x50;
    8fbc:	8b 81       	ldd	r24, Y+3	; 0x03
    8fbe:	80 5b       	subi	r24, 0xB0	; 176
    8fc0:	89 83       	std	Y+1, r24	; 0x01
				break;
	}					
	/* Move the LCD cursor to this specific address */
	LCD_sendCommand(lcd_memory_address | LCD_SET_CURSOR_LOCATION);
    8fc2:	89 81       	ldd	r24, Y+1	; 0x01
    8fc4:	80 68       	ori	r24, 0x80	; 128
    8fc6:	0e 94 8c 3e 	call	0x7d18	; 0x7d18 <LCD_sendCommand>
}
    8fca:	0f 90       	pop	r0
    8fcc:	0f 90       	pop	r0
    8fce:	0f 90       	pop	r0
    8fd0:	0f 90       	pop	r0
    8fd2:	0f 90       	pop	r0
    8fd4:	cf 91       	pop	r28
    8fd6:	df 91       	pop	r29
    8fd8:	08 95       	ret

00008fda <LCD_displayStringRowColumn>:
/*
 * Description :
 * Display the required string in a specified row and column index on the screen
 */
void LCD_displayStringRowColumn(uint8 row,uint8 col,const char *Str)
{
    8fda:	df 93       	push	r29
    8fdc:	cf 93       	push	r28
    8fde:	00 d0       	rcall	.+0      	; 0x8fe0 <LCD_displayStringRowColumn+0x6>
    8fe0:	00 d0       	rcall	.+0      	; 0x8fe2 <LCD_displayStringRowColumn+0x8>
    8fe2:	cd b7       	in	r28, 0x3d	; 61
    8fe4:	de b7       	in	r29, 0x3e	; 62
    8fe6:	89 83       	std	Y+1, r24	; 0x01
    8fe8:	6a 83       	std	Y+2, r22	; 0x02
    8fea:	5c 83       	std	Y+4, r21	; 0x04
    8fec:	4b 83       	std	Y+3, r20	; 0x03
	LCD_moveCursor(row,col); /* go to to the required LCD position */
    8fee:	89 81       	ldd	r24, Y+1	; 0x01
    8ff0:	6a 81       	ldd	r22, Y+2	; 0x02
    8ff2:	0e 94 ab 47 	call	0x8f56	; 0x8f56 <LCD_moveCursor>
	LCD_displayString(Str); /* display the string */
    8ff6:	8b 81       	ldd	r24, Y+3	; 0x03
    8ff8:	9c 81       	ldd	r25, Y+4	; 0x04
    8ffa:	0e 94 82 47 	call	0x8f04	; 0x8f04 <LCD_displayString>
}
    8ffe:	0f 90       	pop	r0
    9000:	0f 90       	pop	r0
    9002:	0f 90       	pop	r0
    9004:	0f 90       	pop	r0
    9006:	cf 91       	pop	r28
    9008:	df 91       	pop	r29
    900a:	08 95       	ret

0000900c <LCD_intgerToString>:
/*
 * Description :
 * Display the required decimal value on the screen
 */
void LCD_intgerToString(int data)
{
    900c:	df 93       	push	r29
    900e:	cf 93       	push	r28
    9010:	cd b7       	in	r28, 0x3d	; 61
    9012:	de b7       	in	r29, 0x3e	; 62
    9014:	62 97       	sbiw	r28, 0x12	; 18
    9016:	0f b6       	in	r0, 0x3f	; 63
    9018:	f8 94       	cli
    901a:	de bf       	out	0x3e, r29	; 62
    901c:	0f be       	out	0x3f, r0	; 63
    901e:	cd bf       	out	0x3d, r28	; 61
    9020:	9a 8b       	std	Y+18, r25	; 0x12
    9022:	89 8b       	std	Y+17, r24	; 0x11
   char buff[16]; /* String to hold the ascii result */
   itoa(data,buff,10); /* Use itoa C function to convert the data to its corresponding ASCII value, 10 for decimal */
    9024:	89 89       	ldd	r24, Y+17	; 0x11
    9026:	9a 89       	ldd	r25, Y+18	; 0x12
    9028:	9e 01       	movw	r18, r28
    902a:	2f 5f       	subi	r18, 0xFF	; 255
    902c:	3f 4f       	sbci	r19, 0xFF	; 255
    902e:	b9 01       	movw	r22, r18
    9030:	4a e0       	ldi	r20, 0x0A	; 10
    9032:	50 e0       	ldi	r21, 0x00	; 0
    9034:	0e 94 91 49 	call	0x9322	; 0x9322 <itoa>
   LCD_displayString(buff); /* Display the string */
    9038:	ce 01       	movw	r24, r28
    903a:	01 96       	adiw	r24, 0x01	; 1
    903c:	0e 94 82 47 	call	0x8f04	; 0x8f04 <LCD_displayString>
}
    9040:	62 96       	adiw	r28, 0x12	; 18
    9042:	0f b6       	in	r0, 0x3f	; 63
    9044:	f8 94       	cli
    9046:	de bf       	out	0x3e, r29	; 62
    9048:	0f be       	out	0x3f, r0	; 63
    904a:	cd bf       	out	0x3d, r28	; 61
    904c:	cf 91       	pop	r28
    904e:	df 91       	pop	r29
    9050:	08 95       	ret

00009052 <LCD_clearScreen>:
/*
 * Description :
 * Send the clear screen command
 */
void LCD_clearScreen(void)
{
    9052:	df 93       	push	r29
    9054:	cf 93       	push	r28
    9056:	cd b7       	in	r28, 0x3d	; 61
    9058:	de b7       	in	r29, 0x3e	; 62
	LCD_sendCommand(LCD_CLEAR_COMMAND); /* Send clear display command */
    905a:	81 e0       	ldi	r24, 0x01	; 1
    905c:	0e 94 8c 3e 	call	0x7d18	; 0x7d18 <LCD_sendCommand>
}
    9060:	cf 91       	pop	r28
    9062:	df 91       	pop	r29
    9064:	08 95       	ret

00009066 <main>:

void Task3_Func(void);
TaskHandle_t task3ptr;

int main(void)
{
    9066:	ef 92       	push	r14
    9068:	ff 92       	push	r15
    906a:	0f 93       	push	r16
    906c:	df 93       	push	r29
    906e:	cf 93       	push	r28
    9070:	cd b7       	in	r28, 0x3d	; 61
    9072:	de b7       	in	r29, 0x3e	; 62
	DIO_init();
    9074:	0e 94 79 3c 	call	0x78f2	; 0x78f2 <DIO_init>
	LCD_init();
    9078:	0e 94 da 3d 	call	0x7bb4	; 0x7bb4 <LCD_init>
//	timer1_PWM_Init();

	SREG |=(1<<7);			// I bit Enabled
    907c:	af e5       	ldi	r26, 0x5F	; 95
    907e:	b0 e0       	ldi	r27, 0x00	; 0
    9080:	ef e5       	ldi	r30, 0x5F	; 95
    9082:	f0 e0       	ldi	r31, 0x00	; 0
    9084:	80 81       	ld	r24, Z
    9086:	80 68       	ori	r24, 0x80	; 128
    9088:	8c 93       	st	X, r24

	xTaskCreate(Task1_Func,"first",configMINIMAL_STACK_SIZE,NULL,1,&task1ptr);
    908a:	85 e7       	ldi	r24, 0x75	; 117
    908c:	98 e4       	ldi	r25, 0x48	; 72
    908e:	2c e1       	ldi	r18, 0x1C	; 28
    9090:	31 e0       	ldi	r19, 0x01	; 1
    9092:	e1 e0       	ldi	r30, 0x01	; 1
    9094:	f9 e0       	ldi	r31, 0x09	; 9
    9096:	b9 01       	movw	r22, r18
    9098:	45 e5       	ldi	r20, 0x55	; 85
    909a:	50 e0       	ldi	r21, 0x00	; 0
    909c:	20 e0       	ldi	r18, 0x00	; 0
    909e:	30 e0       	ldi	r19, 0x00	; 0
    90a0:	01 e0       	ldi	r16, 0x01	; 1
    90a2:	7f 01       	movw	r14, r30
    90a4:	0e 94 37 1b 	call	0x366e	; 0x366e <xTaskCreate>
	xTaskCreate(Task2_Func,"second",configMINIMAL_STACK_SIZE,NULL,1,&task2ptr);
    90a8:	81 e8       	ldi	r24, 0x81	; 129
    90aa:	98 e4       	ldi	r25, 0x48	; 72
    90ac:	22 e2       	ldi	r18, 0x22	; 34
    90ae:	31 e0       	ldi	r19, 0x01	; 1
    90b0:	ef ef       	ldi	r30, 0xFF	; 255
    90b2:	f8 e0       	ldi	r31, 0x08	; 8
    90b4:	b9 01       	movw	r22, r18
    90b6:	45 e5       	ldi	r20, 0x55	; 85
    90b8:	50 e0       	ldi	r21, 0x00	; 0
    90ba:	20 e0       	ldi	r18, 0x00	; 0
    90bc:	30 e0       	ldi	r19, 0x00	; 0
    90be:	01 e0       	ldi	r16, 0x01	; 1
    90c0:	7f 01       	movw	r14, r30
    90c2:	0e 94 37 1b 	call	0x366e	; 0x366e <xTaskCreate>
	xTaskCreate(Task3_Func,"third",configMINIMAL_STACK_SIZE,NULL,0,&task3ptr);
    90c6:	83 ea       	ldi	r24, 0xA3	; 163
    90c8:	98 e4       	ldi	r25, 0x48	; 72
    90ca:	29 e2       	ldi	r18, 0x29	; 41
    90cc:	31 e0       	ldi	r19, 0x01	; 1
    90ce:	ed ef       	ldi	r30, 0xFD	; 253
    90d0:	f8 e0       	ldi	r31, 0x08	; 8
    90d2:	b9 01       	movw	r22, r18
    90d4:	45 e5       	ldi	r20, 0x55	; 85
    90d6:	50 e0       	ldi	r21, 0x00	; 0
    90d8:	20 e0       	ldi	r18, 0x00	; 0
    90da:	30 e0       	ldi	r19, 0x00	; 0
    90dc:	00 e0       	ldi	r16, 0x00	; 0
    90de:	7f 01       	movw	r14, r30
    90e0:	0e 94 37 1b 	call	0x366e	; 0x366e <xTaskCreate>
//	xTimerStart(xTimer1, 1);
//	xTimerStart(xTimer2, 10);



	vTaskStartScheduler();
    90e4:	0e 94 41 1e 	call	0x3c82	; 0x3c82 <vTaskStartScheduler>
    90e8:	ff cf       	rjmp	.-2      	; 0x90e8 <main+0x82>

000090ea <Task1_Func>:
//	Poll();
//}


void Task1_Func(void)
{
    90ea:	df 93       	push	r29
    90ec:	cf 93       	push	r28
    90ee:	cd b7       	in	r28, 0x3d	; 61
    90f0:	de b7       	in	r29, 0x3e	; 62
	while(1)
	{
//		SET_BIT(PORTB,5);
		DeviceFlag = 1;
    90f2:	81 e0       	ldi	r24, 0x01	; 1
    90f4:	80 93 f3 08 	sts	0x08F3, r24
		vTaskDelay(100/portTICK_PERIOD_MS);
    90f8:	84 e6       	ldi	r24, 0x64	; 100
    90fa:	90 e0       	ldi	r25, 0x00	; 0
    90fc:	0e 94 1f 1e 	call	0x3c3e	; 0x3c3e <vTaskDelay>
    9100:	f8 cf       	rjmp	.-16     	; 0x90f2 <Task1_Func+0x8>

00009102 <Task2_Func>:
	}

}

void Task2_Func(void)
{
    9102:	df 93       	push	r29
    9104:	cf 93       	push	r28
    9106:	cd b7       	in	r28, 0x3d	; 61
    9108:	de b7       	in	r29, 0x3e	; 62
	while(1)
	{
//		CLEAR_BIT(PORTB,5);
		if(DeviceFlag == 1)
    910a:	80 91 f3 08 	lds	r24, 0x08F3
    910e:	81 30       	cpi	r24, 0x01	; 1
    9110:	e1 f7       	brne	.-8      	; 0x910a <Task2_Func+0x8>
		{
		DeviceFlag = 0;
    9112:	10 92 f3 08 	sts	0x08F3, r1
		ButtonStateTest = Get_Data();
    9116:	0e 94 3a 37 	call	0x6e74	; 0x6e74 <Get_Data>
    911a:	dc 01       	movw	r26, r24
    911c:	cb 01       	movw	r24, r22
    911e:	80 93 f5 08 	sts	0x08F5, r24
    9122:	90 93 f6 08 	sts	0x08F6, r25
    9126:	a0 93 f7 08 	sts	0x08F7, r26
    912a:	b0 93 f8 08 	sts	0x08F8, r27
		HandlerFlag = 1;
    912e:	81 e0       	ldi	r24, 0x01	; 1
    9130:	80 93 f4 08 	sts	0x08F4, r24
		TOGGLE_BIT(PORTB,5);
    9134:	a8 e3       	ldi	r26, 0x38	; 56
    9136:	b0 e0       	ldi	r27, 0x00	; 0
    9138:	e8 e3       	ldi	r30, 0x38	; 56
    913a:	f0 e0       	ldi	r31, 0x00	; 0
    913c:	90 81       	ld	r25, Z
    913e:	80 e2       	ldi	r24, 0x20	; 32
    9140:	89 27       	eor	r24, r25
    9142:	8c 93       	st	X, r24
    9144:	e2 cf       	rjmp	.-60     	; 0x910a <Task2_Func+0x8>

00009146 <Task3_Func>:

		}
	}
}
/*******************************Some unworking tests**************************************************************************/
void Task3_Func(void){
    9146:	df 93       	push	r29
    9148:	cf 93       	push	r28
    914a:	cd b7       	in	r28, 0x3d	; 61
    914c:	de b7       	in	r29, 0x3e	; 62
	//	TickType_t xLastWakeTime2;
	//	const TickType_t xPeriod2 = pdMS_TO_TICKS( 2000 );
	//	xLastWakeTime2 = xTaskGetTickCount();
	while(1)
	{
		if(HandlerFlag == 1)
    914e:	80 91 f4 08 	lds	r24, 0x08F4
    9152:	81 30       	cpi	r24, 0x01	; 1
    9154:	e1 f7       	brne	.-8      	; 0x914e <Task3_Func+0x8>
		{
			HandlerFlag = 0;
    9156:	10 92 f4 08 	sts	0x08F4, r1
			TOGGLE_BIT(PORTB,6);
    915a:	a8 e3       	ldi	r26, 0x38	; 56
    915c:	b0 e0       	ldi	r27, 0x00	; 0
    915e:	e8 e3       	ldi	r30, 0x38	; 56
    9160:	f0 e0       	ldi	r31, 0x00	; 0
    9162:	90 81       	ld	r25, Z
    9164:	80 e4       	ldi	r24, 0x40	; 64
    9166:	89 27       	eor	r24, r25
    9168:	8c 93       	st	X, r24
    916a:	f1 cf       	rjmp	.-30     	; 0x914e <Task3_Func+0x8>

0000916c <Poll>:

int polling_enabled= 1;
int polling_counter= 1;
int counter = 0 ;
void Poll(void)
{
    916c:	df 93       	push	r29
    916e:	cf 93       	push	r28
    9170:	00 d0       	rcall	.+0      	; 0x9172 <Poll+0x6>
    9172:	00 d0       	rcall	.+0      	; 0x9174 <Poll+0x8>
    9174:	cd b7       	in	r28, 0x3d	; 61
    9176:	de b7       	in	r29, 0x3e	; 62
	if(polling_enabled && (!counter))
    9178:	80 91 39 02 	lds	r24, 0x0239
    917c:	90 91 3a 02 	lds	r25, 0x023A
    9180:	00 97       	sbiw	r24, 0x00	; 0
    9182:	91 f0       	breq	.+36     	; 0x91a8 <Poll+0x3c>
    9184:	80 91 f9 08 	lds	r24, 0x08F9
    9188:	90 91 fa 08 	lds	r25, 0x08FA
    918c:	00 97       	sbiw	r24, 0x00	; 0
    918e:	61 f4       	brne	.+24     	; 0x91a8 <Poll+0x3c>
	{
		States_GroupType data;
		data = Get_Data();
    9190:	0e 94 3a 37 	call	0x6e74	; 0x6e74 <Get_Data>
    9194:	dc 01       	movw	r26, r24
    9196:	cb 01       	movw	r24, r22
    9198:	89 83       	std	Y+1, r24	; 0x01
    919a:	9a 83       	std	Y+2, r25	; 0x02
    919c:	ab 83       	std	Y+3, r26	; 0x03
    919e:	bc 83       	std	Y+4, r27	; 0x04
		Handle_data(&data);
    91a0:	ce 01       	movw	r24, r28
    91a2:	01 96       	adiw	r24, 0x01	; 1
    91a4:	0e 94 83 34 	call	0x6906	; 0x6906 <Handle_data>

	}
	counter++;
    91a8:	80 91 f9 08 	lds	r24, 0x08F9
    91ac:	90 91 fa 08 	lds	r25, 0x08FA
    91b0:	01 96       	adiw	r24, 0x01	; 1
    91b2:	90 93 fa 08 	sts	0x08FA, r25
    91b6:	80 93 f9 08 	sts	0x08F9, r24
	counter = counter%polling_counter;
    91ba:	80 91 f9 08 	lds	r24, 0x08F9
    91be:	90 91 fa 08 	lds	r25, 0x08FA
    91c2:	20 91 3b 02 	lds	r18, 0x023B
    91c6:	30 91 3c 02 	lds	r19, 0x023C
    91ca:	b9 01       	movw	r22, r18
    91cc:	0e 94 37 49 	call	0x926e	; 0x926e <__divmodhi4>
    91d0:	90 93 fa 08 	sts	0x08FA, r25
    91d4:	80 93 f9 08 	sts	0x08F9, r24
}
    91d8:	0f 90       	pop	r0
    91da:	0f 90       	pop	r0
    91dc:	0f 90       	pop	r0
    91de:	0f 90       	pop	r0
    91e0:	cf 91       	pop	r28
    91e2:	df 91       	pop	r29
    91e4:	08 95       	ret

000091e6 <StartPolling>:

void StartPolling(void)
{
    91e6:	df 93       	push	r29
    91e8:	cf 93       	push	r28
    91ea:	cd b7       	in	r28, 0x3d	; 61
    91ec:	de b7       	in	r29, 0x3e	; 62
	polling_enabled=1;
    91ee:	81 e0       	ldi	r24, 0x01	; 1
    91f0:	90 e0       	ldi	r25, 0x00	; 0
    91f2:	90 93 3a 02 	sts	0x023A, r25
    91f6:	80 93 39 02 	sts	0x0239, r24
}
    91fa:	cf 91       	pop	r28
    91fc:	df 91       	pop	r29
    91fe:	08 95       	ret

00009200 <StopPolling>:

void StopPolling(void)
{
    9200:	df 93       	push	r29
    9202:	cf 93       	push	r28
    9204:	cd b7       	in	r28, 0x3d	; 61
    9206:	de b7       	in	r29, 0x3e	; 62
	polling_enabled=0;
    9208:	10 92 3a 02 	sts	0x023A, r1
    920c:	10 92 39 02 	sts	0x0239, r1
}
    9210:	cf 91       	pop	r28
    9212:	df 91       	pop	r29
    9214:	08 95       	ret

00009216 <SetPollingTime>:

void SetPollingTime(int polling_time)
{
    9216:	df 93       	push	r29
    9218:	cf 93       	push	r28
    921a:	00 d0       	rcall	.+0      	; 0x921c <SetPollingTime+0x6>
    921c:	cd b7       	in	r28, 0x3d	; 61
    921e:	de b7       	in	r29, 0x3e	; 62
    9220:	9a 83       	std	Y+2, r25	; 0x02
    9222:	89 83       	std	Y+1, r24	; 0x01
	polling_counter = polling_time/(50*2);
    9224:	89 81       	ldd	r24, Y+1	; 0x01
    9226:	9a 81       	ldd	r25, Y+2	; 0x02
    9228:	24 e6       	ldi	r18, 0x64	; 100
    922a:	30 e0       	ldi	r19, 0x00	; 0
    922c:	b9 01       	movw	r22, r18
    922e:	0e 94 37 49 	call	0x926e	; 0x926e <__divmodhi4>
    9232:	cb 01       	movw	r24, r22
    9234:	90 93 3c 02 	sts	0x023C, r25
    9238:	80 93 3b 02 	sts	0x023B, r24
	 *
	 *
	 *
	 *
	 * */
}
    923c:	0f 90       	pop	r0
    923e:	0f 90       	pop	r0
    9240:	cf 91       	pop	r28
    9242:	df 91       	pop	r29
    9244:	08 95       	ret

00009246 <__udivmodhi4>:
    9246:	aa 1b       	sub	r26, r26
    9248:	bb 1b       	sub	r27, r27
    924a:	51 e1       	ldi	r21, 0x11	; 17
    924c:	07 c0       	rjmp	.+14     	; 0x925c <__udivmodhi4_ep>

0000924e <__udivmodhi4_loop>:
    924e:	aa 1f       	adc	r26, r26
    9250:	bb 1f       	adc	r27, r27
    9252:	a6 17       	cp	r26, r22
    9254:	b7 07       	cpc	r27, r23
    9256:	10 f0       	brcs	.+4      	; 0x925c <__udivmodhi4_ep>
    9258:	a6 1b       	sub	r26, r22
    925a:	b7 0b       	sbc	r27, r23

0000925c <__udivmodhi4_ep>:
    925c:	88 1f       	adc	r24, r24
    925e:	99 1f       	adc	r25, r25
    9260:	5a 95       	dec	r21
    9262:	a9 f7       	brne	.-22     	; 0x924e <__udivmodhi4_loop>
    9264:	80 95       	com	r24
    9266:	90 95       	com	r25
    9268:	bc 01       	movw	r22, r24
    926a:	cd 01       	movw	r24, r26
    926c:	08 95       	ret

0000926e <__divmodhi4>:
    926e:	97 fb       	bst	r25, 7
    9270:	09 2e       	mov	r0, r25
    9272:	07 26       	eor	r0, r23
    9274:	0a d0       	rcall	.+20     	; 0x928a <__divmodhi4_neg1>
    9276:	77 fd       	sbrc	r23, 7
    9278:	04 d0       	rcall	.+8      	; 0x9282 <__divmodhi4_neg2>
    927a:	e5 df       	rcall	.-54     	; 0x9246 <__udivmodhi4>
    927c:	06 d0       	rcall	.+12     	; 0x928a <__divmodhi4_neg1>
    927e:	00 20       	and	r0, r0
    9280:	1a f4       	brpl	.+6      	; 0x9288 <__divmodhi4_exit>

00009282 <__divmodhi4_neg2>:
    9282:	70 95       	com	r23
    9284:	61 95       	neg	r22
    9286:	7f 4f       	sbci	r23, 0xFF	; 255

00009288 <__divmodhi4_exit>:
    9288:	08 95       	ret

0000928a <__divmodhi4_neg1>:
    928a:	f6 f7       	brtc	.-4      	; 0x9288 <__divmodhi4_exit>
    928c:	90 95       	com	r25
    928e:	81 95       	neg	r24
    9290:	9f 4f       	sbci	r25, 0xFF	; 255
    9292:	08 95       	ret

00009294 <__prologue_saves__>:
    9294:	2f 92       	push	r2
    9296:	3f 92       	push	r3
    9298:	4f 92       	push	r4
    929a:	5f 92       	push	r5
    929c:	6f 92       	push	r6
    929e:	7f 92       	push	r7
    92a0:	8f 92       	push	r8
    92a2:	9f 92       	push	r9
    92a4:	af 92       	push	r10
    92a6:	bf 92       	push	r11
    92a8:	cf 92       	push	r12
    92aa:	df 92       	push	r13
    92ac:	ef 92       	push	r14
    92ae:	ff 92       	push	r15
    92b0:	0f 93       	push	r16
    92b2:	1f 93       	push	r17
    92b4:	cf 93       	push	r28
    92b6:	df 93       	push	r29
    92b8:	cd b7       	in	r28, 0x3d	; 61
    92ba:	de b7       	in	r29, 0x3e	; 62
    92bc:	ca 1b       	sub	r28, r26
    92be:	db 0b       	sbc	r29, r27
    92c0:	0f b6       	in	r0, 0x3f	; 63
    92c2:	f8 94       	cli
    92c4:	de bf       	out	0x3e, r29	; 62
    92c6:	0f be       	out	0x3f, r0	; 63
    92c8:	cd bf       	out	0x3d, r28	; 61
    92ca:	09 94       	ijmp

000092cc <__epilogue_restores__>:
    92cc:	2a 88       	ldd	r2, Y+18	; 0x12
    92ce:	39 88       	ldd	r3, Y+17	; 0x11
    92d0:	48 88       	ldd	r4, Y+16	; 0x10
    92d2:	5f 84       	ldd	r5, Y+15	; 0x0f
    92d4:	6e 84       	ldd	r6, Y+14	; 0x0e
    92d6:	7d 84       	ldd	r7, Y+13	; 0x0d
    92d8:	8c 84       	ldd	r8, Y+12	; 0x0c
    92da:	9b 84       	ldd	r9, Y+11	; 0x0b
    92dc:	aa 84       	ldd	r10, Y+10	; 0x0a
    92de:	b9 84       	ldd	r11, Y+9	; 0x09
    92e0:	c8 84       	ldd	r12, Y+8	; 0x08
    92e2:	df 80       	ldd	r13, Y+7	; 0x07
    92e4:	ee 80       	ldd	r14, Y+6	; 0x06
    92e6:	fd 80       	ldd	r15, Y+5	; 0x05
    92e8:	0c 81       	ldd	r16, Y+4	; 0x04
    92ea:	1b 81       	ldd	r17, Y+3	; 0x03
    92ec:	aa 81       	ldd	r26, Y+2	; 0x02
    92ee:	b9 81       	ldd	r27, Y+1	; 0x01
    92f0:	ce 0f       	add	r28, r30
    92f2:	d1 1d       	adc	r29, r1
    92f4:	0f b6       	in	r0, 0x3f	; 63
    92f6:	f8 94       	cli
    92f8:	de bf       	out	0x3e, r29	; 62
    92fa:	0f be       	out	0x3f, r0	; 63
    92fc:	cd bf       	out	0x3d, r28	; 61
    92fe:	ed 01       	movw	r28, r26
    9300:	08 95       	ret

00009302 <memcpy>:
    9302:	fb 01       	movw	r30, r22
    9304:	dc 01       	movw	r26, r24
    9306:	02 c0       	rjmp	.+4      	; 0x930c <memcpy+0xa>
    9308:	01 90       	ld	r0, Z+
    930a:	0d 92       	st	X+, r0
    930c:	41 50       	subi	r20, 0x01	; 1
    930e:	50 40       	sbci	r21, 0x00	; 0
    9310:	d8 f7       	brcc	.-10     	; 0x9308 <memcpy+0x6>
    9312:	08 95       	ret

00009314 <memset>:
    9314:	dc 01       	movw	r26, r24
    9316:	01 c0       	rjmp	.+2      	; 0x931a <memset+0x6>
    9318:	6d 93       	st	X+, r22
    931a:	41 50       	subi	r20, 0x01	; 1
    931c:	50 40       	sbci	r21, 0x00	; 0
    931e:	e0 f7       	brcc	.-8      	; 0x9318 <memset+0x4>
    9320:	08 95       	ret

00009322 <itoa>:
    9322:	fb 01       	movw	r30, r22
    9324:	9f 01       	movw	r18, r30
    9326:	e8 94       	clt
    9328:	42 30       	cpi	r20, 0x02	; 2
    932a:	c4 f0       	brlt	.+48     	; 0x935c <itoa+0x3a>
    932c:	45 32       	cpi	r20, 0x25	; 37
    932e:	b4 f4       	brge	.+44     	; 0x935c <itoa+0x3a>
    9330:	4a 30       	cpi	r20, 0x0A	; 10
    9332:	29 f4       	brne	.+10     	; 0x933e <itoa+0x1c>
    9334:	97 fb       	bst	r25, 7
    9336:	1e f4       	brtc	.+6      	; 0x933e <itoa+0x1c>
    9338:	90 95       	com	r25
    933a:	81 95       	neg	r24
    933c:	9f 4f       	sbci	r25, 0xFF	; 255
    933e:	64 2f       	mov	r22, r20
    9340:	77 27       	eor	r23, r23
    9342:	0e 94 23 49 	call	0x9246	; 0x9246 <__udivmodhi4>
    9346:	80 5d       	subi	r24, 0xD0	; 208
    9348:	8a 33       	cpi	r24, 0x3A	; 58
    934a:	0c f0       	brlt	.+2      	; 0x934e <itoa+0x2c>
    934c:	89 5d       	subi	r24, 0xD9	; 217
    934e:	81 93       	st	Z+, r24
    9350:	cb 01       	movw	r24, r22
    9352:	00 97       	sbiw	r24, 0x00	; 0
    9354:	a1 f7       	brne	.-24     	; 0x933e <itoa+0x1c>
    9356:	16 f4       	brtc	.+4      	; 0x935c <itoa+0x3a>
    9358:	5d e2       	ldi	r21, 0x2D	; 45
    935a:	51 93       	st	Z+, r21
    935c:	10 82       	st	Z, r1
    935e:	c9 01       	movw	r24, r18
    9360:	0c 94 b2 49 	jmp	0x9364	; 0x9364 <strrev>

00009364 <strrev>:
    9364:	dc 01       	movw	r26, r24
    9366:	fc 01       	movw	r30, r24
    9368:	67 2f       	mov	r22, r23
    936a:	71 91       	ld	r23, Z+
    936c:	77 23       	and	r23, r23
    936e:	e1 f7       	brne	.-8      	; 0x9368 <strrev+0x4>
    9370:	32 97       	sbiw	r30, 0x02	; 2
    9372:	04 c0       	rjmp	.+8      	; 0x937c <strrev+0x18>
    9374:	7c 91       	ld	r23, X
    9376:	6d 93       	st	X+, r22
    9378:	70 83       	st	Z, r23
    937a:	62 91       	ld	r22, -Z
    937c:	ae 17       	cp	r26, r30
    937e:	bf 07       	cpc	r27, r31
    9380:	c8 f3       	brcs	.-14     	; 0x9374 <strrev+0x10>
    9382:	08 95       	ret

00009384 <_exit>:
    9384:	f8 94       	cli

00009386 <__stop_program>:
    9386:	ff cf       	rjmp	.-2      	; 0x9386 <__stop_program>
